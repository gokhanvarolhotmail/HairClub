<?xml version="1.0"?>
<DTS:Executable xmlns:DTS="www.microsoft.com/SqlServer/Dts"
  DTS:refId="Package"
  DTS:CreationDate="2/22/2012 10:27:39 AM"
  DTS:CreationName="Microsoft.Package"
  DTS:CreatorComputerName="ITWS18"
  DTS:CreatorName="HCFM\hdu"
  DTS:DTSID="{CE0E2616-4675-4008-A3B8-516ECB62D9D6}"
  DTS:ExecutableType="Microsoft.Package"
  DTS:LastModifiedProductVersion="14.0.3048.4"
  DTS:LocaleID="1033"
  DTS:ObjectName="ExportOrderPriceUpdate"
  DTS:PackageType="5"
  DTS:ProtectionLevel="5"
  DTS:SuppressConfigurationWarnings="True"
  DTS:VersionBuild="131"
  DTS:VersionGUID="{CB69C38B-9703-4371-83D5-787910BDBB18}">
  <DTS:Property
    DTS:Name="PackageFormatVersion">8</DTS:Property>
  <DTS:ConnectionManagers>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[CMSConnection]"
      DTS:CreationName="OLEDB"
      DTS:DTSID="{7FF16ED2-2AF4-4A66-8166-F9DB3D3987B2}"
      DTS:ObjectName="CMSConnection">
      <DTS:ObjectData>
        <DTS:ConnectionManager
          DTS:ConnectionString="Data Source=HCTESTSQL01;Initial Catalog=HairClubCMSTest;Provider=SQLNCLI11;Integrated Security=SSPI;Auto Translate=False;Application Name=ExportOrderPriceUpdate;" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[SMTP Connection Manager]"
      DTS:CreationName="SMTP"
      DTS:DTSID="{44746D80-BC52-4CE6-8DCE-21F9A9AE6791}"
      DTS:ObjectName="SMTP Connection Manager">
      <DTS:ObjectData>
        <SmtpConnectionManager
          ConnectionString="SmtpServer=HCSMTP.hcfm.com;UseWindowsAuthentication=True;EnableSsl=False;" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
  </DTS:ConnectionManagers>
  <DTS:PackageParameters>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{86B180E6-E3A6-4010-BE5F-7D0B65C9FAD0}"
      DTS:ObjectName="BCCLine">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue"
        xml:space="preserve"></DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{3D581DFC-FC27-4F5E-96AF-C108076BF33C}"
      DTS:ObjectName="CCLine">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue"
        xml:space="preserve"></DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{5FE1B117-BCCB-494F-B43E-9092BA88FC52}"
      DTS:ObjectName="FromLine"
      DTS:Required="True">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">aptak@hcfm.com</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{BF0E1E66-7FFC-4AA8-8CBA-EB6488E19CC7}"
      DTS:ObjectName="SaveDirectory"
      DTS:Required="True">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">E:\SSIS\Projects\HC\ExportByHPONumberAndFactory\HCFilesXML\PriceUpdate\</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{5753FFEA-8B37-4F1B-B98E-69CC0864666F}"
      DTS:ObjectName="Subject"
      DTS:Required="True">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">Factory Price Update</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{198A0344-6269-4DFE-A96A-0B5456ED1BB1}"
      DTS:ObjectName="ToLine"
      DTS:Required="True">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">aptak@hcfm.com</DTS:Property>
    </DTS:PackageParameter>
  </DTS:PackageParameters>
  <DTS:Variables>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{E89159B6-D2A8-40D9-98EE-10B6D3D665D3}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="EmailAttachments">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{D6F17E1F-BE41-447A-8B2A-E1AB2B8EB832}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="FactoryCode">
      <DTS:VariableValue
        DTS:DataType="8">5A</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{BF44BC8B-511C-49F4-BB9B-CB48B6EEF4A4}"
      DTS:IncludeInDebugDump="6789"
      DTS:Namespace="User"
      DTS:ObjectName="FactoryList">
      <DTS:VariableValue
        DTS:DataSubType="ManagedSerializable"
        DTS:DataType="13">
        <SOAP-ENV:Envelope xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
          <SOAP-ENV:Body>
            <xsd:anyType
              id="ref-1"></xsd:anyType>
          </SOAP-ENV:Body>
        </SOAP-ENV:Envelope>
      </DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{0A262CCF-01F3-4029-BF52-D2D5C55A773A}"
      DTS:IncludeInDebugDump="6789"
      DTS:Namespace="User"
      DTS:ObjectName="PriceList">
      <DTS:VariableValue
        DTS:DataSubType="ManagedSerializable"
        DTS:DataType="13">
        <SOAP-ENV:Envelope xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
          <SOAP-ENV:Body>
            <xsd:anyType
              id="ref-1"></xsd:anyType>
          </SOAP-ENV:Body>
        </SOAP-ENV:Envelope>
      </DTS:VariableValue>
    </DTS:Variable>
  </DTS:Variables>
  <DTS:Executables>
    <DTS:Executable
      DTS:refId="Package\Cleanup Task"
      DTS:CreationName="Microsoft.ScriptTask"
      DTS:Description="Cleanup Task"
      DTS:DTSID="{D802FBB7-64DB-4CD0-9ED0-D7D970C4B9BE}"
      DTS:ExecutableType="Microsoft.ScriptTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="Cleanup Task"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:ObjectData>
        <ScriptProject
          Name="ST_07a74a55d6864247a54f1ccfbed42465"
          VSTAMajorVersion="15"
          VSTAMinorVersion="0"
          Language="CSharp"
          ReadOnlyVariables="$Package::SaveDirectory">
          <ProjectItem
            Name="Properties\Resources.resx"
            Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem>
          <ProjectItem
            Name="Properties\Settings.Designer.cs"
            Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_07a74a55d6864247a54f1ccfbed42465.Properties.Settings.get_Default():ST_07a74a55d6864247a54f1ccfbed42465.Properties.Sett" +
    "ings")]

namespace ST_07a74a55d6864247a54f1ccfbed42465.Properties {
    
    
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem>
          <ProjectItem
            Name="ScriptMain.cs"
            Encoding="UTF8"><![CDATA[#region Help:  Introduction to the script task
/* The Script Task allows you to perform virtually any operation that can be accomplished in
 * a .Net application within the context of an Integration Services control flow. 
 * 
 * Expand the other regions which have "Help" prefixes for examples of specific ways to use
 * Integration Services features within this script task. */
#endregion


#region Namespaces
using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using System.IO;
#endregion

namespace ST_07a74a55d6864247a54f1ccfbed42465
{
    /// <summary>
    /// ScriptMain is the entry point class of the script.  Do not change the name, attributes,
    /// or parent of this class.
    /// </summary>
	[Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
	public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
	{
        #region Help:  Using Integration Services variables and parameters in a script
        /* To use a variable in this script, first ensure that the variable has been added to 
         * either the list contained in the ReadOnlyVariables property or the list contained in 
         * the ReadWriteVariables property of this script task, according to whether or not your
         * code needs to write to the variable.  To add the variable, save this script, close this instance of
         * Visual Studio, and update the ReadOnlyVariables and 
         * ReadWriteVariables properties in the Script Transformation Editor window.
         * To use a parameter in this script, follow the same steps. Parameters are always read-only.
         * 
         * Example of reading from a variable:
         *  DateTime startTime = (DateTime) Dts.Variables["System::StartTime"].Value;
         * 
         * Example of writing to a variable:
         *  Dts.Variables["User::myStringVariable"].Value = "new value";
         * 
         * Example of reading from a package parameter:
         *  int batchId = (int) Dts.Variables["$Package::batchId"].Value;
         *  
         * Example of reading from a project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].Value;
         * 
         * Example of reading from a sensitive project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].GetSensitiveValue();
         * */

        #endregion

        #region Help:  Firing Integration Services events from a script
        /* This script task can fire events for logging purposes.
         * 
         * Example of firing an error event:
         *  Dts.Events.FireError(18, "Process Values", "Bad value", "", 0);
         * 
         * Example of firing an information event:
         *  Dts.Events.FireInformation(3, "Process Values", "Processing has started", "", 0, ref fireAgain)
         * 
         * Example of firing a warning event:
         *  Dts.Events.FireWarning(14, "Process Values", "No values received for input", "", 0);
         * */
        #endregion

        #region Help:  Using Integration Services connection managers in a script
        /* Some types of connection managers can be used in this script task.  See the topic 
         * "Working with Connection Managers Programatically" for details.
         * 
         * Example of using an ADO.Net connection manager:
         *  object rawConnection = Dts.Connections["Sales DB"].AcquireConnection(Dts.Transaction);
         *  SqlConnection myADONETConnection = (SqlConnection)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Sales DB"].ReleaseConnection(rawConnection);
         *
         * Example of using a File connection manager
         *  object rawConnection = Dts.Connections["Prices.zip"].AcquireConnection(Dts.Transaction);
         *  string filePath = (string)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Prices.zip"].ReleaseConnection(rawConnection);
         * */
        #endregion


		/// <summary>
        /// This method is called when this script task executes in the control flow.
        /// Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
        /// To open Help, press F1.
        /// </summary>
		public void Main()
		{
            try
            {
                string sourceFolder = Dts.Variables["SaveDirectory"].Value.ToString();

                foreach (string x in Directory.GetFiles(sourceFolder))
                {
                    File.Delete(x);
                }
            }
            catch
            {
                // TODO: Add your code here
            }

            Dts.TaskResult = (int)ScriptResults.Success;
		}

        #region ScriptResults declaration
        /// <summary>
        /// This enum provides a convenient shorthand within the scope of this class for setting the
        /// result of the script.
        /// 
        /// This code was generated automatically.
        /// </summary>
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

	}
}]]></ProjectItem>
          <ProjectItem
            Name="ST_07a74a55d6864247a54f1ccfbed42465.csproj"
            Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{bd916d09-3d74-4a89-a2f2-d0f0f171ca80}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ST_07a74a55d6864247a54f1ccfbed42465</RootNamespace>
    <AssemblyName>ST_07a74a55d6864247a54f1ccfbed42465</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>true</ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>
    <TargetFrameworkProfile></TargetFrameworkProfile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="ScriptTask" HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}" ApplicationType="usd" Language="cs" TemplatesPath="" DebugInfoCommandLine="" DebugInfoWorkingDir="" IconImageList="" />
        <Host Name="ScriptTask" GeneratedNamespace="$safeprojectname" IconIndex=""></Host>
        <ProjectClient>
          <HostIdentifier>SSIS_ST130</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem>
          <ProjectItem
            Name="Project"
            Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="4.0" schemaVersion="1.0">
	<msb:PropertyGroup>
		<msb:CodeName>ST_07a74a55d6864247a54f1ccfbed42465</msb:CodeName>
		<msb:Language>msBuild</msb:Language>
		<msb:DisplayName>ST_07a74a55d6864247a54f1ccfbed42465</msb:DisplayName>
		<msb:ProjectId>{EBD92872-F3BE-4EFD-A683-B9107422EB31}</msb:ProjectId>
	</msb:PropertyGroup>
	<msb:ItemGroup>
		<msb:Project Include="ST_07a74a55d6864247a54f1ccfbed42465.csproj"/>
		<msb:File Include="Properties\Settings.settings"/>
		<msb:File Include="Properties\AssemblyInfo.cs"/>
		<msb:File Include="Properties\Resources.resx"/>
		<msb:File Include="Properties\Resources.Designer.cs"/>
		<msb:File Include="Properties\Settings.Designer.cs"/>
		<msb:File Include="ScriptMain.cs"/>
	</msb:ItemGroup>
</c:Project>]]></ProjectItem>
          <ProjectItem
            Name="Properties\AssemblyInfo.cs"
            Encoding="UTF8"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_07a74a55d6864247a54f1ccfbed42465")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ST_07a74a55d6864247a54f1ccfbed42465")]
[assembly: AssemblyCopyright("Copyright @  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem>
          <ProjectItem
            Name="Properties\Settings.settings"
            Encoding="UTF8"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem>
          <ProjectItem
            Name="Properties\Resources.Designer.cs"
            Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_07a74a55d6864247a54f1ccfbed42465.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_07a74a55d6864247a54f1ccfbed42465.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_07a74a55d6864247a54f1ccfbed42465.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_07a74a55d6864247a54f1ccfbed42465.Properties {
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if ((resourceMan == null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_07a74a55d6864247a54f1ccfbed42465.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem>
          <BinaryItem
            Name="ST_07a74a55d6864247a54f1ccfbed42465.dll">TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1v
ZGUuDQ0KJAAAAAAAAABQRQAATAEDAN7folsAAAAAAAAAAOAAIiALATAAABAAAAAIAAAAAAAAAi4A
AAAgAAAAQAAAAAAAEAAgAAAAAgAABAAAAAAAAAAGAAAAAAAAAACAAAAAAgAAAAAAAAMAYIUAABAA
ABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAALAtAABPAAAAAEAAAHgEAAAAAAAAAAAAAAAAAAAA
AAAAAGAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAIAAACAAAAAAAAAAAAAAACCAAAEgAAAAAAAAAAAAAAC50ZXh0AAAACA4AAAAgAAAAEAAAAAIA
AAAAAAAAAAAAAAAAACAAAGAucnNyYwAAAHgEAAAAQAAAAAYAAAASAAAAAAAAAAAAAAAAAABAAABA
LnJlbG9jAAAMAAAAAGAAAAACAAAAGAAAAAAAAAAAAAAAAAAAQAAAQgAAAAAAAAAAAAAAAAAAAADk
LQAAAAAAAEgAAAACAAUAJCEAANQLAAABAAAAAAAAAPgsAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAABswAgBNAAAAAQAAEQIoEAAACm8RAAAKcgEAAHBvEgAACm8T
AAAKbxQAAAooFQAACgoWCysMBgeaKBYAAAoHF1gLBwaOaTLu3gMm3gACKBAAAAoWbxcAAAoqAAAA
ARAAAAAAAAA9PQADDwAAAR4CKBgAAAoqHgIoGQAACiqufgEAAAQtHnIdAABw0AMAAAIoGgAACm8b
AAAKcxwAAAqAAQAABH4BAAAEKhp+AgAABCoeAoACAAAEKhp+AwAABCoeAigdAAAKKi5zCAAABoAD
AAAEKgAAQlNKQgEAAQAAAAAADAAAAHY0LjAuMzAzMTkAAAAABQBsAAAA1AMAACN+AABABAAAhAUA
ACNTdHJpbmdzAAAAAMQJAACQAAAAI1VTAFQKAAAQAAAAI0dVSUQAAABkCgAAcAEAACNCbG9iAAAA
AAAAAAIAAAFXHaIBCQMAAAD6ATMAFgAAAQAAAB8AAAAFAAAABgAAAAkAAAABAAAAHQAAAAIAAAAQ
AAAAAQAAAAIAAAADAAAABAAAAAEAAAAEAAAAAQAAAAEAAAAAAIsDAQAAAAAABgA7AlsEBgDKAlsE
BgCHAUgEDwDPBAAABgC0AQkEBgAeAgkEBgD/AQkEBgCxAgkEBgBbAgkEBgB0AgkEBgDLAQkEBgDm
AfgCCgCPAjoDCgD/ADoDBgBLBbwDBgDDA7wDBgBqAUgEBgArBHsEBgAbBPQDDgAzAXUDDgCbAXUD
DgAbAd8DBgBPAVsECgBjAzoDEgARBaoAEgB4AKoABgB6BS4ABgClAC4ABgDKALwDBgCBALwDBgBx
BQkEAAAAACUAAAAAAAEAAQABABAA1AMBADkAAQABAAAAEACCBN4EPQABAAMAAAEQACQF3gRZAAMA
BwADAQAAPQUAAEEABAAKABEAyANzABEA7wB3ABEAaAB7AAYGVwB/AFaALQWCAFaAzwCCAFAgAAAA
AIYA2gMGAAEAvCAAAAAAhhg7BAYAAQDEIAAAAACDGDsEBgABAMwgAAAAAJMIJwSGAAEA+CAAAAAA
kwjXAIsAAQD/IAAAAACTCOMAkAABAAchAAAAAJYIUgWWAAIADiEAAAAAhhg7BAYAAgAWIQAAAACR
GEEEmwACAAAAAQDyAgkAOwQBABEAOwQGABkAOwQKACkAOwQQADEAOwQQADkAOwQQAEEAOwQQAEkA
OwQQAFEAOwQQAFkAOwQQAGEAOwQQAGkAOwQGAIkAOwQGAKkAOwQVALkAOwQGAHEANQUhAMEADQUm
AMkAswMrANEA6AIxAHkAEgM1ANkAGwU5AOEASAE/AMEAXgUBAHEAOwQGAHkAOwQGAOkAkwBEAOkA
bQVLAJEAOwRQALEAOwQGAAgAFABpAAgAGABuACkAcwDWAC4ACwCuAC4AEwC3AC4AGwDWAC4AIwDf
AC4AKwAIAS4AMwAIAS4AOwAIAS4AQwDfAC4ASwAOAS4AUwAIAS4AWwAlAUMAYwBuAEkAcwDWAGEA
ewBuAGMAawBuABsAAwABAAQAAwAAACsEnwAAAPcApAAAAFYFqQACAAQAAwACAAUABQABAAYABQAC
AAcABwAEgAAAAQAAALQaB4QAAAAAAAABAAAABAAAAAAAAAAAAAAAVwBfAAAAAAAOAAAAAAAAAAAA
AABgABsDAAAAAAQAAAAAAAAAAAAAAFcAvAMAAAAADgAAAAAAAAAAAAAAYAA4AAAAAAAAAAAAAQAA
AIwEAAAFAAIAAAAAU1RfMDdhNzRhNTVkNjg2NDI0N2E1NGYxY2NmYmVkNDI0NjUAPE1vZHVsZT4A
U3lzdGVtLklPAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuTWFuYWdlZERUUwB2YWx1ZV9fAG1zY29ybGli
AGRlZmF1bHRJbnN0YW5jZQBWYXJpYWJsZQBSdW50aW1lVHlwZUhhbmRsZQBHZXRUeXBlRnJvbUhh
bmRsZQBGaWxlAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuRHRzLlJ1bnRpbWUAVHlwZQBGYWlsdXJlAGdl
dF9DdWx0dXJlAHNldF9DdWx0dXJlAHJlc291cmNlQ3VsdHVyZQBWU1RBUlRTY3JpcHRPYmplY3RN
b2RlbEJhc2UAQXBwbGljYXRpb25TZXR0aW5nc0Jhc2UARWRpdG9yQnJvd3NhYmxlU3RhdGUARGVs
ZXRlAENvbXBpbGVyR2VuZXJhdGVkQXR0cmlidXRlAERlYnVnZ2VyTm9uVXNlckNvZGVBdHRyaWJ1
dGUARGVidWdnYWJsZUF0dHJpYnV0ZQBFZGl0b3JCcm93c2FibGVBdHRyaWJ1dGUAQXNzZW1ibHlU
aXRsZUF0dHJpYnV0ZQBBc3NlbWJseVRyYWRlbWFya0F0dHJpYnV0ZQBUYXJnZXRGcmFtZXdvcmtB
dHRyaWJ1dGUAQXNzZW1ibHlDb25maWd1cmF0aW9uQXR0cmlidXRlAEFzc2VtYmx5RGVzY3JpcHRp
b25BdHRyaWJ1dGUAQ29tcGlsYXRpb25SZWxheGF0aW9uc0F0dHJpYnV0ZQBBc3NlbWJseVByb2R1
Y3RBdHRyaWJ1dGUAQXNzZW1ibHlDb3B5cmlnaHRBdHRyaWJ1dGUAU1NJU1NjcmlwdFRhc2tFbnRy
eVBvaW50QXR0cmlidXRlAEFzc2VtYmx5Q29tcGFueUF0dHJpYnV0ZQBSdW50aW1lQ29tcGF0aWJp
bGl0eUF0dHJpYnV0ZQBnZXRfVmFsdWUAdmFsdWUAU3lzdGVtLlJ1bnRpbWUuVmVyc2lvbmluZwBU
b1N0cmluZwBNaWNyb3NvZnQuU3FsU2VydmVyLlNjcmlwdFRhc2sATWljcm9zb2Z0LlNxbFNlcnZl
ci5EdHMuVGFza3MuU2NyaXB0VGFzawBTY3JpcHRPYmplY3RNb2RlbABTeXN0ZW0uQ29tcG9uZW50
TW9kZWwAU1RfMDdhNzRhNTVkNjg2NDI0N2E1NGYxY2NmYmVkNDI0NjUuZGxsAGdldF9JdGVtAFN5
c3RlbQBFbnVtAHJlc291cmNlTWFuAFNjcmlwdE1haW4AU3lzdGVtLkNvbmZpZ3VyYXRpb24AU3lz
dGVtLkdsb2JhbGl6YXRpb24AU3lzdGVtLlJlZmxlY3Rpb24AQ3VsdHVyZUluZm8AZ2V0X1Jlc291
cmNlTWFuYWdlcgAuY3RvcgAuY2N0b3IAU3lzdGVtLkRpYWdub3N0aWNzAFN5c3RlbS5SdW50aW1l
LkNvbXBpbGVyU2VydmljZXMAU3lzdGVtLlJlc291cmNlcwBTVF8wN2E3NGE1NWQ2ODY0MjQ3YTU0
ZjFjY2ZiZWQ0MjQ2NS5Qcm9wZXJ0aWVzLlJlc291cmNlcy5yZXNvdXJjZXMARGVidWdnaW5nTW9k
ZXMAU1RfMDdhNzRhNTVkNjg2NDI0N2E1NGYxY2NmYmVkNDI0NjUuUHJvcGVydGllcwBnZXRfVmFy
aWFibGVzAEdldEZpbGVzAFNldHRpbmdzAFN1Y2Nlc3MAZ2V0X0R0cwBTY3JpcHRSZXN1bHRzAE9i
amVjdABnZXRfRGVmYXVsdABzZXRfVGFza1Jlc3VsdABnZXRfQXNzZW1ibHkARGlyZWN0b3J5AAAb
UwBhAHYAZQBEAGkAcgBlAGMAdABvAHIAeQAAcVMAVABfADAANwBhADcANABhADUANQBkADYAOAA2
ADQAMgA0ADcAYQA1ADQAZgAxAGMAYwBmAGIAZQBkADQAMgA0ADYANQAuAFAAcgBvAHAAZQByAHQA
aQBlAHMALgBSAGUAcwBvAHUAcgBjAGUAcwAAAOiCSi7bji9FoO013ipN5jQABCABAQgDIAABBSAB
ARERBCABAQ4FIAEBEVEFBwIdDggEIAASYQQgABJlBSABEmkcAyAAHAMgAA4FAAEdDg4EAAEBDgYA
ARJ1EXkEIAASfQYgAgEOEn0It3pcVhk04IkIiYRdzYCAzJEEAAAAAAQBAAAAAwYSSQMGEk0DBhIQ
AgYIAwYRFAQAABJJBAAAEk0FAAEBEk0EAAASEAMAAAEECAASSQQIABJNBAgAEhAIAQAIAAAAAAAe
AQABAFQCFldyYXBOb25FeGNlcHRpb25UaHJvd3MBCAEAAgAAAAAAKAEAI1NUXzA3YTc0YTU1ZDY4
NjQyNDdhNTRmMWNjZmJlZDQyNDY1AAAFAQAAAAAWAQARQ29weXJpZ2h0IEAgIDIwMTgAAEkBABou
TkVURnJhbWV3b3JrLFZlcnNpb249djQuNQEAVA4URnJhbWV3b3JrRGlzcGxheU5hbWUSLk5FVCBG
cmFtZXdvcmsgNC41ALQAAADOyu++AQAAAJEAAABsU3lzdGVtLlJlc291cmNlcy5SZXNvdXJjZVJl
YWRlciwgbXNjb3JsaWIsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNL
ZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5I1N5c3RlbS5SZXNvdXJjZXMuUnVudGltZVJlc291cmNl
U2V0AgAAAAAAAAAAAAAAUEFEUEFEULQAAADYLQAAAAAAAAAAAADyLQAAACAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAA5C0AAAAAAAAAAAAAAABfQ29yRGxsTWFpbgBtc2NvcmVlLmRsbAAAAAAA/yUAIAAQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAABABAAAAAYAACAAAAAAAAAAAAAAAAAAAABAAEAAAAwAACAAAAAAAAAAAAAAAAAAAABAAAA
AABIAAAAWEAAABoEAAAAAAAAAAAAABoENAAAAFYAUwBfAFYARQBSAFMASQBPAE4AXwBJAE4ARgBP
AAAAAAC9BO/+AAABAAAAAQAHhLQaAAABAAeEtBo/AAAAAAAAAAQAAAACAAAAAAAAAAAAAAAAAAAA
RAAAAAEAVgBhAHIARgBpAGwAZQBJAG4AZgBvAAAAAAAkAAQAAABUAHIAYQBuAHMAbABhAHQAaQBv
AG4AAAAAAAAAsAR6AwAAAQBTAHQAcgBpAG4AZwBGAGkAbABlAEkAbgBmAG8AAABWAwAAAQAwADAA
MAAwADAANABiADAAAAAaAAEAAQBDAG8AbQBtAGUAbgB0AHMAAAAAAAAAIgABAAEAQwBvAG0AcABh
AG4AeQBOAGEAbQBlAAAAAAAAAAAAcAAkAAEARgBpAGwAZQBEAGUAcwBjAHIAaQBwAHQAaQBvAG4A
AAAAAFMAVABfADAANwBhADcANABhADUANQBkADYAOAA2ADQAMgA0ADcAYQA1ADQAZgAxAGMAYwBm
AGIAZQBkADQAMgA0ADYANQAAAD4ADwABAEYAaQBsAGUAVgBlAHIAcwBpAG8AbgAAAAAAMQAuADAA
LgA2ADgAMwA2AC4AMwAzADcAOQA5AAAAAABwACgAAQBJAG4AdABlAHIAbgBhAGwATgBhAG0AZQAA
AFMAVABfADAANwBhADcANABhADUANQBkADYAOAA2ADQAMgA0ADcAYQA1ADQAZgAxAGMAYwBmAGIA
ZQBkADQAMgA0ADYANQAuAGQAbABsAAAASAASAAEATABlAGcAYQBsAEMAbwBwAHkAcgBpAGcAaAB0
AAAAQwBvAHAAeQByAGkAZwBoAHQAIABAACAAIAAyADAAMQA4AAAAKgABAAEATABlAGcAYQBsAFQA
cgBhAGQAZQBtAGEAcgBrAHMAAAAAAAAAAAB4ACgAAQBPAHIAaQBnAGkAbgBhAGwARgBpAGwAZQBu
AGEAbQBlAAAAUwBUAF8AMAA3AGEANwA0AGEANQA1AGQANgA4ADYANAAyADQANwBhADUANABmADEA
YwBjAGYAYgBlAGQANAAyADQANgA1AC4AZABsAGwAAABoACQAAQBQAHIAbwBkAHUAYwB0AE4AYQBt
AGUAAAAAAFMAVABfADAANwBhADcANABhADUANQBkADYAOAA2ADQAMgA0ADcAYQA1ADQAZgAxAGMA
YwBmAGIAZQBkADQAMgA0ADYANQAAAEIADwABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAA
ADEALgAwAC4ANgA4ADMANgAuADMAMwA3ADkAOQAAAAAARgAPAAEAQQBzAHMAZQBtAGIAbAB5ACAA
VgBlAHIAcwBpAG8AbgAAADEALgAwAC4ANgA4ADMANgAuADMAMwA3ADkAOQAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAwAAAAEPgAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</BinaryItem>
        </ScriptProject>
      </DTS:ObjectData>
    </DTS:Executable>
    <DTS:Executable
      DTS:refId="Package\Foreach Hair Factory"
      DTS:CreationName="STOCK:FOREACHLOOP"
      DTS:Description="Foreach Loop Container"
      DTS:DTSID="{287490E1-DF66-426E-BD27-6535ED937E5C}"
      DTS:ExecutableType="STOCK:FOREACHLOOP"
      DTS:LocaleID="-1"
      DTS:ObjectName="Foreach Hair Factory">
      <DTS:ForEachEnumerator
        DTS:CreationName="Microsoft.ForEachADOEnumerator"
        DTS:DTSID="{4C541E49-6BE5-49BC-BA58-3544EE7CB174}"
        DTS:ObjectName="{4C541E49-6BE5-49BC-BA58-3544EE7CB174}">
        <DTS:ObjectData>
          <FEEADO
            EnumType="EnumerateRowsInFirstTable"
            VarName="User::FactoryList" />
        </DTS:ObjectData>
      </DTS:ForEachEnumerator>
      <DTS:Variables />
      <DTS:Executables>
        <DTS:Executable
          DTS:refId="Package\Foreach Hair Factory\Create XML"
          DTS:CreationName="Microsoft.ScriptTask"
          DTS:Description="Script Task"
          DTS:DTSID="{E4F6D492-9914-45E6-A257-5D0422250DDF}"
          DTS:ExecutableType="Microsoft.ScriptTask"
          DTS:LocaleID="-1"
          DTS:ObjectName="Create XML"
          DTS:ThreadHint="0">
          <DTS:Variables />
          <DTS:ObjectData>
            <ScriptProject
              Name="ST_3c47d42ad6f44aa593d59449b7b7eb81"
              VSTAMajorVersion="15"
              VSTAMinorVersion="0"
              Language="CSharp"
              ReadOnlyVariables="User::FactoryCode,User::PriceList,$Package::SaveDirectory"
              ReadWriteVariables="User::EmailAttachments">
              <ProjectItem
                Name="Properties\AssemblyInfo.cs"
                Encoding="UTF8"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_3c47d42ad6f44aa593d59449b7b7eb81")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ST_3c47d42ad6f44aa593d59449b7b7eb81")]
[assembly: AssemblyCopyright("Copyright @  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem>
              <ProjectItem
                Name="Properties\Resources.resx"
                Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem>
              <ProjectItem
                Name="ST_3c47d42ad6f44aa593d59449b7b7eb81.csproj"
                Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{B67A51FA-1FF6-44F8-9922-8CA24F899514}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ST_3c47d42ad6f44aa593d59449b7b7eb81</RootNamespace>
    <AssemblyName>ST_3c47d42ad6f44aa593d59449b7b7eb81</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>true</ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>
    <TargetFrameworkProfile></TargetFrameworkProfile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="VSTAHostName" HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}" ApplicationType="usd" Language="cs" TemplatesPath="" />
        <Host Name="ScriptTask" />
        <ProjectClient>
          <HostIdentifier>SSIS_ST130</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem>
              <ProjectItem
                Name="ScriptMain.cs"
                Encoding="UTF8"><![CDATA[#region Help:  Introduction to the script task
/* The Script Task allows you to perform virtually any operation that can be accomplished in
 * a .Net application within the context of an Integration Services control flow. 
 * 
 * Expand the other regions which have "Help" prefixes for examples of specific ways to use
 * Integration Services features within this script task. */
#endregion


#region Namespaces
using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using System.Data.OleDb;
using System.Xml.Serialization;
using System.IO;
#endregion

namespace ST_3c47d42ad6f44aa593d59449b7b7eb81
{
    /// <summary>
    /// ScriptMain is the entry point class of the script.  Do not change the name, attributes,
    /// or parent of this class.
    /// </summary>
	[Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
	public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
	{
        #region Help:  Using Integration Services variables and parameters in a script
        /* To use a variable in this script, first ensure that the variable has been added to 
         * either the list contained in the ReadOnlyVariables property or the list contained in 
         * the ReadWriteVariables property of this script task, according to whether or not your
         * code needs to write to the variable.  To add the variable, save this script, close this instance of
         * Visual Studio, and update the ReadOnlyVariables and 
         * ReadWriteVariables properties in the Script Transformation Editor window.
         * To use a parameter in this script, follow the same steps. Parameters are always read-only.
         * 
         * Example of reading from a variable:
         *  DateTime startTime = (DateTime) Dts.Variables["System::StartTime"].Value;
         * 
         * Example of writing to a variable:
         *  Dts.Variables["User::myStringVariable"].Value = "new value";
         * 
         * Example of reading from a package parameter:
         *  int batchId = (int) Dts.Variables["$Package::batchId"].Value;
         *  
         * Example of reading from a project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].Value;
         * 
         * Example of reading from a sensitive project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].GetSensitiveValue();
         * */

        #endregion

        #region Help:  Firing Integration Services events from a script
        /* This script task can fire events for logging purposes.
         * 
         * Example of firing an error event:
         *  Dts.Events.FireError(18, "Process Values", "Bad value", "", 0);
         * 
         * Example of firing an information event:
         *  Dts.Events.FireInformation(3, "Process Values", "Processing has started", "", 0, ref fireAgain)
         * 
         * Example of firing a warning event:
         *  Dts.Events.FireWarning(14, "Process Values", "No values received for input", "", 0);
         * */
        #endregion

        #region Help:  Using Integration Services connection managers in a script
        /* Some types of connection managers can be used in this script task.  See the topic 
         * "Working with Connection Managers Programatically" for details.
         * 
         * Example of using an ADO.Net connection manager:
         *  object rawConnection = Dts.Connections["Sales DB"].AcquireConnection(Dts.Transaction);
         *  SqlConnection myADONETConnection = (SqlConnection)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Sales DB"].ReleaseConnection(rawConnection);
         *
         * Example of using a File connection manager
         *  object rawConnection = Dts.Connections["Prices.zip"].AcquireConnection(Dts.Transaction);
         *  string filePath = (string)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Prices.zip"].ReleaseConnection(rawConnection);
         * */
        #endregion


        /// <summary>
        /// This method is called when this script task executes in the control flow.
        /// Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
        /// To open Help, press F1.
        /// </summary>
        public void Main()
        {
            object x = Dts.Variables["PriceList"].Value;
            string dir = Dts.Variables["SaveDirectory"].Value.ToString();
            string fc = Dts.Variables["FactoryCode"].Value.ToString();
            string filename = dir + "\\PRICEUPDATE_" + fc + "_" + DateTime.Today.ToString("yyyyMMdd") + ".xml";

            OleDbDataAdapter oleDA = new OleDbDataAdapter();
            DataTable dt = new DataTable();
            oleDA.Fill(dt, x);

            if (dt.Rows.Count > 0)
            {
                HairSystemOrderPrice[] PriceList = new HairSystemOrderPrice[dt.Rows.Count];

                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    HairSystemOrderPrice NewPrice = new HairSystemOrderPrice();
                    NewPrice.FactoryCode = dt.Rows[i]["VendorDescriptionShort"].ToString();
                    NewPrice.ContractName = dt.Rows[i]["ContractName"].ToString();
                    NewPrice.HairSystemOrderNumber = dt.Rows[i]["HairSystemOrderNumber"].ToString();
                    NewPrice.HairSystemPrice = (decimal)dt.Rows[i]["HairSystemPrice"];

                    PriceList[i] = NewPrice;
                }

                if (Dts.Variables["EmailAttachments"].Value.ToString().Length > 0)
                    Dts.Variables["EmailAttachments"].Value += "|";

                Dts.Variables["EmailAttachments"].Value += filename;

                XmlSerializer xml = new XmlSerializer(PriceList.GetType());
                StreamWriter writer = new StreamWriter(filename);
                xml.Serialize(writer, PriceList);
                writer.Close();
                writer.Dispose();
            }

            Dts.TaskResult = (int)ScriptResults.Success;
        }
    }

    [Serializable]
    public class HairSystemOrderPrice
    {
        [XmlElement]
        public string FactoryCode { get; set; }

        [XmlElement]
        public string ContractName { get; set; }

        [XmlElement]
        public string HairSystemOrderNumber { get; set; }

        [XmlElement]
        public decimal HairSystemPrice { get; set; }
    }

    #region ScriptResults declaration
    /// <summary>
    /// This enum provides a convenient shorthand within the scope of this class for setting the
    /// result of the script.
    /// 
    /// This code was generated automatically.
    /// </summary>
    enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

}]]></ProjectItem>
              <ProjectItem
                Name="Project"
                Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="4.0" schemaVersion="1.0">
	<msb:PropertyGroup>
		<msb:CodeName>ST_3c47d42ad6f44aa593d59449b7b7eb81</msb:CodeName>
		<msb:Language>msBuild</msb:Language>
		<msb:DisplayName>ST_3c47d42ad6f44aa593d59449b7b7eb81</msb:DisplayName>
		<msb:ProjectId>{DD36A1D5-CE7D-4EFD-A9A9-137BEB9FA1C9}</msb:ProjectId>
	</msb:PropertyGroup>
	<msb:ItemGroup>
		<msb:Project Include="ST_3c47d42ad6f44aa593d59449b7b7eb81.csproj"/>
		<msb:File Include="Properties\Settings.settings"/>
		<msb:File Include="Properties\AssemblyInfo.cs"/>
		<msb:File Include="Properties\Resources.resx"/>
		<msb:File Include="Properties\Resources.Designer.cs"/>
		<msb:File Include="Properties\Settings.Designer.cs"/>
		<msb:File Include="ScriptMain.cs"/>
	</msb:ItemGroup>
</c:Project>]]></ProjectItem>
              <ProjectItem
                Name="Properties\Settings.Designer.cs"
                Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Settings.get_Default():ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Sett" +
    "ings")]

namespace ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties {
    
    
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem>
              <ProjectItem
                Name="Properties\Settings.settings"
                Encoding="UTF8"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem>
              <ProjectItem
                Name="Properties\Resources.Designer.cs"
                Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties {
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if ((resourceMan == null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_3c47d42ad6f44aa593d59449b7b7eb81.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem>
              <BinaryItem
                Name="ST_3c47d42ad6f44aa593d59449b7b7eb81.dll">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
EAByBQEAOQABAAEAASAQADEBAQA9AAEAAwAAAQAAaAcBAFkABQAMAAAAEAC2BhIHPQAIAAwAAAEQ
AE8HEgdxAAoAEAABAKcAxgABAMQAxgABAOIAxgABAIYAyQAGBlcAzQBWgFgH0ABWgAAC0AARAGYF
1AARACAC2AARAEYB3ABQIAAAAACGAHgFBgABAKEiAAAAAIYYbwYGAAEAqSIAAAAAhghWAUIAAQCx
IgAAAACGCGYBEAABALoiAAAAAIYIrQFCAAIAwiIAAAAAhgi+ARAAAgDLIgAAAACGCPAFQgADANMi
AAAAAIYICgYQAAMA3CIAAAAAhggJAeAABADkIgAAAACGCB0B5QAEAO0iAAAAAIYYbwYGAAUA7SIA
AAAAgxhvBgYABQD1IgAAAACTCCQG6wAFACEjAAAAAJMICALwAAUAKCMAAAAAkwgUAvUABQAwIwAA
AACWCI0H+wAGADcjAAAAAIYYbwYGAAYAPyMAAAAAkRh1BgABBgAAAAEAYwQAAAEAYwQAAAEAYwQA
AAEAYwQAAAEAYwQJAG8GAQARAG8GBgAZAG8GCgApAG8GEAAxAG8GEAA5AG8GEABBAG8GEABJAG8G
EABRAG8GEABZAG8GEABhAG8GEABpAG8GBgCZAG8GBgCpAG8GBgC5AG8GBgDZAG8GFQBxAGAHLgDp
AEEHMwDxAFEFOAD5AE8EPgB5AI0EQgCJALoHRgCJAI0ESwABAX8HUAAJAW8GBgCBAG8GBgAJAUEF
VgCBAHYHXQAZAagHYwARAVEFZwAhAVEFbgABAZYEYwABAX8HcwD5AFkEeQB5APgBfgAxAW8GhACR
AG8GEAAxAWkEiwA5AX8CBgA5AYUCBgDpAJkHAQBxAG8GBgB5AG8GBgApAZsBkwApAcQHnADBAG8G
ogDhAG8GBgAIABgAvAAIABwAwQAhAGsAwQApAHMAwQAuAAsAHAEuABMAJQEuABsARAEuACMATQEu
ACsAdgEuADMAdgEuADsAdgEuAEMATQEuAEsAfAEuAFMAdgEuAFsAkwFBAGsAwQBDAGMAwQBJAHMA
wQBgAGsAwQBhAGsAwQBpAHMAwQCAAGsAwQCBAGsAwQCJAHMAwQCgAGsAwQCjAHsAwQCpAIMARAHA
AGsAwQDJAIMARAHgAGsAwQAAAWsAwQAgAWsAwQBAAWsAwQBBAWsAwQAbAAMAAQAFAAUABgAHAAAA
agEEAQAAwgEEAQAADgYEAQAAIQEIAQAAKAYNAQAAKAISAQAAkQcXAQIAAwADAAEABAADAAIABQAF
AAEABgAFAAIABwAHAAEACAAHAAIACQAJAAEACgAJAAIADQALAAIADgANAAEADwANAAIAEAAPAASA
AAABAAAAtRpxOwAAAAAAAAEAAAAEAAAAAAAAAAAAAACqAH0AAAAAAA4AAAAAAAAAAAAAALMAoQQA
AAAABAAAAAAAAAAAAAAAqgBfAAAAAAAEAAAAAAAAAAAAAACqAEYFAAAAAAQAAAAAAAAAAAAAAKoA
WgUAAAAADgAAAAAAAAAAAAAAswA4AAAAAAAAAAAAAQAAAMAGAAAAAABTVF8zYzQ3ZDQyYWQ2ZjQ0
YWE1OTNkNTk0NDliN2I3ZWI4MQA8TW9kdWxlPgBTeXN0ZW0uSU8ATWljcm9zb2Z0LlNxbFNlcnZl
ci5NYW5hZ2VkRFRTAHZhbHVlX18AU3lzdGVtLkRhdGEAU3lzdGVtLkRhdGEuT2xlRGIAbXNjb3Js
aWIAPEhhaXJTeXN0ZW1QcmljZT5rX19CYWNraW5nRmllbGQAPEZhY3RvcnlDb2RlPmtfX0JhY2tp
bmdGaWVsZAA8Q29udHJhY3ROYW1lPmtfX0JhY2tpbmdGaWVsZAA8SGFpclN5c3RlbU9yZGVyTnVt
YmVyPmtfX0JhY2tpbmdGaWVsZABnZXRfSGFpclN5c3RlbVByaWNlAHNldF9IYWlyU3lzdGVtUHJp
Y2UASGFpclN5c3RlbU9yZGVyUHJpY2UAZGVmYXVsdEluc3RhbmNlAGdldF9GYWN0b3J5Q29kZQBz
ZXRfRmFjdG9yeUNvZGUARGF0YVRhYmxlAFZhcmlhYmxlAFJ1bnRpbWVUeXBlSGFuZGxlAEdldFR5
cGVGcm9tSGFuZGxlAGdldF9Db250cmFjdE5hbWUAc2V0X0NvbnRyYWN0TmFtZQBEYXRlVGltZQBN
aWNyb3NvZnQuU3FsU2VydmVyLkR0cy5SdW50aW1lAEdldFR5cGUARmFpbHVyZQBnZXRfQ3VsdHVy
ZQBzZXRfQ3VsdHVyZQByZXNvdXJjZUN1bHR1cmUAVlNUQVJUU2NyaXB0T2JqZWN0TW9kZWxCYXNl
AEludGVybmFsRGF0YUNvbGxlY3Rpb25CYXNlAEFwcGxpY2F0aW9uU2V0dGluZ3NCYXNlAENsb3Nl
AERpc3Bvc2UARWRpdG9yQnJvd3NhYmxlU3RhdGUAQ29tcGlsZXJHZW5lcmF0ZWRBdHRyaWJ1dGUA
RGVidWdnZXJOb25Vc2VyQ29kZUF0dHJpYnV0ZQBEZWJ1Z2dhYmxlQXR0cmlidXRlAEVkaXRvckJy
b3dzYWJsZUF0dHJpYnV0ZQBBc3NlbWJseVRpdGxlQXR0cmlidXRlAEFzc2VtYmx5VHJhZGVtYXJr
QXR0cmlidXRlAFRhcmdldEZyYW1ld29ya0F0dHJpYnV0ZQBBc3NlbWJseUNvbmZpZ3VyYXRpb25B
dHRyaWJ1dGUAQXNzZW1ibHlEZXNjcmlwdGlvbkF0dHJpYnV0ZQBDb21waWxhdGlvblJlbGF4YXRp
b25zQXR0cmlidXRlAEFzc2VtYmx5UHJvZHVjdEF0dHJpYnV0ZQBBc3NlbWJseUNvcHlyaWdodEF0
dHJpYnV0ZQBYbWxFbGVtZW50QXR0cmlidXRlAFNTSVNTY3JpcHRUYXNrRW50cnlQb2ludEF0dHJp
YnV0ZQBBc3NlbWJseUNvbXBhbnlBdHRyaWJ1dGUAUnVudGltZUNvbXBhdGliaWxpdHlBdHRyaWJ1
dGUAZ2V0X1ZhbHVlAHNldF9WYWx1ZQB2YWx1ZQBTZXJpYWxpemUAU3lzdGVtLlJ1bnRpbWUuVmVy
c2lvbmluZwBUb1N0cmluZwBnZXRfTGVuZ3RoAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuU2NyaXB0VGFz
awBNaWNyb3NvZnQuU3FsU2VydmVyLkR0cy5UYXNrcy5TY3JpcHRUYXNrAERlY2ltYWwAU2NyaXB0
T2JqZWN0TW9kZWwAU3lzdGVtLkNvbXBvbmVudE1vZGVsAFNUXzNjNDdkNDJhZDZmNDRhYTU5M2Q1
OTQ0OWI3YjdlYjgxLmRsbABGaWxsAFN5c3RlbS5YbWwAZ2V0X0l0ZW0AU3lzdGVtAEVudW0AcmVz
b3VyY2VNYW4AU2NyaXB0TWFpbgBTeXN0ZW0uQ29uZmlndXJhdGlvbgBTeXN0ZW0uR2xvYmFsaXph
dGlvbgBTeXN0ZW0uWG1sLlNlcmlhbGl6YXRpb24AU3lzdGVtLlJlZmxlY3Rpb24ARGF0YVJvd0Nv
bGxlY3Rpb24AQ3VsdHVyZUluZm8AZ2V0X0hhaXJTeXN0ZW1PcmRlck51bWJlcgBzZXRfSGFpclN5
c3RlbU9yZGVyTnVtYmVyAGdldF9SZXNvdXJjZU1hbmFnZXIAU3RyZWFtV3JpdGVyAFRleHRXcml0
ZXIAT2xlRGJEYXRhQWRhcHRlcgBYbWxTZXJpYWxpemVyAC5jdG9yAC5jY3RvcgBTeXN0ZW0uRGlh
Z25vc3RpY3MAU3lzdGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcwBTeXN0ZW0uUmVzb3VyY2Vz
AFNUXzNjNDdkNDJhZDZmNDRhYTU5M2Q1OTQ0OWI3YjdlYjgxLlByb3BlcnRpZXMuUmVzb3VyY2Vz
LnJlc291cmNlcwBEZWJ1Z2dpbmdNb2RlcwBTVF8zYzQ3ZDQyYWQ2ZjQ0YWE1OTNkNTk0NDliN2I3
ZWI4MS5Qcm9wZXJ0aWVzAGdldF9WYXJpYWJsZXMAU2V0dGluZ3MAU3VjY2VzcwBnZXRfRHRzAFNj
cmlwdFJlc3VsdHMAZ2V0X1Jvd3MAQ29uY2F0AE9iamVjdABnZXRfRGVmYXVsdABzZXRfVGFza1Jl
c3VsdABnZXRfQ291bnQARGF0YVJvdwBnZXRfVG9kYXkAZ2V0X0Fzc2VtYmx5AAAAAAATUAByAGkA
YwBlAEwAaQBzAHQAABtTAGEAdgBlAEQAaQByAGUAYwB0AG8AcgB5AAAXRgBhAGMAdABvAHIAeQBD
AG8AZABlAAAbXABQAFIASQBDAEUAVQBQAEQAQQBUAEUAXwAAA18AABF5AHkAeQB5AE0ATQBkAGQA
AAkuAHgAbQBsAAAtVgBlAG4AZABvAHIARABlAHMAYwByAGkAcAB0AGkAbwBuAFMAaABvAHIAdAAA
GUMAbwBuAHQAcgBhAGMAdABOAGEAbQBlAAArSABhAGkAcgBTAHkAcwB0AGUAbQBPAHIAZABlAHIA
TgB1AG0AYgBlAHIAAB9IAGEAaQByAFMAeQBzAHQAZQBtAFAAcgBpAGMAZQAAIUUAbQBhAGkAbABB
AHQAdABhAGMAaABtAGUAbgB0AHMAAAN8AABxUwBUAF8AMwBjADQANwBkADQAMgBhAGQANgBmADQA
NABhAGEANQA5ADMAZAA1ADkANAA0ADkAYgA3AGIANwBlAGIAOAAxAC4AUAByAG8AcABlAHIAdABp
AGUAcwAuAFIAZQBzAG8AdQByAGMAZQBzAAAAAAAyU71JHGYMT6OmXOdSmDbnAAQgAQEIAyAAAQUg
AQEREQQgAQEOBSABARFpEgcKHA4ODhJBEUUdEgwSSQgSDAQgABJ1BCAAEnkFIAESfRwDIAAcAyAA
DgQAABFFBCABDg4FAAEOHQ4GIAIIEkEcBSAAEoCJAyAACAYgARKAkQgEIAEcDgUAAg4cHAQgAQEc
BSAAEoCVBiABARKAlQcgAgESgJ0cCAABEoCVEYChBSAAEoClByACAQ4SgKUIt3pcVhk04IkIiYRd
zYCAzJEEAAAAAAQBAAAAAgYOAwYRUQIGCAMGERADBhJhAwYSZQMGEhgEIAARUQUgAQERUQQAABJh
BAAAEmUFAAEBEmUEAAASGAMAAAEDKAAOBCgAEVEECAASYQQIABJlBAgAEhgIAQAIAAAAAAAeAQAB
AFQCFldyYXBOb25FeGNlcHRpb25UaHJvd3MBCAEAAgAAAAAAKAEAI1NUXzNjNDdkNDJhZDZmNDRh
YTU5M2Q1OTQ0OWI3YjdlYjgxAAAFAQAAAAAWAQARQ29weXJpZ2h0IEAgIDIwMTgAAEkBABouTkVU
RnJhbWV3b3JrLFZlcnNpb249djQuNQEAVA4URnJhbWV3b3JrRGlzcGxheU5hbWUSLk5FVCBGcmFt
ZXdvcmsgNC41AAAAtAAAAM7K774BAAAAkQAAAGxTeXN0ZW0uUmVzb3VyY2VzLlJlc291cmNlUmVh
ZGVyLCBtc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tl
eVRva2VuPWI3N2E1YzU2MTkzNGUwODkjU3lzdGVtLlJlc291cmNlcy5SdW50aW1lUmVzb3VyY2VT
ZXQCAAAAAAAAAAAAAABQQURQQURQtAAAABQ2AAAAAAAAAAAAAC42AAAAIAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAgNgAAAAAAAAAAAAAAAF9Db3JEbGxNYWluAG1zY29yZWUuZGxsAAAAAAD/JQAgABAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAEAEAAAABgAAIAAAAAAAAAAAAAAAAAAAAEAAQAAADAAAIAAAAAAAAAAAAAAAAAAAAEAAAAAAEgA
AABYQAAAGgQAAAAAAAAAAAAAGgQ0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAA
AL0E7/4AAAEAAAABAHE7tRoAAAEAcTu1Gj8AAAAAAAAABAAAAAIAAAAAAAAAAAAAAAAAAABEAAAA
AQBWAGEAcgBGAGkAbABlAEkAbgBmAG8AAAAAACQABAAAAFQAcgBhAG4AcwBsAGEAdABpAG8AbgAA
AAAAAACwBHoDAAABAFMAdAByAGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAAFYDAAABADAAMAAwADAA
MAA0AGIAMAAAABoAAQABAEMAbwBtAG0AZQBuAHQAcwAAAAAAAAAiAAEAAQBDAG8AbQBwAGEAbgB5
AE4AYQBtAGUAAAAAAAAAAABwACQAAQBGAGkAbABlAEQAZQBzAGMAcgBpAHAAdABpAG8AbgAAAAAA
UwBUAF8AMwBjADQANwBkADQAMgBhAGQANgBmADQANABhAGEANQA5ADMAZAA1ADkANAA0ADkAYgA3
AGIANwBlAGIAOAAxAAAAPgAPAAEARgBpAGwAZQBWAGUAcgBzAGkAbwBuAAAAAAAxAC4AMAAuADYA
OAAzADcALgAxADUAMgAxADcAAAAAAHAAKAABAEkAbgB0AGUAcgBuAGEAbABOAGEAbQBlAAAAUwBU
AF8AMwBjADQANwBkADQAMgBhAGQANgBmADQANABhAGEANQA5ADMAZAA1ADkANAA0ADkAYgA3AGIA
NwBlAGIAOAAxAC4AZABsAGwAAABIABIAAQBMAGUAZwBhAGwAQwBvAHAAeQByAGkAZwBoAHQAAABD
AG8AcAB5AHIAaQBnAGgAdAAgAEAAIAAgADIAMAAxADgAAAAqAAEAAQBMAGUAZwBhAGwAVAByAGEA
ZABlAG0AYQByAGsAcwAAAAAAAAAAAHgAKAABAE8AcgBpAGcAaQBuAGEAbABGAGkAbABlAG4AYQBt
AGUAAABTAFQAXwAzAGMANAA3AGQANAAyAGEAZAA2AGYANAA0AGEAYQA1ADkAMwBkADUAOQA0ADQA
OQBiADcAYgA3AGUAYgA4ADEALgBkAGwAbAAAAGgAJAABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAA
AAAAUwBUAF8AMwBjADQANwBkADQAMgBhAGQANgBmADQANABhAGEANQA5ADMAZAA1ADkANAA0ADkA
YgA3AGIANwBlAGIAOAAxAAAAQgAPAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAu
ADAALgA2ADgAMwA3AC4AMQA1ADIAMQA3AAAAAABGAA8AAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUA
cgBzAGkAbwBuAAAAMQAuADAALgA2ADgAMwA3AC4AMQA1ADIAMQA3AAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAADAAAAEA2AAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</BinaryItem>
            </ScriptProject>
          </DTS:ObjectData>
        </DTS:Executable>
        <DTS:Executable
          DTS:refId="Package\Foreach Hair Factory\Query Prices"
          DTS:CreationName="Microsoft.ExecuteSQLTask"
          DTS:Description="Execute SQL Task"
          DTS:DTSID="{5FFBE16E-98EB-425F-904D-883DC58E6FFA}"
          DTS:ExecutableType="Microsoft.ExecuteSQLTask"
          DTS:LocaleID="-1"
          DTS:ObjectName="Query Prices"
          DTS:TaskContact="Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
          DTS:ThreadHint="0">
          <DTS:Variables />
          <DTS:ObjectData>
            <SQLTask:SqlTaskData
              SQLTask:Connection="{7FF16ED2-2AF4-4A66-8166-F9DB3D3987B2}"
              SQLTask:BypassPrepare="False"
              SQLTask:SqlStatementSource="EXEC mtnOpenFactoryOrderPriceExport ?"
              SQLTask:ResultType="ResultSetType_Rowset" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask">
              <SQLTask:ResultBinding
                SQLTask:ResultName="0"
                SQLTask:DtsVariableName="User::PriceList" />
              <SQLTask:ParameterBinding
                SQLTask:ParameterName="@FactoryCode"
                SQLTask:DtsVariableName="User::FactoryCode"
                SQLTask:ParameterDirection="Input"
                SQLTask:DataType="129"
                SQLTask:ParameterSize="1" />
            </SQLTask:SqlTaskData>
          </DTS:ObjectData>
        </DTS:Executable>
      </DTS:Executables>
      <DTS:PrecedenceConstraints>
        <DTS:PrecedenceConstraint
          DTS:refId="Package\Foreach Hair Factory.PrecedenceConstraints[Constraint 1]"
          DTS:CreationName=""
          DTS:DTSID="{1D8495EA-CCB9-4A5C-BBDD-A1AFFFF79218}"
          DTS:From="Package\Foreach Hair Factory\Query Prices"
          DTS:LogicalAnd="True"
          DTS:ObjectName="Constraint 1"
          DTS:To="Package\Foreach Hair Factory\Create XML" />
      </DTS:PrecedenceConstraints>
      <DTS:ForEachVariableMappings>
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{EFEBD023-EF6D-4C5F-9F11-015718434470}"
          DTS:ObjectName="{EFEBD023-EF6D-4C5F-9F11-015718434470}"
          DTS:ValueIndex="2"
          DTS:VariableName="User::FactoryCode" />
      </DTS:ForEachVariableMappings>
    </DTS:Executable>
    <DTS:Executable
      DTS:refId="Package\Get Hair Factories"
      DTS:CreationName="Microsoft.ExecuteSQLTask"
      DTS:Description="Execute SQL Task"
      DTS:DTSID="{3CB0B29B-B553-42F8-90ED-EB81A32353DC}"
      DTS:ExecutableType="Microsoft.ExecuteSQLTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="Get Hair Factories"
      DTS:TaskContact="Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:ObjectData>
        <SQLTask:SqlTaskData
          SQLTask:Connection="{7FF16ED2-2AF4-4A66-8166-F9DB3D3987B2}"
          SQLTask:BypassPrepare="False"
          SQLTask:SqlStatementSource="SELECT VendorTypeID,VendorDescription,VendorDescriptionShort&#xA;FROM dbo.cfgVendor &#xA;WHERE VendorTypeID = 2 AND IsActiveFlag = 1"
          SQLTask:ResultType="ResultSetType_Rowset" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask">
          <SQLTask:ResultBinding
            SQLTask:ResultName="0"
            SQLTask:DtsVariableName="User::FactoryList" />
        </SQLTask:SqlTaskData>
      </DTS:ObjectData>
    </DTS:Executable>
    <DTS:Executable
      DTS:refId="Package\New Zip Task"
      DTS:CreationName="Microsoft.ScriptTask"
      DTS:Description="Script Task"
      DTS:DTSID="{B7A03722-F92C-46CC-8D93-EE7832F0DD78}"
      DTS:ExecutableType="Microsoft.ScriptTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="New Zip Task"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:ObjectData>
        <ScriptProject
          Name="ST_db9c914794964d28bf6f1d7116dd222f"
          VSTAMajorVersion="15"
          VSTAMinorVersion="0"
          Language="CSharp"
          ReadOnlyVariables="$Package::SaveDirectory"
          ReadWriteVariables="User::EmailAttachments">
          <ProjectItem
            Name="Properties\Resources.resx"
            Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem>
          <ProjectItem
            Name="Properties\Settings.Designer.cs"
            Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_db9c914794964d28bf6f1d7116dd222f.Properties.Settings.get_Default():ST_db9c914794964d28bf6f1d7116dd222f.Properties.Sett" +
    "ings")]

namespace ST_db9c914794964d28bf6f1d7116dd222f.Properties {
    
    
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem>
          <ProjectItem
            Name="ST_db9c914794964d28bf6f1d7116dd222f.csproj"
            Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{00d275d4-764c-4168-b07f-0c1c96c98ee8}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ST_db9c914794964d28bf6f1d7116dd222f</RootNamespace>
    <AssemblyName>ST_db9c914794964d28bf6f1d7116dd222f</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>true</ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>
  </PropertyGroup>

  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>

  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>

  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
         <Generator>ResXFileCodeGenerator</Generator>
         <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
             <AutoGen>True</AutoGen>
         <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
         <Generator>SettingsSingleFileGenerator</Generator>
         <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
         <AutoGen>True</AutoGen>
         <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
         <SubType>Code</SubType>
    </Compile>
  </ItemGroup>

  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />

  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="ScriptTask"
                           HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}"
                           ApplicationType="usd"
                           Language="cs"
                           TemplatesPath=""
                           DebugInfoCommandLine=""
                           DebugInfoWorkingDir=""
                           IconImageList=""/>
        <Host Name="ScriptTask" GeneratedNamespace="$safeprojectname" IconIndex="">
        </Host>
        <ProjectClient>
            <HostIdentifier>SSIS_ST130</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem>
          <ProjectItem
            Name="ScriptMain.cs"
            Encoding="UTF8"><![CDATA[#region Help:  Introduction to the script task
/* The Script Task allows you to perform virtually any operation that can be accomplished in
 * a .Net application within the context of an Integration Services control flow. 
 * 
 * Expand the other regions which have "Help" prefixes for examples of specific ways to use
 * Integration Services features within this script task. */
#endregion


#region Namespaces
using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using System.IO;
using ICSharpCode.SharpZipLib.Zip;
#endregion

namespace ST_db9c914794964d28bf6f1d7116dd222f
{
    /// <summary>
    /// ScriptMain is the entry point class of the script.  Do not change the name, attributes,
    /// or parent of this class.
    /// </summary>
	[Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
	public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
	{
        #region Help:  Using Integration Services variables and parameters in a script
        /* To use a variable in this script, first ensure that the variable has been added to 
         * either the list contained in the ReadOnlyVariables property or the list contained in 
         * the ReadWriteVariables property of this script task, according to whether or not your
         * code needs to write to the variable.  To add the variable, save this script, close this instance of
         * Visual Studio, and update the ReadOnlyVariables and 
         * ReadWriteVariables properties in the Script Transformation Editor window.
         * To use a parameter in this script, follow the same steps. Parameters are always read-only.
         * 
         * Example of reading from a variable:
         *  DateTime startTime = (DateTime) Dts.Variables["System::StartTime"].Value;
         * 
         * Example of writing to a variable:
         *  Dts.Variables["User::myStringVariable"].Value = "new value";
         * 
         * Example of reading from a package parameter:
         *  int batchId = (int) Dts.Variables["$Package::batchId"].Value;
         *  
         * Example of reading from a project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].Value;
         * 
         * Example of reading from a sensitive project parameter:
         *  int batchId = (int) Dts.Variables["$Project::batchId"].GetSensitiveValue();
         * */

        #endregion

        #region Help:  Firing Integration Services events from a script
        /* This script task can fire events for logging purposes.
         * 
         * Example of firing an error event:
         *  Dts.Events.FireError(18, "Process Values", "Bad value", "", 0);
         * 
         * Example of firing an information event:
         *  Dts.Events.FireInformation(3, "Process Values", "Processing has started", "", 0, ref fireAgain)
         * 
         * Example of firing a warning event:
         *  Dts.Events.FireWarning(14, "Process Values", "No values received for input", "", 0);
         * */
        #endregion

        #region Help:  Using Integration Services connection managers in a script
        /* Some types of connection managers can be used in this script task.  See the topic 
         * "Working with Connection Managers Programatically" for details.
         * 
         * Example of using an ADO.Net connection manager:
         *  object rawConnection = Dts.Connections["Sales DB"].AcquireConnection(Dts.Transaction);
         *  SqlConnection myADONETConnection = (SqlConnection)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Sales DB"].ReleaseConnection(rawConnection);
         *
         * Example of using a File connection manager
         *  object rawConnection = Dts.Connections["Prices.zip"].AcquireConnection(Dts.Transaction);
         *  string filePath = (string)rawConnection;
         *  //Use the connection in some code here, then release the connection
         *  Dts.Connections["Prices.zip"].ReleaseConnection(rawConnection);
         * */
        #endregion


		/// <summary>
        /// This method is called when this script task executes in the control flow.
        /// Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
        /// To open Help, press F1.
        /// </summary>
		public void Main()
		{
            Dts.TaskResult = (int)ScriptResults.Success;

            string sourceFolder = Dts.Variables["SaveDirectory"].Value.ToString();
            string targetZip = sourceFolder + "\\PriceUpdate" + DateTime.Now.ToString("yyyyMMdd") + ".zip";
            Dts.Variables["EmailAttachments"].Value = targetZip;
            Compress(sourceFolder, targetZip);
        }
        private void Compress(string sourceFolder, string targetZip)
        {
            try
            {

                if (File.Exists(targetZip)) { File.Delete(targetZip); }

                int index = sourceFolder.LastIndexOf('\\');
                if (index < 0)
                    return;

                string sourceDir = sourceFolder.Substring(0, index);
                string searchPattern = "*.xml";

                if (!Directory.Exists(sourceDir))
                    return;

                string[] files = Directory.GetFiles(sourceDir, searchPattern);

                using (ZipOutputStream s = new ZipOutputStream(File.Create(targetZip)))
                {

                    s.SetLevel(9); // 0 - store only to 9 - means best compression

                    byte[] buffer = new byte[4096];

                    foreach (string file in files)
                    {
                        // Using GetFileName makes the result compatible with XP
                        // as the resulting path is not absolute.
                        ZipEntry entry = new ZipEntry(Path.GetFileName(file));

                        // Setup the entry data as required.

                        // Crc and size are handled by the library for seakable streams
                        // so no need to do them here.

                        // Could also use the last write time or similar for the file.
                        entry.DateTime = DateTime.Now;
                        s.PutNextEntry(entry);

                        using (FileStream fs = File.OpenRead(file))
                        {
                            // Using a fixed size buffer here makes no noticeable difference for output
                            // but keeps a lid on memory usage.
                            int sourceBytes;
                            do
                            {
                                sourceBytes = fs.Read(buffer, 0, buffer.Length);
                                s.Write(buffer, 0, sourceBytes);
                            } while (sourceBytes > 0);
                        }
                    }
                    s.Finish();
                    s.Close();
                }
            }
            catch (Exception)
            {
                Dts.TaskResult = (int)ScriptResults.Failure;
            }
        }

        #region ScriptResults declaration
        /// <summary>
        /// This enum provides a convenient shorthand within the scope of this class for setting the
        /// result of the script.
        /// 
        /// This code was generated automatically.
        /// </summary>
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

	}
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Computes Adler32 checksum for a stream of data. An Adler32
    /// checksum is not as reliable as a CRC32 checksum, but a lot faster to
    /// compute.
    /// 
    /// The specification for Adler32 may be found in RFC 1950.
    /// ZLIB Compressed Data Format Specification version 3.3)
    /// 
    /// 
    /// From that document:
    /// 
    ///      "ADLER32 (Adler-32 checksum)
    ///       This contains a checksum value of the uncompressed data
    ///       (excluding any dictionary data) computed according to Adler-32
    ///       algorithm. This algorithm is a 32-bit extension and improvement
    ///       of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
    ///       standard.
    /// 
    ///       Adler-32 is composed of two sums accumulated per byte: s1 is
    ///       the sum of all bytes, s2 is the sum of all s1 values. Both sums
    ///       are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
    ///       Adler-32 checksum is stored as s2*65536 + s1 in most-
    ///       significant-byte first (network) order."
    /// 
    ///  "8.2. The Adler-32 algorithm
    /// 
    ///    The Adler-32 algorithm is much faster than the CRC32 algorithm yet
    ///    still provides an extremely low probability of undetected errors.
    /// 
    ///    The modulo on unsigned long accumulators can be delayed for 5552
    ///    bytes, so the modulo operation time is negligible.  If the bytes
    ///    are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
    ///    and order sensitive, unlike the first sum, which is just a
    ///    checksum.  That 65521 is prime is important to avoid a possible
    ///    large class of two-byte errors that leave the check unchanged.
    ///    (The Fletcher checksum uses 255, which is not prime and which also
    ///    makes the Fletcher check insensitive to single byte changes 0 -
    ///    255.)
    /// 
    ///    The sum s1 is initialized to 1 instead of zero to make the length
    ///    of the sequence part of s2, so that the length does not have to be
    ///    checked separately. (Any sequence of zeroes has a Fletcher
    ///    checksum of zero.)"
    /// </summary>
    /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
    /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
    public sealed class Adler32 : IChecksum
    {
        /// <summary>
        /// largest prime smaller than 65536
        /// </summary>
        const uint BASE = 65521;

        /// <summary>
        /// Returns the Adler32 data checksum computed so far.
        /// </summary>
        public long Value
        {
            get
            {
                return checksum;
            }
        }

        /// <summary>
        /// Creates a new instance of the Adler32 class.
        /// The checksum starts off with a value of 1.
        /// </summary>
        public Adler32()
        {
            Reset();
        }

        /// <summary>
        /// Resets the Adler32 checksum to the initial value.
        /// </summary>
        public void Reset()
        {
            checksum = 1;
        }

        /// <summary>
        /// Updates the checksum with a byte value.
        /// </summary>
        /// <param name="value">
        /// The data value to add. The high byte of the int is ignored.
        /// </param>
        public void Update(int value)
        {
            // We could make a length 1 byte array and call update again, but I
            // would rather not have that overhead
            uint s1 = checksum & 0xFFFF;
            uint s2 = checksum >> 16;

            s1 = (s1 + ((uint)value & 0xFF)) % BASE;
            s2 = (s1 + s2) % BASE;

            checksum = (s2 << 16) + s1;
        }

        /// <summary>
        /// Updates the checksum with an array of bytes.
        /// </summary>
        /// <param name="buffer">
        /// The source of the data to update with.
        /// </param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Updates the checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// an array of bytes
        /// </param>
        /// <param name="offset">
        /// the start of the data used for this update
        /// </param>
        /// <param name="count">
        /// the number of bytes to use for this update
        /// </param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "cannot be negative");
#endif
            }

            if (offset >= buffer.Length)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "not a valid index into buffer");
#endif
            }

            if (offset + count > buffer.Length)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "exceeds buffer size");
#endif
            }

            //(By Per Bothner)
            uint s1 = checksum & 0xFFFF;
            uint s2 = checksum >> 16;

            while (count > 0)
            {
                // We can defer the modulo operation:
                // s1 maximally grows from 65521 to 65521 + 255 * 3800
                // s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31
                int n = 3800;
                if (n > count)
                {
                    n = count;
                }
                count -= n;
                while (--n >= 0)
                {
                    s1 = s1 + (uint)(buffer[offset++] & 0xff);
                    s2 = s2 + s1;
                }
                s1 %= BASE;
                s2 %= BASE;
            }

            checksum = (s2 << 16) | s1;
        }

        #region Instance Fields
        uint checksum;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
    /// x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
    ///
    /// Polynomials over GF(2) are represented in binary, one bit per coefficient,
    /// with the lowest powers in the most significant bit.  Then adding polynomials
    /// is just exclusive-or, and multiplying a polynomial by x is a right shift by
    /// one.  If we call the above polynomial p, and represent a byte as the
    /// polynomial q, also with the lowest power in the most significant bit (so the
    /// byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
    /// where a mod b means the remainder after dividing a by b.
    ///
    /// This calculation is done using the shift-register method of multiplying and
    /// taking the remainder.  The register is initialized to zero, and for each
    /// incoming bit, x^32 is added mod p to the register if the bit is a one (where
    /// x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
    /// x (which is shifting right by one and adding x^32 mod p if the bit shifted
    /// out is a one).  We start with the highest power (least significant bit) of
    /// q and repeat for all eight bits of q.
    ///
    /// The table is simply the CRC of all possible eight bit values.  This is all
    /// the information needed to generate CRC's on data a byte at a time for all
    /// combinations of CRC register values and incoming bytes.
    /// </summary>
    public sealed class Crc32 : IChecksum
    {
        const uint CrcSeed = 0xFFFFFFFF;

        readonly static uint[] CrcTable = new uint[] {
            0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
            0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
            0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
            0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
            0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
            0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
            0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
            0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
            0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
            0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
            0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
            0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
            0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
            0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
            0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
            0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
            0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
            0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
            0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
            0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
            0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
            0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
            0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
            0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
            0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
            0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
            0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
            0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
            0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
            0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
            0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
            0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
            0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
            0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
            0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
            0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
            0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
            0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
            0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
            0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
            0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
            0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
            0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
            0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
            0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
            0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
            0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
            0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
            0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
            0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
            0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
            0x2D02EF8D
        };

        internal static uint ComputeCrc32(uint oldCrc, byte value)
        {
            return (uint)(Crc32.CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
        }

        /// <summary>
        /// The crc data checksum so far.
        /// </summary>
        uint crc;

        /// <summary>
        /// Returns the CRC32 data checksum computed so far.
        /// </summary>
        public long Value
        {
            get
            {
                return (long)crc;
            }
            set
            {
                crc = (uint)value;
            }
        }

        /// <summary>
        /// Resets the CRC32 data checksum as if no update was ever called.
        /// </summary>
        public void Reset()
        {
            crc = 0;
        }

        /// <summary>
        /// Updates the checksum with the int bval.
        /// </summary>
        /// <param name = "value">
        /// the byte is taken as the lower 8 bits of value
        /// </param>
        public void Update(int value)
        {
            crc ^= CrcSeed;
            crc = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
            crc ^= CrcSeed;
        }

        /// <summary>
        /// Updates the checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// buffer an array of bytes
        /// </param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Adds the byte array to the data checksum.
        /// </summary>
        /// <param name = "buffer">
        /// The buffer which contains the data
        /// </param>
        /// <param name = "offset">
        /// The offset in the buffer where the data starts
        /// </param>
        /// <param name = "count">
        /// The number of data bytes to update the CRC with.
        /// </param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Count cannot be less than zero");
#endif
            }

            if (offset < 0 || offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            crc ^= CrcSeed;

            while (--count >= 0)
            {
                crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);
            }

            crc ^= CrcSeed;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This is the Deflater class.  The deflater class compresses input
    /// with the deflate algorithm described in RFC 1951.  It has several
    /// compression levels and three different strategies described below.
    ///
    /// This class is <i>not</i> thread safe.  This is inherent in the API, due
    /// to the split of deflate and setInput.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class Deflater
    {
        #region Deflater Documentation
        /*
		* The Deflater can do the following state transitions:
		*
		* (1) -> INIT_STATE   ----> INIT_FINISHING_STATE ---.
		*        /  | (2)      (5)                          |
		*       /   v          (5)                          |
		*   (3)| SETDICT_STATE ---> SETDICT_FINISHING_STATE |(3)
		*       \   | (3)                 |        ,--------'
		*        |  |                     | (3)   /
		*        v  v          (5)        v      v
		* (1) -> BUSY_STATE   ----> FINISHING_STATE
		*                                | (6)
		*                                v
		*                           FINISHED_STATE
		*    \_____________________________________/
		*                    | (7)
		*                    v
		*               CLOSED_STATE
		*
		* (1) If we should produce a header we start in INIT_STATE, otherwise
		*     we start in BUSY_STATE.
		* (2) A dictionary may be set only when we are in INIT_STATE, then
		*     we change the state as indicated.
		* (3) Whether a dictionary is set or not, on the first call of deflate
		*     we change to BUSY_STATE.
		* (4) -- intentionally left blank -- :)
		* (5) FINISHING_STATE is entered, when flush() is called to indicate that
		*     there is no more INPUT.  There are also states indicating, that
		*     the header wasn't written yet.
		* (6) FINISHED_STATE is entered, when everything has been flushed to the
		*     internal pending output buffer.
		* (7) At any time (7)
		*
		*/
        #endregion
        #region Public Constants
        /// <summary>
        /// The best and slowest compression level.  This tries to find very
        /// long and distant string repetitions.
        /// </summary>
        public const int BEST_COMPRESSION = 9;

        /// <summary>
        /// The worst but fastest compression level.
        /// </summary>
        public const int BEST_SPEED = 1;

        /// <summary>
        /// The default compression level.
        /// </summary>
        public const int DEFAULT_COMPRESSION = -1;

        /// <summary>
        /// This level won't compress at all but output uncompressed blocks.
        /// </summary>
        public const int NO_COMPRESSION = 0;

        /// <summary>
        /// The compression method.  This is the only method supported so far.
        /// There is no need to use this constant at all.
        /// </summary>
        public const int DEFLATED = 8;
        #endregion
        #region Local Constants
        private const int IS_SETDICT = 0x01;
        private const int IS_FLUSHING = 0x04;
        private const int IS_FINISHING = 0x08;

        private const int INIT_STATE = 0x00;
        private const int SETDICT_STATE = 0x01;
        //		private static  int INIT_FINISHING_STATE    = 0x08;
        //		private static  int SETDICT_FINISHING_STATE = 0x09;
        private const int BUSY_STATE = 0x10;
        private const int FLUSHING_STATE = 0x14;
        private const int FINISHING_STATE = 0x1c;
        private const int FINISHED_STATE = 0x1e;
        private const int CLOSED_STATE = 0x7f;
        #endregion
        #region Constructors
        /// <summary>
        /// Creates a new deflater with default compression level.
        /// </summary>
        public Deflater()
            : this(DEFAULT_COMPRESSION, false)
        {

        }

        /// <summary>
        /// Creates a new deflater with given compression level.
        /// </summary>
        /// <param name="level">
        /// the compression level, a value between NO_COMPRESSION
        /// and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
        /// </param>
        /// <exception cref="System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        public Deflater(int level)
            : this(level, false)
        {

        }

        /// <summary>
        /// Creates a new deflater with given compression level.
        /// </summary>
        /// <param name="level">
        /// the compression level, a value between NO_COMPRESSION
        /// and BEST_COMPRESSION.
        /// </param>
        /// <param name="noZlibHeaderOrFooter">
        /// true, if we should suppress the Zlib/RFC1950 header at the
        /// beginning and the adler checksum at the end of the output.  This is
        /// useful for the GZIP/PKZIP formats.
        /// </param>
        /// <exception cref="System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        public Deflater(int level, bool noZlibHeaderOrFooter)
        {
            if (level == DEFAULT_COMPRESSION)
            {
                level = 6;
            }
            else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)
            {
                throw new ArgumentOutOfRangeException("level");
            }

            pending = new DeflaterPending();
            engine = new DeflaterEngine(pending);
            this.noZlibHeaderOrFooter = noZlibHeaderOrFooter;
            SetStrategy(DeflateStrategy.Default);
            SetLevel(level);
            Reset();
        }
        #endregion

        /// <summary>
        /// Resets the deflater.  The deflater acts afterwards as if it was
        /// just created with the same compression level and strategy as it
        /// had before.
        /// </summary>
        public void Reset()
        {
            state = (noZlibHeaderOrFooter ? BUSY_STATE : INIT_STATE);
            totalOut = 0;
            pending.Reset();
            engine.Reset();
        }

        /// <summary>
        /// Gets the current adler checksum of the data that was processed so far.
        /// </summary>
        public int Adler
        {
            get
            {
                return engine.Adler;
            }
        }

        /// <summary>
        /// Gets the number of input bytes processed so far.
        /// </summary>
        public long TotalIn
        {
            get
            {
                return engine.TotalIn;
            }
        }

        /// <summary>
        /// Gets the number of output bytes so far.
        /// </summary>
        public long TotalOut
        {
            get
            {
                return totalOut;
            }
        }

        /// <summary>
        /// Flushes the current input block.  Further calls to deflate() will
        /// produce enough output to inflate everything in the current input
        /// block.  This is not part of Sun's JDK so I have made it package
        /// private.  It is used by DeflaterOutputStream to implement
        /// flush().
        /// </summary>
        public void Flush()
        {
            state |= IS_FLUSHING;
        }

        /// <summary>
        /// Finishes the deflater with the current input block.  It is an error
        /// to give more input after this method was called.  This method must
        /// be called to force all bytes to be flushed.
        /// </summary>
        public void Finish()
        {
            state |= (IS_FLUSHING | IS_FINISHING);
        }

        /// <summary>
        /// Returns true if the stream was finished and no more output bytes
        /// are available.
        /// </summary>
        public bool IsFinished
        {
            get
            {
                return (state == FINISHED_STATE) && pending.IsFlushed;
            }
        }

        /// <summary>
        /// Returns true, if the input buffer is empty.
        /// You should then call setInput(). 
        /// NOTE: This method can also return true when the stream
        /// was finished.
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return engine.NeedsInput();
            }
        }

        /// <summary>
        /// Sets the data which should be compressed next.  This should be only
        /// called when needsInput indicates that more input is needed.
        /// If you call setInput when needsInput() returns false, the
        /// previous input that is still pending will be thrown away.
        /// The given byte array should not be changed, before needsInput() returns
        /// true again.
        /// This call is equivalent to <code>setInput(input, 0, input.length)</code>.
        /// </summary>
        /// <param name="input">
        /// the buffer containing the input data.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if the buffer was finished() or ended().
        /// </exception>
        public void SetInput(byte[] input)
        {
            SetInput(input, 0, input.Length);
        }

        /// <summary>
        /// Sets the data which should be compressed next.  This should be
        /// only called when needsInput indicates that more input is needed.
        /// The given byte array should not be changed, before needsInput() returns
        /// true again.
        /// </summary>
        /// <param name="input">
        /// the buffer containing the input data.
        /// </param>
        /// <param name="offset">
        /// the start of the data.
        /// </param>
        /// <param name="count">
        /// the number of data bytes of input.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if the buffer was Finish()ed or if previous input is still pending.
        /// </exception>
        public void SetInput(byte[] input, int offset, int count)
        {
            if ((state & IS_FINISHING) != 0)
            {
                throw new InvalidOperationException("Finish() already called");
            }
            engine.SetInput(input, offset, count);
        }

        /// <summary>
        /// Sets the compression level.  There is no guarantee of the exact
        /// position of the change, but if you call this when needsInput is
        /// true the change of compression level will occur somewhere near
        /// before the end of the so far given input.
        /// </summary>
        /// <param name="level">
        /// the new compression level.
        /// </param>
        public void SetLevel(int level)
        {
            if (level == DEFAULT_COMPRESSION)
            {
                level = 6;
            }
            else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)
            {
                throw new ArgumentOutOfRangeException("level");
            }

            if (this.level != level)
            {
                this.level = level;
                engine.SetLevel(level);
            }
        }

        /// <summary>
        /// Get current compression level
        /// </summary>
        /// <returns>Returns the current compression level</returns>
        public int GetLevel()
        {
            return level;
        }

        /// <summary>
        /// Sets the compression strategy. Strategy is one of
        /// DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
        /// position where the strategy is changed, the same as for
        /// SetLevel() applies.
        /// </summary>
        /// <param name="strategy">
        /// The new compression strategy.
        /// </param>
        public void SetStrategy(DeflateStrategy strategy)
        {
            engine.Strategy = strategy;
        }

        /// <summary>
        /// Deflates the current input block with to the given array.
        /// </summary>
        /// <param name="output">
        /// The buffer where compressed data is stored
        /// </param>
        /// <returns>
        /// The number of compressed bytes added to the output, or 0 if either
        /// IsNeedingInput() or IsFinished returns true or length is zero.
        /// </returns>
        public int Deflate(byte[] output)
        {
            return Deflate(output, 0, output.Length);
        }

        /// <summary>
        /// Deflates the current input block to the given array.
        /// </summary>
        /// <param name="output">
        /// Buffer to store the compressed data.
        /// </param>
        /// <param name="offset">
        /// Offset into the output array.
        /// </param>
        /// <param name="length">
        /// The maximum number of bytes that may be stored.
        /// </param>
        /// <returns>
        /// The number of compressed bytes added to the output, or 0 if either
        /// needsInput() or finished() returns true or length is zero.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">
        /// If Finish() was previously called.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// If offset or length don't match the array length.
        /// </exception>
        public int Deflate(byte[] output, int offset, int length)
        {
            int origLength = length;

            if (state == CLOSED_STATE)
            {
                throw new InvalidOperationException("Deflater closed");
            }

            if (state < BUSY_STATE)
            {
                // output header
                int header = (DEFLATED +
                    ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;
                int level_flags = (level - 1) >> 1;
                if (level_flags < 0 || level_flags > 3)
                {
                    level_flags = 3;
                }
                header |= level_flags << 6;
                if ((state & IS_SETDICT) != 0)
                {
                    // Dictionary was set
                    header |= DeflaterConstants.PRESET_DICT;
                }
                header += 31 - (header % 31);

                pending.WriteShortMSB(header);
                if ((state & IS_SETDICT) != 0)
                {
                    int chksum = engine.Adler;
                    engine.ResetAdler();
                    pending.WriteShortMSB(chksum >> 16);
                    pending.WriteShortMSB(chksum & 0xffff);
                }

                state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));
            }

            for (;;)
            {
                int count = pending.Flush(output, offset, length);
                offset += count;
                totalOut += count;
                length -= count;

                if (length == 0 || state == FINISHED_STATE)
                {
                    break;
                }

                if (!engine.Deflate((state & IS_FLUSHING) != 0, (state & IS_FINISHING) != 0))
                {
                    if (state == BUSY_STATE)
                    {
                        // We need more input now
                        return origLength - length;
                    }
                    else if (state == FLUSHING_STATE)
                    {
                        if (level != NO_COMPRESSION)
                        {
                            /* We have to supply some lookahead.  8 bit lookahead
                             * is needed by the zlib inflater, and we must fill
                             * the next byte, so that all bits are flushed.
                             */
                            int neededbits = 8 + ((-pending.BitCount) & 7);
                            while (neededbits > 0)
                            {
                                /* write a static tree block consisting solely of
                                 * an EOF:
                                 */
                                pending.WriteBits(2, 10);
                                neededbits -= 10;
                            }
                        }
                        state = BUSY_STATE;
                    }
                    else if (state == FINISHING_STATE)
                    {
                        pending.AlignToByte();

                        // Compressed data is complete.  Write footer information if required.
                        if (!noZlibHeaderOrFooter)
                        {
                            int adler = engine.Adler;
                            pending.WriteShortMSB(adler >> 16);
                            pending.WriteShortMSB(adler & 0xffff);
                        }
                        state = FINISHED_STATE;
                    }
                }
            }
            return origLength - length;
        }

        /// <summary>
        /// Sets the dictionary which should be used in the deflate process.
        /// This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
        /// </summary>
        /// <param name="dictionary">
        /// the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if SetInput () or Deflate () were already called or another dictionary was already set.
        /// </exception>
        public void SetDictionary(byte[] dictionary)
        {
            SetDictionary(dictionary, 0, dictionary.Length);
        }

        /// <summary>
        /// Sets the dictionary which should be used in the deflate process.
        /// The dictionary is a byte array containing strings that are
        /// likely to occur in the data which should be compressed.  The
        /// dictionary is not stored in the compressed output, only a
        /// checksum.  To decompress the output you need to supply the same
        /// dictionary again.
        /// </summary>
        /// <param name="dictionary">
        /// The dictionary data
        /// </param>
        /// <param name="index">
        /// The index where dictionary information commences.
        /// </param>
        /// <param name="count">
        /// The number of bytes in the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// If SetInput () or Deflate() were already called or another dictionary was already set.
        /// </exception>
        public void SetDictionary(byte[] dictionary, int index, int count)
        {
            if (state != INIT_STATE)
            {
                throw new InvalidOperationException();
            }

            state = SETDICT_STATE;
            engine.SetDictionary(dictionary, index, count);
        }

        #region Instance Fields
        /// <summary>
        /// Compression level.
        /// </summary>
        int level;

        /// <summary>
        /// If true no Zlib/RFC1950 headers or footers are generated
        /// </summary>
        bool noZlibHeaderOrFooter;

        /// <summary>
        /// The current state.
        /// </summary>
        int state;

        /// <summary>
        /// The total bytes of output written.
        /// </summary>
        long totalOut;

        /// <summary>
        /// The pending output.
        /// </summary>
        DeflaterPending pending;

        /// <summary>
        /// The deflater engine.
        /// </summary>
        DeflaterEngine engine;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This class contains constants used for deflation.
    /// </summary>
    public class DeflaterConstants
    {
        /// <summary>
        /// Set to true to enable debugging
        /// </summary>
        public const bool DEBUGGING = false;

        /// <summary>
        /// Written to Zip file to identify a stored block
        /// </summary>
        public const int STORED_BLOCK = 0;

        /// <summary>
        /// Identifies static tree in Zip file
        /// </summary>
        public const int STATIC_TREES = 1;

        /// <summary>
        /// Identifies dynamic tree in Zip file
        /// </summary>
        public const int DYN_TREES = 2;

        /// <summary>
        /// Header flag indicating a preset dictionary for deflation
        /// </summary>
        public const int PRESET_DICT = 0x20;

        /// <summary>
        /// Sets internal buffer sizes for Huffman encoding
        /// </summary>
        public const int DEFAULT_MEM_LEVEL = 8;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_MATCH = 258;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MIN_MATCH = 3;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_WBITS = 15;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int WSIZE = 1 << MAX_WBITS;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int WMASK = WSIZE - 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_BITS = DEFAULT_MEM_LEVEL + 7;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_SIZE = 1 << HASH_BITS;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_MASK = HASH_SIZE - 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_SHIFT = (HASH_BITS + MIN_MATCH - 1) / MIN_MATCH;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_DIST = WSIZE - MIN_LOOKAHEAD;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int PENDING_BUF_SIZE = 1 << (DEFAULT_MEM_LEVEL + 8);

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int MAX_BLOCK_SIZE = Math.Min(65535, PENDING_BUF_SIZE - 5);

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_STORED = 0;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_FAST = 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_SLOW = 2;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] GOOD_LENGTH = { 0, 4, 4, 4, 4, 8, 8, 8, 32, 32 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] MAX_LAZY = { 0, 4, 5, 6, 4, 16, 16, 32, 128, 258 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] NICE_LENGTH = { 0, 8, 16, 32, 16, 32, 128, 128, 258, 258 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] MAX_CHAIN = { 0, 4, 8, 32, 16, 32, 128, 256, 1024, 4096 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] COMPR_FUNC = { 0, 1, 1, 1, 1, 2, 2, 2, 2, 2 };

    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Checksums;
    /// <summary>
    /// Strategies for deflater
    /// </summary>
    public enum DeflateStrategy
    {
        /// <summary>
        /// The default strategy
        /// </summary>
        Default = 0,

        /// <summary>
        /// This strategy will only allow longer string repetitions.  It is
        /// useful for random data with a small character set.
        /// </summary>
        Filtered = 1,


        /// <summary>
        /// This strategy will not look for string repetitions at all.  It
        /// only encodes with Huffman trees (which means, that more common
        /// characters get a smaller encoding.
        /// </summary>
        HuffmanOnly = 2
    }

    // DEFLATE ALGORITHM:
    // 
    // The uncompressed stream is inserted into the window array.  When
    // the window array is full the first half is thrown away and the
    // second half is copied to the beginning.
    //
    // The head array is a hash table.  Three characters build a hash value
    // and they the value points to the corresponding index in window of 
    // the last string with this hash.  The prev array implements a
    // linked list of matches with the same hash: prev[index & WMASK] points
    // to the previous index with the same hash.
    // 


    /// <summary>
    /// Low level compression engine for deflate algorithm which uses a 32K sliding window
    /// with secondary compression from Huffman/Shannon-Fano codes.
    /// </summary>
    public class DeflaterEngine : DeflaterConstants
    {
        #region Constants
        const int TooFar = 4096;
        #endregion

        #region Constructors
        /// <summary>
        /// Construct instance with pending buffer
        /// </summary>
        /// <param name="pending">
        /// Pending buffer to use
        /// </param>>
        public DeflaterEngine(DeflaterPending pending)
        {
            this.pending = pending;
            huffman = new DeflaterHuffman(pending);
            adler = new Adler32();

            window = new byte[2 * WSIZE];
            head = new short[HASH_SIZE];
            prev = new short[WSIZE];

            // We start at index 1, to avoid an implementation deficiency, that
            // we cannot build a repeat pattern at index 0.
            blockStart = strstart = 1;
        }

        #endregion

        /// <summary>
        /// Deflate drives actual compression of data
        /// </summary>
        /// <param name="flush">True to flush input buffers</param>
        /// <param name="finish">Finish deflation with the current input.</param>
        /// <returns>Returns true if progress has been made.</returns>
        public bool Deflate(bool flush, bool finish)
        {
            bool progress;
            do
            {
                FillWindow();
                bool canFlush = flush && (inputOff == inputEnd);

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) {
					Console.WriteLine("window: [" + blockStart + "," + strstart + ","
								+ lookahead + "], " + compressionFunction + "," + canFlush);
				}
#endif
                switch (compressionFunction)
                {
                    case DEFLATE_STORED:
                        progress = DeflateStored(canFlush, finish);
                        break;
                    case DEFLATE_FAST:
                        progress = DeflateFast(canFlush, finish);
                        break;
                    case DEFLATE_SLOW:
                        progress = DeflateSlow(canFlush, finish);
                        break;
                    default:
                        throw new InvalidOperationException("unknown compressionFunction");
                }
            } while (pending.IsFlushed && progress); // repeat while we have no pending output and progress was made
            return progress;
        }

        /// <summary>
        /// Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
        /// returns true
        /// </summary>
        /// <param name="buffer">The buffer containing input data.</param>
        /// <param name="offset">The offset of the first byte of data.</param>
        /// <param name="count">The number of bytes of data to use as input.</param>
        public void SetInput(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if (inputOff < inputEnd)
            {
                throw new InvalidOperationException("Old input was not completely processed");
            }

            int end = offset + count;

            /* We want to throw an ArrayIndexOutOfBoundsException early.  The
            * check is very tricky: it also handles integer wrap around.
            */
            if ((offset > end) || (end > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            inputBuf = buffer;
            inputOff = offset;
            inputEnd = end;
        }

        /// <summary>
        /// Determines if more <see cref="SetInput">input</see> is needed.
        /// </summary>		
        /// <returns>Return true if input is needed via <see cref="SetInput">SetInput</see></returns>
        public bool NeedsInput()
        {
            return (inputEnd == inputOff);
        }

        /// <summary>
        /// Set compression dictionary
        /// </summary>
        /// <param name="buffer">The buffer containing the dictionary data</param>
        /// <param name="offset">The offset in the buffer for the first byte of data</param>
        /// <param name="length">The length of the dictionary data.</param>
        public void SetDictionary(byte[] buffer, int offset, int length)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (strstart != 1) ) 
			{
				throw new InvalidOperationException("strstart not 1");
			}
#endif
            adler.Update(buffer, offset, length);
            if (length < MIN_MATCH)
            {
                return;
            }

            if (length > MAX_DIST)
            {
                offset += length - MAX_DIST;
                length = MAX_DIST;
            }

            System.Array.Copy(buffer, offset, window, strstart, length);

            UpdateHash();
            --length;
            while (--length > 0)
            {
                InsertString();
                strstart++;
            }
            strstart += 2;
            blockStart = strstart;
        }

        /// <summary>
        /// Reset internal state
        /// </summary>		
        public void Reset()
        {
            huffman.Reset();
            adler.Reset();
            blockStart = strstart = 1;
            lookahead = 0;
            totalIn = 0;
            prevAvailable = false;
            matchLen = MIN_MATCH - 1;

            for (int i = 0; i < HASH_SIZE; i++)
            {
                head[i] = 0;
            }

            for (int i = 0; i < WSIZE; i++)
            {
                prev[i] = 0;
            }
        }

        /// <summary>
        /// Reset Adler checksum
        /// </summary>		
        public void ResetAdler()
        {
            adler.Reset();
        }

        /// <summary>
        /// Get current value of Adler checksum
        /// </summary>		
        public int Adler
        {
            get
            {
                return unchecked((int)adler.Value);
            }
        }

        /// <summary>
        /// Total data processed
        /// </summary>		
        public long TotalIn
        {
            get
            {
                return totalIn;
            }
        }

        /// <summary>
        /// Get/set the <see cref="DeflateStrategy">deflate strategy</see>
        /// </summary>		
        public DeflateStrategy Strategy
        {
            get
            {
                return strategy;
            }
            set
            {
                strategy = value;
            }
        }

        /// <summary>
        /// Set the deflate level (0-9)
        /// </summary>
        /// <param name="level">The value to set the level to.</param>
        public void SetLevel(int level)
        {
            if ((level < 0) || (level > 9))
            {
                throw new ArgumentOutOfRangeException("level");
            }

            goodLength = DeflaterConstants.GOOD_LENGTH[level];
            max_lazy = DeflaterConstants.MAX_LAZY[level];
            niceLength = DeflaterConstants.NICE_LENGTH[level];
            max_chain = DeflaterConstants.MAX_CHAIN[level];

            if (DeflaterConstants.COMPR_FUNC[level] != compressionFunction)
            {

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) {
				   Console.WriteLine("Change from " + compressionFunction + " to "
										  + DeflaterConstants.COMPR_FUNC[level]);
				}
#endif
                switch (compressionFunction)
                {
                    case DEFLATE_STORED:
                        if (strstart > blockStart)
                        {
                            huffman.FlushStoredBlock(window, blockStart,
                                strstart - blockStart, false);
                            blockStart = strstart;
                        }
                        UpdateHash();
                        break;

                    case DEFLATE_FAST:
                        if (strstart > blockStart)
                        {
                            huffman.FlushBlock(window, blockStart, strstart - blockStart,
                                false);
                            blockStart = strstart;
                        }
                        break;

                    case DEFLATE_SLOW:
                        if (prevAvailable)
                        {
                            huffman.TallyLit(window[strstart - 1] & 0xff);
                        }
                        if (strstart > blockStart)
                        {
                            huffman.FlushBlock(window, blockStart, strstart - blockStart, false);
                            blockStart = strstart;
                        }
                        prevAvailable = false;
                        matchLen = MIN_MATCH - 1;
                        break;
                }
                compressionFunction = COMPR_FUNC[level];
            }
        }

        /// <summary>
        /// Fill the window
        /// </summary>
        public void FillWindow()
        {
            /* If the window is almost full and there is insufficient lookahead,
             * move the upper half to the lower one to make room in the upper half.
             */
            if (strstart >= WSIZE + MAX_DIST)
            {
                SlideWindow();
            }

            /* If there is not enough lookahead, but still some input left,
             * read in the input
             */
            while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd)
            {
                int more = 2 * WSIZE - lookahead - strstart;

                if (more > inputEnd - inputOff)
                {
                    more = inputEnd - inputOff;
                }

                System.Array.Copy(inputBuf, inputOff, window, strstart + lookahead, more);
                adler.Update(inputBuf, inputOff, more);

                inputOff += more;
                totalIn += more;
                lookahead += more;
            }

            if (lookahead >= MIN_MATCH)
            {
                UpdateHash();
            }
        }

        void UpdateHash()
        {
            /*
                        if (DEBUGGING) {
                            Console.WriteLine("updateHash: "+strstart);
                        }
            */
            ins_h = (window[strstart] << HASH_SHIFT) ^ window[strstart + 1];
        }

        /// <summary>
        /// Inserts the current string in the head hash and returns the previous
        /// value for this hash.
        /// </summary>
        /// <returns>The previous hash value</returns>
        int InsertString()
        {
            short match;
            int hash = ((ins_h << HASH_SHIFT) ^ window[strstart + (MIN_MATCH - 1)]) & HASH_MASK;

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) 
			{
				if (hash != (((window[strstart] << (2*HASH_SHIFT)) ^ 
								  (window[strstart + 1] << HASH_SHIFT) ^ 
								  (window[strstart + 2])) & HASH_MASK)) {
						throw new SharpZipBaseException("hash inconsistent: " + hash + "/"
												+window[strstart] + ","
												+window[strstart + 1] + ","
												+window[strstart + 2] + "," + HASH_SHIFT);
					}
			}
#endif
            prev[strstart & WMASK] = match = head[hash];
            head[hash] = unchecked((short)strstart);
            ins_h = hash;
            return match & 0xffff;
        }

        void SlideWindow()
        {
            Array.Copy(window, WSIZE, window, 0, WSIZE);
            matchStart -= WSIZE;
            strstart -= WSIZE;
            blockStart -= WSIZE;

            // Slide the hash table (could be avoided with 32 bit values
            // at the expense of memory usage).
            for (int i = 0; i < HASH_SIZE; ++i)
            {
                int m = head[i] & 0xffff;
                head[i] = (short)(m >= WSIZE ? (m - WSIZE) : 0);
            }

            // Slide the prev table.
            for (int i = 0; i < WSIZE; i++)
            {
                int m = prev[i] & 0xffff;
                prev[i] = (short)(m >= WSIZE ? (m - WSIZE) : 0);
            }
        }

        /// <summary>
        /// Find the best (longest) string in the window matching the 
        /// string starting at strstart.
        ///
        /// Preconditions:
        /// <code>
        /// strstart + MAX_MATCH &lt;= window.length.</code>
        /// </summary>
        /// <param name="curMatch"></param>
        /// <returns>True if a match greater than the minimum length is found</returns>
        bool FindLongestMatch(int curMatch)
        {
            int chainLength = this.max_chain;
            int niceLength = this.niceLength;
            short[] prev = this.prev;
            int scan = this.strstart;
            int match;
            int best_end = this.strstart + matchLen;
            int best_len = Math.Max(matchLen, MIN_MATCH - 1);

            int limit = Math.Max(strstart - MAX_DIST, 0);

            int strend = strstart + MAX_MATCH - 1;
            byte scan_end1 = window[best_end - 1];
            byte scan_end = window[best_end];

            // Do not waste too much time if we already have a good match:
            if (best_len >= this.goodLength)
            {
                chainLength >>= 2;
            }

            /* Do not look for matches beyond the end of the input. This is necessary
            * to make deflate deterministic.
            */
            if (niceLength > lookahead)
            {
                niceLength = lookahead;
            }

#if DebugDeflation

			if (DeflaterConstants.DEBUGGING && (strstart > 2 * WSIZE - MIN_LOOKAHEAD))
			{
				throw new InvalidOperationException("need lookahead");
			}
#endif

            do
            {

#if DebugDeflation

				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )
				{
					throw new InvalidOperationException("no future");
				}
#endif
                if (window[curMatch + best_len] != scan_end ||
                    window[curMatch + best_len - 1] != scan_end1 ||
                    window[curMatch] != window[scan] ||
                    window[curMatch + 1] != window[scan + 1])
                {
                    continue;
                }

                match = curMatch + 2;
                scan += 2;

                /* We check for insufficient lookahead only every 8th comparison;
                * the 256th check will be made at strstart + 258.
                */
                while (
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    (scan < strend))
                {
                    // Do nothing
                }

                if (scan > best_end)
                {
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )
						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));
#endif
                    matchStart = curMatch;
                    best_end = scan;
                    best_len = scan - strstart;

                    if (best_len >= niceLength)
                    {
                        break;
                    }

                    scan_end1 = window[best_end - 1];
                    scan_end = window[best_end];
                }
                scan = strstart;
            } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);

            matchLen = Math.Min(best_len, lookahead);
            return matchLen >= MIN_MATCH;
        }

        bool DeflateStored(bool flush, bool finish)
        {
            if (!flush && (lookahead == 0))
            {
                return false;
            }

            strstart += lookahead;
            lookahead = 0;

            int storedLength = strstart - blockStart;

            if ((storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full
                (blockStart < WSIZE && storedLength >= MAX_DIST) ||   // Block may move out of window
                flush)
            {
                bool lastBlock = finish;
                if (storedLength > DeflaterConstants.MAX_BLOCK_SIZE)
                {
                    storedLength = DeflaterConstants.MAX_BLOCK_SIZE;
                    lastBlock = false;
                }

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) 
				{
				   Console.WriteLine("storedBlock[" + storedLength + "," + lastBlock + "]");
				}
#endif

                huffman.FlushStoredBlock(window, blockStart, storedLength, lastBlock);
                blockStart += storedLength;
                return !lastBlock;
            }
            return true;
        }

        bool DeflateFast(bool flush, bool finish)
        {
            if (lookahead < MIN_LOOKAHEAD && !flush)
            {
                return false;
            }

            while (lookahead >= MIN_LOOKAHEAD || flush)
            {
                if (lookahead == 0)
                {
                    // We are flushing everything
                    huffman.FlushBlock(window, blockStart, strstart - blockStart, finish);
                    blockStart = strstart;
                    return false;
                }

                if (strstart > 2 * WSIZE - MIN_LOOKAHEAD)
                {
                    /* slide window, as FindLongestMatch needs this.
                     * This should only happen when flushing and the window
                     * is almost full.
                     */
                    SlideWindow();
                }

                int hashHead;
                if (lookahead >= MIN_MATCH &&
                    (hashHead = InsertString()) != 0 &&
                    strategy != DeflateStrategy.HuffmanOnly &&
                    strstart - hashHead <= MAX_DIST &&
                    FindLongestMatch(hashHead))
                {
                    // longestMatch sets matchStart and matchLen
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING) 
					{
						for (int i = 0 ; i < matchLen; i++) {
							if (window[strstart + i] != window[matchStart + i]) {
								throw new SharpZipBaseException("Match failure");
							}
						}
					}
#endif

                    bool full = huffman.TallyDist(strstart - matchStart, matchLen);

                    lookahead -= matchLen;
                    if (matchLen <= max_lazy && lookahead >= MIN_MATCH)
                    {
                        while (--matchLen > 0)
                        {
                            ++strstart;
                            InsertString();
                        }
                        ++strstart;
                    }
                    else
                    {
                        strstart += matchLen;
                        if (lookahead >= MIN_MATCH - 1)
                        {
                            UpdateHash();
                        }
                    }
                    matchLen = MIN_MATCH - 1;
                    if (!full)
                    {
                        continue;
                    }
                }
                else
                {
                    // No match found
                    huffman.TallyLit(window[strstart] & 0xff);
                    ++strstart;
                    --lookahead;
                }

                if (huffman.IsFull())
                {
                    bool lastBlock = finish && (lookahead == 0);
                    huffman.FlushBlock(window, blockStart, strstart - blockStart, lastBlock);
                    blockStart = strstart;
                    return !lastBlock;
                }
            }
            return true;
        }

        bool DeflateSlow(bool flush, bool finish)
        {
            if (lookahead < MIN_LOOKAHEAD && !flush)
            {
                return false;
            }

            while (lookahead >= MIN_LOOKAHEAD || flush)
            {
                if (lookahead == 0)
                {
                    if (prevAvailable)
                    {
                        huffman.TallyLit(window[strstart - 1] & 0xff);
                    }
                    prevAvailable = false;

                    // We are flushing everything
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING && !flush) 
					{
						throw new SharpZipBaseException("Not flushing, but no lookahead");
					}
#endif
                    huffman.FlushBlock(window, blockStart, strstart - blockStart,
                        finish);
                    blockStart = strstart;
                    return false;
                }

                if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD)
                {
                    /* slide window, as FindLongestMatch needs this.
                     * This should only happen when flushing and the window
                     * is almost full.
                     */
                    SlideWindow();
                }

                int prevMatch = matchStart;
                int prevLen = matchLen;
                if (lookahead >= MIN_MATCH)
                {

                    int hashHead = InsertString();

                    if (strategy != DeflateStrategy.HuffmanOnly &&
                        hashHead != 0 &&
                        strstart - hashHead <= MAX_DIST &&
                        FindLongestMatch(hashHead))
                    {

                        // longestMatch sets matchStart and matchLen

                        // Discard match if too small and too far away
                        if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))
                        {
                            matchLen = MIN_MATCH - 1;
                        }
                    }
                }

                // previous match was better
                if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))
                {
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING) 
					{
					   for (int i = 0 ; i < matchLen; i++) {
						  if (window[strstart-1+i] != window[prevMatch + i])
							 throw new SharpZipBaseException();
						}
					}
#endif
                    huffman.TallyDist(strstart - 1 - prevMatch, prevLen);
                    prevLen -= 2;
                    do
                    {
                        strstart++;
                        lookahead--;
                        if (lookahead >= MIN_MATCH)
                        {
                            InsertString();
                        }
                    } while (--prevLen > 0);

                    strstart++;
                    lookahead--;
                    prevAvailable = false;
                    matchLen = MIN_MATCH - 1;
                }
                else
                {
                    if (prevAvailable)
                    {
                        huffman.TallyLit(window[strstart - 1] & 0xff);
                    }
                    prevAvailable = true;
                    strstart++;
                    lookahead--;
                }

                if (huffman.IsFull())
                {
                    int len = strstart - blockStart;
                    if (prevAvailable)
                    {
                        len--;
                    }
                    bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);
                    huffman.FlushBlock(window, blockStart, len, lastBlock);
                    blockStart += len;
                    return !lastBlock;
                }
            }
            return true;
        }

        #region Instance Fields

        // Hash index of string to be inserted
        int ins_h;

        /// <summary>
        /// Hashtable, hashing three characters to an index for window, so
        /// that window[index]..window[index+2] have this hash code.  
        /// Note that the array should really be unsigned short, so you need
        /// to and the values with 0xffff.
        /// </summary>
        short[] head;

        /// <summary>
        /// <code>prev[index &amp; WMASK]</code> points to the previous index that has the
        /// same hash code as the string starting at index.  This way 
        /// entries with the same hash code are in a linked list.
        /// Note that the array should really be unsigned short, so you need
        /// to and the values with 0xffff.
        /// </summary>
        short[] prev;

        int matchStart;
        // Length of best match
        int matchLen;
        // Set if previous match exists
        bool prevAvailable;
        int blockStart;

        /// <summary>
        /// Points to the current character in the window.
        /// </summary>
        int strstart;

        /// <summary>
        /// lookahead is the number of characters starting at strstart in
        /// window that are valid.
        /// So window[strstart] until window[strstart+lookahead-1] are valid
        /// characters.
        /// </summary>
        int lookahead;

        /// <summary>
        /// This array contains the part of the uncompressed stream that 
        /// is of relevance.  The current character is indexed by strstart.
        /// </summary>
        byte[] window;

        DeflateStrategy strategy;
        int max_chain, max_lazy, niceLength, goodLength;

        /// <summary>
        /// The current compression function.
        /// </summary>
        int compressionFunction;

        /// <summary>
        /// The input data for compression.
        /// </summary>
        byte[] inputBuf;

        /// <summary>
        /// The total bytes of input read.
        /// </summary>
        long totalIn;

        /// <summary>
        /// The offset into inputBuf, where input data starts.
        /// </summary>
        int inputOff;

        /// <summary>
        /// The end offset of the input data.
        /// </summary>
        int inputEnd;

        DeflaterPending pending;
        DeflaterHuffman huffman;

        /// <summary>
        /// The adler checksum
        /// </summary>
        Adler32 adler;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This is the DeflaterHuffman class.
    /// 
    /// This class is <i>not</i> thread safe.  This is inherent in the API, due
    /// to the split of Deflate and SetInput.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class DeflaterHuffman
    {
        const int BUFSIZE = 1 << (DeflaterConstants.DEFAULT_MEM_LEVEL + 6);
        const int LITERAL_NUM = 286;

        // Number of distance codes
        const int DIST_NUM = 30;
        // Number of codes used to transfer bit lengths
        const int BITLEN_NUM = 19;

        // repeat previous bit length 3-6 times (2 bits of repeat count)
        const int REP_3_6 = 16;
        // repeat a zero length 3-10 times  (3 bits of repeat count)
        const int REP_3_10 = 17;
        // repeat a zero length 11-138 times  (7 bits of repeat count)
        const int REP_11_138 = 18;

        const int EOF_SYMBOL = 256;

        // The lengths of the bit length codes are sent in order of decreasing
        // probability, to avoid transmitting the lengths for unused bit length codes.
        static readonly int[] BL_ORDER = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

        static readonly byte[] bit4Reverse = {
            0,
            8,
            4,
            12,
            2,
            10,
            6,
            14,
            1,
            9,
            5,
            13,
            3,
            11,
            7,
            15
        };

        static short[] staticLCodes;
        static byte[] staticLLength;
        static short[] staticDCodes;
        static byte[] staticDLength;

        class Tree
        {
            #region Instance Fields
            public short[] freqs;

            public byte[] length;

            public int minNumCodes;

            public int numCodes;

            short[] codes;
            int[] bl_counts;
            int maxLength;
            DeflaterHuffman dh;
            #endregion

            #region Constructors
            public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
            {
                this.dh = dh;
                this.minNumCodes = minCodes;
                this.maxLength = maxLength;
                freqs = new short[elems];
                bl_counts = new int[maxLength];
            }

            #endregion

            /// <summary>
            /// Resets the internal state of the tree
            /// </summary>
            public void Reset()
            {
                for (int i = 0; i < freqs.Length; i++)
                {
                    freqs[i] = 0;
                }
                codes = null;
                length = null;
            }

            public void WriteSymbol(int code)
            {
                //				if (DeflaterConstants.DEBUGGING) {
                //					freqs[code]--;
                //					//  	  Console.Write("writeSymbol("+freqs.length+","+code+"): ");
                //				}
                dh.pending.WriteBits(codes[code] & 0xffff, length[code]);
            }

            /// <summary>
            /// Check that all frequencies are zero
            /// </summary>
            /// <exception cref="SharpZipBaseException">
            /// At least one frequency is non-zero
            /// </exception>
            public void CheckEmpty()
            {
                bool empty = true;
                for (int i = 0; i < freqs.Length; i++)
                {
                    if (freqs[i] != 0)
                    {
                        //Console.WriteLine("freqs[" + i + "] == " + freqs[i]);
                        empty = false;
                    }
                }

                if (!empty)
                {
                    throw new SharpZipBaseException("!Empty");
                }
            }

            /// <summary>
            /// Set static codes and length
            /// </summary>
            /// <param name="staticCodes">new codes</param>
            /// <param name="staticLengths">length for new codes</param>
            public void SetStaticCodes(short[] staticCodes, byte[] staticLengths)
            {
                codes = staticCodes;
                length = staticLengths;
            }

            /// <summary>
            /// Build dynamic codes and lengths
            /// </summary>
            public void BuildCodes()
            {
                int numSymbols = freqs.Length;
                int[] nextCode = new int[maxLength];
                int code = 0;

                codes = new short[freqs.Length];

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("buildCodes: "+freqs.Length);
                //				}

                for (int bits = 0; bits < maxLength; bits++)
                {
                    nextCode[bits] = code;
                    code += bl_counts[bits] << (15 - bits);

                    //					if (DeflaterConstants.DEBUGGING) {
                    //						//Console.WriteLine("bits: " + ( bits + 1) + " count: " + bl_counts[bits]
                    //						                  +" nextCode: "+code);
                    //					}
                }

#if DebugDeflation
				if ( DeflaterConstants.DEBUGGING && (code != 65536) ) 
				{
					throw new SharpZipBaseException("Inconsistent bl_counts!");
				}
#endif
                for (int i = 0; i < numCodes; i++)
                {
                    int bits = length[i];
                    if (bits > 0)
                    {

                        //						if (DeflaterConstants.DEBUGGING) {
                        //								//Console.WriteLine("codes["+i+"] = rev(" + nextCode[bits-1]+"),
                        //								                  +bits);
                        //						}

                        codes[i] = BitReverse(nextCode[bits - 1]);
                        nextCode[bits - 1] += 1 << (16 - bits);
                    }
                }
            }

            public void BuildTree()
            {
                int numSymbols = freqs.Length;

                /* heap is a priority queue, sorted by frequency, least frequent
                * nodes first.  The heap is a binary tree, with the property, that
                * the parent node is smaller than both child nodes.  This assures
                * that the smallest node is the first parent.
                *
                * The binary tree is encoded in an array:  0 is root node and
                * the nodes 2*n+1, 2*n+2 are the child nodes of node n.
                */
                int[] heap = new int[numSymbols];
                int heapLen = 0;
                int maxCode = 0;
                for (int n = 0; n < numSymbols; n++)
                {
                    int freq = freqs[n];
                    if (freq != 0)
                    {
                        // Insert n into heap
                        int pos = heapLen++;
                        int ppos;
                        while (pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq)
                        {
                            heap[pos] = heap[ppos];
                            pos = ppos;
                        }
                        heap[pos] = n;

                        maxCode = n;
                    }
                }

                /* We could encode a single literal with 0 bits but then we
                * don't see the literals.  Therefore we force at least two
                * literals to avoid this case.  We don't care about order in
                * this case, both literals get a 1 bit code.
                */
                while (heapLen < 2)
                {
                    int node = maxCode < 2 ? ++maxCode : 0;
                    heap[heapLen++] = node;
                }

                numCodes = Math.Max(maxCode + 1, minNumCodes);

                int numLeafs = heapLen;
                int[] childs = new int[4 * heapLen - 2];
                int[] values = new int[2 * heapLen - 1];
                int numNodes = numLeafs;
                for (int i = 0; i < heapLen; i++)
                {
                    int node = heap[i];
                    childs[2 * i] = node;
                    childs[2 * i + 1] = -1;
                    values[i] = freqs[node] << 8;
                    heap[i] = i;
                }

                /* Construct the Huffman tree by repeatedly combining the least two
                * frequent nodes.
                */
                do
                {
                    int first = heap[0];
                    int last = heap[--heapLen];

                    // Propagate the hole to the leafs of the heap
                    int ppos = 0;
                    int path = 1;

                    while (path < heapLen)
                    {
                        if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])
                        {
                            path++;
                        }

                        heap[ppos] = heap[path];
                        ppos = path;
                        path = path * 2 + 1;
                    }

                    /* Now propagate the last element down along path.  Normally
                    * it shouldn't go too deep.
                    */
                    int lastVal = values[last];
                    while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)
                    {
                        heap[path] = heap[ppos];
                    }
                    heap[path] = last;


                    int second = heap[0];

                    // Create a new node father of first and second
                    last = numNodes++;
                    childs[2 * last] = first;
                    childs[2 * last + 1] = second;
                    int mindepth = Math.Min(values[first] & 0xff, values[second] & 0xff);
                    values[last] = lastVal = values[first] + values[second] - mindepth + 1;

                    // Again, propagate the hole to the leafs
                    ppos = 0;
                    path = 1;

                    while (path < heapLen)
                    {
                        if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])
                        {
                            path++;
                        }

                        heap[ppos] = heap[path];
                        ppos = path;
                        path = ppos * 2 + 1;
                    }

                    // Now propagate the new element down along path
                    while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)
                    {
                        heap[path] = heap[ppos];
                    }
                    heap[path] = last;
                } while (heapLen > 1);

                if (heap[0] != childs.Length / 2 - 1)
                {
                    throw new SharpZipBaseException("Heap invariant violated");
                }

                BuildLength(childs);
            }

            /// <summary>
            /// Get encoded length
            /// </summary>
            /// <returns>Encoded length, the sum of frequencies * lengths</returns>
            public int GetEncodedLength()
            {
                int len = 0;
                for (int i = 0; i < freqs.Length; i++)
                {
                    len += freqs[i] * length[i];
                }
                return len;
            }

            /// <summary>
            /// Scan a literal or distance tree to determine the frequencies of the codes
            /// in the bit length tree.
            /// </summary>
            public void CalcBLFreq(Tree blTree)
            {
                int max_count;               /* max repeat count */
                int min_count;               /* min repeat count */
                int count;                   /* repeat count of the current code */
                int curlen = -1;             /* length of current code */

                int i = 0;
                while (i < numCodes)
                {
                    count = 1;
                    int nextlen = length[i];
                    if (nextlen == 0)
                    {
                        max_count = 138;
                        min_count = 3;
                    }
                    else
                    {
                        max_count = 6;
                        min_count = 3;
                        if (curlen != nextlen)
                        {
                            blTree.freqs[nextlen]++;
                            count = 0;
                        }
                    }
                    curlen = nextlen;
                    i++;

                    while (i < numCodes && curlen == length[i])
                    {
                        i++;
                        if (++count >= max_count)
                        {
                            break;
                        }
                    }

                    if (count < min_count)
                    {
                        blTree.freqs[curlen] += (short)count;
                    }
                    else if (curlen != 0)
                    {
                        blTree.freqs[REP_3_6]++;
                    }
                    else if (count <= 10)
                    {
                        blTree.freqs[REP_3_10]++;
                    }
                    else
                    {
                        blTree.freqs[REP_11_138]++;
                    }
                }
            }

            /// <summary>
            /// Write tree values
            /// </summary>
            /// <param name="blTree">Tree to write</param>
            public void WriteTree(Tree blTree)
            {
                int max_count;               // max repeat count
                int min_count;               // min repeat count
                int count;                   // repeat count of the current code
                int curlen = -1;             // length of current code

                int i = 0;
                while (i < numCodes)
                {
                    count = 1;
                    int nextlen = length[i];
                    if (nextlen == 0)
                    {
                        max_count = 138;
                        min_count = 3;
                    }
                    else
                    {
                        max_count = 6;
                        min_count = 3;
                        if (curlen != nextlen)
                        {
                            blTree.WriteSymbol(nextlen);
                            count = 0;
                        }
                    }
                    curlen = nextlen;
                    i++;

                    while (i < numCodes && curlen == length[i])
                    {
                        i++;
                        if (++count >= max_count)
                        {
                            break;
                        }
                    }

                    if (count < min_count)
                    {
                        while (count-- > 0)
                        {
                            blTree.WriteSymbol(curlen);
                        }
                    }
                    else if (curlen != 0)
                    {
                        blTree.WriteSymbol(REP_3_6);
                        dh.pending.WriteBits(count - 3, 2);
                    }
                    else if (count <= 10)
                    {
                        blTree.WriteSymbol(REP_3_10);
                        dh.pending.WriteBits(count - 3, 3);
                    }
                    else
                    {
                        blTree.WriteSymbol(REP_11_138);
                        dh.pending.WriteBits(count - 11, 7);
                    }
                }
            }

            void BuildLength(int[] childs)
            {
                this.length = new byte[freqs.Length];
                int numNodes = childs.Length / 2;
                int numLeafs = (numNodes + 1) / 2;
                int overflow = 0;

                for (int i = 0; i < maxLength; i++)
                {
                    bl_counts[i] = 0;
                }

                // First calculate optimal bit lengths
                int[] lengths = new int[numNodes];
                lengths[numNodes - 1] = 0;

                for (int i = numNodes - 1; i >= 0; i--)
                {
                    if (childs[2 * i + 1] != -1)
                    {
                        int bitLength = lengths[i] + 1;
                        if (bitLength > maxLength)
                        {
                            bitLength = maxLength;
                            overflow++;
                        }
                        lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;
                    }
                    else
                    {
                        // A leaf node
                        int bitLength = lengths[i];
                        bl_counts[bitLength - 1]++;
                        this.length[childs[2 * i]] = (byte)lengths[i];
                    }
                }

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("Tree "+freqs.Length+" lengths:");
                //					for (int i=0; i < numLeafs; i++) {
                //						//Console.WriteLine("Node "+childs[2*i]+" freq: "+freqs[childs[2*i]]
                //						                  + " len: "+length[childs[2*i]]);
                //					}
                //				}

                if (overflow == 0)
                {
                    return;
                }

                int incrBitLen = maxLength - 1;
                do
                {
                    // Find the first bit length which could increase:
                    while (bl_counts[--incrBitLen] == 0)
                        ;

                    // Move this node one down and remove a corresponding
                    // number of overflow nodes.
                    do
                    {
                        bl_counts[incrBitLen]--;
                        bl_counts[++incrBitLen]++;
                        overflow -= 1 << (maxLength - 1 - incrBitLen);
                    } while (overflow > 0 && incrBitLen < maxLength - 1);
                } while (overflow > 0);

                /* We may have overshot above.  Move some nodes from maxLength to
                * maxLength-1 in that case.
                */
                bl_counts[maxLength - 1] += overflow;
                bl_counts[maxLength - 2] -= overflow;

                /* Now recompute all bit lengths, scanning in increasing
                * frequency.  It is simpler to reconstruct all lengths instead of
                * fixing only the wrong ones. This idea is taken from 'ar'
                * written by Haruhiko Okumura.
                *
                * The nodes were inserted with decreasing frequency into the childs
                * array.
                */
                int nodePtr = 2 * numLeafs;
                for (int bits = maxLength; bits != 0; bits--)
                {
                    int n = bl_counts[bits - 1];
                    while (n > 0)
                    {
                        int childPtr = 2 * childs[nodePtr++];
                        if (childs[childPtr + 1] == -1)
                        {
                            // We found another leaf
                            length[childs[childPtr]] = (byte)bits;
                            n--;
                        }
                    }
                }
                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("*** After overflow elimination. ***");
                //					for (int i=0; i < numLeafs; i++) {
                //						//Console.WriteLine("Node "+childs[2*i]+" freq: "+freqs[childs[2*i]]
                //						                  + " len: "+length[childs[2*i]]);
                //					}
                //				}
            }

        }

        #region Instance Fields
        /// <summary>
        /// Pending buffer to use
        /// </summary>
        public DeflaterPending pending;

        Tree literalTree;
        Tree distTree;
        Tree blTree;

        // Buffer for distances
        short[] d_buf;
        byte[] l_buf;
        int last_lit;
        int extra_bits;
        #endregion

        static DeflaterHuffman()
        {
            // See RFC 1951 3.2.6
            // Literal codes
            staticLCodes = new short[LITERAL_NUM];
            staticLLength = new byte[LITERAL_NUM];

            int i = 0;
            while (i < 144)
            {
                staticLCodes[i] = BitReverse((0x030 + i) << 8);
                staticLLength[i++] = 8;
            }

            while (i < 256)
            {
                staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);
                staticLLength[i++] = 9;
            }

            while (i < 280)
            {
                staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);
                staticLLength[i++] = 7;
            }

            while (i < LITERAL_NUM)
            {
                staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);
                staticLLength[i++] = 8;
            }

            // Distance codes
            staticDCodes = new short[DIST_NUM];
            staticDLength = new byte[DIST_NUM];
            for (i = 0; i < DIST_NUM; i++)
            {
                staticDCodes[i] = BitReverse(i << 11);
                staticDLength[i] = 5;
            }
        }

        /// <summary>
        /// Construct instance with pending buffer
        /// </summary>
        /// <param name="pending">Pending buffer to use</param>
        public DeflaterHuffman(DeflaterPending pending)
        {
            this.pending = pending;

            literalTree = new Tree(this, LITERAL_NUM, 257, 15);
            distTree = new Tree(this, DIST_NUM, 1, 15);
            blTree = new Tree(this, BITLEN_NUM, 4, 7);

            d_buf = new short[BUFSIZE];
            l_buf = new byte[BUFSIZE];
        }

        /// <summary>
        /// Reset internal state
        /// </summary>		
        public void Reset()
        {
            last_lit = 0;
            extra_bits = 0;
            literalTree.Reset();
            distTree.Reset();
            blTree.Reset();
        }

        /// <summary>
        /// Write all trees to pending buffer
        /// </summary>
        /// <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        public void SendAllTrees(int blTreeCodes)
        {
            blTree.BuildCodes();
            literalTree.BuildCodes();
            distTree.BuildCodes();
            pending.WriteBits(literalTree.numCodes - 257, 5);
            pending.WriteBits(distTree.numCodes - 1, 5);
            pending.WriteBits(blTreeCodes - 4, 4);
            for (int rank = 0; rank < blTreeCodes; rank++)
            {
                pending.WriteBits(blTree.length[BL_ORDER[rank]], 3);
            }
            literalTree.WriteTree(blTree);
            distTree.WriteTree(blTree);

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				blTree.CheckEmpty();
			}
#endif
        }

        /// <summary>
        /// Compress current buffer writing data to pending buffer
        /// </summary>
        public void CompressBlock()
        {
            for (int i = 0; i < last_lit; i++)
            {
                int litlen = l_buf[i] & 0xff;
                int dist = d_buf[i];
                if (dist-- != 0)
                {
                    //					if (DeflaterConstants.DEBUGGING) {
                    //						Console.Write("["+(dist+1)+","+(litlen+3)+"]: ");
                    //					}

                    int lc = Lcode(litlen);
                    literalTree.WriteSymbol(lc);

                    int bits = (lc - 261) / 4;
                    if (bits > 0 && bits <= 5)
                    {
                        pending.WriteBits(litlen & ((1 << bits) - 1), bits);
                    }

                    int dc = Dcode(dist);
                    distTree.WriteSymbol(dc);

                    bits = dc / 2 - 1;
                    if (bits > 0)
                    {
                        pending.WriteBits(dist & ((1 << bits) - 1), bits);
                    }
                }
                else
                {
                    //					if (DeflaterConstants.DEBUGGING) {
                    //						if (litlen > 32 && litlen < 127) {
                    //							Console.Write("("+(char)litlen+"): ");
                    //						} else {
                    //							Console.Write("{"+litlen+"}: ");
                    //						}
                    //					}
                    literalTree.WriteSymbol(litlen);
                }
            }

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				Console.Write("EOF: ");
			}
#endif
            literalTree.WriteSymbol(EOF_SYMBOL);

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				literalTree.CheckEmpty();
				distTree.CheckEmpty();
			}
#endif
        }

        /// <summary>
        /// Flush block to output with no compression
        /// </summary>
        /// <param name="stored">Data to write</param>
        /// <param name="storedOffset">Index of first byte to write</param>
        /// <param name="storedLength">Count of bytes to write</param>
        /// <param name="lastBlock">True if this is the last block</param>
        public void FlushStoredBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
        {
#if DebugDeflation
			//			if (DeflaterConstants.DEBUGGING) {
			//				//Console.WriteLine("Flushing stored block "+ storedLength);
			//			}
#endif
            pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0), 3);
            pending.AlignToByte();
            pending.WriteShort(storedLength);
            pending.WriteShort(~storedLength);
            pending.WriteBlock(stored, storedOffset, storedLength);
            Reset();
        }

        /// <summary>
        /// Flush block to output with compression
        /// </summary>		
        /// <param name="stored">Data to flush</param>
        /// <param name="storedOffset">Index of first byte to flush</param>
        /// <param name="storedLength">Count of bytes to flush</param>
        /// <param name="lastBlock">True if this is the last block</param>
        public void FlushBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
        {
            literalTree.freqs[EOF_SYMBOL]++;

            // Build trees
            literalTree.BuildTree();
            distTree.BuildTree();

            // Calculate bitlen frequency
            literalTree.CalcBLFreq(blTree);
            distTree.CalcBLFreq(blTree);

            // Build bitlen tree
            blTree.BuildTree();

            int blTreeCodes = 4;
            for (int i = 18; i > blTreeCodes; i--)
            {
                if (blTree.length[BL_ORDER[i]] > 0)
                {
                    blTreeCodes = i + 1;
                }
            }
            int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +
                literalTree.GetEncodedLength() + distTree.GetEncodedLength() +
                extra_bits;

            int static_len = extra_bits;
            for (int i = 0; i < LITERAL_NUM; i++)
            {
                static_len += literalTree.freqs[i] * staticLLength[i];
            }
            for (int i = 0; i < DIST_NUM; i++)
            {
                static_len += distTree.freqs[i] * staticDLength[i];
            }
            if (opt_len >= static_len)
            {
                // Force static trees
                opt_len = static_len;
            }

            if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)
            {
                // Store Block

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("Storing, since " + storedLength + " < " + opt_len
                //					                  + " <= " + static_len);
                //				}
                FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
            }
            else if (opt_len == static_len)
            {
                // Encode with static tree
                pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0), 3);
                literalTree.SetStaticCodes(staticLCodes, staticLLength);
                distTree.SetStaticCodes(staticDCodes, staticDLength);
                CompressBlock();
                Reset();
            }
            else
            {
                // Encode with dynamic tree
                pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0), 3);
                SendAllTrees(blTreeCodes);
                CompressBlock();
                Reset();
            }
        }

        /// <summary>
        /// Get value indicating if internal buffer is full
        /// </summary>
        /// <returns>true if buffer is full</returns>
        public bool IsFull()
        {
            return last_lit >= BUFSIZE;
        }

        /// <summary>
        /// Add literal to buffer
        /// </summary>
        /// <param name="literal">Literal value to add to buffer.</param>
        /// <returns>Value indicating internal buffer is full</returns>
        public bool TallyLit(int literal)
        {
            //			if (DeflaterConstants.DEBUGGING) {
            //				if (lit > 32 && lit < 127) {
            //					//Console.WriteLine("("+(char)lit+")");
            //				} else {
            //					//Console.WriteLine("{"+lit+"}");
            //				}
            //			}
            d_buf[last_lit] = 0;
            l_buf[last_lit++] = (byte)literal;
            literalTree.freqs[literal]++;
            return IsFull();
        }

        /// <summary>
        /// Add distance code and length to literal and distance trees
        /// </summary>
        /// <param name="distance">Distance code</param>
        /// <param name="length">Length</param>
        /// <returns>Value indicating if internal buffer is full</returns>
        public bool TallyDist(int distance, int length)
        {
            //			if (DeflaterConstants.DEBUGGING) {
            //				//Console.WriteLine("[" + distance + "," + length + "]");
            //			}

            d_buf[last_lit] = (short)distance;
            l_buf[last_lit++] = (byte)(length - 3);

            int lc = Lcode(length - 3);
            literalTree.freqs[lc]++;
            if (lc >= 265 && lc < 285)
            {
                extra_bits += (lc - 261) / 4;
            }

            int dc = Dcode(distance - 1);
            distTree.freqs[dc]++;
            if (dc >= 4)
            {
                extra_bits += dc / 2 - 1;
            }
            return IsFull();
        }


        /// <summary>
        /// Reverse the bits of a 16 bit value.
        /// </summary>
        /// <param name="toReverse">Value to reverse bits</param>
        /// <returns>Value with bits reversed</returns>
        public static short BitReverse(int toReverse)
        {
            return (short)(bit4Reverse[toReverse & 0xF] << 12 |
                            bit4Reverse[(toReverse >> 4) & 0xF] << 8 |
                            bit4Reverse[(toReverse >> 8) & 0xF] << 4 |
                            bit4Reverse[toReverse >> 12]);
        }

        static int Lcode(int length)
        {
            if (length == 255)
            {
                return 285;
            }

            int code = 257;
            while (length >= 8)
            {
                code += 4;
                length >>= 1;
            }
            return code + length;
        }

        static int Dcode(int distance)
        {
            int code = 0;
            while (distance >= 4)
            {
                code += 2;
                distance >>= 1;
            }
            return code + distance;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    using System.IO;

#if !NETCF_1_0
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    /// <summary>
    /// A special stream deflating or compressing the bytes that are
    /// written to it.  It uses a Deflater to perform actual deflating.<br/>
    /// Authors of the original java version : Tom Tromey, Jochen Hoenicke 
    /// </summary>
    public class DeflaterOutputStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// the output stream where deflated output should be written.
        /// </param>
        public DeflaterOutputStream(Stream baseOutputStream)
            : this(baseOutputStream, new Deflater(), 512)
        {
        }

        /// <summary>
        /// Creates a new DeflaterOutputStream with the given Deflater and
        /// default buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// the output stream where deflated output should be written.
        /// </param>
        /// <param name="deflater">
        /// the underlying deflater.
        /// </param>
        public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater)
            : this(baseOutputStream, deflater, 512)
        {
        }

        /// <summary>
        /// Creates a new DeflaterOutputStream with the given Deflater and
        /// buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// The output stream where deflated output is written.
        /// </param>
        /// <param name="deflater">
        /// The underlying deflater to use
        /// </param>
        /// <param name="bufferSize">
        /// The buffer size in bytes to use when deflating (minimum value 512)
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// bufsize is less than or equal to zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// baseOutputStream does not support writing
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// deflater instance is null
        /// </exception>
        public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater, int bufferSize)
        {
            if (baseOutputStream == null)
            {
                throw new ArgumentNullException("baseOutputStream");
            }

            if (baseOutputStream.CanWrite == false)
            {
                throw new ArgumentException("Must support writing", "baseOutputStream");
            }

            if (deflater == null)
            {
                throw new ArgumentNullException("deflater");
            }

            if (bufferSize < 512)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }

            baseOutputStream_ = baseOutputStream;
            buffer_ = new byte[bufferSize];
            deflater_ = deflater;
        }
        #endregion

        #region Public API
        /// <summary>
        /// Finishes the stream by calling finish() on the deflater. 
        /// </summary>
        /// <exception cref="SharpZipBaseException">
        /// Not all input is deflated
        /// </exception>
        public virtual void Finish()
        {
            deflater_.Finish();
            while (!deflater_.IsFinished)
            {
                int len = deflater_.Deflate(buffer_, 0, buffer_.Length);
                if (len <= 0)
                {
                    break;
                }

#if NETCF_1_0
				if ( keys != null ) {
#else
                if (cryptoTransform_ != null)
                {
#endif
                    EncryptBlock(buffer_, 0, len);
                }

                baseOutputStream_.Write(buffer_, 0, len);
            }

            if (!deflater_.IsFinished)
            {
                throw new SharpZipBaseException("Can't deflate all input?");
            }

            baseOutputStream_.Flush();

#if NETCF_1_0
			if ( keys != null ) {
				keys = null;
			}
#else
            if (cryptoTransform_ != null)
            {
#if !NET_1_1 && !NETCF_2_0
                if (cryptoTransform_ is ZipAESTransform)
                {
                    AESAuthCode = ((ZipAESTransform)cryptoTransform_).GetAuthCode();
                }
#endif
                cryptoTransform_.Dispose();
                cryptoTransform_ = null;
            }
#endif
        }

        /// <summary>
        /// Get/set flag indicating ownership of the underlying stream.
        /// When the flag is true <see cref="Close"></see> will close the underlying stream also.
        /// </summary>
        public bool IsStreamOwner
        {
            get { return isStreamOwner_; }
            set { isStreamOwner_ = value; }
        }

        ///	<summary>
        /// Allows client to determine if an entry can be patched after its added
        /// </summary>
        public bool CanPatchEntries
        {
            get
            {
                return baseOutputStream_.CanSeek;
            }
        }

        #endregion

        #region Encryption

        string password;

#if NETCF_1_0
		uint[] keys;
#else
        ICryptoTransform cryptoTransform_;

        /// <summary>
        /// Returns the 10 byte AUTH CODE to be appended immediately following the AES data stream.
        /// </summary>
        protected byte[] AESAuthCode;
#endif

        /// <summary>
        /// Get/set the password used for encryption.
        /// </summary>
        /// <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        public string Password
        {
            get
            {
                return password;
            }
            set
            {
                if ((value != null) && (value.Length == 0))
                {
                    password = null;
                }
                else
                {
                    password = value;
                }
            }
        }

        /// <summary>
        /// Encrypt a block of data
        /// </summary>
        /// <param name="buffer">
        /// Data to encrypt.  NOTE the original contents of the buffer are lost
        /// </param>
        /// <param name="offset">
        /// Offset of first byte in buffer to encrypt
        /// </param>
        /// <param name="length">
        /// Number of bytes in buffer to encrypt
        /// </param>
        protected void EncryptBlock(byte[] buffer, int offset, int length)
        {
#if NETCF_1_0
			for (int i = offset; i < offset + length; ++i) {
				byte oldbyte = buffer[i];
				buffer[i] ^= EncryptByte();
				UpdateKeys(oldbyte);
			}
#else
            cryptoTransform_.TransformBlock(buffer, 0, length, buffer, 0);
#endif
        }

        /// <summary>
        /// Initializes encryption keys based on given <paramref name="password"/>.
        /// </summary>
        /// <param name="password">The password.</param>
        protected void InitializePassword(string password)
        {
#if NETCF_1_0
			keys = new uint[] {
				0x12345678,
				0x23456789,
				0x34567890
			};
			
			byte[] rawPassword = ZipConstants.ConvertToArray(password);
			
			for (int i = 0; i < rawPassword.Length; ++i) {
				UpdateKeys((byte)rawPassword[i]);
			}
			
#else
            PkzipClassicManaged pkManaged = new PkzipClassicManaged();
            byte[] key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(password));
            cryptoTransform_ = pkManaged.CreateEncryptor(key, null);
#endif
        }

#if !NET_1_1 && !NETCF_2_0
        /// <summary>
        /// Initializes encryption keys based on given password.
        /// </summary>
        protected void InitializeAESPassword(ZipEntry entry, string rawPassword,
                                            out byte[] salt, out byte[] pwdVerifier)
        {
            salt = new byte[entry.AESSaltLen];
            // Salt needs to be cryptographically random, and unique per file
            if (_aesRnd == null)
                _aesRnd = new RNGCryptoServiceProvider();
            _aesRnd.GetBytes(salt);
            int blockSize = entry.AESKeySize / 8;	// bits to bytes

            cryptoTransform_ = new ZipAESTransform(rawPassword, salt, blockSize, true);
            pwdVerifier = ((ZipAESTransform)cryptoTransform_).PwdVerifier;
        }
#endif

#if NETCF_1_0
		
		/// <summary>
		/// Encrypt a single byte 
		/// </summary>
		/// <returns>
		/// The encrypted value
		/// </returns>
		protected byte EncryptByte()
		{
			uint temp = ((keys[2] & 0xFFFF) | 2);
			return (byte)((temp * (temp ^ 1)) >> 8);
		}

		/// <summary>
		/// Update encryption keys 
		/// </summary>		
		protected void UpdateKeys(byte ch)
		{
			keys[0] = Crc32.ComputeCrc32(keys[0], ch);
			keys[1] = keys[1] + (byte)keys[0];
			keys[1] = keys[1] * 134775813 + 1;
			keys[2] = Crc32.ComputeCrc32(keys[2], (byte)(keys[1] >> 24));
		}
#endif

        #endregion

        #region Deflation Support
        /// <summary>
        /// Deflates everything in the input buffers.  This will call
        /// <code>def.deflate()</code> until all bytes from the input buffers
        /// are processed.
        /// </summary>
        protected void Deflate()
        {
            while (!deflater_.IsNeedingInput)
            {
                int deflateCount = deflater_.Deflate(buffer_, 0, buffer_.Length);

                if (deflateCount <= 0)
                {
                    break;
                }
#if NETCF_1_0
				if (keys != null) 
#else
                if (cryptoTransform_ != null)
#endif
                {
                    EncryptBlock(buffer_, 0, deflateCount);
                }

                baseOutputStream_.Write(buffer_, 0, deflateCount);
            }

            if (!deflater_.IsNeedingInput)
            {
                throw new SharpZipBaseException("DeflaterOutputStream can't deflate all input?");
            }
        }
        #endregion

        #region Stream Overrides
        /// <summary>
        /// Gets value indicating stream can be read from
        /// </summary>
        public override bool CanRead
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a value indicating if seeking is supported for this stream
        /// This property always returns false
        /// </summary>
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Get value indicating if this stream supports writing
        /// </summary>
        public override bool CanWrite
        {
            get
            {
                return baseOutputStream_.CanWrite;
            }
        }

        /// <summary>
        /// Get current length of stream
        /// </summary>
        public override long Length
        {
            get
            {
                return baseOutputStream_.Length;
            }
        }

        /// <summary>
        /// Gets the current position within the stream.
        /// </summary>
        /// <exception cref="NotSupportedException">Any attempt to set position</exception>
        public override long Position
        {
            get
            {
                return baseOutputStream_.Position;
            }
            set
            {
                throw new NotSupportedException("Position property not supported");
            }
        }

        /// <summary>
        /// Sets the current position of this stream to the given value. Not supported by this class!
        /// </summary>
        /// <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
        /// <param name="origin">The <see cref="SeekOrigin"/> to seek from.</param>
        /// <returns>The new position in the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("DeflaterOutputStream Seek not supported");
        }

        /// <summary>
        /// Sets the length of this stream to the given value. Not supported by this class!
        /// </summary>
        /// <param name="value">The new stream length.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("DeflaterOutputStream SetLength not supported");
        }

        /// <summary>
        /// Read a byte from stream advancing position by one
        /// </summary>
        /// <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override int ReadByte()
        {
            throw new NotSupportedException("DeflaterOutputStream ReadByte not supported");
        }

        /// <summary>
        /// Read a block of bytes from stream
        /// </summary>
        /// <param name="buffer">The buffer to store read data in.</param>
        /// <param name="offset">The offset to start storing at.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("DeflaterOutputStream Read not supported");
        }

        /// <summary>
        /// Asynchronous reads are not supported a NotSupportedException is always thrown
        /// </summary>
        /// <param name="buffer">The buffer to read into.</param>
        /// <param name="offset">The offset to start storing data at.</param>
        /// <param name="count">The number of bytes to read</param>
        /// <param name="callback">The async callback to use.</param>
        /// <param name="state">The state to use.</param>
        /// <returns>Returns an <see cref="IAsyncResult"/></returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("DeflaterOutputStream BeginRead not currently supported");
        }

        /// <summary>
        /// Asynchronous writes arent supported, a NotSupportedException is always thrown
        /// </summary>
        /// <param name="buffer">The buffer to write.</param>
        /// <param name="offset">The offset to begin writing at.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <param name="callback">The <see cref="AsyncCallback"/> to use.</param>
        /// <param name="state">The state object.</param>
        /// <returns>Returns an IAsyncResult.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("BeginWrite is not supported");
        }

        /// <summary>
        /// Flushes the stream by calling <see cref="DeflaterOutputStream.Flush">Flush</see> on the deflater and then
        /// on the underlying stream.  This ensures that all bytes are flushed.
        /// </summary>
        public override void Flush()
        {
            deflater_.Flush();
            Deflate();
            baseOutputStream_.Flush();
        }

        /// <summary>
        /// Calls <see cref="Finish"/> and closes the underlying
        /// stream when <see cref="IsStreamOwner"></see> is true.
        /// </summary>
        public override void Close()
        {
            if (!isClosed_)
            {
                isClosed_ = true;

                try
                {
                    Finish();
#if NETCF_1_0
					keys=null;
#else
                    if (cryptoTransform_ != null)
                    {
                        GetAuthCodeIfAES();
                        cryptoTransform_.Dispose();
                        cryptoTransform_ = null;
                    }
#endif
                }
                finally
                {
                    if (isStreamOwner_)
                    {
                        baseOutputStream_.Close();
                    }
                }
            }
        }

        private void GetAuthCodeIfAES()
        {
#if !NET_1_1 && !NETCF_2_0
            if (cryptoTransform_ is ZipAESTransform)
            {
                AESAuthCode = ((ZipAESTransform)cryptoTransform_).GetAuthCode();
            }
#endif
        }

        /// <summary>
        /// Writes a single byte to the compressed output stream.
        /// </summary>
        /// <param name="value">
        /// The byte value.
        /// </param>
        public override void WriteByte(byte value)
        {
            byte[] b = new byte[1];
            b[0] = value;
            Write(b, 0, 1);
        }

        /// <summary>
        /// Writes bytes from an array to the compressed stream.
        /// </summary>
        /// <param name="buffer">
        /// The byte array
        /// </param>
        /// <param name="offset">
        /// The offset into the byte array where to start.
        /// </param>
        /// <param name="count">
        /// The number of bytes to write.
        /// </param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            deflater_.SetInput(buffer, offset, count);
            Deflate();
        }
        #endregion

        #region Instance Fields
        /// <summary>
        /// This buffer is used temporarily to retrieve the bytes from the
        /// deflater and write them to the underlying output stream.
        /// </summary>
        byte[] buffer_;

        /// <summary>
        /// The deflater which is used to deflate the stream.
        /// </summary>
        protected Deflater deflater_;

        /// <summary>
        /// Base stream the deflater depends on.
        /// </summary>
        protected Stream baseOutputStream_;

        bool isClosed_;

        bool isStreamOwner_ = true;
        #endregion

        #region Static Fields

#if !NET_1_1 && !NETCF_2_0
        // Static to help ensure that multiple files within a zip will get different random salt
        private static RNGCryptoServiceProvider _aesRnd;
#endif
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{

    /// <summary>
    /// This class stores the pending output of the Deflater.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class DeflaterPending : PendingBuffer
    {
        /// <summary>
        /// Construct instance with default buffer size
        /// </summary>
        public DeflaterPending()
            : base(DeflaterConstants.PENDING_BUF_SIZE)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// FastZipEvents supports all events applicable to <see cref="FastZip">FastZip</see> operations.
    /// </summary>
    public class FastZipEvents
    {
        /// <summary>
        /// Delegate to invoke when processing directories.
        /// </summary>
        public ProcessDirectoryHandler ProcessDirectory;

        /// <summary>
        /// Delegate to invoke when processing files.
        /// </summary>
        public ProcessFileHandler ProcessFile;

        /// <summary>
        /// Delegate to invoke during processing of files.
        /// </summary>
        public ProgressHandler Progress;

        /// <summary>
        /// Delegate to invoke when processing for a file has been completed.
        /// </summary>
        public CompletedFileHandler CompletedFile;

        /// <summary>
        /// Delegate to invoke when processing directory failures.
        /// </summary>
        public DirectoryFailureHandler DirectoryFailure;

        /// <summary>
        /// Delegate to invoke when processing file failures.
        /// </summary>
        public FileFailureHandler FileFailure;

        /// <summary>
        /// Raise the <see cref="DirectoryFailure">directory failure</see> event.
        /// </summary>
        /// <param name="directory">The directory causing the failure.</param>
        /// <param name="e">The exception for this event.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnDirectoryFailure(string directory, Exception e)
        {
            bool result = false;
            DirectoryFailureHandler handler = DirectoryFailure;

            if (handler != null)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(directory, e);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="FileFailure"> file failure handler delegate</see>.
        /// </summary>
        /// <param name="file">The file causing the failure.</param>
        /// <param name="e">The exception for this failure.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnFileFailure(string file, Exception e)
        {
            FileFailureHandler handler = FileFailure;
            bool result = (handler != null);

            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(file, e);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="ProcessFile">ProcessFile delegate</see>.
        /// </summary>
        /// <param name="file">The file being processed.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnProcessFile(string file)
        {
            bool result = true;
            ProcessFileHandler handler = ProcessFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="CompletedFile"/> delegate
        /// </summary>
        /// <param name="file">The file whose processing has been completed.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnCompletedFile(string file)
        {
            bool result = true;
            CompletedFileHandler handler = CompletedFile;
            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="ProcessDirectory">process directory</see> delegate.
        /// </summary>
        /// <param name="directory">The directory being processed.</param>
        /// <param name="hasMatchingFiles">Flag indicating if the directory has matching files as determined by the current filter.</param>
        /// <returns>A <see cref="bool"/> of true if the operation should continue; false otherwise.</returns>
        public bool OnProcessDirectory(string directory, bool hasMatchingFiles)
        {
            bool result = true;
            ProcessDirectoryHandler handler = ProcessDirectory;
            if (handler != null)
            {
                DirectoryEventArgs args = new DirectoryEventArgs(directory, hasMatchingFiles);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// The minimum timespan between <see cref="Progress"/> events.
        /// </summary>
        /// <value>The minimum period of time between <see cref="Progress"/> events.</value>
        /// <seealso cref="Progress"/>
        /// <remarks>The default interval is three seconds.</remarks>
        public TimeSpan ProgressInterval
        {
            get { return progressInterval_; }
            set { progressInterval_ = value; }
        }

        #region Instance Fields
        TimeSpan progressInterval_ = TimeSpan.FromSeconds(3);
        #endregion
    }

    /// <summary>
    /// FastZip provides facilities for creating and extracting zip files.
    /// </summary>
    public class FastZip
    {
        #region Enumerations
        /// <summary>
        /// Defines the desired handling when overwriting files during extraction.
        /// </summary>
        public enum Overwrite
        {
            /// <summary>
            /// Prompt the user to confirm overwriting
            /// </summary>
            Prompt,
            /// <summary>
            /// Never overwrite files.
            /// </summary>
            Never,
            /// <summary>
            /// Always overwrite files.
            /// </summary>
            Always
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initialise a default instance of <see cref="FastZip"/>.
        /// </summary>
        public FastZip()
        {
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FastZip"/>
        /// </summary>
        /// <param name="events">The <see cref="FastZipEvents">events</see> to use during operations.</param>
        public FastZip(FastZipEvents events)
        {
            events_ = events;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get/set a value indicating wether empty directories should be created.
        /// </summary>
        public bool CreateEmptyDirectories
        {
            get { return createEmptyDirectories_; }
            set { createEmptyDirectories_ = value; }
        }

#if !NETCF_1_0
        /// <summary>
        /// Get / set the password value.
        /// </summary>
        public string Password
        {
            get { return password_; }
            set { password_ = value; }
        }
#endif

        /// <summary>
        /// Get or set the <see cref="INameTransform"></see> active when creating Zip files.
        /// </summary>
        /// <seealso cref="EntryFactory"></seealso>
        public INameTransform NameTransform
        {
            get { return entryFactory_.NameTransform; }
            set
            {
                entryFactory_.NameTransform = value;
            }
        }

        /// <summary>
        /// Get or set the <see cref="IEntryFactory"></see> active when creating Zip files.
        /// </summary>
        public IEntryFactory EntryFactory
        {
            get { return entryFactory_; }
            set
            {
                if (value == null)
                {
                    entryFactory_ = new ZipEntryFactory();
                }
                else
                {
                    entryFactory_ = value;
                }
            }
        }

        /// <summary>
        /// Gets or sets the setting for <see cref="UseZip64">Zip64 handling when writing.</see>
        /// </summary>
        /// <remarks>
        /// The default value is dynamic which is not backwards compatible with old
        /// programs and can cause problems with XP's built in compression which cant
        /// read Zip64 archives. However it does avoid the situation were a large file
        /// is added and cannot be completed correctly.
        /// NOTE: Setting the size for entries before they are added is the best solution!
        /// By default the EntryFactory used by FastZip will set fhe file size.
        /// </remarks>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        /// <summary>
        /// Get/set a value indicating wether file dates and times should 
        /// be restored when extracting files from an archive.
        /// </summary>
        /// <remarks>The default value is false.</remarks>
        public bool RestoreDateTimeOnExtract
        {
            get
            {
                return restoreDateTimeOnExtract_;
            }
            set
            {
                restoreDateTimeOnExtract_ = value;
            }
        }

        /// <summary>
        /// Get/set a value indicating wether file attributes should
        /// be restored during extract operations
        /// </summary>
        public bool RestoreAttributesOnExtract
        {
            get { return restoreAttributesOnExtract_; }
            set { restoreAttributesOnExtract_ = value; }
        }
        #endregion

        #region Delegates
        /// <summary>
        /// Delegate called when confirming overwriting of files.
        /// </summary>
        public delegate bool ConfirmOverwriteDelegate(string fileName);
        #endregion

        #region CreateZip
        /// <summary>
        /// Create a zip file.
        /// </summary>
        /// <param name="zipFileName">The name of the zip file to create.</param>
        /// <param name="sourceDirectory">The directory to source files from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter">directory filter</see> to apply.</param>
        public void CreateZip(string zipFileName, string sourceDirectory,
            bool recurse, string fileFilter, string directoryFilter)
        {
            CreateZip(File.Create(zipFileName), sourceDirectory, recurse, fileFilter, directoryFilter);
        }

        /// <summary>
        /// Create a zip file/archive.
        /// </summary>
        /// <param name="zipFileName">The name of the zip file to create.</param>
        /// <param name="sourceDirectory">The directory to obtain files and directories from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The file filter to apply.</param>
        public void CreateZip(string zipFileName, string sourceDirectory, bool recurse, string fileFilter)
        {
            CreateZip(File.Create(zipFileName), sourceDirectory, recurse, fileFilter, null);
        }

        /// <summary>
        /// Create a zip archive sending output to the <paramref name="outputStream"/> passed.
        /// </summary>
        /// <param name="outputStream">The stream to write archive data to.</param>
        /// <param name="sourceDirectory">The directory to source files from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter">directory filter</see> to apply.</param>
        /// <remarks>The <paramref name="outputStream"/> is closed after creation.</remarks>
        public void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, string fileFilter, string directoryFilter)
        {
            NameTransform = new ZipNameTransform(sourceDirectory);
            sourceDirectory_ = sourceDirectory;

            using (outputStream_ = new ZipOutputStream(outputStream))
            {

#if !NETCF_1_0
                if (password_ != null)
                {
                    outputStream_.Password = password_;
                }
#endif

                outputStream_.UseZip64 = UseZip64;
                FileSystemScanner scanner = new FileSystemScanner(fileFilter, directoryFilter);
                scanner.ProcessFile += new ProcessFileHandler(ProcessFile);
                if (this.CreateEmptyDirectories)
                {
                    scanner.ProcessDirectory += new ProcessDirectoryHandler(ProcessDirectory);
                }

                if (events_ != null)
                {
                    if (events_.FileFailure != null)
                    {
                        scanner.FileFailure += events_.FileFailure;
                    }

                    if (events_.DirectoryFailure != null)
                    {
                        scanner.DirectoryFailure += events_.DirectoryFailure;
                    }
                }

                scanner.Scan(sourceDirectory, recurse);
            }
        }

        #endregion

        #region ExtractZip
        /// <summary>
        /// Extract the contents of a zip file.
        /// </summary>
        /// <param name="zipFileName">The zip file to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter)
        {
            ExtractZip(zipFileName, targetDirectory, Overwrite.Always, null, fileFilter, null, restoreDateTimeOnExtract_);
        }

        /// <summary>
        /// Extract the contents of a zip file.
        /// </summary>
        /// <param name="zipFileName">The zip file to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="overwrite">The style of <see cref="Overwrite">overwriting</see> to apply.</param>
        /// <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        /// <param name="directoryFilter">A filter to apply to directories.</param>
        /// <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
        public void ExtractZip(string zipFileName, string targetDirectory,
                               Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate,
                               string fileFilter, string directoryFilter, bool restoreDateTime)
        {
            Stream inputStream = File.Open(zipFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            ExtractZip(inputStream, targetDirectory, overwrite, confirmDelegate, fileFilter, directoryFilter, restoreDateTime, true);
        }

        /// <summary>
        /// Extract the contents of a zip file held in a stream.
        /// </summary>
        /// <param name="inputStream">The seekable input stream containing the zip to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="overwrite">The style of <see cref="Overwrite">overwriting</see> to apply.</param>
        /// <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        /// <param name="directoryFilter">A filter to apply to directories.</param>
        /// <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
        /// <param name="isStreamOwner">Flag indicating whether the inputStream will be closed by this method.</param>
        public void ExtractZip(Stream inputStream, string targetDirectory,
                       Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate,
                       string fileFilter, string directoryFilter, bool restoreDateTime,
                       bool isStreamOwner)
        {
            if ((overwrite == Overwrite.Prompt) && (confirmDelegate == null))
            {
                throw new ArgumentNullException("confirmDelegate");
            }

            continueRunning_ = true;
            overwrite_ = overwrite;
            confirmDelegate_ = confirmDelegate;
            extractNameTransform_ = new WindowsNameTransform(targetDirectory);

            fileFilter_ = new NameFilter(fileFilter);
            directoryFilter_ = new NameFilter(directoryFilter);
            restoreDateTimeOnExtract_ = restoreDateTime;

            using (zipFile_ = new ZipFile(inputStream))
            {

#if !NETCF_1_0
                if (password_ != null)
                {
                    zipFile_.Password = password_;
                }
#endif
                zipFile_.IsStreamOwner = isStreamOwner;
                System.Collections.IEnumerator enumerator = zipFile_.GetEnumerator();
                while (continueRunning_ && enumerator.MoveNext())
                {
                    ZipEntry entry = (ZipEntry)enumerator.Current;
                    if (entry.IsFile)
                    {
                        // TODO Path.GetDirectory can fail here on invalid characters.
                        if (directoryFilter_.IsMatch(Path.GetDirectoryName(entry.Name)) && fileFilter_.IsMatch(entry.Name))
                        {
                            ExtractEntry(entry);
                        }
                    }
                    else if (entry.IsDirectory)
                    {
                        if (directoryFilter_.IsMatch(entry.Name) && CreateEmptyDirectories)
                        {
                            ExtractEntry(entry);
                        }
                    }
                    else
                    {
                        // Do nothing for volume labels etc...
                    }
                }
            }
        }
        #endregion

        #region Internal Processing
        void ProcessDirectory(object sender, DirectoryEventArgs e)
        {
            if (!e.HasMatchingFiles && CreateEmptyDirectories)
            {
                if (events_ != null)
                {
                    events_.OnProcessDirectory(e.Name, e.HasMatchingFiles);
                }

                if (e.ContinueRunning)
                {
                    if (e.Name != sourceDirectory_)
                    {
                        ZipEntry entry = entryFactory_.MakeDirectoryEntry(e.Name);
                        outputStream_.PutNextEntry(entry);
                    }
                }
            }
        }

        void ProcessFile(object sender, ScanEventArgs e)
        {
            if ((events_ != null) && (events_.ProcessFile != null))
            {
                events_.ProcessFile(sender, e);
            }

            if (e.ContinueRunning)
            {
                try
                {
                    // The open below is equivalent to OpenRead which gaurantees that if opened the 
                    // file will not be changed by subsequent openers, but precludes opening in some cases
                    // were it could succeed.
                    using (FileStream stream = File.Open(e.Name, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        ZipEntry entry = entryFactory_.MakeFileEntry(e.Name);
                        outputStream_.PutNextEntry(entry);
                        AddFileContents(e.Name, stream);
                    }
                }
                catch (Exception ex)
                {
                    if (events_ != null)
                    {
                        continueRunning_ = events_.OnFileFailure(e.Name, ex);
                    }
                    else
                    {
                        continueRunning_ = false;
                        throw;
                    }
                }
            }
        }

        void AddFileContents(string name, Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (buffer_ == null)
            {
                buffer_ = new byte[4096];
            }

            if ((events_ != null) && (events_.Progress != null))
            {
                StreamUtils.Copy(stream, outputStream_, buffer_,
                    events_.Progress, events_.ProgressInterval, this, name);
            }
            else
            {
                StreamUtils.Copy(stream, outputStream_, buffer_);
            }

            if (events_ != null)
            {
                continueRunning_ = events_.OnCompletedFile(name);
            }
        }

        void ExtractFileEntry(ZipEntry entry, string targetName)
        {
            bool proceed = true;
            if (overwrite_ != Overwrite.Always)
            {
                if (File.Exists(targetName))
                {
                    if ((overwrite_ == Overwrite.Prompt) && (confirmDelegate_ != null))
                    {
                        proceed = confirmDelegate_(targetName);
                    }
                    else
                    {
                        proceed = false;
                    }
                }
            }

            if (proceed)
            {
                if (events_ != null)
                {
                    continueRunning_ = events_.OnProcessFile(entry.Name);
                }

                if (continueRunning_)
                {
                    try
                    {
                        using (FileStream outputStream = File.Create(targetName))
                        {
                            if (buffer_ == null)
                            {
                                buffer_ = new byte[4096];
                            }
                            if ((events_ != null) && (events_.Progress != null))
                            {
                                StreamUtils.Copy(zipFile_.GetInputStream(entry), outputStream, buffer_,
                                    events_.Progress, events_.ProgressInterval, this, entry.Name, entry.Size);
                            }
                            else
                            {
                                StreamUtils.Copy(zipFile_.GetInputStream(entry), outputStream, buffer_);
                            }

                            if (events_ != null)
                            {
                                continueRunning_ = events_.OnCompletedFile(entry.Name);
                            }
                        }

#if !NETCF_1_0 && !NETCF_2_0
                        if (restoreDateTimeOnExtract_)
                        {
                            File.SetLastWriteTime(targetName, entry.DateTime);
                        }

                        if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1))
                        {
                            FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;
                            // TODO: FastZip - Setting of other file attributes on extraction is a little trickier.
                            fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);
                            File.SetAttributes(targetName, fileAttributes);
                        }
#endif
                    }
                    catch (Exception ex)
                    {
                        if (events_ != null)
                        {
                            continueRunning_ = events_.OnFileFailure(targetName, ex);
                        }
                        else
                        {
                            continueRunning_ = false;
                            throw;
                        }
                    }
                }
            }
        }

        void ExtractEntry(ZipEntry entry)
        {
            bool doExtraction = entry.IsCompressionMethodSupported();
            string targetName = entry.Name;

            if (doExtraction)
            {
                if (entry.IsFile)
                {
                    targetName = extractNameTransform_.TransformFile(targetName);
                }
                else if (entry.IsDirectory)
                {
                    targetName = extractNameTransform_.TransformDirectory(targetName);
                }

                doExtraction = !((targetName == null) || (targetName.Length == 0));
            }

            // TODO: Fire delegate/throw exception were compression method not supported, or name is invalid?

            string dirName = null;

            if (doExtraction)
            {
                if (entry.IsDirectory)
                {
                    dirName = targetName;
                }
                else
                {
                    dirName = Path.GetDirectoryName(Path.GetFullPath(targetName));
                }
            }

            if (doExtraction && !Directory.Exists(dirName))
            {
                if (!entry.IsDirectory || CreateEmptyDirectories)
                {
                    try
                    {
                        Directory.CreateDirectory(dirName);
                    }
                    catch (Exception ex)
                    {
                        doExtraction = false;
                        if (events_ != null)
                        {
                            if (entry.IsDirectory)
                            {
                                continueRunning_ = events_.OnDirectoryFailure(targetName, ex);
                            }
                            else
                            {
                                continueRunning_ = events_.OnFileFailure(targetName, ex);
                            }
                        }
                        else
                        {
                            continueRunning_ = false;
                            throw;
                        }
                    }
                }
            }

            if (doExtraction && entry.IsFile)
            {
                ExtractFileEntry(entry, targetName);
            }
        }

        static int MakeExternalAttributes(FileInfo info)
        {
            return (int)info.Attributes;
        }

#if NET_1_0 || NET_1_1 || NETCF_1_0
		static bool NameIsValid(string name)
		{
			return (name != null) &&
				(name.Length > 0) &&
				(name.IndexOfAny(Path.InvalidPathChars) < 0);
		}
#else
        static bool NameIsValid(string name)
        {
            return (name != null) &&
                (name.Length > 0) &&
                (name.IndexOfAny(Path.GetInvalidPathChars()) < 0);
        }
#endif
        #endregion

        #region Instance Fields
        bool continueRunning_;
        byte[] buffer_;
        ZipOutputStream outputStream_;
        ZipFile zipFile_;
        string sourceDirectory_;
        NameFilter fileFilter_;
        NameFilter directoryFilter_;
        Overwrite overwrite_;
        ConfirmOverwriteDelegate confirmDelegate_;

        bool restoreDateTimeOnExtract_;
        bool restoreAttributesOnExtract_;
        bool createEmptyDirectories_;
        FastZipEvents events_;
        IEntryFactory entryFactory_ = new ZipEntryFactory();
        INameTransform extractNameTransform_;
        UseZip64 useZip64_ = UseZip64.Dynamic;

#if !NETCF_1_0
        string password_;
#endif

        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    #region EventArgs
    /// <summary>
    /// Event arguments for scanning.
    /// </summary>
    public class ScanEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanEventArgs"/>
        /// </summary>
        /// <param name="name">The file or directory name.</param>
        public ScanEventArgs(string name)
        {
            name_ = name;
        }
        #endregion

        /// <summary>
        /// The file or directory name for this event.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Get set a value indicating if scanning should continue or not.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        #region Instance Fields
        string name_;
        bool continueRunning_ = true;
        #endregion
    }

    /// <summary>
    /// Event arguments during processing of a single file or directory.
    /// </summary>
    public class ProgressEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanEventArgs"/>
        /// </summary>
        /// <param name="name">The file or directory name if known.</param>
        /// <param name="processed">The number of bytes processed so far</param>
        /// <param name="target">The total number of bytes to process, 0 if not known</param>
        public ProgressEventArgs(string name, long processed, long target)
        {
            name_ = name;
            processed_ = processed;
            target_ = target;
        }
        #endregion

        /// <summary>
        /// The name for this event if known.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Get set a value indicating wether scanning should continue or not.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        /// <summary>
        /// Get a percentage representing how much of the <see cref="Target"></see> has been processed
        /// </summary>
        /// <value>0.0 to 100.0 percent; 0 if target is not known.</value>
        public float PercentComplete
        {
            get
            {
                float result;
                if (target_ <= 0)
                {
                    result = 0;
                }
                else
                {
                    result = ((float)processed_ / (float)target_) * 100.0f;
                }
                return result;
            }
        }

        /// <summary>
        /// The number of bytes processed so far
        /// </summary>
        public long Processed
        {
            get { return processed_; }
        }

        /// <summary>
        /// The number of bytes to process.
        /// </summary>
        /// <remarks>Target may be 0 or negative if the value isnt known.</remarks>
        public long Target
        {
            get { return target_; }
        }

        #region Instance Fields
        string name_;
        long processed_;
        long target_;
        bool continueRunning_ = true;
        #endregion
    }

    /// <summary>
    /// Event arguments for directories.
    /// </summary>
    public class DirectoryEventArgs : ScanEventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialize an instance of <see cref="DirectoryEventArgs"></see>.
        /// </summary>
        /// <param name="name">The name for this directory.</param>
        /// <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
        public DirectoryEventArgs(string name, bool hasMatchingFiles)
            : base(name)
        {
            hasMatchingFiles_ = hasMatchingFiles;
        }
        #endregion

        /// <summary>
        /// Get a value indicating if the directory contains any matching files or not.
        /// </summary>
        public bool HasMatchingFiles
        {
            get { return hasMatchingFiles_; }
        }

        #region Instance Fields
        bool hasMatchingFiles_;
        #endregion
    }

    /// <summary>
    /// Arguments passed when scan failures are detected.
    /// </summary>
    public class ScanFailureEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanFailureEventArgs"></see>
        /// </summary>
        /// <param name="name">The name to apply.</param>
        /// <param name="e">The exception to use.</param>
        public ScanFailureEventArgs(string name, Exception e)
        {
            name_ = name;
            exception_ = e;
            continueRunning_ = true;
        }
        #endregion

        /// <summary>
        /// The applicable name.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// The applicable exception.
        /// </summary>
        public Exception Exception
        {
            get { return exception_; }
        }

        /// <summary>
        /// Get / set a value indicating wether scanning should continue.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        #region Instance Fields
        string name_;
        Exception exception_;
        bool continueRunning_;
        #endregion
    }

    #endregion

    #region Delegates
    /// <summary>
    /// Delegate invoked before starting to process a directory.
    /// </summary>
    public delegate void ProcessDirectoryHandler(object sender, DirectoryEventArgs e);

    /// <summary>
    /// Delegate invoked before starting to process a file.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void ProcessFileHandler(object sender, ScanEventArgs e);

    /// <summary>
    /// Delegate invoked during processing of a file or directory
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void ProgressHandler(object sender, ProgressEventArgs e);

    /// <summary>
    /// Delegate invoked when a file has been completely processed.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void CompletedFileHandler(object sender, ScanEventArgs e);

    /// <summary>
    /// Delegate invoked when a directory failure is detected.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void DirectoryFailureHandler(object sender, ScanFailureEventArgs e);

    /// <summary>
    /// Delegate invoked when a file failure is detected.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void FileFailureHandler(object sender, ScanFailureEventArgs e);
    #endregion

    /// <summary>
    /// FileSystemScanner provides facilities scanning of files and directories.
    /// </summary>
    public class FileSystemScanner
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="filter">The <see cref="PathFilter">file filter</see> to apply when scanning.</param>
        public FileSystemScanner(string filter)
        {
            fileFilter_ = new PathFilter(filter);
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter"> directory filter</see> to apply.</param>
        public FileSystemScanner(string fileFilter, string directoryFilter)
        {
            fileFilter_ = new PathFilter(fileFilter);
            directoryFilter_ = new PathFilter(directoryFilter);
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The file <see cref="IScanFilter">filter</see> to apply.</param>
        public FileSystemScanner(IScanFilter fileFilter)
        {
            fileFilter_ = fileFilter;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The file <see cref="IScanFilter">filter</see>  to apply.</param>
        /// <param name="directoryFilter">The directory <see cref="IScanFilter">filter</see>  to apply.</param>
        public FileSystemScanner(IScanFilter fileFilter, IScanFilter directoryFilter)
        {
            fileFilter_ = fileFilter;
            directoryFilter_ = directoryFilter;
        }
        #endregion

        #region Delegates
        /// <summary>
        /// Delegate to invoke when a directory is processed.
        /// </summary>
        public ProcessDirectoryHandler ProcessDirectory;

        /// <summary>
        /// Delegate to invoke when a file is processed.
        /// </summary>
        public ProcessFileHandler ProcessFile;

        /// <summary>
        /// Delegate to invoke when processing for a file has finished.
        /// </summary>
        public CompletedFileHandler CompletedFile;

        /// <summary>
        /// Delegate to invoke when a directory failure is detected.
        /// </summary>
        public DirectoryFailureHandler DirectoryFailure;

        /// <summary>
        /// Delegate to invoke when a file failure is detected.
        /// </summary>
        public FileFailureHandler FileFailure;
        #endregion

        /// <summary>
        /// Raise the DirectoryFailure event.
        /// </summary>
        /// <param name="directory">The directory name.</param>
        /// <param name="e">The exception detected.</param>
        bool OnDirectoryFailure(string directory, Exception e)
        {
            DirectoryFailureHandler handler = DirectoryFailure;
            bool result = (handler != null);
            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(directory, e);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Raise the FileFailure event.
        /// </summary>
        /// <param name="file">The file name.</param>
        /// <param name="e">The exception detected.</param>
        bool OnFileFailure(string file, Exception e)
        {
            FileFailureHandler handler = FileFailure;

            bool result = (handler != null);

            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(file, e);
                FileFailure(this, args);
                alive_ = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Raise the ProcessFile event.
        /// </summary>
        /// <param name="file">The file name.</param>
        void OnProcessFile(string file)
        {
            ProcessFileHandler handler = ProcessFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Raise the complete file event
        /// </summary>
        /// <param name="file">The file name</param>
        void OnCompleteFile(string file)
        {
            CompletedFileHandler handler = CompletedFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Raise the ProcessDirectory event.
        /// </summary>
        /// <param name="directory">The directory name.</param>
        /// <param name="hasMatchingFiles">Flag indicating if the directory has matching files.</param>
        void OnProcessDirectory(string directory, bool hasMatchingFiles)
        {
            ProcessDirectoryHandler handler = ProcessDirectory;

            if (handler != null)
            {
                DirectoryEventArgs args = new DirectoryEventArgs(directory, hasMatchingFiles);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Scan a directory.
        /// </summary>
        /// <param name="directory">The base directory to scan.</param>
        /// <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
        public void Scan(string directory, bool recurse)
        {
            alive_ = true;
            ScanDir(directory, recurse);
        }

        void ScanDir(string directory, bool recurse)
        {

            try
            {
                string[] names = System.IO.Directory.GetFiles(directory);
                bool hasMatch = false;
                for (int fileIndex = 0; fileIndex < names.Length; ++fileIndex)
                {
                    if (!fileFilter_.IsMatch(names[fileIndex]))
                    {
                        names[fileIndex] = null;
                    }
                    else
                    {
                        hasMatch = true;
                    }
                }

                OnProcessDirectory(directory, hasMatch);

                if (alive_ && hasMatch)
                {
                    foreach (string fileName in names)
                    {
                        try
                        {
                            if (fileName != null)
                            {
                                OnProcessFile(fileName);
                                if (!alive_)
                                {
                                    break;
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            if (!OnFileFailure(fileName, e))
                            {
                                throw;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (!OnDirectoryFailure(directory, e))
                {
                    throw;
                }
            }

            if (alive_ && recurse)
            {
                try
                {
                    string[] names = System.IO.Directory.GetDirectories(directory);
                    foreach (string fulldir in names)
                    {
                        if ((directoryFilter_ == null) || (directoryFilter_.IsMatch(fulldir)))
                        {
                            ScanDir(fulldir, true);
                            if (!alive_)
                            {
                                break;
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    if (!OnDirectoryFailure(directory, e))
                    {
                        throw;
                    }
                }
            }
        }

        #region Instance Fields
        /// <summary>
        /// The file filter currently in use.
        /// </summary>
        IScanFilter fileFilter_;
        /// <summary>
        /// The directory filter currently in use.
        /// </summary>
        IScanFilter directoryFilter_;
        /// <summary>
        /// Flag indicating if scanning should continue running.
        /// </summary>
        bool alive_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{

    /// <summary>
    /// Interface to compute a data checksum used by checked input/output streams.
    /// A data checksum can be updated by one byte or with a byte array. After each
    /// update the value of the current checksum can be returned by calling
    /// <code>getValue</code>. The complete checksum object can also be reset
    /// so it can be used again with new data.
    /// </summary>
    public interface IChecksum
    {
        /// <summary>
        /// Returns the data checksum computed so far.
        /// </summary>
        long Value
        {
            get;
        }

        /// <summary>
        /// Resets the data checksum as if no update was ever called.
        /// </summary>
        void Reset();

        /// <summary>
        /// Adds one byte to the data checksum.
        /// </summary>
        /// <param name = "value">
        /// the data value to add. The high byte of the int is ignored.
        /// </param>
        void Update(int value);

        /// <summary>
        /// Updates the data checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// buffer an array of bytes
        /// </param>
        void Update(byte[] buffer);

        /// <summary>
        /// Adds the byte array to the data checksum.
        /// </summary>
        /// <param name = "buffer">
        /// The buffer which contains the data
        /// </param>
        /// <param name = "offset">
        /// The offset in the buffer where the data starts
        /// </param>
        /// <param name = "count">
        /// the number of data bytes to add.
        /// </param>
        void Update(byte[] buffer, int offset, int count);
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using ICSharpCode.SharpZipLib.Core;
    /// <summary>
    /// Defines factory methods for creating new <see cref="ZipEntry"></see> values.
    /// </summary>
    public interface IEntryFactory
    {
        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a file given its name
        /// </summary>
        /// <param name="fileName">The name of the file to create an entry for.</param>
        /// <returns>Returns a <see cref="ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        ZipEntry MakeFileEntry(string fileName);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a file given its name
        /// </summary>
        /// <param name="fileName">The name of the file to create an entry for.</param>
        /// <param name="useFileSystem">If true get details from the file system if the file exists.</param>
        /// <returns>Returns a <see cref="ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        ZipEntry MakeFileEntry(string fileName, bool useFileSystem);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a directory given its name
        /// </summary>
        /// <param name="directoryName">The name of the directory to create an entry for.</param>
        /// <returns>Returns a <see cref="ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        ZipEntry MakeDirectoryEntry(string directoryName);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a directory given its name
        /// </summary>
        /// <param name="directoryName">The name of the directory to create an entry for.</param>
        /// <param name="useFileSystem">If true get details from the file system for this directory if it exists.</param>
        /// <returns>Returns a <see cref="ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem);

        /// <summary>
        /// Get/set the <see cref="INameTransform"></see> applicable.
        /// </summary>
        INameTransform NameTransform { get; set; }
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// INameTransform defines how file system names are transformed for use with archives, or vice versa.
    /// </summary>
    public interface INameTransform
    {
        /// <summary>
        /// Given a file name determine the transformed value.
        /// </summary>
        /// <param name="name">The name to transform.</param>
        /// <returns>The transformed file name.</returns>
        string TransformFile(string name);

        /// <summary>
        /// Given a directory name determine the transformed value.
        /// </summary>
        /// <param name="name">The name to transform.</param>
        /// <returns>The transformed directory name</returns>
        string TransformDirectory(string name);
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// Inflater is used to decompress data that has been compressed according
    /// to the "deflate" standard described in rfc1951.
    /// 
    /// By default Zlib (rfc1950) headers and footers are expected in the input.
    /// You can use constructor <code> public Inflater(bool noHeader)</code> passing true
    /// if there is no Zlib header information
    ///
    /// The usage is as following.  First you have to set some input with
    /// <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
    /// inflate any bytes there may be three reasons:
    /// <ul>
    /// <li>IsNeedingInput() returns true because the input buffer is empty.
    /// You have to provide more input with <code>SetInput()</code>.
    /// NOTE: IsNeedingInput() also returns true when, the stream is finished.
    /// </li>
    /// <li>IsNeedingDictionary() returns true, you have to provide a preset
    ///    dictionary with <code>SetDictionary()</code>.</li>
    /// <li>IsFinished returns true, the inflater has finished.</li>
    /// </ul>
    /// Once the first output byte is produced, a dictionary will not be
    /// needed at a later stage.
    ///
    /// author of the original java version : John Leuner, Jochen Hoenicke
    /// </summary>
    public class Inflater
    {
        #region Constants/Readonly
        /// <summary>
        /// Copy lengths for literal codes 257..285
        /// </summary>
        static readonly int[] CPLENS = {
                                  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
                                  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258
                              };

        /// <summary>
        /// Extra bits for literal codes 257..285
        /// </summary>
        static readonly int[] CPLEXT = {
                                  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
                                  3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
                              };

        /// <summary>
        /// Copy offsets for distance codes 0..29
        /// </summary>
        static readonly int[] CPDIST = {
                                1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                                257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
                                8193, 12289, 16385, 24577
                              };

        /// <summary>
        /// Extra bits for distance codes
        /// </summary>
        static readonly int[] CPDEXT = {
                                0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
                                7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
                                12, 12, 13, 13
                              };

        /// <summary>
        /// These are the possible states for an inflater
        /// </summary>
        const int DECODE_HEADER = 0;
        const int DECODE_DICT = 1;
        const int DECODE_BLOCKS = 2;
        const int DECODE_STORED_LEN1 = 3;
        const int DECODE_STORED_LEN2 = 4;
        const int DECODE_STORED = 5;
        const int DECODE_DYN_HEADER = 6;
        const int DECODE_HUFFMAN = 7;
        const int DECODE_HUFFMAN_LENBITS = 8;
        const int DECODE_HUFFMAN_DIST = 9;
        const int DECODE_HUFFMAN_DISTBITS = 10;
        const int DECODE_CHKSUM = 11;
        const int FINISHED = 12;
        #endregion

        #region Instance Fields
        /// <summary>
        /// This variable contains the current state.
        /// </summary>
        int mode;

        /// <summary>
        /// The adler checksum of the dictionary or of the decompressed
        /// stream, as it is written in the header resp. footer of the
        /// compressed stream. 
        /// Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
        /// </summary>
        int readAdler;

        /// <summary>
        /// The number of bits needed to complete the current state.  This
        /// is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
        /// DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
        /// </summary>
        int neededBits;
        int repLength;
        int repDist;
        int uncomprLen;

        /// <summary>
        /// True, if the last block flag was set in the last block of the
        /// inflated stream.  This means that the stream ends after the
        /// current block.
        /// </summary>
        bool isLastBlock;

        /// <summary>
        /// The total number of inflated bytes.
        /// </summary>
        long totalOut;

        /// <summary>
        /// The total number of bytes set with setInput().  This is not the
        /// value returned by the TotalIn property, since this also includes the
        /// unprocessed input.
        /// </summary>
        long totalIn;

        /// <summary>
        /// This variable stores the noHeader flag that was given to the constructor.
        /// True means, that the inflated stream doesn't contain a Zlib header or 
        /// footer.
        /// </summary>
        bool noHeader;

        StreamManipulator input;
        OutputWindow outputWindow;
        InflaterDynHeader dynHeader;
        InflaterHuffmanTree litlenTree, distTree;
        Adler32 adler;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new inflater or RFC1951 decompressor
        /// RFC1950/Zlib headers and footers will be expected in the input data
        /// </summary>
        public Inflater()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new inflater.
        /// </summary>
        /// <param name="noHeader">
        /// True if no RFC1950/Zlib header and footer fields are expected in the input data
        /// 
        /// This is used for GZIPed/Zipped input.
        /// 
        /// For compatibility with
        /// Sun JDK you should provide one byte of input more than needed in
        /// this case.
        /// </param>
        public Inflater(bool noHeader)
        {
            this.noHeader = noHeader;
            this.adler = new Adler32();
            input = new StreamManipulator();
            outputWindow = new OutputWindow();
            mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
        }
        #endregion

        /// <summary>
        /// Resets the inflater so that a new stream can be decompressed.  All
        /// pending input and output will be discarded.
        /// </summary>
        public void Reset()
        {
            mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
            totalIn = 0;
            totalOut = 0;
            input.Reset();
            outputWindow.Reset();
            dynHeader = null;
            litlenTree = null;
            distTree = null;
            isLastBlock = false;
            adler.Reset();
        }

        /// <summary>
        /// Decodes a zlib/RFC1950 header.
        /// </summary>
        /// <returns>
        /// False if more input is needed.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// The header is invalid.
        /// </exception>
        private bool DecodeHeader()
        {
            int header = input.PeekBits(16);
            if (header < 0)
            {
                return false;
            }
            input.DropBits(16);

            // The header is written in "wrong" byte order
            header = ((header << 8) | (header >> 8)) & 0xffff;
            if (header % 31 != 0)
            {
                throw new SharpZipBaseException("Header checksum illegal");
            }

            if ((header & 0x0f00) != (Deflater.DEFLATED << 8))
            {
                throw new SharpZipBaseException("Compression Method unknown");
            }

            /* Maximum size of the backwards window in bits.
            * We currently ignore this, but we could use it to make the
            * inflater window more space efficient. On the other hand the
            * full window (15 bits) is needed most times, anyway.
            int max_wbits = ((header & 0x7000) >> 12) + 8;
            */

            if ((header & 0x0020) == 0)
            { // Dictionary flag?
                mode = DECODE_BLOCKS;
            }
            else
            {
                mode = DECODE_DICT;
                neededBits = 32;
            }
            return true;
        }

        /// <summary>
        /// Decodes the dictionary checksum after the deflate header.
        /// </summary>
        /// <returns>
        /// False if more input is needed.
        /// </returns>
        private bool DecodeDict()
        {
            while (neededBits > 0)
            {
                int dictByte = input.PeekBits(8);
                if (dictByte < 0)
                {
                    return false;
                }
                input.DropBits(8);
                readAdler = (readAdler << 8) | dictByte;
                neededBits -= 8;
            }
            return false;
        }

        /// <summary>
        /// Decodes the huffman encoded symbols in the input stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed, true if output window is
        /// full or the current block ends.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// if deflated stream is invalid.
        /// </exception>
        private bool DecodeHuffman()
        {
            int free = outputWindow.GetFreeSpace();
            while (free >= 258)
            {
                int symbol;
                switch (mode)
                {
                    case DECODE_HUFFMAN:
                        // This is the inner loop so it is optimized a bit
                        while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)
                        {
                            outputWindow.Write(symbol);
                            if (--free < 258)
                            {
                                return true;
                            }
                        }

                        if (symbol < 257)
                        {
                            if (symbol < 0)
                            {
                                return false;
                            }
                            else
                            {
                                // symbol == 256: end of block
                                distTree = null;
                                litlenTree = null;
                                mode = DECODE_BLOCKS;
                                return true;
                            }
                        }

                        try
                        {
                            repLength = CPLENS[symbol - 257];
                            neededBits = CPLEXT[symbol - 257];
                        }
                        catch (Exception)
                        {
                            throw new SharpZipBaseException("Illegal rep length code");
                        }
                        goto case DECODE_HUFFMAN_LENBITS; // fall through

                    case DECODE_HUFFMAN_LENBITS:
                        if (neededBits > 0)
                        {
                            mode = DECODE_HUFFMAN_LENBITS;
                            int i = input.PeekBits(neededBits);
                            if (i < 0)
                            {
                                return false;
                            }
                            input.DropBits(neededBits);
                            repLength += i;
                        }
                        mode = DECODE_HUFFMAN_DIST;
                        goto case DECODE_HUFFMAN_DIST; // fall through

                    case DECODE_HUFFMAN_DIST:
                        symbol = distTree.GetSymbol(input);
                        if (symbol < 0)
                        {
                            return false;
                        }

                        try
                        {
                            repDist = CPDIST[symbol];
                            neededBits = CPDEXT[symbol];
                        }
                        catch (Exception)
                        {
                            throw new SharpZipBaseException("Illegal rep dist code");
                        }

                        goto case DECODE_HUFFMAN_DISTBITS; // fall through

                    case DECODE_HUFFMAN_DISTBITS:
                        if (neededBits > 0)
                        {
                            mode = DECODE_HUFFMAN_DISTBITS;
                            int i = input.PeekBits(neededBits);
                            if (i < 0)
                            {
                                return false;
                            }
                            input.DropBits(neededBits);
                            repDist += i;
                        }

                        outputWindow.Repeat(repLength, repDist);
                        free -= repLength;
                        mode = DECODE_HUFFMAN;
                        break;

                    default:
                        throw new SharpZipBaseException("Inflater unknown mode");
                }
            }
            return true;
        }

        /// <summary>
        /// Decodes the adler checksum after the deflate stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// If checksum doesn't match.
        /// </exception>
        private bool DecodeChksum()
        {
            while (neededBits > 0)
            {
                int chkByte = input.PeekBits(8);
                if (chkByte < 0)
                {
                    return false;
                }
                input.DropBits(8);
                readAdler = (readAdler << 8) | chkByte;
                neededBits -= 8;
            }

            if ((int)adler.Value != readAdler)
            {
                throw new SharpZipBaseException("Adler chksum doesn't match: " + (int)adler.Value + " vs. " + readAdler);
            }

            mode = FINISHED;
            return false;
        }

        /// <summary>
        /// Decodes the deflated stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed, or if finished.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// if deflated stream is invalid.
        /// </exception>
        private bool Decode()
        {
            switch (mode)
            {
                case DECODE_HEADER:
                    return DecodeHeader();

                case DECODE_DICT:
                    return DecodeDict();

                case DECODE_CHKSUM:
                    return DecodeChksum();

                case DECODE_BLOCKS:
                    if (isLastBlock)
                    {
                        if (noHeader)
                        {
                            mode = FINISHED;
                            return false;
                        }
                        else
                        {
                            input.SkipToByteBoundary();
                            neededBits = 32;
                            mode = DECODE_CHKSUM;
                            return true;
                        }
                    }

                    int type = input.PeekBits(3);
                    if (type < 0)
                    {
                        return false;
                    }
                    input.DropBits(3);

                    if ((type & 1) != 0)
                    {
                        isLastBlock = true;
                    }
                    switch (type >> 1)
                    {
                        case DeflaterConstants.STORED_BLOCK:
                            input.SkipToByteBoundary();
                            mode = DECODE_STORED_LEN1;
                            break;
                        case DeflaterConstants.STATIC_TREES:
                            litlenTree = InflaterHuffmanTree.defLitLenTree;
                            distTree = InflaterHuffmanTree.defDistTree;
                            mode = DECODE_HUFFMAN;
                            break;
                        case DeflaterConstants.DYN_TREES:
                            dynHeader = new InflaterDynHeader();
                            mode = DECODE_DYN_HEADER;
                            break;
                        default:
                            throw new SharpZipBaseException("Unknown block type " + type);
                    }
                    return true;

                case DECODE_STORED_LEN1:
                    {
                        if ((uncomprLen = input.PeekBits(16)) < 0)
                        {
                            return false;
                        }
                        input.DropBits(16);
                        mode = DECODE_STORED_LEN2;
                    }
                    goto case DECODE_STORED_LEN2; // fall through

                case DECODE_STORED_LEN2:
                    {
                        int nlen = input.PeekBits(16);
                        if (nlen < 0)
                        {
                            return false;
                        }
                        input.DropBits(16);
                        if (nlen != (uncomprLen ^ 0xffff))
                        {
                            throw new SharpZipBaseException("broken uncompressed block");
                        }
                        mode = DECODE_STORED;
                    }
                    goto case DECODE_STORED; // fall through

                case DECODE_STORED:
                    {
                        int more = outputWindow.CopyStored(input, uncomprLen);
                        uncomprLen -= more;
                        if (uncomprLen == 0)
                        {
                            mode = DECODE_BLOCKS;
                            return true;
                        }
                        return !input.IsNeedingInput;
                    }

                case DECODE_DYN_HEADER:
                    if (!dynHeader.Decode(input))
                    {
                        return false;
                    }

                    litlenTree = dynHeader.BuildLitLenTree();
                    distTree = dynHeader.BuildDistTree();
                    mode = DECODE_HUFFMAN;
                    goto case DECODE_HUFFMAN; // fall through

                case DECODE_HUFFMAN:
                case DECODE_HUFFMAN_LENBITS:
                case DECODE_HUFFMAN_DIST:
                case DECODE_HUFFMAN_DISTBITS:
                    return DecodeHuffman();

                case FINISHED:
                    return false;

                default:
                    throw new SharpZipBaseException("Inflater.Decode unknown mode");
            }
        }

        /// <summary>
        /// Sets the preset dictionary.  This should only be called, if
        /// needsDictionary() returns true and it should set the same
        /// dictionary, that was used for deflating.  The getAdler()
        /// function returns the checksum of the dictionary needed.
        /// </summary>
        /// <param name="buffer">
        /// The dictionary.
        /// </param>
        public void SetDictionary(byte[] buffer)
        {
            SetDictionary(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Sets the preset dictionary.  This should only be called, if
        /// needsDictionary() returns true and it should set the same
        /// dictionary, that was used for deflating.  The getAdler()
        /// function returns the checksum of the dictionary needed.
        /// </summary>
        /// <param name="buffer">
        /// The dictionary.
        /// </param>
        /// <param name="index">
        /// The index into buffer where the dictionary starts.
        /// </param>
        /// <param name="count">
        /// The number of bytes in the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// No dictionary is needed.
        /// </exception>
        /// <exception cref="SharpZipBaseException">
        /// The adler checksum for the buffer is invalid
        /// </exception>
        public void SetDictionary(byte[] buffer, int index, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (index < 0)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if (!IsNeedingDictionary)
            {
                throw new InvalidOperationException("Dictionary is not needed");
            }

            adler.Update(buffer, index, count);

            if ((int)adler.Value != readAdler)
            {
                throw new SharpZipBaseException("Wrong adler checksum");
            }
            adler.Reset();
            outputWindow.CopyDict(buffer, index, count);
            mode = DECODE_BLOCKS;
        }

        /// <summary>
        /// Sets the input.  This should only be called, if needsInput()
        /// returns true.
        /// </summary>
        /// <param name="buffer">
        /// the input.
        /// </param>
        public void SetInput(byte[] buffer)
        {
            SetInput(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Sets the input.  This should only be called, if needsInput()
        /// returns true.
        /// </summary>
        /// <param name="buffer">
        /// The source of input data
        /// </param>
        /// <param name="index">
        /// The index into buffer where the input starts.
        /// </param>
        /// <param name="count">
        /// The number of bytes of input to use.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// No input is needed.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// The index and/or count are wrong.
        /// </exception>
        public void SetInput(byte[] buffer, int index, int count)
        {
            input.SetInput(buffer, index, count);
            totalIn += (long)count;
        }

        /// <summary>
        /// Inflates the compressed stream to the output buffer.  If this
        /// returns 0, you should check, whether IsNeedingDictionary(),
        /// IsNeedingInput() or IsFinished() returns true, to determine why no
        /// further output is produced.
        /// </summary>
        /// <param name="buffer">
        /// the output buffer.
        /// </param>
        /// <returns>
        /// The number of bytes written to the buffer, 0 if no further
        /// output can be produced.
        /// </returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if buffer has length 0.
        /// </exception>
        /// <exception cref="System.FormatException">
        /// if deflated stream is invalid.
        /// </exception>
        public int Inflate(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            return Inflate(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Inflates the compressed stream to the output buffer.  If this
        /// returns 0, you should check, whether needsDictionary(),
        /// needsInput() or finished() returns true, to determine why no
        /// further output is produced.
        /// </summary>
        /// <param name="buffer">
        /// the output buffer.
        /// </param>
        /// <param name="offset">
        /// the offset in buffer where storing starts.
        /// </param>
        /// <param name="count">
        /// the maximum number of bytes to output.
        /// </param>
        /// <returns>
        /// the number of bytes written to the buffer, 0 if no further output can be produced.
        /// </returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if count is less than 0.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if the index and / or count are wrong.
        /// </exception>
        /// <exception cref="System.FormatException">
        /// if deflated stream is invalid.
        /// </exception>
        public int Inflate(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "count cannot be negative");
#endif
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "offset cannot be negative");
#endif
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException("count exceeds buffer bounds");
            }

            // Special case: count may be zero
            if (count == 0)
            {
                if (!IsFinished)
                { // -jr- 08-Nov-2003 INFLATE_BUG fix..
                    Decode();
                }
                return 0;
            }

            int bytesCopied = 0;

            do
            {
                if (mode != DECODE_CHKSUM)
                {
                    /* Don't give away any output, if we are waiting for the
                    * checksum in the input stream.
                    *
                    * With this trick we have always:
                    *   IsNeedingInput() and not IsFinished()
                    *   implies more output can be produced.
                    */
                    int more = outputWindow.CopyOutput(buffer, offset, count);
                    if (more > 0)
                    {
                        adler.Update(buffer, offset, more);
                        offset += more;
                        bytesCopied += more;
                        totalOut += (long)more;
                        count -= more;
                        if (count == 0)
                        {
                            return bytesCopied;
                        }
                    }
                }
            } while (Decode() || ((outputWindow.GetAvailable() > 0) && (mode != DECODE_CHKSUM)));
            return bytesCopied;
        }

        /// <summary>
        /// Returns true, if the input buffer is empty.
        /// You should then call setInput(). 
        /// NOTE: This method also returns true when the stream is finished.
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return input.IsNeedingInput;
            }
        }

        /// <summary>
        /// Returns true, if a preset dictionary is needed to inflate the input.
        /// </summary>
        public bool IsNeedingDictionary
        {
            get
            {
                return mode == DECODE_DICT && neededBits == 0;
            }
        }

        /// <summary>
        /// Returns true, if the inflater has finished.  This means, that no
        /// input is needed and no output can be produced.
        /// </summary>
        public bool IsFinished
        {
            get
            {
                return mode == FINISHED && outputWindow.GetAvailable() == 0;
            }
        }

        /// <summary>
        /// Gets the adler checksum.  This is either the checksum of all
        /// uncompressed bytes returned by inflate(), or if needsDictionary()
        /// returns true (and thus no output was yet produced) this is the
        /// adler checksum of the expected dictionary.
        /// </summary>
        /// <returns>
        /// the adler checksum.
        /// </returns>
        public int Adler
        {
            get
            {
                return IsNeedingDictionary ? readAdler : (int)adler.Value;
            }
        }

        /// <summary>
        /// Gets the total number of output bytes returned by Inflate().
        /// </summary>
        /// <returns>
        /// the total number of output bytes.
        /// </returns>
        public long TotalOut
        {
            get
            {
                return totalOut;
            }
        }

        /// <summary>
        /// Gets the total number of processed compressed input bytes.
        /// </summary>
        /// <returns>
        /// The total number of bytes of processed input bytes.
        /// </returns>
        public long TotalIn
        {
            get
            {
                return totalIn - (long)RemainingInput;
            }
        }

        /// <summary>
        /// Gets the number of unprocessed input bytes.  Useful, if the end of the
        /// stream is reached and you want to further process the bytes after
        /// the deflate stream.
        /// </summary>
        /// <returns>
        /// The number of bytes of the input which have not been processed.
        /// </returns>
        public int RemainingInput
        {
            // TODO: This should be a long?
            get
            {
                return input.AvailableBytes;
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    class InflaterDynHeader
    {
        #region Constants
        const int LNUM = 0;
        const int DNUM = 1;
        const int BLNUM = 2;
        const int BLLENS = 3;
        const int LENS = 4;
        const int REPS = 5;

        static readonly int[] repMin = { 3, 3, 11 };
        static readonly int[] repBits = { 2, 3, 7 };

        static readonly int[] BL_ORDER = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

        #endregion

        #region Constructors
        public InflaterDynHeader()
        {
        }
        #endregion

        public bool Decode(StreamManipulator input)
        {
            decode_loop:
            for (;;)
            {
                switch (mode)
                {
                    case LNUM:
                        lnum = input.PeekBits(5);
                        if (lnum < 0)
                        {
                            return false;
                        }
                        lnum += 257;
                        input.DropBits(5);
                        //  	    System.err.println("LNUM: "+lnum);
                        mode = DNUM;
                        goto case DNUM; // fall through
                    case DNUM:
                        dnum = input.PeekBits(5);
                        if (dnum < 0)
                        {
                            return false;
                        }
                        dnum++;
                        input.DropBits(5);
                        //  	    System.err.println("DNUM: "+dnum);
                        num = lnum + dnum;
                        litdistLens = new byte[num];
                        mode = BLNUM;
                        goto case BLNUM; // fall through
                    case BLNUM:
                        blnum = input.PeekBits(4);
                        if (blnum < 0)
                        {
                            return false;
                        }
                        blnum += 4;
                        input.DropBits(4);
                        blLens = new byte[19];
                        ptr = 0;
                        //  	    System.err.println("BLNUM: "+blnum);
                        mode = BLLENS;
                        goto case BLLENS; // fall through
                    case BLLENS:
                        while (ptr < blnum)
                        {
                            int len = input.PeekBits(3);
                            if (len < 0)
                            {
                                return false;
                            }
                            input.DropBits(3);
                            //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);
                            blLens[BL_ORDER[ptr]] = (byte)len;
                            ptr++;
                        }
                        blTree = new InflaterHuffmanTree(blLens);
                        blLens = null;
                        ptr = 0;
                        mode = LENS;
                        goto case LENS; // fall through
                    case LENS:
                        {
                            int symbol;
                            while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)
                            {
                                /* Normal case: symbol in [0..15] */

                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);
                                litdistLens[ptr++] = lastLen = (byte)symbol;

                                if (ptr == num)
                                {
                                    /* Finished */
                                    return true;
                                }
                            }

                            /* need more input ? */
                            if (symbol < 0)
                            {
                                return false;
                            }

                            /* otherwise repeat code */
                            if (symbol >= 17)
                            {
                                /* repeat zero */
                                //  		  System.err.println("repeating zero");
                                lastLen = 0;
                            }
                            else
                            {
                                if (ptr == 0)
                                {
                                    throw new SharpZipBaseException();
                                }
                            }
                            repSymbol = symbol - 16;
                        }
                        mode = REPS;
                        goto case REPS; // fall through
                    case REPS:
                        {
                            int bits = repBits[repSymbol];
                            int count = input.PeekBits(bits);
                            if (count < 0)
                            {
                                return false;
                            }
                            input.DropBits(bits);
                            count += repMin[repSymbol];
                            //  	      System.err.println("litdistLens repeated: "+count);

                            if (ptr + count > num)
                            {
                                throw new SharpZipBaseException();
                            }
                            while (count-- > 0)
                            {
                                litdistLens[ptr++] = lastLen;
                            }

                            if (ptr == num)
                            {
                                /* Finished */
                                return true;
                            }
                        }
                        mode = LENS;
                        goto decode_loop;
                }
            }
        }

        public InflaterHuffmanTree BuildLitLenTree()
        {
            byte[] litlenLens = new byte[lnum];
            Array.Copy(litdistLens, 0, litlenLens, 0, lnum);
            return new InflaterHuffmanTree(litlenLens);
        }

        public InflaterHuffmanTree BuildDistTree()
        {
            byte[] distLens = new byte[dnum];
            Array.Copy(litdistLens, lnum, distLens, 0, dnum);
            return new InflaterHuffmanTree(distLens);
        }

        #region Instance Fields
        byte[] blLens;
        byte[] litdistLens;

        InflaterHuffmanTree blTree;

        /// <summary>
        /// The current decode mode
        /// </summary>
        int mode;
        int lnum, dnum, blnum, num;
        int repSymbol;
        byte lastLen;
        int ptr;
        #endregion

    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// Huffman tree used for inflation
    /// </summary>
    public class InflaterHuffmanTree
    {
        #region Constants
        const int MAX_BITLEN = 15;
        #endregion

        #region Instance Fields
        short[] tree;
        #endregion

        /// <summary>
        /// Literal length tree
        /// </summary>
        public static InflaterHuffmanTree defLitLenTree;

        /// <summary>
        /// Distance tree
        /// </summary>
        public static InflaterHuffmanTree defDistTree;

        static InflaterHuffmanTree()
        {
            try
            {
                byte[] codeLengths = new byte[288];
                int i = 0;
                while (i < 144)
                {
                    codeLengths[i++] = 8;
                }
                while (i < 256)
                {
                    codeLengths[i++] = 9;
                }
                while (i < 280)
                {
                    codeLengths[i++] = 7;
                }
                while (i < 288)
                {
                    codeLengths[i++] = 8;
                }
                defLitLenTree = new InflaterHuffmanTree(codeLengths);

                codeLengths = new byte[32];
                i = 0;
                while (i < 32)
                {
                    codeLengths[i++] = 5;
                }
                defDistTree = new InflaterHuffmanTree(codeLengths);
            }
            catch (Exception)
            {
                throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");
            }
        }

        #region Constructors
        /// <summary>
        /// Constructs a Huffman tree from the array of code lengths.
        /// </summary>
        /// <param name = "codeLengths">
        /// the array of code lengths
        /// </param>
        public InflaterHuffmanTree(byte[] codeLengths)
        {
            BuildTree(codeLengths);
        }
        #endregion

        void BuildTree(byte[] codeLengths)
        {
            int[] blCount = new int[MAX_BITLEN + 1];
            int[] nextCode = new int[MAX_BITLEN + 1];

            for (int i = 0; i < codeLengths.Length; i++)
            {
                int bits = codeLengths[i];
                if (bits > 0)
                {
                    blCount[bits]++;
                }
            }

            int code = 0;
            int treeSize = 512;
            for (int bits = 1; bits <= MAX_BITLEN; bits++)
            {
                nextCode[bits] = code;
                code += blCount[bits] << (16 - bits);
                if (bits >= 10)
                {
                    /* We need an extra table for bit lengths >= 10. */
                    int start = nextCode[bits] & 0x1ff80;
                    int end = code & 0x1ff80;
                    treeSize += (end - start) >> (16 - bits);
                }
            }

            /* -jr comment this out! doesnt work for dynamic trees and pkzip 2.04g
                        if (code != 65536) 
                        {
                            throw new SharpZipBaseException("Code lengths don't add up properly.");
                        }
            */
            /* Now create and fill the extra tables from longest to shortest
            * bit len.  This way the sub trees will be aligned.
            */
            tree = new short[treeSize];
            int treePtr = 512;
            for (int bits = MAX_BITLEN; bits >= 10; bits--)
            {
                int end = code & 0x1ff80;
                code -= blCount[bits] << (16 - bits);
                int start = code & 0x1ff80;
                for (int i = start; i < end; i += 1 << 7)
                {
                    tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);
                    treePtr += 1 << (bits - 9);
                }
            }

            for (int i = 0; i < codeLengths.Length; i++)
            {
                int bits = codeLengths[i];
                if (bits == 0)
                {
                    continue;
                }
                code = nextCode[bits];
                int revcode = DeflaterHuffman.BitReverse(code);
                if (bits <= 9)
                {
                    do
                    {
                        tree[revcode] = (short)((i << 4) | bits);
                        revcode += 1 << bits;
                    } while (revcode < 512);
                }
                else
                {
                    int subTree = tree[revcode & 511];
                    int treeLen = 1 << (subTree & 15);
                    subTree = -(subTree >> 4);
                    do
                    {
                        tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);
                        revcode += 1 << bits;
                    } while (revcode < treeLen);
                }
                nextCode[bits] = code + (1 << (16 - bits));
            }

        }

        /// <summary>
        /// Reads the next symbol from input.  The symbol is encoded using the
        /// huffman tree.
        /// </summary>
        /// <param name="input">
        /// input the input source.
        /// </param>
        /// <returns>
        /// the next symbol, or -1 if not enough input is available.
        /// </returns>
        public int GetSymbol(StreamManipulator input)
        {
            int lookahead, symbol;
            if ((lookahead = input.PeekBits(9)) >= 0)
            {
                if ((symbol = tree[lookahead]) >= 0)
                {
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                int subtree = -(symbol >> 4);
                int bitlen = symbol & 15;
                if ((lookahead = input.PeekBits(bitlen)) >= 0)
                {
                    symbol = tree[subtree | (lookahead >> 9)];
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                else
                {
                    int bits = input.AvailableBits;
                    lookahead = input.PeekBits(bits);
                    symbol = tree[subtree | (lookahead >> 9)];
                    if ((symbol & 15) <= bits)
                    {
                        input.DropBits(symbol & 15);
                        return symbol >> 4;
                    }
                    else
                    {
                        return -1;
                    }
                }
            }
            else
            {
                int bits = input.AvailableBits;
                lookahead = input.PeekBits(bits);
                symbol = tree[lookahead];
                if (symbol >= 0 && (symbol & 15) <= bits)
                {
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                else
                {
                    return -1;
                }
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    using System.IO;

#if !NETCF_1_0
    using System.Security.Cryptography;
#endif
    /// <summary>
    /// An input buffer customised for use by <see cref="InflaterInputStream"/>
    /// </summary>
    /// <remarks>
    /// The buffer supports decryption of incoming data.
    /// </remarks>
    public class InflaterInputBuffer
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="InflaterInputBuffer"/> with a default buffer size
        /// </summary>
        /// <param name="stream">The stream to buffer.</param>
        public InflaterInputBuffer(Stream stream)
            : this(stream, 4096)
        {
        }

        /// <summary>
        /// Initialise a new instance of <see cref="InflaterInputBuffer"/>
        /// </summary>
        /// <param name="stream">The stream to buffer.</param>
        /// <param name="bufferSize">The size to use for the buffer</param>
        /// <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        public InflaterInputBuffer(Stream stream, int bufferSize)
        {
            inputStream = stream;
            if (bufferSize < 1024)
            {
                bufferSize = 1024;
            }
            rawData = new byte[bufferSize];
            clearText = rawData;
        }
        #endregion

        /// <summary>
        /// Get the length of bytes bytes in the <see cref="RawData"/>
        /// </summary>
        public int RawLength
        {
            get
            {
                return rawLength;
            }
        }

        /// <summary>
        /// Get the contents of the raw data buffer.
        /// </summary>
        /// <remarks>This may contain encrypted data.</remarks>
        public byte[] RawData
        {
            get
            {
                return rawData;
            }
        }

        /// <summary>
        /// Get the number of useable bytes in <see cref="ClearText"/>
        /// </summary>
        public int ClearTextLength
        {
            get
            {
                return clearTextLength;
            }
        }

        /// <summary>
        /// Get the contents of the clear text buffer.
        /// </summary>
        public byte[] ClearText
        {
            get
            {
                return clearText;
            }
        }

        /// <summary>
        /// Get/set the number of bytes available
        /// </summary>
        public int Available
        {
            get { return available; }
            set { available = value; }
        }

        /// <summary>
        /// Call <see cref="Inflater.SetInput(byte[], int, int)"/> passing the current clear text buffer contents.
        /// </summary>
        /// <param name="inflater">The inflater to set input for.</param>
        public void SetInflaterInput(Inflater inflater)
        {
            if (available > 0)
            {
                inflater.SetInput(clearText, clearTextLength - available, available);
                available = 0;
            }
        }

        /// <summary>
        /// Fill the buffer from the underlying input stream.
        /// </summary>
        public void Fill()
        {
            rawLength = 0;
            int toRead = rawData.Length;

            while (toRead > 0)
            {
                int count = inputStream.Read(rawData, rawLength, toRead);
                if (count <= 0)
                {
                    break;
                }
                rawLength += count;
                toRead -= count;
            }

#if !NETCF_1_0
            if (cryptoTransform != null)
            {
                clearTextLength = cryptoTransform.TransformBlock(rawData, 0, rawLength, clearText, 0);
            }
            else
#endif
            {
                clearTextLength = rawLength;
            }

            available = clearTextLength;
        }

        /// <summary>
        /// Read a buffer directly from the input stream
        /// </summary>
        /// <param name="buffer">The buffer to fill</param>
        /// <returns>Returns the number of bytes read.</returns>
        public int ReadRawBuffer(byte[] buffer)
        {
            return ReadRawBuffer(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Read a buffer directly from the input stream
        /// </summary>
        /// <param name="outBuffer">The buffer to read into</param>
        /// <param name="offset">The offset to start reading data into.</param>
        /// <param name="length">The number of bytes to read.</param>
        /// <returns>Returns the number of bytes read.</returns>
        public int ReadRawBuffer(byte[] outBuffer, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            int currentOffset = offset;
            int currentLength = length;

            while (currentLength > 0)
            {
                if (available <= 0)
                {
                    Fill();
                    if (available <= 0)
                    {
                        return 0;
                    }
                }
                int toCopy = Math.Min(currentLength, available);
                System.Array.Copy(rawData, rawLength - (int)available, outBuffer, currentOffset, toCopy);
                currentOffset += toCopy;
                currentLength -= toCopy;
                available -= toCopy;
            }
            return length;
        }

        /// <summary>
        /// Read clear text data from the input stream.
        /// </summary>
        /// <param name="outBuffer">The buffer to add data to.</param>
        /// <param name="offset">The offset to start adding data at.</param>
        /// <param name="length">The number of bytes to read.</param>
        /// <returns>Returns the number of bytes actually read.</returns>
        public int ReadClearTextBuffer(byte[] outBuffer, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            int currentOffset = offset;
            int currentLength = length;

            while (currentLength > 0)
            {
                if (available <= 0)
                {
                    Fill();
                    if (available <= 0)
                    {
                        return 0;
                    }
                }

                int toCopy = Math.Min(currentLength, available);
                Array.Copy(clearText, clearTextLength - (int)available, outBuffer, currentOffset, toCopy);
                currentOffset += toCopy;
                currentLength -= toCopy;
                available -= toCopy;
            }
            return length;
        }

        /// <summary>
        /// Read a <see cref="byte"/> from the input stream.
        /// </summary>
        /// <returns>Returns the byte read.</returns>
        public int ReadLeByte()
        {
            if (available <= 0)
            {
                Fill();
                if (available <= 0)
                {
                    throw new ZipException("EOF in header");
                }
            }
            byte result = rawData[rawLength - available];
            available -= 1;
            return result;
        }

        /// <summary>
        /// Read an <see cref="short"/> in little endian byte order.
        /// </summary>
        /// <returns>The short value read case to an int.</returns>
        public int ReadLeShort()
        {
            return ReadLeByte() | (ReadLeByte() << 8);
        }

        /// <summary>
        /// Read an <see cref="int"/> in little endian byte order.
        /// </summary>
        /// <returns>The int value read.</returns>
        public int ReadLeInt()
        {
            return ReadLeShort() | (ReadLeShort() << 16);
        }

        /// <summary>
        /// Read a <see cref="long"/> in little endian byte order.
        /// </summary>
        /// <returns>The long value read.</returns>
        public long ReadLeLong()
        {
            return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
        }

#if !NETCF_1_0
        /// <summary>
        /// Get/set the <see cref="ICryptoTransform"/> to apply to any data.
        /// </summary>
        /// <remarks>Set this value to null to have no transform applied.</remarks>
        public ICryptoTransform CryptoTransform
        {
            set
            {
                cryptoTransform = value;
                if (cryptoTransform != null)
                {
                    if (rawData == clearText)
                    {
                        if (internalClearText == null)
                        {
                            internalClearText = new byte[rawData.Length];
                        }
                        clearText = internalClearText;
                    }
                    clearTextLength = rawLength;
                    if (available > 0)
                    {
                        cryptoTransform.TransformBlock(rawData, rawLength - available, available, clearText, rawLength - available);
                    }
                }
                else
                {
                    clearText = rawData;
                    clearTextLength = rawLength;
                }
            }
        }
#endif

        #region Instance Fields
        int rawLength;
        byte[] rawData;

        int clearTextLength;
        byte[] clearText;
#if !NETCF_1_0
        byte[] internalClearText;
#endif

        int available;

#if !NETCF_1_0
        ICryptoTransform cryptoTransform;
#endif
        Stream inputStream;
        #endregion
    }

    /// <summary>
    /// This filter stream is used to decompress data compressed using the "deflate"
    /// format. The "deflate" format is described in RFC 1951.
    ///
    /// This stream may form the basis for other decompression filters, such
    /// as the <see cref="ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
    ///
    /// Author of the original java version : John Leuner.
    /// </summary>
    public class InflaterInputStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Create an InflaterInputStream with the default decompressor
        /// and a default buffer size of 4KB.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The InputStream to read bytes from
        /// </param>
        public InflaterInputStream(Stream baseInputStream)
            : this(baseInputStream, new Inflater(), 4096)
        {
        }

        /// <summary>
        /// Create an InflaterInputStream with the specified decompressor
        /// and a default buffer size of 4KB.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The source of input data
        /// </param>
        /// <param name = "inf">
        /// The decompressor used to decompress data read from baseInputStream
        /// </param>
        public InflaterInputStream(Stream baseInputStream, Inflater inf)
            : this(baseInputStream, inf, 4096)
        {
        }

        /// <summary>
        /// Create an InflaterInputStream with the specified decompressor
        /// and the specified buffer size.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The InputStream to read bytes from
        /// </param>
        /// <param name = "inflater">
        /// The decompressor to use
        /// </param>
        /// <param name = "bufferSize">
        /// Size of the buffer to use
        /// </param>
        public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize)
        {
            if (baseInputStream == null)
            {
                throw new ArgumentNullException("baseInputStream");
            }

            if (inflater == null)
            {
                throw new ArgumentNullException("inflater");
            }

            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }

            this.baseInputStream = baseInputStream;
            this.inf = inflater;

            inputBuffer = new InflaterInputBuffer(baseInputStream, bufferSize);
        }

        #endregion

        /// <summary>
        /// Get/set flag indicating ownership of underlying stream.
        /// When the flag is true <see cref="Close"/> will close the underlying stream also.
        /// </summary>
        /// <remarks>
        /// The default value is true.
        /// </remarks>
        public bool IsStreamOwner
        {
            get { return isStreamOwner; }
            set { isStreamOwner = value; }
        }

        /// <summary>
        /// Skip specified number of bytes of uncompressed data
        /// </summary>
        /// <param name ="count">
        /// Number of bytes to skip
        /// </param>
        /// <returns>
        /// The number of bytes skipped, zero if the end of 
        /// stream has been reached
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
        /// </exception>
        public long Skip(long count)
        {
            if (count <= 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            // v0.80 Skip by seeking if underlying stream supports it...
            if (baseInputStream.CanSeek)
            {
                baseInputStream.Seek(count, SeekOrigin.Current);
                return count;
            }
            else
            {
                int length = 2048;
                if (count < length)
                {
                    length = (int)count;
                }

                byte[] tmp = new byte[length];
                int readCount = 1;
                long toSkip = count;

                while ((toSkip > 0) && (readCount > 0))
                {
                    if (toSkip < length)
                    {
                        length = (int)toSkip;
                    }

                    readCount = baseInputStream.Read(tmp, 0, length);
                    toSkip -= readCount;
                }

                return count - toSkip;
            }
        }

        /// <summary>
        /// Clear any cryptographic state.
        /// </summary>		
        protected void StopDecrypting()
        {
#if !NETCF_1_0
            inputBuffer.CryptoTransform = null;
#endif
        }

        /// <summary>
        /// Returns 0 once the end of the stream (EOF) has been reached.
        /// Otherwise returns 1.
        /// </summary>
        public virtual int Available
        {
            get
            {
                return inf.IsFinished ? 0 : 1;
            }
        }

        /// <summary>
        /// Fills the buffer with more data to decompress.
        /// </summary>
        /// <exception cref="SharpZipBaseException">
        /// Stream ends early
        /// </exception>
        protected void Fill()
        {
            // Protect against redundant calls
            if (inputBuffer.Available <= 0)
            {
                inputBuffer.Fill();
                if (inputBuffer.Available <= 0)
                {
                    throw new SharpZipBaseException("Unexpected EOF");
                }
            }
            inputBuffer.SetInflaterInput(inf);
        }

        #region Stream Overrides
        /// <summary>
        /// Gets a value indicating whether the current stream supports reading
        /// </summary>
        public override bool CanRead
        {
            get
            {
                return baseInputStream.CanRead;
            }
        }

        /// <summary>
        /// Gets a value of false indicating seeking is not supported for this stream.
        /// </summary>
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a value of false indicating that this stream is not writeable.
        /// </summary>
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// A value representing the length of the stream in bytes.
        /// </summary>
        public override long Length
        {
            get
            {
                return inputBuffer.RawLength;
            }
        }

        /// <summary>
        /// The current position within the stream.
        /// Throws a NotSupportedException when attempting to set the position
        /// </summary>
        /// <exception cref="NotSupportedException">Attempting to set the position</exception>
        public override long Position
        {
            get
            {
                return baseInputStream.Position;
            }
            set
            {
                throw new NotSupportedException("InflaterInputStream Position not supported");
            }
        }

        /// <summary>
        /// Flushes the baseInputStream
        /// </summary>
        public override void Flush()
        {
            baseInputStream.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="offset">The relative offset to seek to.</param>
        /// <param name="origin">The <see cref="SeekOrigin"/> defining where to seek from.</param>
        /// <returns>The new position in the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Seek not supported");
        }

        /// <summary>
        /// Set the length of the current stream
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="value">The new length value for the stream.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("InflaterInputStream SetLength not supported");
        }

        /// <summary>
        /// Writes a sequence of bytes to stream and advances the current position
        /// This method always throws a NotSupportedException
        /// </summary>
        /// <param name="buffer">Thew buffer containing data to write.</param>
        /// <param name="offset">The offset of the first byte to write.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("InflaterInputStream Write not supported");
        }

        /// <summary>
        /// Writes one byte to the current stream and advances the current position
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="value">The byte to write.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void WriteByte(byte value)
        {
            throw new NotSupportedException("InflaterInputStream WriteByte not supported");
        }

        /// <summary>
        /// Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
        /// </summary>
        /// <param name="buffer">The buffer to write data from</param>
        /// <param name="offset">Offset of first byte to write</param>
        /// <param name="count">The maximum number of bytes to write</param>
        /// <param name="callback">The method to be called when the asynchronous write operation is completed</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
        /// <returns>An <see cref="System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("InflaterInputStream BeginWrite not supported");
        }

        /// <summary>
        /// Closes the input stream.  When <see cref="IsStreamOwner"></see>
        /// is true the underlying stream is also closed.
        /// </summary>
        public override void Close()
        {
            if (!isClosed)
            {
                isClosed = true;
                if (isStreamOwner)
                {
                    baseInputStream.Close();
                }
            }
        }

        /// <summary>
        /// Reads decompressed data into the provided buffer byte array
        /// </summary>
        /// <param name ="buffer">
        /// The array to read and decompress data into
        /// </param>
        /// <param name ="offset">
        /// The offset indicating where the data should be placed
        /// </param>
        /// <param name ="count">
        /// The number of bytes to decompress
        /// </param>
        /// <returns>The number of bytes read.  Zero signals the end of stream</returns>
        /// <exception cref="SharpZipBaseException">
        /// Inflater needs a dictionary
        /// </exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (inf.IsNeedingDictionary)
            {
                throw new SharpZipBaseException("Need a dictionary");
            }

            int remainingBytes = count;
            while (true)
            {
                int bytesRead = inf.Inflate(buffer, offset, remainingBytes);
                offset += bytesRead;
                remainingBytes -= bytesRead;

                if (remainingBytes == 0 || inf.IsFinished)
                {
                    break;
                }

                if (inf.IsNeedingInput)
                {
                    Fill();
                }
                else if (bytesRead == 0)
                {
                    throw new ZipException("Dont know what to do");
                }
            }
            return count - remainingBytes;
        }
        #endregion

        #region Instance Fields
        /// <summary>
        /// Decompressor for this stream
        /// </summary>
        protected Inflater inf;

        /// <summary>
        /// <see cref="InflaterInputBuffer">Input buffer</see> for this stream.
        /// </summary>
        protected InflaterInputBuffer inputBuffer;

        /// <summary>
        /// Base stream the inflater reads from.
        /// </summary>
        private Stream baseInputStream;

        /// <summary>
        /// The compressed size
        /// </summary>
        protected long csize;

        /// <summary>
        /// Flag indicating wether this instance has been closed or not.
        /// </summary>
        bool isClosed;

        /// <summary>
        /// Flag indicating wether this instance is designated the stream owner.
        /// When closing if this flag is true the underlying stream is closed.
        /// </summary>
        bool isStreamOwner = true;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// Scanning filters support filtering of names.
    /// </summary>
    public interface IScanFilter
    {
        /// <summary>
        /// Test a name to see if it 'matches' the filter.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name matches the filter, false if it does not match.</returns>
        bool IsMatch(string name);
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.Collections;
    using System.Text;
    using System.Text.RegularExpressions;
    /// <summary>
    /// NameFilter is a string matching class which allows for both positive and negative
    /// matching.
    /// A filter is a sequence of independant <see cref="Regex">regular expressions</see> separated by semi-colons ';'.
    /// To include a semi-colon it may be quoted as in \;. Each expression can be prefixed by a plus '+' sign or
    /// a minus '-' sign to denote the expression is intended to include or exclude names.
    /// If neither a plus or minus sign is found include is the default.
    /// A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
    /// and not matching an exclude spec are deemed to match the filter.
    /// An empty filter matches any name.
    /// </summary>
    /// <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
    /// "+\.dat$;-^dummy\.dat$"
    /// </example>
    public class NameFilter : IScanFilter
    {
        #region Constructors
        /// <summary>
        /// Construct an instance based on the filter expression passed
        /// </summary>
        /// <param name="filter">The filter expression.</param>
        public NameFilter(string filter)
        {
            filter_ = filter;
            inclusions_ = new ArrayList();
            exclusions_ = new ArrayList();
            Compile();
        }
        #endregion

        /// <summary>
        /// Test a string to see if it is a valid regular expression.
        /// </summary>
        /// <param name="expression">The expression to test.</param>
        /// <returns>True if expression is a valid <see cref="System.Text.RegularExpressions.Regex"/> false otherwise.</returns>
        public static bool IsValidExpression(string expression)
        {
            bool result = true;
            try
            {
                Regex exp = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }
            catch (ArgumentException)
            {
                result = false;
            }
            return result;
        }

        /// <summary>
        /// Test an expression to see if it is valid as a filter.
        /// </summary>
        /// <param name="toTest">The filter expression to test.</param>
        /// <returns>True if the expression is valid, false otherwise.</returns>
        public static bool IsValidFilterExpression(string toTest)
        {
            if (toTest == null)
            {
                throw new ArgumentNullException("toTest");
            }

            bool result = true;

            try
            {
                string[] items = SplitQuoted(toTest);
                for (int i = 0; i < items.Length; ++i)
                {
                    if ((items[i] != null) && (items[i].Length > 0))
                    {
                        string toCompile;

                        if (items[i][0] == '+')
                        {
                            toCompile = items[i].Substring(1, items[i].Length - 1);
                        }
                        else if (items[i][0] == '-')
                        {
                            toCompile = items[i].Substring(1, items[i].Length - 1);
                        }
                        else
                        {
                            toCompile = items[i];
                        }

                        Regex testRegex = new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Singleline);
                    }
                }
            }
            catch (ArgumentException)
            {
                result = false;
            }

            return result;
        }

        /// <summary>
        /// Split a string into its component pieces
        /// </summary>
        /// <param name="original">The original string</param>
        /// <returns>Returns an array of <see cref="T:System.String"/> values containing the individual filter elements.</returns>
        public static string[] SplitQuoted(string original)
        {
            char escape = '\\';
            char[] separators = { ';' };

            ArrayList result = new ArrayList();

            if ((original != null) && (original.Length > 0))
            {
                int endIndex = -1;
                StringBuilder b = new StringBuilder();

                while (endIndex < original.Length)
                {
                    endIndex += 1;
                    if (endIndex >= original.Length)
                    {
                        result.Add(b.ToString());
                    }
                    else if (original[endIndex] == escape)
                    {
                        endIndex += 1;
                        if (endIndex >= original.Length)
                        {
#if NETCF_1_0
							throw new ArgumentException("Missing terminating escape character");
#else
                            throw new ArgumentException("Missing terminating escape character", "original");
#endif
                        }
                        // include escape if this is not an escaped separator
                        if (Array.IndexOf(separators, original[endIndex]) < 0)
                            b.Append(escape);

                        b.Append(original[endIndex]);
                    }
                    else
                    {
                        if (Array.IndexOf(separators, original[endIndex]) >= 0)
                        {
                            result.Add(b.ToString());
                            b.Length = 0;
                        }
                        else
                        {
                            b.Append(original[endIndex]);
                        }
                    }
                }
            }

            return (string[])result.ToArray(typeof(string));
        }

        /// <summary>
        /// Convert this filter to its string equivalent.
        /// </summary>
        /// <returns>The string equivalent for this filter.</returns>
        public override string ToString()
        {
            return filter_;
        }

        /// <summary>
        /// Test a value to see if it is included by the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value is included, false otherwise.</returns>
        public bool IsIncluded(string name)
        {
            bool result = false;
            if (inclusions_.Count == 0)
            {
                result = true;
            }
            else
            {
                foreach (Regex r in inclusions_)
                {
                    if (r.IsMatch(name))
                    {
                        result = true;
                        break;
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Test a value to see if it is excluded by the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value is excluded, false otherwise.</returns>
        public bool IsExcluded(string name)
        {
            bool result = false;
            foreach (Regex r in exclusions_)
            {
                if (r.IsMatch(name))
                {
                    result = true;
                    break;
                }
            }
            return result;
        }

        #region IScanFilter Members
        /// <summary>
        /// Test a value to see if it matches the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value matches, false otherwise.</returns>
        public bool IsMatch(string name)
        {
            return (IsIncluded(name) && !IsExcluded(name));
        }
        #endregion

        /// <summary>
        /// Compile this filter.
        /// </summary>
        void Compile()
        {
            // TODO: Check to see if combining RE's makes it faster/smaller.
            // simple scheme would be to have one RE for inclusion and one for exclusion.
            if (filter_ == null)
            {
                return;
            }

            string[] items = SplitQuoted(filter_);
            for (int i = 0; i < items.Length; ++i)
            {
                if ((items[i] != null) && (items[i].Length > 0))
                {
                    bool include = (items[i][0] != '-');
                    string toCompile;

                    if (items[i][0] == '+')
                    {
                        toCompile = items[i].Substring(1, items[i].Length - 1);
                    }
                    else if (items[i][0] == '-')
                    {
                        toCompile = items[i].Substring(1, items[i].Length - 1);
                    }
                    else
                    {
                        toCompile = items[i];
                    }

                    // NOTE: Regular expressions can fail to compile here for a number of reasons that cause an exception
                    // these are left unhandled here as the caller is responsible for ensuring all is valid.
                    // several functions IsValidFilterExpression and IsValidExpression are provided for such checking
                    if (include)
                    {
                        inclusions_.Add(new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
                    }
                    else
                    {
                        exclusions_.Add(new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
                    }
                }
            }
        }

        #region Instance Fields
        string filter_;
        ArrayList inclusions_;
        ArrayList exclusions_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    /// <summary>
    /// Contains the output from the Inflation process.
    /// We need to have a window so that we can refer backwards into the output stream
    /// to repeat stuff.<br/>
    /// Author of the original java version : John Leuner
    /// </summary>
    public class OutputWindow
    {
        #region Constants
        const int WindowSize = 1 << 15;
        const int WindowMask = WindowSize - 1;
        #endregion

        #region Instance Fields
        byte[] window = new byte[WindowSize]; //The window is 2^15 bytes
        int windowEnd;
        int windowFilled;
        #endregion

        /// <summary>
        /// Write a byte to this output window
        /// </summary>
        /// <param name="value">value to write</param>
        /// <exception cref="InvalidOperationException">
        /// if window is full
        /// </exception>
        public void Write(int value)
        {
            if (windowFilled++ == WindowSize)
            {
                throw new InvalidOperationException("Window full");
            }
            window[windowEnd++] = (byte)value;
            windowEnd &= WindowMask;
        }


        private void SlowRepeat(int repStart, int length, int distance)
        {
            while (length-- > 0)
            {
                window[windowEnd++] = window[repStart++];
                windowEnd &= WindowMask;
                repStart &= WindowMask;
            }
        }

        /// <summary>
        /// Append a byte pattern already in the window itself
        /// </summary>
        /// <param name="length">length of pattern to copy</param>
        /// <param name="distance">distance from end of window pattern occurs</param>
        /// <exception cref="InvalidOperationException">
        /// If the repeated data overflows the window
        /// </exception>
        public void Repeat(int length, int distance)
        {
            if ((windowFilled += length) > WindowSize)
            {
                throw new InvalidOperationException("Window full");
            }

            int repStart = (windowEnd - distance) & WindowMask;
            int border = WindowSize - length;
            if ((repStart <= border) && (windowEnd < border))
            {
                if (length <= distance)
                {
                    System.Array.Copy(window, repStart, window, windowEnd, length);
                    windowEnd += length;
                }
                else
                {
                    // We have to copy manually, since the repeat pattern overlaps.
                    while (length-- > 0)
                    {
                        window[windowEnd++] = window[repStart++];
                    }
                }
            }
            else
            {
                SlowRepeat(repStart, length, distance);
            }
        }

        /// <summary>
        /// Copy from input manipulator to internal window
        /// </summary>
        /// <param name="input">source of data</param>
        /// <param name="length">length of data to copy</param>
        /// <returns>the number of bytes copied</returns>
        public int CopyStored(StreamManipulator input, int length)
        {
            length = Math.Min(Math.Min(length, WindowSize - windowFilled), input.AvailableBytes);
            int copied;

            int tailLen = WindowSize - windowEnd;
            if (length > tailLen)
            {
                copied = input.CopyBytes(window, windowEnd, tailLen);
                if (copied == tailLen)
                {
                    copied += input.CopyBytes(window, 0, length - tailLen);
                }
            }
            else
            {
                copied = input.CopyBytes(window, windowEnd, length);
            }

            windowEnd = (windowEnd + copied) & WindowMask;
            windowFilled += copied;
            return copied;
        }

        /// <summary>
        /// Copy dictionary to window
        /// </summary>
        /// <param name="dictionary">source dictionary</param>
        /// <param name="offset">offset of start in source dictionary</param>
        /// <param name="length">length of dictionary</param>
        /// <exception cref="InvalidOperationException">
        /// If window isnt empty
        /// </exception>
        public void CopyDict(byte[] dictionary, int offset, int length)
        {
            if (dictionary == null)
            {
                throw new ArgumentNullException("dictionary");
            }

            if (windowFilled > 0)
            {
                throw new InvalidOperationException();
            }

            if (length > WindowSize)
            {
                offset += length - WindowSize;
                length = WindowSize;
            }
            System.Array.Copy(dictionary, offset, window, 0, length);
            windowEnd = length & WindowMask;
        }

        /// <summary>
        /// Get remaining unfilled space in window
        /// </summary>
        /// <returns>Number of bytes left in window</returns>
        public int GetFreeSpace()
        {
            return WindowSize - windowFilled;
        }

        /// <summary>
        /// Get bytes available for output in window
        /// </summary>
        /// <returns>Number of bytes filled</returns>
        public int GetAvailable()
        {
            return windowFilled;
        }

        /// <summary>
        /// Copy contents of window to output
        /// </summary>
        /// <param name="output">buffer to copy to</param>
        /// <param name="offset">offset to start at</param>
        /// <param name="len">number of bytes to count</param>
        /// <returns>The number of bytes copied</returns>
        /// <exception cref="InvalidOperationException">
        /// If a window underflow occurs
        /// </exception>
        public int CopyOutput(byte[] output, int offset, int len)
        {
            int copyEnd = windowEnd;
            if (len > windowFilled)
            {
                len = windowFilled;
            }
            else
            {
                copyEnd = (windowEnd - windowFilled + len) & WindowMask;
            }

            int copied = len;
            int tailLen = len - copyEnd;

            if (tailLen > 0)
            {
                System.Array.Copy(window, WindowSize - tailLen, output, offset, tailLen);
                offset += tailLen;
                len = copyEnd;
            }
            System.Array.Copy(window, copyEnd - len, output, offset, len);
            windowFilled -= copied;
            if (windowFilled < 0)
            {
                throw new InvalidOperationException();
            }
            return copied;
        }

        /// <summary>
        /// Reset by clearing window so <see cref="GetAvailable">GetAvailable</see> returns 0
        /// </summary>
        public void Reset()
        {
            windowFilled = windowEnd = 0;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.IO;
    /// <summary>
    /// PathFilter filters directories and files using a form of <see cref="System.Text.RegularExpressions.Regex">regular expressions</see>
    /// by full path name.
    /// See <see cref="NameFilter">NameFilter</see> for more detail on filtering.
    /// </summary>
    public class PathFilter : IScanFilter
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="PathFilter"></see>.
        /// </summary>
        /// <param name="filter">The <see cref="NameFilter">filter</see> expression to apply.</param>
        public PathFilter(string filter)
        {
            nameFilter_ = new NameFilter(filter);
        }
        #endregion

        #region IScanFilter Members
        /// <summary>
        /// Test a name to see if it matches the filter.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>True if the name matches, false otherwise.</returns>
        /// <remarks><see cref="Path.GetFullPath(string)"/> is used to get the full path before matching.</remarks>
        public virtual bool IsMatch(string name)
        {
            bool result = false;

            if (name != null)
            {
                string cooked = (name.Length > 0) ? Path.GetFullPath(name) : "";
                result = nameFilter_.IsMatch(cooked);
            }
            return result;
        }
        #endregion

        #region Instance Fields
        NameFilter nameFilter_;
        #endregion
    }

    /// <summary>
    /// ExtendedPathFilter filters based on name, file size, and the last write time of the file.
    /// </summary>
    /// <remarks>Provides an example of how to customise filtering.</remarks>
    public class ExtendedPathFilter : PathFilter
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        public ExtendedPathFilter(string filter,
            long minSize, long maxSize)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
        }

        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minDate">The minimum <see cref="DateTime"/> to include.</param>
        /// <param name="maxDate">The maximum <see cref="DateTime"/> to include.</param>
        public ExtendedPathFilter(string filter,
            DateTime minDate, DateTime maxDate)
            : base(filter)
        {
            MinDate = minDate;
            MaxDate = maxDate;
        }

        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        /// <param name="minDate">The minimum <see cref="DateTime"/> to include.</param>
        /// <param name="maxDate">The maximum <see cref="DateTime"/> to include.</param>
        public ExtendedPathFilter(string filter,
            long minSize, long maxSize,
            DateTime minDate, DateTime maxDate)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
            MinDate = minDate;
            MaxDate = maxDate;
        }
        #endregion

        #region IScanFilter Members
        /// <summary>
        /// Test a filename to see if it matches the filter.
        /// </summary>
        /// <param name="name">The filename to test.</param>
        /// <returns>True if the filter matches, false otherwise.</returns>
        /// <exception cref="System.IO.FileNotFoundException">The <see paramref="fileName"/> doesnt exist</exception>
        public override bool IsMatch(string name)
        {
            bool result = base.IsMatch(name);

            if (result)
            {
                FileInfo fileInfo = new FileInfo(name);
                result =
                    (MinSize <= fileInfo.Length) &&
                    (MaxSize >= fileInfo.Length) &&
                    (MinDate <= fileInfo.LastWriteTime) &&
                    (MaxDate >= fileInfo.LastWriteTime)
                    ;
            }
            return result;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get/set the minimum size/length for a file that will match this filter.
        /// </summary>
        /// <remarks>The default value is zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException">value is less than zero; greater than <see cref="MaxSize"/></exception>
        public long MinSize
        {
            get { return minSize_; }
            set
            {
                if ((value < 0) || (maxSize_ < value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                minSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum size/length for a file that will match this filter.
        /// </summary>
        /// <remarks>The default value is <see cref="System.Int64.MaxValue"/></remarks>
        /// <exception cref="ArgumentOutOfRangeException">value is less than zero or less than <see cref="MinSize"/></exception>
        public long MaxSize
        {
            get { return maxSize_; }
            set
            {
                if ((value < 0) || (minSize_ > value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                maxSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the minimum <see cref="DateTime"/> value that will match for this filter.
        /// </summary>
        /// <remarks>Files with a LastWrite time less than this value are excluded by the filter.</remarks>
        public DateTime MinDate
        {
            get
            {
                return minDate_;
            }

            set
            {
                if (value > maxDate_)
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "Exceeds MaxDate");
#endif
                }

                minDate_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum <see cref="DateTime"/> value that will match for this filter.
        /// </summary>
        /// <remarks>Files with a LastWrite time greater than this value are excluded by the filter.</remarks>
        public DateTime MaxDate
        {
            get
            {
                return maxDate_;
            }

            set
            {
                if (minDate_ > value)
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "Exceeds MinDate");
#endif
                }

                maxDate_ = value;
            }
        }
        #endregion

        #region Instance Fields
        long minSize_;
        long maxSize_ = long.MaxValue;
        DateTime minDate_ = DateTime.MinValue;
        DateTime maxDate_ = DateTime.MaxValue;
        #endregion
    }

    /// <summary>
    /// NameAndSizeFilter filters based on name and file size.
    /// </summary>
    /// <remarks>A sample showing how filters might be extended.</remarks>
    [Obsolete("Use ExtendedPathFilter instead")]
    public class NameAndSizeFilter : PathFilter
    {

        /// <summary>
        /// Initialise a new instance of NameAndSizeFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        public NameAndSizeFilter(string filter, long minSize, long maxSize)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
        }

        /// <summary>
        /// Test a filename to see if it matches the filter.
        /// </summary>
        /// <param name="name">The filename to test.</param>
        /// <returns>True if the filter matches, false otherwise.</returns>
        public override bool IsMatch(string name)
        {
            bool result = base.IsMatch(name);

            if (result)
            {
                FileInfo fileInfo = new FileInfo(name);
                long length = fileInfo.Length;
                result =
                    (MinSize <= length) &&
                    (MaxSize >= length);
            }
            return result;
        }

        /// <summary>
        /// Get/set the minimum size for a file that will match this filter.
        /// </summary>
        public long MinSize
        {
            get { return minSize_; }
            set
            {
                if ((value < 0) || (maxSize_ < value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                minSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum size for a file that will match this filter.
        /// </summary>
        public long MaxSize
        {
            get { return maxSize_; }
            set
            {
                if ((value < 0) || (minSize_ > value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                maxSize_ = value;
            }
        }

        #region Instance Fields
        long minSize_;
        long maxSize_ = long.MaxValue;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This class is general purpose class for writing data to a buffer.
    /// 
    /// It allows you to write bits as well as bytes
    /// Based on DeflaterPending.java
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class PendingBuffer
    {
        #region Instance Fields
        /// <summary>
        /// Internal work buffer
        /// </summary>
        byte[] buffer_;

        int start;
        int end;

        uint bits;
        int bitCount;
        #endregion

        #region Constructors
        /// <summary>
        /// construct instance using default buffer size of 4096
        /// </summary>
        public PendingBuffer()
            : this(4096)
        {
        }

        /// <summary>
        /// construct instance using specified buffer size
        /// </summary>
        /// <param name="bufferSize">
        /// size to use for internal buffer
        /// </param>
        public PendingBuffer(int bufferSize)
        {
            buffer_ = new byte[bufferSize];
        }

        #endregion

        /// <summary>
        /// Clear internal state/buffers
        /// </summary>
        public void Reset()
        {
            start = end = bitCount = 0;
        }

        /// <summary>
        /// Write a byte to buffer
        /// </summary>
        /// <param name="value">
        /// The value to write
        /// </param>
        public void WriteByte(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
        }

        /// <summary>
        /// Write a short value to buffer LSB first
        /// </summary>
        /// <param name="value">
        /// The value to write.
        /// </param>
        public void WriteShort(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
            buffer_[end++] = unchecked((byte)(value >> 8));
        }

        /// <summary>
        /// write an integer LSB first
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteInt(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
            buffer_[end++] = unchecked((byte)(value >> 8));
            buffer_[end++] = unchecked((byte)(value >> 16));
            buffer_[end++] = unchecked((byte)(value >> 24));
        }

        /// <summary>
        /// Write a block of data to buffer
        /// </summary>
        /// <param name="block">data to write</param>
        /// <param name="offset">offset of first byte to write</param>
        /// <param name="length">number of bytes to write</param>
        public void WriteBlock(byte[] block, int offset, int length)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            System.Array.Copy(block, offset, buffer_, end, length);
            end += length;
        }

        /// <summary>
        /// The number of bits written to the buffer
        /// </summary>
        public int BitCount
        {
            get
            {
                return bitCount;
            }
        }

        /// <summary>
        /// Align internal buffer on a byte boundary
        /// </summary>
        public void AlignToByte()
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            if (bitCount > 0)
            {
                buffer_[end++] = unchecked((byte)bits);
                if (bitCount > 8)
                {
                    buffer_[end++] = unchecked((byte)(bits >> 8));
                }
            }
            bits = 0;
            bitCount = 0;
        }

        /// <summary>
        /// Write bits to internal buffer
        /// </summary>
        /// <param name="b">source of bits</param>
        /// <param name="count">number of bits to write</param>
        public void WriteBits(int b, int count)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}

			//			if (DeflaterConstants.DEBUGGING) {
			//				//Console.WriteLine("writeBits("+b+","+count+")");
			//			}
#endif
            bits |= (uint)(b << bitCount);
            bitCount += count;
            if (bitCount >= 16)
            {
                buffer_[end++] = unchecked((byte)bits);
                buffer_[end++] = unchecked((byte)(bits >> 8));
                bits >>= 16;
                bitCount -= 16;
            }
        }

        /// <summary>
        /// Write a short value to internal buffer most significant byte first
        /// </summary>
        /// <param name="s">value to write</param>
        public void WriteShortMSB(int s)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)(s >> 8));
            buffer_[end++] = unchecked((byte)s);
        }

        /// <summary>
        /// Indicates if buffer has been flushed
        /// </summary>
        public bool IsFlushed
        {
            get
            {
                return end == 0;
            }
        }

        /// <summary>
        /// Flushes the pending buffer into the given output array.  If the
        /// output array is to small, only a partial flush is done.
        /// </summary>
        /// <param name="output">The output array.</param>
        /// <param name="offset">The offset into output array.</param>
        /// <param name="length">The maximum number of bytes to store.</param>
        /// <returns>The number of bytes flushed.</returns>
        public int Flush(byte[] output, int offset, int length)
        {
            if (bitCount >= 8)
            {
                buffer_[end++] = unchecked((byte)bits);
                bits >>= 8;
                bitCount -= 8;
            }

            if (length > end - start)
            {
                length = end - start;
                System.Array.Copy(buffer_, start, output, offset, length);
                start = 0;
                end = 0;
            }
            else
            {
                System.Array.Copy(buffer_, start, output, offset, length);
                start += length;
            }
            return length;
        }

        /// <summary>
        /// Convert internal buffer to byte array.
        /// Buffer is empty on completion
        /// </summary>
        /// <returns>
        /// The internal buffer contents converted to a byte array.
        /// </returns>
        public byte[] ToByteArray()
        {
            byte[] result = new byte[end - start];
            System.Array.Copy(buffer_, start, result, 0, result.Length);
            start = 0;
            end = 0;
            return result;
        }
    }
}

namespace ICSharpCode.SharpZipLib
{
    using System;

#if !NETCF_1_0 && !NETCF_2_0
    using System.Runtime.Serialization;
#endif

    /// <summary>
    /// SharpZipBaseException is the base exception class for the SharpZipLibrary.
    /// All library exceptions are derived from this.
    /// </summary>
    /// <remarks>NOTE: Not all exceptions thrown will be derived from this class.
    /// A variety of other exceptions are possible for example <see cref="ArgumentNullException"></see></remarks>
#if !NETCF_1_0 && !NETCF_2_0
    [Serializable]
#endif
    public class SharpZipBaseException : ApplicationException
    {
#if !NETCF_1_0 && !NETCF_2_0
        /// <summary>
        /// Deserialization constructor 
        /// </summary>
        /// <param name="info"><see cref="System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
        /// <param name="context"><see cref="StreamingContext"/> for this constructor</param>
        protected SharpZipBaseException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class.
        /// </summary>
        public SharpZipBaseException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class with a specified error message.
        /// </summary>
        /// <param name="message">A message describing the exception.</param>
        public SharpZipBaseException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">A message describing the exception.</param>
        /// <param name="innerException">The inner exception</param>
        public SharpZipBaseException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Bzip2 checksum algorithm
    /// </summary>
    public class StrangeCRC : IChecksum
    {
        readonly static uint[] crc32Table = {
            0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
            0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
            0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
            0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
            0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
            0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
            0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
            0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
            0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
            0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
            0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
            0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
            0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
            0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
            0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
            0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
            0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
            0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
            0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
            0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
            0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
            0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
            0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
            0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
            0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
            0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
            0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
            0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
            0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
            0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
            0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
            0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
            0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
            0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
            0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
            0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
            0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
            0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
            0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
            0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
            0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
            0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
            0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
            0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
            0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
            0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
            0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
            0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
            0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
            0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
            0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
            0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
            0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
            0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
            0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
            0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
            0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
            0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
            0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
            0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
            0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
            0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
            0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
            0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
        };

        int globalCrc;

        /// <summary>
        /// Initialise a default instance of <see cref="StrangeCRC"></see>
        /// </summary>	
        public StrangeCRC()
        {
            Reset();
        }

        /// <summary>
        /// Reset the state of Crc.
        /// </summary>
        public void Reset()
        {
            globalCrc = -1;
        }

        /// <summary>
        /// Get the current Crc value.
        /// </summary>
        public long Value
        {
            get
            {
                return ~globalCrc;
            }
        }

        /// <summary>
        /// Update the Crc value.
        /// </summary>
        /// <param name="value">data update is based on</param>
        public void Update(int value)
        {
            int temp = (globalCrc >> 24) ^ value;
            if (temp < 0)
            {
                temp = 256 + temp;
            }
            globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table[temp]));
        }

        /// <summary>
        /// Update Crc based on a block of data
        /// </summary>
        /// <param name="buffer">The buffer containing data to update the crc with.</param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Update Crc based on a portion of a block of data
        /// </summary>
        /// <param name="buffer">block of data</param>
        /// <param name="offset">index of first byte to use</param>
        /// <param name="count">number of bytes to use</param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "cannot be less than zero");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "cannot be less than zero");
#endif
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            for (int i = 0; i < count; ++i)
            {
                Update(buffer[offset++]);
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    /// <summary>
    /// This class allows us to retrieve a specified number of bits from
    /// the input buffer, as well as copy big byte blocks.
    ///
    /// It uses an int buffer to store up to 31 bits for direct
    /// manipulation.  This guarantees that we can get at least 16 bits,
    /// but we only need at most 15, so this is all safe.
    ///
    /// There are some optimizations in this class, for example, you must
    /// never peek more than 8 bits more than needed, and you must first
    /// peek bits before you may drop them.  This is not a general purpose
    /// class but optimized for the behaviour of the Inflater.
    ///
    /// authors of the original java version : John Leuner, Jochen Hoenicke
    /// </summary>
    public class StreamManipulator
    {
        #region Constructors
        /// <summary>
        /// Constructs a default StreamManipulator with all buffers empty
        /// </summary>
        public StreamManipulator()
        {
        }
        #endregion

        /// <summary>
        /// Get the next sequence of bits but don't increase input pointer.  bitCount must be
        /// less or equal 16 and if this call succeeds, you must drop
        /// at least n - 8 bits in the next call.
        /// </summary>
        /// <param name="bitCount">The number of bits to peek.</param>
        /// <returns>
        /// the value of the bits, or -1 if not enough bits available.  */
        /// </returns>
        public int PeekBits(int bitCount)
        {
            if (bitsInBuffer_ < bitCount)
            {
                if (windowStart_ == windowEnd_)
                {
                    return -1; // ok
                }
                buffer_ |= (uint)((window_[windowStart_++] & 0xff |
                                 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);
                bitsInBuffer_ += 16;
            }
            return (int)(buffer_ & ((1 << bitCount) - 1));
        }

        /// <summary>
        /// Drops the next n bits from the input.  You should have called PeekBits
        /// with a bigger or equal n before, to make sure that enough bits are in
        /// the bit buffer.
        /// </summary>
        /// <param name="bitCount">The number of bits to drop.</param>
        public void DropBits(int bitCount)
        {
            buffer_ >>= bitCount;
            bitsInBuffer_ -= bitCount;
        }

        /// <summary>
        /// Gets the next n bits and increases input pointer.  This is equivalent
        /// to <see cref="PeekBits"/> followed by <see cref="DropBits"/>, except for correct error handling.
        /// </summary>
        /// <param name="bitCount">The number of bits to retrieve.</param>
        /// <returns>
        /// the value of the bits, or -1 if not enough bits available.
        /// </returns>
        public int GetBits(int bitCount)
        {
            int bits = PeekBits(bitCount);
            if (bits >= 0)
            {
                DropBits(bitCount);
            }
            return bits;
        }

        /// <summary>
        /// Gets the number of bits available in the bit buffer.  This must be
        /// only called when a previous PeekBits() returned -1.
        /// </summary>
        /// <returns>
        /// the number of bits available.
        /// </returns>
        public int AvailableBits
        {
            get
            {
                return bitsInBuffer_;
            }
        }

        /// <summary>
        /// Gets the number of bytes available.
        /// </summary>
        /// <returns>
        /// The number of bytes available.
        /// </returns>
        public int AvailableBytes
        {
            get
            {
                return windowEnd_ - windowStart_ + (bitsInBuffer_ >> 3);
            }
        }

        /// <summary>
        /// Skips to the next byte boundary.
        /// </summary>
        public void SkipToByteBoundary()
        {
            buffer_ >>= (bitsInBuffer_ & 7);
            bitsInBuffer_ &= ~7;
        }

        /// <summary>
        /// Returns true when SetInput can be called
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return windowStart_ == windowEnd_;
            }
        }

        /// <summary>
        /// Copies bytes from input buffer to output buffer starting
        /// at output[offset].  You have to make sure, that the buffer is
        /// byte aligned.  If not enough bytes are available, copies fewer
        /// bytes.
        /// </summary>
        /// <param name="output">
        /// The buffer to copy bytes to.
        /// </param>
        /// <param name="offset">
        /// The offset in the buffer at which copying starts
        /// </param>
        /// <param name="length">
        /// The length to copy, 0 is allowed.
        /// </param>
        /// <returns>
        /// The number of bytes copied, 0 if no bytes were available.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Length is less than zero
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Bit buffer isnt byte aligned
        /// </exception>
        public int CopyBytes(byte[] output, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            if ((bitsInBuffer_ & 7) != 0)
            {
                // bits_in_buffer may only be 0 or a multiple of 8
                throw new InvalidOperationException("Bit buffer is not byte aligned!");
            }

            int count = 0;
            while ((bitsInBuffer_ > 0) && (length > 0))
            {
                output[offset++] = (byte)buffer_;
                buffer_ >>= 8;
                bitsInBuffer_ -= 8;
                length--;
                count++;
            }

            if (length == 0)
            {
                return count;
            }

            int avail = windowEnd_ - windowStart_;
            if (length > avail)
            {
                length = avail;
            }
            System.Array.Copy(window_, windowStart_, output, offset, length);
            windowStart_ += length;

            if (((windowStart_ - windowEnd_) & 1) != 0)
            {
                // We always want an even number of bytes in input, see peekBits
                buffer_ = (uint)(window_[windowStart_++] & 0xff);
                bitsInBuffer_ = 8;
            }
            return count + length;
        }

        /// <summary>
        /// Resets state and empties internal buffers
        /// </summary>
        public void Reset()
        {
            buffer_ = 0;
            windowStart_ = windowEnd_ = bitsInBuffer_ = 0;
        }

        /// <summary>
        /// Add more input for consumption.
        /// Only call when IsNeedingInput returns true
        /// </summary>
        /// <param name="buffer">data to be input</param>
        /// <param name="offset">offset of first byte of input</param>
        /// <param name="count">number of bytes of input to add.</param>
        public void SetInput(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if (windowStart_ < windowEnd_)
            {
                throw new InvalidOperationException("Old input was not completely processed");
            }

            int end = offset + count;

            // We want to throw an ArrayIndexOutOfBoundsException early.
            // Note the check also handles integer wrap around.
            if ((offset > end) || (end > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if ((count & 1) != 0)
            {
                // We always want an even number of bytes in input, see PeekBits
                buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);
                bitsInBuffer_ += 8;
            }

            window_ = buffer;
            windowStart_ = offset;
            windowEnd_ = end;
        }

        #region Instance Fields
        private byte[] window_;
        private int windowStart_;
        private int windowEnd_;

        private uint buffer_;
        private int bitsInBuffer_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.IO;
    /// <summary>
    /// Provides simple <see cref="Stream"/>" utilities.
    /// </summary>
    public sealed class StreamUtils
    {
        /// <summary>
        /// Read from a <see cref="Stream"/> ensuring all the required data is read.
        /// </summary>
        /// <param name="stream">The stream to read.</param>
        /// <param name="buffer">The buffer to fill.</param>
        /// <seealso cref="ReadFully(Stream,byte[],int,int)"/>
        static public void ReadFully(Stream stream, byte[] buffer)
        {
            ReadFully(stream, buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Read from a <see cref="Stream"/>" ensuring all the required data is read.
        /// </summary>
        /// <param name="stream">The stream to read data from.</param>
        /// <param name="buffer">The buffer to store data in.</param>
        /// <param name="offset">The offset at which to begin storing data.</param>
        /// <param name="count">The number of bytes of data to store.</param>
        /// <exception cref="ArgumentNullException">Required parameter is null</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="offset"/> and or <paramref name="count"/> are invalid.</exception>
        /// <exception cref="EndOfStreamException">End of stream is encountered before all the data has been read.</exception>
        static public void ReadFully(Stream stream, byte[] buffer, int offset, int count)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Offset can equal length when buffer and count are 0.
            if ((offset < 0) || (offset > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            if ((count < 0) || (offset + count > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            while (count > 0)
            {
                int readCount = stream.Read(buffer, offset, count);
                if (readCount <= 0)
                {
                    throw new EndOfStreamException();
                }
                offset += readCount;
                count -= readCount;
            }
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        static public void Copy(Stream source, Stream destination, byte[] buffer)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Ensure a reasonable size of buffer is used without being prohibitive.
            if (buffer.Length < 128)
            {
                throw new ArgumentException("Buffer is too small", "buffer");
            }

            bool copying = true;

            while (copying)
            {
                int bytesRead = source.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    destination.Write(buffer, 0, bytesRead);
                }
                else
                {
                    destination.Flush();
                    copying = false;
                }
            }
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        /// <param name="progressHandler">The <see cref="ProgressHandler">progress handler delegate</see> to use.</param>
        /// <param name="updateInterval">The minimum <see cref="TimeSpan"/> between progress updates.</param>
        /// <param name="sender">The source for this event.</param>
        /// <param name="name">The name to use with the event.</param>
        /// <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        static public void Copy(Stream source, Stream destination,
            byte[] buffer, ProgressHandler progressHandler, TimeSpan updateInterval, object sender, string name)
        {
            Copy(source, destination, buffer, progressHandler, updateInterval, sender, name, -1);
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        /// <param name="progressHandler">The <see cref="ProgressHandler">progress handler delegate</see> to use.</param>
        /// <param name="updateInterval">The minimum <see cref="TimeSpan"/> between progress updates.</param>
        /// <param name="sender">The source for this event.</param>
        /// <param name="name">The name to use with the event.</param>
        /// <param name="fixedTarget">A predetermined fixed target value to use with progress updates.
        /// If the value is negative the target is calculated by looking at the stream.</param>
        /// <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        static public void Copy(Stream source, Stream destination,
            byte[] buffer,
            ProgressHandler progressHandler, TimeSpan updateInterval,
            object sender, string name, long fixedTarget)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Ensure a reasonable size of buffer is used without being prohibitive.
            if (buffer.Length < 128)
            {
                throw new ArgumentException("Buffer is too small", "buffer");
            }

            if (progressHandler == null)
            {
                throw new ArgumentNullException("progressHandler");
            }

            bool copying = true;

            DateTime marker = DateTime.Now;
            long processed = 0;
            long target = 0;

            if (fixedTarget >= 0)
            {
                target = fixedTarget;
            }
            else if (source.CanSeek)
            {
                target = source.Length - source.Position;
            }

            // Always fire 0% progress..
            ProgressEventArgs args = new ProgressEventArgs(name, processed, target);
            progressHandler(sender, args);

            bool progressFired = true;

            while (copying)
            {
                int bytesRead = source.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    processed += bytesRead;
                    progressFired = false;
                    destination.Write(buffer, 0, bytesRead);
                }
                else
                {
                    destination.Flush();
                    copying = false;
                }

                if (DateTime.Now - marker > updateInterval)
                {
                    progressFired = true;
                    marker = DateTime.Now;
                    args = new ProgressEventArgs(name, processed, target);
                    progressHandler(sender, args);

                    copying = args.ContinueRunning;
                }
            }

            if (!progressFired)
            {
                args = new ProgressEventArgs(name, processed, target);
                progressHandler(sender, args);
            }
        }

        /// <summary>
        /// Initialise an instance of <see cref="StreamUtils"></see>
        /// </summary>
        private StreamUtils()
        {
            // Do nothing.
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;

    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// WindowsNameTransform transforms <see cref="ZipFile"/> names to windows compatible ones.
    /// </summary>
    public class WindowsNameTransform : INameTransform
    {
        /// <summary>
        /// Initialises a new instance of <see cref="WindowsNameTransform"/>
        /// </summary>
        /// <param name="baseDirectory"></param>
        public WindowsNameTransform(string baseDirectory)
        {
            if (baseDirectory == null)
            {
                throw new ArgumentNullException("baseDirectory", "Directory name is invalid");
            }

            BaseDirectory = baseDirectory;
        }

        /// <summary>
        /// Initialise a default instance of <see cref="WindowsNameTransform"/>
        /// </summary>
        public WindowsNameTransform()
        {
            // Do nothing.
        }

        /// <summary>
        /// Gets or sets a value containing the target directory to prefix values with.
        /// </summary>
        public string BaseDirectory
        {
            get { return _baseDirectory; }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                _baseDirectory = Path.GetFullPath(value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating wether paths on incoming values should be removed.
        /// </summary>
        public bool TrimIncomingPaths
        {
            get { return _trimIncomingPaths; }
            set { _trimIncomingPaths = value; }
        }

        /// <summary>
        /// Transform a Zip directory name to a windows directory name.
        /// </summary>
        /// <param name="name">The directory name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformDirectory(string name)
        {
            name = TransformFile(name);
            if (name.Length > 0)
            {
                while (name.EndsWith(@"\"))
                {
                    name = name.Remove(name.Length - 1, 1);
                }
            }
            else
            {
                throw new ZipException("Cannot have an empty directory name");
            }
            return name;
        }

        /// <summary>
        /// Transform a Zip format file name to a windows style one.
        /// </summary>
        /// <param name="name">The file name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformFile(string name)
        {
            if (name != null)
            {
                name = MakeValidName(name, _replacementChar);

                if (_trimIncomingPaths)
                {
                    name = Path.GetFileName(name);
                }

                // This may exceed windows length restrictions.
                // Combine will throw a PathTooLongException in that case.
                if (_baseDirectory != null)
                {
                    name = Path.Combine(_baseDirectory, name);
                }
            }
            else
            {
                name = string.Empty;
            }
            return name;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a windows filename as extracted from a Zip archive.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>The filename isnt a true windows path in some fundamental ways like no absolute paths, no rooted paths etc.</remarks>
        public static bool IsValidName(string name)
        {
            bool result =
                (name != null) &&
                (name.Length <= MaxPath) &&
                (string.Compare(name, MakeValidName(name, '_')) == 0)
                ;

            return result;
        }

        /// <summary>
        /// Initialise static class information.
        /// </summary>
        static WindowsNameTransform()
        {
            char[] invalidPathChars;

#if NET_1_0 || NET_1_1 || NETCF_1_0
			invalidPathChars = Path.InvalidPathChars;
#else
            invalidPathChars = Path.GetInvalidPathChars();
#endif
            int howMany = invalidPathChars.Length + 3;

            InvalidEntryChars = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryChars, 0, invalidPathChars.Length);
            InvalidEntryChars[howMany - 1] = '*';
            InvalidEntryChars[howMany - 2] = '?';
            InvalidEntryChars[howMany - 3] = ':';
        }

        /// <summary>
        /// Force a name to be valid by replacing invalid characters with a fixed value
        /// </summary>
        /// <param name="name">The name to make valid</param>
        /// <param name="replacement">The replacement character to use for any invalid characters.</param>
        /// <returns>Returns a valid name</returns>
        public static string MakeValidName(string name, char replacement)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            name = WindowsPathUtils.DropPathRoot(name.Replace("/", @"\"));

            // Drop any leading slashes.
            while ((name.Length > 0) && (name[0] == '\\'))
            {
                name = name.Remove(0, 1);
            }

            // Drop any trailing slashes.
            while ((name.Length > 0) && (name[name.Length - 1] == '\\'))
            {
                name = name.Remove(name.Length - 1, 1);
            }

            // Convert consecutive \\ characters to \
            int index = name.IndexOf(@"\\");
            while (index >= 0)
            {
                name = name.Remove(index, 1);
                index = name.IndexOf(@"\\");
            }

            // Convert any invalid characters using the replacement one.
            index = name.IndexOfAny(InvalidEntryChars);
            if (index >= 0)
            {
                StringBuilder builder = new StringBuilder(name);

                while (index >= 0)
                {
                    builder[index] = replacement;

                    if (index >= name.Length)
                    {
                        index = -1;
                    }
                    else
                    {
                        index = name.IndexOfAny(InvalidEntryChars, index + 1);
                    }
                }
                name = builder.ToString();
            }

            // Check for names greater than MaxPath characters.
            // TODO: Were is CLR version of MaxPath defined?  Can't find it in Environment.
            if (name.Length > MaxPath)
            {
                throw new PathTooLongException();
            }

            return name;
        }

        /// <summary>
        /// Gets or set the character to replace invalid characters during transformations.
        /// </summary>
        public char Replacement
        {
            get { return _replacementChar; }
            set
            {
                for (int i = 0; i < InvalidEntryChars.Length; ++i)
                {
                    if (InvalidEntryChars[i] == value)
                    {
                        throw new ArgumentException("invalid path character");
                    }
                }

                if ((value == '\\') || (value == '/'))
                {
                    throw new ArgumentException("invalid replacement character");
                }

                _replacementChar = value;
            }
        }

        /// <summary>
        ///  The maximum windows path name permitted.
        /// </summary>
        /// <remarks>This may not valid for all windows systems - CE?, etc but I cant find the equivalent in the CLR.</remarks>
        const int MaxPath = 260;

        #region Instance Fields
        string _baseDirectory;
        bool _trimIncomingPaths;
        char _replacementChar = '_';
        #endregion

        #region Class Fields
        static readonly char[] InvalidEntryChars;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// WindowsPathUtils provides simple utilities for handling windows paths.
    /// </summary>
    public abstract class WindowsPathUtils
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WindowsPathUtils"/> class.
        /// </summary>
        internal WindowsPathUtils()
        {
        }

        /// <summary>
        /// Remove any path root present in the path
        /// </summary>
        /// <param name="path">A <see cref="string"/> containing path information.</param>
        /// <returns>The path with the root removed if it was present; path otherwise.</returns>
        /// <remarks>Unlike the <see cref="System.IO.Path"/> class the path isnt otherwise checked for validity.</remarks>
        public static string DropPathRoot(string path)
        {
            string result = path;

            if ((path != null) && (path.Length > 0))
            {
                if ((path[0] == '\\') || (path[0] == '/'))
                {
                    // UNC name ?
                    if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))
                    {
                        int index = 2;
                        int elements = 2;

                        // Scan for two separate elements \\machine\share\restofpath
                        while ((index <= path.Length) &&
                            (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))
                        {
                            index++;
                        }

                        index++;

                        if (index < path.Length)
                        {
                            result = path.Substring(index);
                        }
                        else
                        {
                            result = "";
                        }
                    }
                }
                else if ((path.Length > 1) && (path[1] == ':'))
                {
                    int dropCount = 2;
                    if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))
                    {
                        dropCount = 3;
                    }
                    result = result.Remove(0, dropCount);
                }
            }
            return result;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.Text;
    using System.Threading;

#if NETCF_1_0 || NETCF_2_0
using System.Globalization;
#endif
    #region Enumerations

    /// <summary>
    /// Determines how entries are tested to see if they should use Zip64 extensions or not.
    /// </summary>
    public enum UseZip64
    {
        /// <summary>
        /// Zip64 will not be forced on entries during processing.
        /// </summary>
        /// <remarks>An entry can have this overridden if required <see cref="ZipEntry.ForceZip64"></see></remarks>
        Off,
        /// <summary>
        /// Zip64 should always be used.
        /// </summary>
        On,
        /// <summary>
        /// #ZipLib will determine use based on entry values when added to archive.
        /// </summary>
        Dynamic,
    }

    /// <summary>
    /// The kind of compression used for an entry in an archive
    /// </summary>
    public enum CompressionMethod
    {
        /// <summary>
        /// A direct copy of the file contents is held in the archive
        /// </summary>
        Stored = 0,

        /// <summary>
        /// Common Zip compression method using a sliding dictionary 
        /// of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
        /// </summary>
        Deflated = 8,

        /// <summary>
        /// An extension to deflate with a 64KB window. Not supported by #Zip currently
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// BZip2 compression. Not supported by #Zip.
        /// </summary>
        BZip2 = 11,

        /// <summary>
        /// WinZip special for AES encryption, Now supported by #Zip.
        /// </summary>
        WinZipAES = 99,

    }

    /// <summary>
    /// Identifies the encryption algorithm used for an entry
    /// </summary>
    public enum EncryptionAlgorithm
    {
        /// <summary>
        /// No encryption has been used.
        /// </summary>
        None = 0,
        /// <summary>
        /// Encrypted using PKZIP 2.0 or 'classic' encryption.
        /// </summary>
        PkzipClassic = 1,
        /// <summary>
        /// DES encryption has been used.
        /// </summary>
        Des = 0x6601,
        /// <summary>
        /// RCS encryption has been used for encryption.
        /// </summary>
        RC2 = 0x6602,
        /// <summary>
        /// Triple DES encryption with 168 bit keys has been used for this entry.
        /// </summary>
        TripleDes168 = 0x6603,
        /// <summary>
        /// Triple DES with 112 bit keys has been used for this entry.
        /// </summary>
        TripleDes112 = 0x6609,
        /// <summary>
        /// AES 128 has been used for encryption.
        /// </summary>
        Aes128 = 0x660e,
        /// <summary>
        /// AES 192 has been used for encryption.
        /// </summary>
        Aes192 = 0x660f,
        /// <summary>
        /// AES 256 has been used for encryption.
        /// </summary>
        Aes256 = 0x6610,
        /// <summary>
        /// RC2 corrected has been used for encryption.
        /// </summary>
        RC2Corrected = 0x6702,
        /// <summary>
        /// Blowfish has been used for encryption.
        /// </summary>
        Blowfish = 0x6720,
        /// <summary>
        /// Twofish has been used for encryption.
        /// </summary>
        Twofish = 0x6721,
        /// <summary>
        /// RC4 has been used for encryption.
        /// </summary>
        RC4 = 0x6801,
        /// <summary>
        /// An unknown algorithm has been used for encryption.
        /// </summary>
        Unknown = 0xffff
    }

    /// <summary>
    /// Defines the contents of the general bit flags field for an archive entry.
    /// </summary>
    [Flags]
    public enum GeneralBitFlags : int
    {
        /// <summary>
        /// Bit 0 if set indicates that the file is encrypted
        /// </summary>
        Encrypted = 0x0001,
        /// <summary>
        /// Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
        /// </summary>
        Method = 0x0006,
        /// <summary>
        /// Bit 3 if set indicates a trailing data desciptor is appended to the entry data
        /// </summary>
        Descriptor = 0x0008,
        /// <summary>
        /// Bit 4 is reserved for use with method 8 for enhanced deflation
        /// </summary>
        ReservedPKware4 = 0x0010,
        /// <summary>
        /// Bit 5 if set indicates the file contains Pkzip compressed patched data.
        /// Requires version 2.7 or greater.
        /// </summary>
        Patched = 0x0020,
        /// <summary>
        /// Bit 6 if set indicates strong encryption has been used for this entry.
        /// </summary>
        StrongEncryption = 0x0040,
        /// <summary>
        /// Bit 7 is currently unused
        /// </summary>
        Unused7 = 0x0080,
        /// <summary>
        /// Bit 8 is currently unused
        /// </summary>
        Unused8 = 0x0100,
        /// <summary>
        /// Bit 9 is currently unused
        /// </summary>
        Unused9 = 0x0200,
        /// <summary>
        /// Bit 10 is currently unused
        /// </summary>
        Unused10 = 0x0400,
        /// <summary>
        /// Bit 11 if set indicates the filename and 
        /// comment fields for this file must be encoded using UTF-8.
        /// </summary>
        UnicodeText = 0x0800,
        /// <summary>
        /// Bit 12 is documented as being reserved by PKware for enhanced compression.
        /// </summary>
        EnhancedCompress = 0x1000,
        /// <summary>
        /// Bit 13 if set indicates that values in the local header are masked to hide
        /// their actual values, and the central directory is encrypted.
        /// </summary>
        /// <remarks>
        /// Used when encrypting the central directory contents.
        /// </remarks>
        HeaderMasked = 0x2000,
        /// <summary>
        /// Bit 14 is documented as being reserved for use by PKware
        /// </summary>
        ReservedPkware14 = 0x4000,
        /// <summary>
        /// Bit 15 is documented as being reserved for use by PKware
        /// </summary>
        ReservedPkware15 = 0x8000
    }

    #endregion

    /// <summary>
    /// This class contains constants used for Zip format files
    /// </summary>
    public sealed class ZipConstants
    {
        #region Versions
        /// <summary>
        /// The version made by field for entries in the central header when created by this library
        /// </summary>
        /// <remarks>
        /// This is also the Zip version for the library when comparing against the version required to extract
        /// for an entry.  See <see cref="ZipEntry.CanDecompress"/>.
        /// </remarks>
        public const int VersionMadeBy = 51; // was 45 before AES

        /// <summary>
        /// The version made by field for entries in the central header when created by this library
        /// </summary>
        /// <remarks>
        /// This is also the Zip version for the library when comparing against the version required to extract
        /// for an entry.  See <see cref="ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
        /// </remarks>
        [Obsolete("Use VersionMadeBy instead")]
        public const int VERSION_MADE_BY = 51;

        /// <summary>
        /// The minimum version required to support strong encryption
        /// </summary>
        public const int VersionStrongEncryption = 50;

        /// <summary>
        /// The minimum version required to support strong encryption
        /// </summary>
        [Obsolete("Use VersionStrongEncryption instead")]
        public const int VERSION_STRONG_ENCRYPTION = 50;

        /// <summary>
        /// Version indicating AES encryption
        /// </summary>
        public const int VERSION_AES = 51;

        /// <summary>
        /// The version required for Zip64 extensions (4.5 or higher)
        /// </summary>
        public const int VersionZip64 = 45;
        #endregion

        #region Header Sizes
        /// <summary>
        /// Size of local entry header (excluding variable length fields at end)
        /// </summary>
        public const int LocalHeaderBaseSize = 30;

        /// <summary>
        /// Size of local entry header (excluding variable length fields at end)
        /// </summary>
        [Obsolete("Use LocalHeaderBaseSize instead")]
        public const int LOCHDR = 30;

        /// <summary>
        /// Size of Zip64 data descriptor
        /// </summary>
        public const int Zip64DataDescriptorSize = 24;

        /// <summary>
        /// Size of data descriptor
        /// </summary>
        public const int DataDescriptorSize = 16;

        /// <summary>
        /// Size of data descriptor
        /// </summary>
        [Obsolete("Use DataDescriptorSize instead")]
        public const int EXTHDR = 16;

        /// <summary>
        /// Size of central header entry (excluding variable fields)
        /// </summary>
        public const int CentralHeaderBaseSize = 46;

        /// <summary>
        /// Size of central header entry
        /// </summary>
        [Obsolete("Use CentralHeaderBaseSize instead")]
        public const int CENHDR = 46;

        /// <summary>
        /// Size of end of central record (excluding variable fields)
        /// </summary>
        public const int EndOfCentralRecordBaseSize = 22;

        /// <summary>
        /// Size of end of central record (excluding variable fields)
        /// </summary>
        [Obsolete("Use EndOfCentralRecordBaseSize instead")]
        public const int ENDHDR = 22;

        /// <summary>
        /// Size of 'classic' cryptographic header stored before any entry data
        /// </summary>
        public const int CryptoHeaderSize = 12;

        /// <summary>
        /// Size of cryptographic header stored before entry data
        /// </summary>
        [Obsolete("Use CryptoHeaderSize instead")]
        public const int CRYPTO_HEADER_SIZE = 12;
        #endregion

        #region Header Signatures

        /// <summary>
        /// Signature for local entry header
        /// </summary>
        public const int LocalHeaderSignature = 'P' | ('K' << 8) | (3 << 16) | (4 << 24);

        /// <summary>
        /// Signature for local entry header
        /// </summary>
        [Obsolete("Use LocalHeaderSignature instead")]
        public const int LOCSIG = 'P' | ('K' << 8) | (3 << 16) | (4 << 24);

        /// <summary>
        /// Signature for spanning entry
        /// </summary>
        public const int SpanningSignature = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for spanning entry
        /// </summary>
        [Obsolete("Use SpanningSignature instead")]
        public const int SPANNINGSIG = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for temporary spanning entry
        /// </summary>
        public const int SpanningTempSignature = 'P' | ('K' << 8) | ('0' << 16) | ('0' << 24);

        /// <summary>
        /// Signature for temporary spanning entry
        /// </summary>
        [Obsolete("Use SpanningTempSignature instead")]
        public const int SPANTEMPSIG = 'P' | ('K' << 8) | ('0' << 16) | ('0' << 24);

        /// <summary>
        /// Signature for data descriptor
        /// </summary>
        /// <remarks>
        /// This is only used where the length, Crc, or compressed size isnt known when the
        /// entry is created and the output stream doesnt support seeking.
        /// The local entry cannot be 'patched' with the correct values in this case
        /// so the values are recorded after the data prefixed by this header, as well as in the central directory.
        /// </remarks>
        public const int DataDescriptorSignature = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for data descriptor
        /// </summary>
        /// <remarks>
        /// This is only used where the length, Crc, or compressed size isnt known when the
        /// entry is created and the output stream doesnt support seeking.
        /// The local entry cannot be 'patched' with the correct values in this case
        /// so the values are recorded after the data prefixed by this header, as well as in the central directory.
        /// </remarks>
        [Obsolete("Use DataDescriptorSignature instead")]
        public const int EXTSIG = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for central header
        /// </summary>
        [Obsolete("Use CentralHeaderSignature instead")]
        public const int CENSIG = 'P' | ('K' << 8) | (1 << 16) | (2 << 24);

        /// <summary>
        /// Signature for central header
        /// </summary>
        public const int CentralHeaderSignature = 'P' | ('K' << 8) | (1 << 16) | (2 << 24);

        /// <summary>
        /// Signature for Zip64 central file header
        /// </summary>
        public const int Zip64CentralFileHeaderSignature = 'P' | ('K' << 8) | (6 << 16) | (6 << 24);

        /// <summary>
        /// Signature for Zip64 central file header
        /// </summary>
        [Obsolete("Use Zip64CentralFileHeaderSignature instead")]
        public const int CENSIG64 = 'P' | ('K' << 8) | (6 << 16) | (6 << 24);

        /// <summary>
        /// Signature for Zip64 central directory locator
        /// </summary>
        public const int Zip64CentralDirLocatorSignature = 'P' | ('K' << 8) | (6 << 16) | (7 << 24);

        /// <summary>
        /// Signature for archive extra data signature (were headers are encrypted).
        /// </summary>
        public const int ArchiveExtraDataSignature = 'P' | ('K' << 8) | (6 << 16) | (7 << 24);

        /// <summary>
        /// Central header digitial signature
        /// </summary>
        public const int CentralHeaderDigitalSignature = 'P' | ('K' << 8) | (5 << 16) | (5 << 24);

        /// <summary>
        /// Central header digitial signature
        /// </summary>
        [Obsolete("Use CentralHeaderDigitalSignaure instead")]
        public const int CENDIGITALSIG = 'P' | ('K' << 8) | (5 << 16) | (5 << 24);

        /// <summary>
        /// End of central directory record signature
        /// </summary>
        public const int EndOfCentralDirectorySignature = 'P' | ('K' << 8) | (5 << 16) | (6 << 24);

        /// <summary>
        /// End of central directory record signature
        /// </summary>
        [Obsolete("Use EndOfCentralDirectorySignature instead")]
        public const int ENDSIG = 'P' | ('K' << 8) | (5 << 16) | (6 << 24);
        #endregion

#if NETCF_1_0 || NETCF_2_0
		// This isnt so great but is better than nothing.
        // Trying to work out an appropriate OEM code page would be good.
        // 850 is a good default for english speakers particularly in Europe.
		static int defaultCodePage = CultureInfo.CurrentCulture.TextInfo.ANSICodePage;
#else
        static int defaultCodePage = Thread.CurrentThread.CurrentCulture.TextInfo.OEMCodePage;
#endif

        /// <summary>
        /// Default encoding used for string conversion.  0 gives the default system OEM code page.
        /// Dont use unicode encodings if you want to be Zip compatible!
        /// Using the default code page isnt the full solution neccessarily
        /// there are many variable factors, codepage 850 is often a good choice for
        /// European users, however be careful about compatability.
        /// </summary>
        public static int DefaultCodePage
        {
            get
            {
                return defaultCodePage;
            }
            set
            {
                defaultCodePage = value;
            }
        }

        /// <summary>
        /// Convert a portion of a byte array to a string.
        /// </summary>		
        /// <param name="data">
        /// Data to convert to string
        /// </param>
        /// <param name="count">
        /// Number of bytes to convert starting from index 0
        /// </param>
        /// <returns>
        /// data[0]..data[length - 1] converted to a string
        /// </returns>
        public static string ConvertToString(byte[] data, int count)
        {
            if (data == null)
            {
                return string.Empty;
            }

            return Encoding.GetEncoding(DefaultCodePage).GetString(data, 0, count);
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToString(byte[] data)
        {
            if (data == null)
            {
                return string.Empty;
            }
            return ConvertToString(data, data.Length);
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="flags">The applicable general purpose bits flags</param>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <param name="count">The number of bytes to convert.</param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToStringExt(int flags, byte[] data, int count)
        {
            if (data == null)
            {
                return string.Empty;
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetString(data, 0, count);
            }
            else
            {
                return ConvertToString(data, count);
            }
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <param name="flags">The applicable general purpose bits flags</param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToStringExt(int flags, byte[] data)
        {
            if (data == null)
            {
                return string.Empty;
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetString(data, 0, data.Length);
            }
            else
            {
                return ConvertToString(data, data.Length);
            }
        }

        /// <summary>
        /// Convert a string to a byte array
        /// </summary>
        /// <param name="str">
        /// String to convert to an array
        /// </param>
        /// <returns>Converted array</returns>
        public static byte[] ConvertToArray(string str)
        {
            if (str == null)
            {
                return new byte[0];
            }

            return Encoding.GetEncoding(DefaultCodePage).GetBytes(str);
        }

        /// <summary>
        /// Convert a string to a byte array
        /// </summary>
        /// <param name="flags">The applicable <see cref="GeneralBitFlags">general purpose bits flags</see></param>
        /// <param name="str">
        /// String to convert to an array
        /// </param>
        /// <returns>Converted array</returns>
        public static byte[] ConvertToArray(int flags, string str)
        {
            if (str == null)
            {
                return new byte[0];
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetBytes(str);
            }
            else
            {
                return ConvertToArray(str);
            }
        }


        /// <summary>
        /// Initialise default instance of <see cref="ZipConstants">ZipConstants</see>
        /// </summary>
        /// <remarks>
        /// Private to prevent instances being created.
        /// </remarks>
        ZipConstants()
        {
            // Do nothing
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    /// <summary>
    /// Defines known values for the <see cref="HostSystemID"/> property.
    /// </summary>
    public enum HostSystemID
    {
        /// <summary>
        /// Host system = MSDOS
        /// </summary>
        Msdos = 0,
        /// <summary>
        /// Host system = Amiga
        /// </summary>
        Amiga = 1,
        /// <summary>
        /// Host system = Open VMS
        /// </summary>
        OpenVms = 2,
        /// <summary>
        /// Host system = Unix
        /// </summary>
        Unix = 3,
        /// <summary>
        /// Host system = VMCms
        /// </summary>
        VMCms = 4,
        /// <summary>
        /// Host system = Atari ST
        /// </summary>
        AtariST = 5,
        /// <summary>
        /// Host system = OS2
        /// </summary>
        OS2 = 6,
        /// <summary>
        /// Host system = Macintosh
        /// </summary>
        Macintosh = 7,
        /// <summary>
        /// Host system = ZSystem
        /// </summary>
        ZSystem = 8,
        /// <summary>
        /// Host system = Cpm
        /// </summary>
        Cpm = 9,
        /// <summary>
        /// Host system = Windows NT
        /// </summary>
        WindowsNT = 10,
        /// <summary>
        /// Host system = MVS
        /// </summary>
        MVS = 11,
        /// <summary>
        /// Host system = VSE
        /// </summary>
        Vse = 12,
        /// <summary>
        /// Host system = Acorn RISC
        /// </summary>
        AcornRisc = 13,
        /// <summary>
        /// Host system = VFAT
        /// </summary>
        Vfat = 14,
        /// <summary>
        /// Host system = Alternate MVS
        /// </summary>
        AlternateMvs = 15,
        /// <summary>
        /// Host system = BEOS
        /// </summary>
        BeOS = 16,
        /// <summary>
        /// Host system = Tandem
        /// </summary>
        Tandem = 17,
        /// <summary>
        /// Host system = OS400
        /// </summary>
        OS400 = 18,
        /// <summary>
        /// Host system = OSX
        /// </summary>
        OSX = 19,
        /// <summary>
        /// Host system = WinZIP AES
        /// </summary>
        WinZipAES = 99,
    }

    /// <summary>
    /// This class represents an entry in a zip archive.  This can be a file
    /// or a directory
    /// ZipFile and ZipInputStream will give you instances of this class as 
    /// information about the members in an archive.  ZipOutputStream
    /// uses an instance of this class when creating an entry in a Zip file.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    public class ZipEntry : ICloneable
    {
        [Flags]
        enum Known : byte
        {
            None = 0,
            Size = 0x01,
            CompressedSize = 0x02,
            Crc = 0x04,
            Time = 0x08,
            ExternalAttributes = 0x10,
        }

        #region Constructors
        /// <summary>
        /// Creates a zip entry with the given name.
        /// </summary>
        /// <param name="name">
        /// The name for this entry. Can include directory components.
        /// The convention for names is 'unix' style paths with relative names only.
        /// There are with no device names and path elements are separated by '/' characters.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        public ZipEntry(string name)
            : this(name, 0, ZipConstants.VersionMadeBy, CompressionMethod.Deflated)
        {
        }

        /// <summary>
        /// Creates a zip entry with the given name and version required to extract
        /// </summary>
        /// <param name="name">
        /// The name for this entry. Can include directory components.
        /// The convention for names is 'unix'  style paths with no device names and 
        /// path elements separated by '/' characters.  This is not enforced see <see cref="CleanName(string)">CleanName</see>
        /// on how to ensure names are valid if this is desired.
        /// </param>
        /// <param name="versionRequiredToExtract">
        /// The minimum 'feature version' required this entry
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        internal ZipEntry(string name, int versionRequiredToExtract)
            : this(name, versionRequiredToExtract, ZipConstants.VersionMadeBy,
            CompressionMethod.Deflated)
        {
        }

        /// <summary>
        /// Initializes an entry with the given name and made by information
        /// </summary>
        /// <param name="name">Name for this entry</param>
        /// <param name="madeByInfo">Version and HostSystem Information</param>
        /// <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
        /// <param name="method">Compression method for this entry.</param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// versionRequiredToExtract should be 0 (auto-calculate) or > 10
        /// </exception>
        /// <remarks>
        /// This constructor is used by the ZipFile class when reading from the central header
        /// It is not generally useful, use the constructor specifying the name only.
        /// </remarks>
        internal ZipEntry(string name, int versionRequiredToExtract, int madeByInfo,
            CompressionMethod method)
        {
            if (name == null)
            {
                throw new System.ArgumentNullException("name");
            }

            if (name.Length > 0xffff)
            {
                throw new ArgumentException("Name is too long", "name");
            }

            if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10))
            {
                throw new ArgumentOutOfRangeException("versionRequiredToExtract");
            }

            this.DateTime = System.DateTime.Now;
            this.name = name;
            this.versionMadeBy = (ushort)madeByInfo;
            this.versionToExtract = (ushort)versionRequiredToExtract;
            this.method = method;
        }

        /// <summary>
        /// Creates a deep copy of the given zip entry.
        /// </summary>
        /// <param name="entry">
        /// The entry to copy.
        /// </param>
        [Obsolete("Use Clone instead")]
        public ZipEntry(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            known = entry.known;
            name = entry.name;
            size = entry.size;
            compressedSize = entry.compressedSize;
            crc = entry.crc;
            dosTime = entry.dosTime;
            method = entry.method;
            comment = entry.comment;
            versionToExtract = entry.versionToExtract;
            versionMadeBy = entry.versionMadeBy;
            externalFileAttributes = entry.externalFileAttributes;
            flags = entry.flags;

            zipFileIndex = entry.zipFileIndex;
            offset = entry.offset;

            forceZip64_ = entry.forceZip64_;

            if (entry.extra != null)
            {
                extra = new byte[entry.extra.Length];
                Array.Copy(entry.extra, 0, extra, 0, entry.extra.Length);
            }
        }

        #endregion

        /// <summary>
        /// Get a value indicating wether the entry has a CRC value available.
        /// </summary>
        public bool HasCrc
        {
            get
            {
                return (known & Known.Crc) != 0;
            }
        }

        /// <summary>
        /// Get/Set flag indicating if entry is encrypted.
        /// A simple helper routine to aid interpretation of <see cref="Flags">flags</see>
        /// </summary>
        /// <remarks>This is an assistant that interprets the <see cref="Flags">flags</see> property.</remarks>
        public bool IsCrypted
        {
            get
            {
                return (flags & 1) != 0;
            }
            set
            {
                if (value)
                {
                    flags |= 1;
                }
                else
                {
                    flags &= ~1;
                }
            }
        }

        /// <summary>
        /// Get / set a flag indicating wether entry name and comment text are
        /// encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
        /// </summary>
        /// <remarks>This is an assistant that interprets the <see cref="Flags">flags</see> property.</remarks>
        public bool IsUnicodeText
        {
            get
            {
                return (flags & (int)GeneralBitFlags.UnicodeText) != 0;
            }
            set
            {
                if (value)
                {
                    flags |= (int)GeneralBitFlags.UnicodeText;
                }
                else
                {
                    flags &= ~(int)GeneralBitFlags.UnicodeText;
                }
            }
        }

        /// <summary>
        /// Value used during password checking for PKZIP 2.0 / 'classic' encryption.
        /// </summary>
        internal byte CryptoCheckValue
        {
            get
            {
                return cryptoCheckValue_;
            }

            set
            {
                cryptoCheckValue_ = value;
            }
        }

        /// <summary>
        /// Get/Set general purpose bit flag for entry
        /// </summary>
        /// <remarks>
        /// General purpose bit flag<br/>
        /// <br/>
        /// Bit 0: If set, indicates the file is encrypted<br/>
        /// Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
        /// Imploding:<br/>
        /// Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
        /// Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
        /// <br/>
        /// Deflating:<br/>
        ///   Bit 2    Bit 1<br/>
        ///     0        0       Normal compression was used<br/>
        ///     0        1       Maximum compression was used<br/>
        ///     1        0       Fast compression was used<br/>
        ///     1        1       Super fast compression was used<br/>
        /// <br/>
        /// Bit 3: If set, the fields crc-32, compressed size
        /// and uncompressed size are were not able to be written during zip file creation
        /// The correct values are held in a data descriptor immediately following the compressed data. <br/>
        /// Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
        /// Bit 5: If set indicates the file contains compressed patch data<br/>
        /// Bit 6: If set indicates strong encryption was used.<br/>
        /// Bit 7-10: Unused or reserved<br/>
        /// Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
        /// Bit 12-15: Unused or reserved<br/>
        /// </remarks>
        /// <seealso cref="IsUnicodeText"></seealso>
        /// <seealso cref="IsCrypted"></seealso>
        public int Flags
        {
            get
            {
                return flags;
            }
            set
            {
                flags = value;
            }
        }

        /// <summary>
        /// Get/Set index of this entry in Zip file
        /// </summary>
        /// <remarks>This is only valid when the entry is part of a <see cref="ZipFile"></see></remarks>
        public long ZipFileIndex
        {
            get
            {
                return zipFileIndex;
            }
            set
            {
                zipFileIndex = value;
            }
        }

        /// <summary>
        /// Get/set offset for use in central header
        /// </summary>
        public long Offset
        {
            get
            {
                return offset;
            }
            set
            {
                offset = value;
            }
        }

        /// <summary>
        /// Get/Set external file attributes as an integer.
        /// The values of this are operating system dependant see
        /// <see cref="HostSystem">HostSystem</see> for details
        /// </summary>
        public int ExternalFileAttributes
        {
            get
            {
                if ((known & Known.ExternalAttributes) == 0)
                {
                    return -1;
                }
                else
                {
                    return externalFileAttributes;
                }
            }

            set
            {
                externalFileAttributes = value;
                known |= Known.ExternalAttributes;
            }
        }

        /// <summary>
        /// Get the version made by for this entry or zero if unknown.
        /// The value / 10 indicates the major version number, and 
        /// the value mod 10 is the minor version number
        /// </summary>
        public int VersionMadeBy
        {
            get
            {
                return (versionMadeBy & 0xff);
            }
        }

        /// <summary>
        /// Get a value indicating this entry is for a DOS/Windows system.
        /// </summary>
        public bool IsDOSEntry
        {
            get
            {
                return ((HostSystem == (int)HostSystemID.Msdos) ||
                    (HostSystem == (int)HostSystemID.WindowsNT));
            }
        }

        /// <summary>
        /// Test the external attributes for this <see cref="ZipEntry"/> to
        /// see if the external attributes are Dos based (including WINNT and variants)
        /// and match the values
        /// </summary>
        /// <param name="attributes">The attributes to test.</param>
        /// <returns>Returns true if the external attributes are known to be DOS/Windows 
        /// based and have the same attributes set as the value passed.</returns>
        bool HasDosAttributes(int attributes)
        {
            bool result = false;
            if ((known & Known.ExternalAttributes) != 0)
            {
                if (((HostSystem == (int)HostSystemID.Msdos) ||
                    (HostSystem == (int)HostSystemID.WindowsNT)) &&
                    (ExternalFileAttributes & attributes) == attributes)
                {
                    result = true;
                }
            }
            return result;
        }

        /// <summary>
        /// Gets the compatability information for the <see cref="ExternalFileAttributes">external file attribute</see>
        /// If the external file attributes are compatible with MS-DOS and can be read
        /// by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
        /// will be non-zero and identify the host system on which the attributes are compatible.
        /// </summary>
        /// 		
        /// <remarks>
        /// The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
        /// misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
        /// to obtain up to date and correct information.  The modified appnote by the infozip group is
        /// particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
        /// <list type="table">
        /// <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
        /// <item>1 - Amiga</item>
        /// <item>2 - OpenVMS</item>
        /// <item>3 - Unix</item>
        /// <item>4 - VM/CMS</item>
        /// <item>5 - Atari ST</item>
        /// <item>6 - OS/2 HPFS</item>
        /// <item>7 - Macintosh</item>
        /// <item>8 - Z-System</item>
        /// <item>9 - CP/M</item>
        /// <item>10 - Windows NTFS</item>
        /// <item>11 - MVS (OS/390 - Z/OS)</item>
        /// <item>12 - VSE</item>
        /// <item>13 - Acorn Risc</item>
        /// <item>14 - VFAT</item>
        /// <item>15 - Alternate MVS</item>
        /// <item>16 - BeOS</item>
        /// <item>17 - Tandem</item>
        /// <item>18 - OS/400</item>
        /// <item>19 - OS/X (Darwin)</item>
        /// <item>99 - WinZip AES</item>
        /// <item>remainder - unused</item>
        /// </list>
        /// </remarks>
        public int HostSystem
        {
            get
            {
                return (versionMadeBy >> 8) & 0xff;
            }

            set
            {
                versionMadeBy &= 0xff;
                versionMadeBy |= (ushort)((value & 0xff) << 8);
            }
        }

        /// <summary>
        /// Get minimum Zip feature version required to extract this entry
        /// </summary>		
        /// <remarks>
        /// Minimum features are defined as:<br/>
        /// 1.0 - Default value<br/>
        /// 1.1 - File is a volume label<br/>
        /// 2.0 - File is a folder/directory<br/>
        /// 2.0 - File is compressed using Deflate compression<br/>
        /// 2.0 - File is encrypted using traditional encryption<br/>
        /// 2.1 - File is compressed using Deflate64<br/>
        /// 2.5 - File is compressed using PKWARE DCL Implode<br/>
        /// 2.7 - File is a patch data set<br/>
        /// 4.5 - File uses Zip64 format extensions<br/>
        /// 4.6 - File is compressed using BZIP2 compression<br/>
        /// 5.0 - File is encrypted using DES<br/>
        /// 5.0 - File is encrypted using 3DES<br/>
        /// 5.0 - File is encrypted using original RC2 encryption<br/>
        /// 5.0 - File is encrypted using RC4 encryption<br/>
        /// 5.1 - File is encrypted using AES encryption<br/>
        /// 5.1 - File is encrypted using corrected RC2 encryption<br/>
        /// 5.1 - File is encrypted using corrected RC2-64 encryption<br/>
        /// 6.1 - File is encrypted using non-OAEP key wrapping<br/>
        /// 6.2 - Central directory encryption (not confirmed yet)<br/>
        /// 6.3 - File is compressed using LZMA<br/>
        /// 6.3 - File is compressed using PPMD+<br/>
        /// 6.3 - File is encrypted using Blowfish<br/>
        /// 6.3 - File is encrypted using Twofish<br/>
        /// </remarks>
        /// <seealso cref="CanDecompress"></seealso>
        public int Version
        {
            get
            {
                // Return recorded version if known.
                if (versionToExtract != 0)
                {
                    return versionToExtract;
                }
                else
                {
                    int result = 10;
                    if (AESKeySize > 0)
                    {
                        result = ZipConstants.VERSION_AES;			// Ver 5.1 = AES
                    }
                    else if (CentralHeaderRequiresZip64)
                    {
                        result = ZipConstants.VersionZip64;
                    }
                    else if (CompressionMethod.Deflated == method)
                    {
                        result = 20;
                    }
                    else if (IsDirectory == true)
                    {
                        result = 20;
                    }
                    else if (IsCrypted == true)
                    {
                        result = 20;
                    }
                    else if (HasDosAttributes(0x08))
                    {
                        result = 11;
                    }
                    return result;
                }
            }
        }

        /// <summary>
        /// Get a value indicating whether this entry can be decompressed by the library.
        /// </summary>
        /// <remarks>This is based on the <see cref="Version"></see> and 
        /// wether the <see cref="IsCompressionMethodSupported()">compression method</see> is supported.</remarks>
        public bool CanDecompress
        {
            get
            {
                return (Version <= ZipConstants.VersionMadeBy) &&
                    ((Version == 10) ||
                    (Version == 11) ||
                    (Version == 20) ||
                    (Version == 45) ||
                    (Version == 51)) &&
                    IsCompressionMethodSupported();
            }
        }

        /// <summary>
        /// Force this entry to be recorded using Zip64 extensions.
        /// </summary>
        public void ForceZip64()
        {
            forceZip64_ = true;
        }

        /// <summary>
        /// Get a value indicating wether Zip64 extensions were forced.
        /// </summary>
        /// <returns>A <see cref="bool"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        public bool IsZip64Forced()
        {
            return forceZip64_;
        }

        /// <summary>
        /// Gets a value indicating if the entry requires Zip64 extensions 
        /// to store the full entry values.
        /// </summary>
        /// <value>A <see cref="bool"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        public bool LocalHeaderRequiresZip64
        {
            get
            {
                bool result = forceZip64_;

                if (!result)
                {
                    ulong trueCompressedSize = compressedSize;

                    if ((versionToExtract == 0) && IsCrypted)
                    {
                        trueCompressedSize += ZipConstants.CryptoHeaderSize;
                    }

                    // TODO: A better estimation of the true limit based on compression overhead should be used
                    // to determine when an entry should use Zip64.
                    result =
                        ((this.size >= uint.MaxValue) || (trueCompressedSize >= uint.MaxValue)) &&
                        ((versionToExtract == 0) || (versionToExtract >= ZipConstants.VersionZip64));
                }

                return result;
            }
        }

        /// <summary>
        /// Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
        /// </summary>
        public bool CentralHeaderRequiresZip64
        {
            get
            {
                return LocalHeaderRequiresZip64 || (offset >= uint.MaxValue);
            }
        }

        /// <summary>
        /// Get/Set DosTime value.
        /// </summary>
        /// <remarks>
        /// The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
        /// </remarks>
        public long DosTime
        {
            get
            {
                if ((known & Known.Time) == 0)
                {
                    return 0;
                }
                else
                {
                    return dosTime;
                }
            }

            set
            {
                unchecked
                {
                    dosTime = (uint)value;
                }

                known |= Known.Time;
            }
        }

        /// <summary>
        /// Gets/Sets the time of last modification of the entry.
        /// </summary>
        /// <remarks>
        /// The <see cref="DosTime"></see> property is updated to match this as far as possible.
        /// </remarks>
        public DateTime DateTime
        {
            get
            {
                uint sec = Math.Min(59, 2 * (dosTime & 0x1f));
                uint min = Math.Min(59, (dosTime >> 5) & 0x3f);
                uint hrs = Math.Min(23, (dosTime >> 11) & 0x1f);
                uint mon = Math.Max(1, Math.Min(12, ((dosTime >> 21) & 0xf)));
                uint year = ((dosTime >> 25) & 0x7f) + 1980;
                int day = Math.Max(1, Math.Min(DateTime.DaysInMonth((int)year, (int)mon), (int)((dosTime >> 16) & 0x1f)));
                return new System.DateTime((int)year, (int)mon, day, (int)hrs, (int)min, (int)sec);
            }

            set
            {
                uint year = (uint)value.Year;
                uint month = (uint)value.Month;
                uint day = (uint)value.Day;
                uint hour = (uint)value.Hour;
                uint minute = (uint)value.Minute;
                uint second = (uint)value.Second;

                if (year < 1980)
                {
                    year = 1980;
                    month = 1;
                    day = 1;
                    hour = 0;
                    minute = 0;
                    second = 0;
                }
                else if (year > 2107)
                {
                    year = 2107;
                    month = 12;
                    day = 31;
                    hour = 23;
                    minute = 59;
                    second = 59;
                }

                DosTime = ((year - 1980) & 0x7f) << 25 |
                    (month << 21) |
                    (day << 16) |
                    (hour << 11) |
                    (minute << 5) |
                    (second >> 1);
            }
        }

        /// <summary>
        /// Returns the entry name.
        /// </summary>
        /// <remarks>
        /// The unix naming convention is followed.
        /// Path components in the entry should always separated by forward slashes ('/').
        /// Dos device names like C: should also be removed.
        /// See the <see cref="ZipNameTransform"/> class, or <see cref="CleanName(string)"/>
        ///</remarks>
        public string Name
        {
            get
            {
                return name;
            }
        }

        /// <summary>
        /// Gets/Sets the size of the uncompressed data.
        /// </summary>
        /// <returns>
        /// The size or -1 if unknown.
        /// </returns>
        /// <remarks>Setting the size before adding an entry to an archive can help
        /// avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        public long Size
        {
            get
            {
                return (known & Known.Size) != 0 ? (long)size : -1L;
            }
            set
            {
                this.size = (ulong)value;
                this.known |= Known.Size;
            }
        }

        /// <summary>
        /// Gets/Sets the size of the compressed data.
        /// </summary>
        /// <returns>
        /// The compressed entry size or -1 if unknown.
        /// </returns>
        public long CompressedSize
        {
            get
            {
                return (known & Known.CompressedSize) != 0 ? (long)compressedSize : -1L;
            }
            set
            {
                this.compressedSize = (ulong)value;
                this.known |= Known.CompressedSize;
            }
        }

        /// <summary>
        /// Gets/Sets the crc of the uncompressed data.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Crc is not in the range 0..0xffffffffL
        /// </exception>
        /// <returns>
        /// The crc value or -1 if unknown.
        /// </returns>
        public long Crc
        {
            get
            {
                return (known & Known.Crc) != 0 ? crc & 0xffffffffL : -1L;
            }
            set
            {
                if (((ulong)crc & 0xffffffff00000000L) != 0)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.crc = (uint)value;
                this.known |= Known.Crc;
            }
        }

        /// <summary>
        /// Gets/Sets the compression method. Only Deflated and Stored are supported.
        /// </summary>
        /// <returns>
        /// The compression method for this entry
        /// </returns>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated"/>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored"/>
        public CompressionMethod CompressionMethod
        {
            get
            {
                return method;
            }

            set
            {
                if (!IsCompressionMethodSupported(value))
                {
                    throw new NotSupportedException("Compression method not supported");
                }
                this.method = value;
            }
        }

        /// <summary>
        /// Gets the compression method for outputting to the local or central header.
        /// Returns same value as CompressionMethod except when AES encrypting, which
        /// places 99 in the method and places the real method in the extra data.
        /// </summary>
        internal CompressionMethod CompressionMethodForHeader
        {
            get
            {
                return (AESKeySize > 0) ? CompressionMethod.WinZipAES : method;
            }
        }

        /// <summary>
        /// Gets/Sets the extra data.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Extra data is longer than 64KB (0xffff) bytes.
        /// </exception>
        /// <returns>
        /// Extra data or null if not set.
        /// </returns>
        public byte[] ExtraData
        {

            get
            {
                // TODO: This is slightly safer but less efficient.  Think about wether it should change.
                //				return (byte[]) extra.Clone();
                return extra;
            }

            set
            {
                if (value == null)
                {
                    extra = null;
                }
                else
                {
                    if (value.Length > 0xffff)
                    {
                        throw new System.ArgumentOutOfRangeException("value");
                    }

                    extra = new byte[value.Length];
                    Array.Copy(value, 0, extra, 0, value.Length);
                }
            }
        }


#if !NET_1_1 && !NETCF_2_0
        /// <summary>
        /// For AES encrypted files returns or sets the number of bits of encryption (128, 192 or 256).
        /// When setting, only 0 (off), 128 or 256 is supported.
        /// </summary>
        public int AESKeySize
        {
            get
            {
                // the strength (1 or 3) is in the entry header
                switch (_aesEncryptionStrength)
                {
                    case 0: return 0;	// Not AES
                    case 1: return 128;
                    case 2: return 192; // Not used by WinZip
                    case 3: return 256;
                    default: throw new ZipException("Invalid AESEncryptionStrength " + _aesEncryptionStrength);
                }
            }
            set
            {
                switch (value)
                {
                    case 0: _aesEncryptionStrength = 0; break;
                    case 128: _aesEncryptionStrength = 1; break;
                    case 256: _aesEncryptionStrength = 3; break;
                    default: throw new ZipException("AESKeySize must be 0, 128 or 256: " + value);
                }
            }
        }

        /// <summary>
        /// AES Encryption strength for storage in extra data in entry header.
        /// 1 is 128 bit, 2 is 192 bit, 3 is 256 bit.
        /// </summary>
        internal byte AESEncryptionStrength
        {
            get
            {
                return (byte)_aesEncryptionStrength;
            }
        }
#else
		/// <summary>
		/// AES unsupported prior to .NET 2.0
		/// </summary>
		internal int AESKeySize;
#endif

        /// <summary>
        /// Returns the length of the salt, in bytes 
        /// </summary>
        internal int AESSaltLen
        {
            get
            {
                // Key size -> Salt length: 128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.
                return AESKeySize / 16;
            }
        }

        /// <summary>
        /// Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
        /// </summary>
        internal int AESOverheadSize
        {
            get
            {
                // File format:
                //   Bytes		Content
                // Variable		Salt value
                //     2		Password verification value
                // Variable		Encrypted file data
                //    10		Authentication code
                return 12 + AESSaltLen;
            }
        }

        /// <summary>
        /// Process extra data fields updating the entry based on the contents.
        /// </summary>
        /// <param name="localHeader">True if the extra data fields should be handled
        /// for a local header, rather than for a central header.
        /// </param>
        internal void ProcessExtraData(bool localHeader)
        {
            ZipExtraData extraData = new ZipExtraData(this.extra);

            if (extraData.Find(0x0001))
            {
                // Version required to extract is ignored here as some archivers dont set it correctly
                // in theory it should be version 45 or higher

                // The recorded size will change but remember that this is zip64.
                forceZip64_ = true;

                if (extraData.ValueLength < 4)
                {
                    throw new ZipException("Extra data extended Zip64 information length is invalid");
                }

                if (localHeader || (size == uint.MaxValue))
                {
                    size = (ulong)extraData.ReadLong();
                }

                if (localHeader || (compressedSize == uint.MaxValue))
                {
                    compressedSize = (ulong)extraData.ReadLong();
                }

                if (!localHeader && (offset == uint.MaxValue))
                {
                    offset = extraData.ReadLong();
                }

                // Disk number on which file starts is ignored
            }
            else
            {
                if (
                    ((versionToExtract & 0xff) >= ZipConstants.VersionZip64) &&
                    ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))
                )
                {
                    throw new ZipException("Zip64 Extended information required but is missing.");
                }
            }

            if (extraData.Find(10))
            {
                // No room for any tags.
                if (extraData.ValueLength < 4)
                {
                    throw new ZipException("NTFS Extra data invalid");
                }

                extraData.ReadInt(); // Reserved

                while (extraData.UnreadCount >= 4)
                {
                    int ntfsTag = extraData.ReadShort();
                    int ntfsLength = extraData.ReadShort();
                    if (ntfsTag == 1)
                    {
                        if (ntfsLength >= 24)
                        {
                            long lastModification = extraData.ReadLong();
                            long lastAccess = extraData.ReadLong();
                            long createTime = extraData.ReadLong();

                            DateTime = System.DateTime.FromFileTime(lastModification);
                        }
                        break;
                    }
                    else
                    {
                        // An unknown NTFS tag so simply skip it.
                        extraData.Skip(ntfsLength);
                    }
                }
            }
            else if (extraData.Find(0x5455))
            {
                int length = extraData.ValueLength;
                int flags = extraData.ReadByte();

                // Can include other times but these are ignored.  Length of data should
                // actually be 1 + 4 * no of bits in flags.
                if (((flags & 1) != 0) && (length >= 5))
                {
                    int iTime = extraData.ReadInt();

                    DateTime = (new System.DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }
            }
            if (method == CompressionMethod.WinZipAES)
            {
                ProcessAESExtraData(extraData);
            }
        }

        // For AES the method in the entry is 99, and the real compression method is in the extradata
        //
        private void ProcessAESExtraData(ZipExtraData extraData)
        {

#if !NET_1_1 && !NETCF_2_0
            if (extraData.Find(0x9901))
            {
                // Set version and flag for Zipfile.CreateAndInitDecryptionStream
                versionToExtract = ZipConstants.VERSION_AES;			// Ver 5.1 = AES see "Version" getter
                // Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream
                Flags = Flags | (int)GeneralBitFlags.StrongEncryption;
                //
                // Unpack AES extra data field see http://www.winzip.com/aes_info.htm
                int length = extraData.ValueLength;			// Data size currently 7
                if (length < 7)
                    throw new ZipException("AES Extra Data Length " + length + " invalid.");
                int ver = extraData.ReadShort();			// Version number (1=AE-1 2=AE-2)
                int vendorId = extraData.ReadShort();		// 2-character vendor ID 0x4541 = "AE"
                int encrStrength = extraData.ReadByte();	// encryption strength 1 = 128 2 = 192 3 = 256
                int actualCompress = extraData.ReadShort(); // The actual compression method used to compress the file
                _aesVer = ver;
                _aesEncryptionStrength = encrStrength;
                method = (CompressionMethod)actualCompress;
            }
            else
                throw new ZipException("AES Extra Data missing");
#else
				throw new ZipException("AES unsupported");
#endif
        }

        /// <summary>
        /// Gets/Sets the entry comment.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// If comment is longer than 0xffff.
        /// </exception>
        /// <returns>
        /// The comment or null if not set.
        /// </returns>
        /// <remarks>
        /// A comment is only available for entries when read via the <see cref="ZipFile"/> class.
        /// The <see cref="ZipInputStream"/> class doesnt have the comment data available.
        /// </remarks>
        public string Comment
        {
            get
            {
                return comment;
            }
            set
            {
                // This test is strictly incorrect as the length is in characters
                // while the storage limit is in bytes.
                // While the test is partially correct in that a comment of this length or greater 
                // is definitely invalid, shorter comments may also have an invalid length
                // where there are multi-byte characters
                // The full test is not possible here however as the code page to apply conversions with
                // isnt available.
                if ((value != null) && (value.Length > 0xffff))
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "cannot exceed 65535");
#endif
                }

                comment = value;
            }
        }

        /// <summary>
        /// Gets a value indicating if the entry is a directory.
        /// however.
        /// </summary>
        /// <remarks>
        /// A directory is determined by an entry name with a trailing slash '/'.
        /// The external file attributes can also indicate an entry is for a directory.
        /// Currently only dos/windows attributes are tested in this manner.
        /// The trailing slash convention should always be followed.
        /// </remarks>
        public bool IsDirectory
        {
            get
            {
                int nameLength = name.Length;
                bool result =
                    ((nameLength > 0) &&
                    ((name[nameLength - 1] == '/') || (name[nameLength - 1] == '\\'))) ||
                    HasDosAttributes(16)
                    ;
                return result;
            }
        }

        /// <summary>
        /// Get a value of true if the entry appears to be a file; false otherwise
        /// </summary>
        /// <remarks>
        /// This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
        /// For linux and others the result may be incorrect.
        /// </remarks>
        public bool IsFile
        {
            get
            {
                return !IsDirectory && !HasDosAttributes(8);
            }
        }

        /// <summary>
        /// Test entry to see if data can be extracted.
        /// </summary>
        /// <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        public bool IsCompressionMethodSupported()
        {
            return IsCompressionMethodSupported(CompressionMethod);
        }

        #region ICloneable Members
        /// <summary>
        /// Creates a copy of this zip entry.
        /// </summary>
        /// <returns>An <see cref="Object"/> that is a copy of the current instance.</returns>
        public object Clone()
        {
            ZipEntry result = (ZipEntry)this.MemberwiseClone();

            // Ensure extra data is unique if it exists.
            if (extra != null)
            {
                result.extra = new byte[extra.Length];
                Array.Copy(extra, 0, result.extra, 0, extra.Length);
            }

            return result;
        }

        #endregion

        /// <summary>
        /// Gets a string representation of this ZipEntry.
        /// </summary>
        /// <returns>A readable textual representation of this <see cref="ZipEntry"/></returns>
        public override string ToString()
        {
            return name;
        }

        /// <summary>
        /// Test a <see cref="CompressionMethod">compression method</see> to see if this library
        /// supports extracting data compressed with that method
        /// </summary>
        /// <param name="method">The compression method to test.</param>
        /// <returns>Returns true if the compression method is supported; false otherwise</returns>
        public static bool IsCompressionMethodSupported(CompressionMethod method)
        {
            return
                (method == CompressionMethod.Deflated) ||
                (method == CompressionMethod.Stored);
        }

        /// <summary>
        /// Cleans a name making it conform to Zip file conventions.
        /// Devices names ('c:\') and UNC share names ('\\server\share') are removed
        /// and forward slashes ('\') are converted to back slashes ('/').
        /// Names are made relative by trimming leading slashes which is compatible
        /// with the ZIP naming convention.
        /// </summary>
        /// <param name="name">The name to clean</param>
        /// <returns>The 'cleaned' name.</returns>
        /// <remarks>
        /// The <seealso cref="ZipNameTransform">Zip name transform</seealso> class is more flexible.
        /// </remarks>
        public static string CleanName(string name)
        {
            if (name == null)
            {
                return string.Empty;
            }

            if (Path.IsPathRooted(name) == true)
            {
                // NOTE:
                // for UNC names...  \\machine\share\zoom\beet.txt gives \zoom\beet.txt
                name = name.Substring(Path.GetPathRoot(name).Length);
            }

            name = name.Replace(@"\", "/");

            while ((name.Length > 0) && (name[0] == '/'))
            {
                name = name.Remove(0, 1);
            }
            return name;
        }

        #region Instance Fields
        Known known;
        int externalFileAttributes = -1;     // contains external attributes (O/S dependant)

        ushort versionMadeBy;					// Contains host system and version information
        // only relevant for central header entries

        string name;
        ulong size;
        ulong compressedSize;
        ushort versionToExtract;                // Version required to extract (library handles <= 2.0)
        uint crc;
        uint dosTime;

        CompressionMethod method = CompressionMethod.Deflated;
        byte[] extra;
        string comment;

        int flags;                             // general purpose bit flags

        long zipFileIndex = -1;                // used by ZipFile
        long offset;                           // used by ZipFile and ZipOutputStream

        bool forceZip64_;
        byte cryptoCheckValue_;
#if !NET_1_1 && !NETCF_2_0
        int _aesVer;							// Version number (2 = AE-2 ?). Assigned but not used.
        int _aesEncryptionStrength;				// Encryption strength 1 = 128 2 = 192 3 = 256
#endif
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;

    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// Basic implementation of <see cref="IEntryFactory"></see>
    /// </summary>
    public class ZipEntryFactory : IEntryFactory
    {
        #region Enumerations
        /// <summary>
        /// Defines the possible values to be used for the <see cref="ZipEntry.DateTime"/>.
        /// </summary>
        public enum TimeSetting
        {
            /// <summary>
            /// Use the recorded LastWriteTime value for the file.
            /// </summary>
            LastWriteTime,
            /// <summary>
            /// Use the recorded LastWriteTimeUtc value for the file
            /// </summary>
            LastWriteTimeUtc,
            /// <summary>
            /// Use the recorded CreateTime value for the file.
            /// </summary>
            CreateTime,
            /// <summary>
            /// Use the recorded CreateTimeUtc value for the file.
            /// </summary>
            CreateTimeUtc,
            /// <summary>
            /// Use the recorded LastAccessTime value for the file.
            /// </summary>
            LastAccessTime,
            /// <summary>
            /// Use the recorded LastAccessTimeUtc value for the file.
            /// </summary>
            LastAccessTimeUtc,
            /// <summary>
            /// Use a fixed value.
            /// </summary>
            /// <remarks>The actual <see cref="DateTime"/> value used can be
            /// specified via the <see cref="ZipEntryFactory(DateTime)"/> constructor or 
            /// using the <see cref="ZipEntryFactory(TimeSetting)"/> with the setting set
            /// to <see cref="TimeSetting.Fixed"/> which will use the <see cref="DateTime"/> when this class was constructed.
            /// The <see cref="FixedDateTime"/> property can also be used to set this value.</remarks>
            Fixed,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initialise a new instance of the <see cref="ZipEntryFactory"/> class.
        /// </summary>
        /// <remarks>A default <see cref="INameTransform"/>, and the LastWriteTime for files is used.</remarks>
        public ZipEntryFactory()
        {
            nameTransform_ = new ZipNameTransform();
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipEntryFactory"/> using the specified <see cref="TimeSetting"/>
        /// </summary>
        /// <param name="timeSetting">The <see cref="TimeSetting">time setting</see> to use when creating <see cref="ZipEntry">Zip entries</see>.</param>
        public ZipEntryFactory(TimeSetting timeSetting)
        {
            timeSetting_ = timeSetting;
            nameTransform_ = new ZipNameTransform();
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipEntryFactory"/> using the specified <see cref="DateTime"/>
        /// </summary>
        /// <param name="time">The time to set all <see cref="ZipEntry.DateTime"/> values to.</param>
        public ZipEntryFactory(DateTime time)
        {
            timeSetting_ = TimeSetting.Fixed;
            FixedDateTime = time;
            nameTransform_ = new ZipNameTransform();
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get / set the <see cref="INameTransform"/> to be used when creating new <see cref="ZipEntry"/> values.
        /// </summary>
        /// <remarks>
        /// Setting this property to null will cause a default <see cref="ZipNameTransform">name transform</see> to be used.
        /// </remarks>
        public INameTransform NameTransform
        {
            get { return nameTransform_; }
            set
            {
                if (value == null)
                {
                    nameTransform_ = new ZipNameTransform();
                }
                else
                {
                    nameTransform_ = value;
                }
            }
        }

        /// <summary>
        /// Get / set the <see cref="TimeSetting"/> in use.
        /// </summary>
        public TimeSetting Setting
        {
            get { return timeSetting_; }
            set { timeSetting_ = value; }
        }

        /// <summary>
        /// Get / set the <see cref="DateTime"/> value to use when <see cref="Setting"/> is set to <see cref="TimeSetting.Fixed"/>
        /// </summary>
        public DateTime FixedDateTime
        {
            get { return fixedDateTime_; }
            set
            {
                if (value.Year < 1970)
                {
                    throw new ArgumentException("Value is too old to be valid", "value");
                }
                fixedDateTime_ = value;
            }
        }

        /// <summary>
        /// A bitmask defining the attributes to be retrieved from the actual file.
        /// </summary>
        /// <remarks>The default is to get all possible attributes from the actual file.</remarks>
        public int GetAttributes
        {
            get { return getAttributes_; }
            set { getAttributes_ = value; }
        }

        /// <summary>
        /// A bitmask defining which attributes are to be set on.
        /// </summary>
        /// <remarks>By default no attributes are set on.</remarks>
        public int SetAttributes
        {
            get { return setAttributes_; }
            set { setAttributes_ = value; }
        }

        /// <summary>
        /// Get set a value indicating wether unidoce text should be set on.
        /// </summary>
        public bool IsUnicodeText
        {
            get { return isUnicodeText_; }
            set { isUnicodeText_ = value; }
        }

        #endregion

        #region IEntryFactory Members

        /// <summary>
        /// Make a new <see cref="ZipEntry"/> for a file.
        /// </summary>
        /// <param name="fileName">The name of the file to create a new entry for.</param>
        /// <returns>Returns a new <see cref="ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        public ZipEntry MakeFileEntry(string fileName)
        {
            return MakeFileEntry(fileName, true);
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"/> from a name.
        /// </summary>
        /// <param name="fileName">The name of the file to create a new entry for.</param>
        /// <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
        /// <returns>Returns a new <see cref="ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        public ZipEntry MakeFileEntry(string fileName, bool useFileSystem)
        {
            ZipEntry result = new ZipEntry(nameTransform_.TransformFile(fileName));
            result.IsUnicodeText = isUnicodeText_;

            int externalAttributes = 0;
            bool useAttributes = (setAttributes_ != 0);

            FileInfo fi = null;
            if (useFileSystem)
            {
                fi = new FileInfo(fileName);
            }

            if ((fi != null) && fi.Exists)
            {
                switch (timeSetting_)
                {
                    case TimeSetting.CreateTime:
                        result.DateTime = fi.CreationTime;
                        break;

                    case TimeSetting.CreateTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.CreationTime.ToUniversalTime();
#else
                        result.DateTime = fi.CreationTimeUtc;
#endif
                        break;

                    case TimeSetting.LastAccessTime:
                        result.DateTime = fi.LastAccessTime;
                        break;

                    case TimeSetting.LastAccessTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.LastAccessTime.ToUniversalTime();
#else
                        result.DateTime = fi.LastAccessTimeUtc;
#endif
                        break;

                    case TimeSetting.LastWriteTime:
                        result.DateTime = fi.LastWriteTime;
                        break;

                    case TimeSetting.LastWriteTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.LastWriteTime.ToUniversalTime();
#else
                        result.DateTime = fi.LastWriteTimeUtc;
#endif
                        break;

                    case TimeSetting.Fixed:
                        result.DateTime = fixedDateTime_;
                        break;

                    default:
                        throw new ZipException("Unhandled time setting in MakeFileEntry");
                }

                result.Size = fi.Length;

                useAttributes = true;
                externalAttributes = ((int)fi.Attributes & getAttributes_);
            }
            else
            {
                if (timeSetting_ == TimeSetting.Fixed)
                {
                    result.DateTime = fixedDateTime_;
                }
            }

            if (useAttributes)
            {
                externalAttributes |= setAttributes_;
                result.ExternalFileAttributes = externalAttributes;
            }

            return result;
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"></see> for a directory.
        /// </summary>
        /// <param name="directoryName">The raw untransformed name for the new directory</param>
        /// <returns>Returns a new <see cref="ZipEntry"></see> representing a directory.</returns>
        public ZipEntry MakeDirectoryEntry(string directoryName)
        {
            return MakeDirectoryEntry(directoryName, true);
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"></see> for a directory.
        /// </summary>
        /// <param name="directoryName">The raw untransformed name for the new directory</param>
        /// <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
        /// <returns>Returns a new <see cref="ZipEntry"></see> representing a directory.</returns>
        public ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem)
        {

            ZipEntry result = new ZipEntry(nameTransform_.TransformDirectory(directoryName));
            result.IsUnicodeText = isUnicodeText_;
            result.Size = 0;

            int externalAttributes = 0;

            DirectoryInfo di = null;

            if (useFileSystem)
            {
                di = new DirectoryInfo(directoryName);
            }


            if ((di != null) && di.Exists)
            {
                switch (timeSetting_)
                {
                    case TimeSetting.CreateTime:
                        result.DateTime = di.CreationTime;
                        break;

                    case TimeSetting.CreateTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.CreationTime.ToUniversalTime();
#else
                        result.DateTime = di.CreationTimeUtc;
#endif
                        break;

                    case TimeSetting.LastAccessTime:
                        result.DateTime = di.LastAccessTime;
                        break;

                    case TimeSetting.LastAccessTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.LastAccessTime.ToUniversalTime();
#else
                        result.DateTime = di.LastAccessTimeUtc;
#endif
                        break;

                    case TimeSetting.LastWriteTime:
                        result.DateTime = di.LastWriteTime;
                        break;

                    case TimeSetting.LastWriteTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.LastWriteTime.ToUniversalTime();
#else
                        result.DateTime = di.LastWriteTimeUtc;
#endif
                        break;

                    case TimeSetting.Fixed:
                        result.DateTime = fixedDateTime_;
                        break;

                    default:
                        throw new ZipException("Unhandled time setting in MakeDirectoryEntry");
                }

                externalAttributes = ((int)di.Attributes & getAttributes_);
            }
            else
            {
                if (timeSetting_ == TimeSetting.Fixed)
                {
                    result.DateTime = fixedDateTime_;
                }
            }

            // Always set directory attribute on.
            externalAttributes |= (setAttributes_ | 16);
            result.ExternalFileAttributes = externalAttributes;

            return result;
        }

        #endregion

        #region Instance Fields
        INameTransform nameTransform_;
        DateTime fixedDateTime_ = DateTime.Now;
        TimeSetting timeSetting_;
        bool isUnicodeText_;

        int getAttributes_ = -1;
        int setAttributes_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;

#if !NETCF_1_0 && !NETCF_2_0
    using System.Runtime.Serialization;
#endif
    /// <summary>
    /// Represents exception conditions specific to Zip archive handling
    /// </summary>
#if !NETCF_1_0 && !NETCF_2_0
    [Serializable]
#endif
    public class ZipException : SharpZipBaseException
    {
#if !NETCF_1_0 && !NETCF_2_0
        /// <summary>
        /// Deserialization constructor 
        /// </summary>
        /// <param name="info"><see cref="SerializationInfo"/> for this constructor</param>
        /// <param name="context"><see cref="StreamingContext"/> for this constructor</param>
        protected ZipException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif

        /// <summary>
        /// Initializes a new instance of the ZipException class.
        /// </summary>
        public ZipException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ZipException class with a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public ZipException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initialise a new instance of ZipException.
        /// </summary>
        /// <param name="message">A message describing the error.</param>
        /// <param name="exception">The exception that is the cause of the current exception.</param>
        public ZipException(string message, Exception exception)
            : base(message, exception)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    // TODO: Sort out wether tagged data is useful and what a good implementation might look like.
    // Its just a sketch of an idea at the moment.

    /// <summary>
    /// ExtraData tagged value interface.
    /// </summary>
    public interface ITaggedData
    {
        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        short TagID { get; }

        /// <summary>
        /// Set the contents of this instance from the data passed.
        /// </summary>
        /// <param name="data">The data to extract contents from.</param>
        /// <param name="offset">The offset to begin extracting data from.</param>
        /// <param name="count">The number of bytes to extract.</param>
        void SetData(byte[] data, int offset, int count);

        /// <summary>
        /// Get the data representing this instance.
        /// </summary>
        /// <returns>Returns the data for this instance.</returns>
        byte[] GetData();
    }

    /// <summary>
    /// A raw binary tagged value
    /// </summary>
    public class RawTaggedData : ITaggedData
    {
        /// <summary>
        /// Initialise a new instance.
        /// </summary>
        /// <param name="tag">The tag ID.</param>
        public RawTaggedData(short tag)
        {
            _tag = tag;
        }

        #region ITaggedData Members

        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        public short TagID
        {
            get { return _tag; }
            set { _tag = value; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="offset">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int offset, int count)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _data = new byte[count];
            Array.Copy(data, offset, _data, 0, count);
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            return _data;
        }

        #endregion

        /// <summary>
        /// Get /set the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] Data
        {
            get { return _data; }
            set { _data = value; }
        }

        #region Instance Fields
        /// <summary>
        /// The tag ID for this instance.
        /// </summary>
        short _tag;

        byte[] _data;
        #endregion
    }

    /// <summary>
    /// Class representing extended unix date time values.
    /// </summary>
    public class ExtendedUnixData : ITaggedData
    {
        /// <summary>
        /// Flags indicate which values are included in this instance.
        /// </summary>
        [Flags]
        public enum Flags : byte
        {
            /// <summary>
            /// The modification time is included
            /// </summary>
            ModificationTime = 0x01,

            /// <summary>
            /// The access time is included
            /// </summary>
            AccessTime = 0x02,

            /// <summary>
            /// The create time is included.
            /// </summary>
            CreateTime = 0x04,
        }

        #region ITaggedData Members

        /// <summary>
        /// Get the ID
        /// </summary>
        public short TagID
        {
            get { return 0x5455; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="index">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int index, int count)
        {
            using (MemoryStream ms = new MemoryStream(data, index, count, false))
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                // bit 0           if set, modification time is present
                // bit 1           if set, access time is present
                // bit 2           if set, creation time is present

                _flags = (Flags)helperStream.ReadByte();
                if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))
                {
                    int iTime = helperStream.ReadLEInt();

                    _modificationTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }

                if ((_flags & Flags.AccessTime) != 0)
                {
                    int iTime = helperStream.ReadLEInt();

                    _lastAccessTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }

                if ((_flags & Flags.CreateTime) != 0)
                {
                    int iTime = helperStream.ReadLEInt();

                    _createTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }
            }
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            using (MemoryStream ms = new MemoryStream())
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.IsStreamOwner = false;
                helperStream.WriteByte((byte)_flags);     // Flags
                if ((_flags & Flags.ModificationTime) != 0)
                {
                    TimeSpan span = _modificationTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                if ((_flags & Flags.AccessTime) != 0)
                {
                    TimeSpan span = _lastAccessTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                if ((_flags & Flags.CreateTime) != 0)
                {
                    TimeSpan span = _createTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                return ms.ToArray();
            }
        }

        #endregion

        /// <summary>
        /// Test a <see cref="DateTime"> value to see if is valid and can be represented here.</see>
        /// </summary>
        /// <param name="value">The <see cref="DateTime">value</see> to test.</param>
        /// <returns>Returns true if the value is valid and can be represented; false if not.</returns>
        /// <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
        /// which is the number of seconds since 1970-01-01.
        /// Being 32 bits means the values here cover a range of about 136 years.
        /// The minimum representable time is 1901-12-13 20:45:52,
        /// and the maximum representable time is 2038-01-19 03:14:07.
        /// </remarks>
        public static bool IsValidValue(DateTime value)
        {
            return ((value >= new DateTime(1901, 12, 13, 20, 45, 52)) ||
                    (value <= new DateTime(2038, 1, 19, 03, 14, 07)));
        }

        /// <summary>
        /// Get /set the Modification Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime ModificationTime
        {
            get { return _modificationTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.ModificationTime;
                _modificationTime = value;
            }
        }

        /// <summary>
        /// Get / set the Access Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime AccessTime
        {
            get { return _lastAccessTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.AccessTime;
                _lastAccessTime = value;
            }
        }

        /// <summary>
        /// Get / Set the Create Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime CreateTime
        {
            get { return _createTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.CreateTime;
                _createTime = value;
            }
        }

        /// <summary>
        /// Get/set the <see cref="Flags">values</see> to include.
        /// </summary>
        Flags Include
        {
            get { return _flags; }
            set { _flags = value; }
        }

        #region Instance Fields
        Flags _flags;
        DateTime _modificationTime = new DateTime(1970, 1, 1);
        DateTime _lastAccessTime = new DateTime(1970, 1, 1);
        DateTime _createTime = new DateTime(1970, 1, 1);
        #endregion
    }

    /// <summary>
    /// Class handling NT date time values.
    /// </summary>
    public class NTTaggedData : ITaggedData
    {
        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        public short TagID
        {
            get { return 10; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="index">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int index, int count)
        {
            using (MemoryStream ms = new MemoryStream(data, index, count, false))
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.ReadLEInt(); // Reserved
                while (helperStream.Position < helperStream.Length)
                {
                    int ntfsTag = helperStream.ReadLEShort();
                    int ntfsLength = helperStream.ReadLEShort();
                    if (ntfsTag == 1)
                    {
                        if (ntfsLength >= 24)
                        {
                            long lastModificationTicks = helperStream.ReadLELong();
                            _lastModificationTime = DateTime.FromFileTime(lastModificationTicks);

                            long lastAccessTicks = helperStream.ReadLELong();
                            _lastAccessTime = DateTime.FromFileTime(lastAccessTicks);

                            long createTimeTicks = helperStream.ReadLELong();
                            _createTime = DateTime.FromFileTime(createTimeTicks);
                        }
                        break;
                    }
                    else
                    {
                        // An unknown NTFS tag so simply skip it.
                        helperStream.Seek(ntfsLength, SeekOrigin.Current);
                    }
                }
            }
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            using (MemoryStream ms = new MemoryStream())
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.IsStreamOwner = false;
                helperStream.WriteLEInt(0);       // Reserved
                helperStream.WriteLEShort(1);     // Tag
                helperStream.WriteLEShort(24);    // Length = 3 x 8.
                helperStream.WriteLELong(_lastModificationTime.ToFileTime());
                helperStream.WriteLELong(_lastAccessTime.ToFileTime());
                helperStream.WriteLELong(_createTime.ToFileTime());
                return ms.ToArray();
            }
        }

        /// <summary>
        /// Test a <see cref="DateTime"> valuie to see if is valid and can be represented here.</see>
        /// </summary>
        /// <param name="value">The <see cref="DateTime">value</see> to test.</param>
        /// <returns>Returns true if the value is valid and can be represented; false if not.</returns>
        /// <remarks>
        /// NTFS filetimes are 64-bit unsigned integers, stored in Intel
        /// (least significant byte first) byte order. They determine the
        /// number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
        /// which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
        /// </remarks>
        public static bool IsValidValue(DateTime value)
        {
            bool result = true;
            try
            {
                value.ToFileTimeUtc();
            }
            catch
            {
                result = false;
            }
            return result;
        }

        /// <summary>
        /// Get/set the <see cref="DateTime">last modification time</see>.
        /// </summary>
        public DateTime LastModificationTime
        {
            get { return _lastModificationTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _lastModificationTime = value;
            }
        }

        /// <summary>
        /// Get /set the <see cref="DateTime">create time</see>
        /// </summary>
        public DateTime CreateTime
        {
            get { return _createTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _createTime = value;
            }
        }

        /// <summary>
        /// Get /set the <see cref="DateTime">last access time</see>.
        /// </summary>
        public DateTime LastAccessTime
        {
            get { return _lastAccessTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _lastAccessTime = value;
            }
        }

        #region Instance Fields
        DateTime _lastAccessTime = DateTime.FromFileTime(0);
        DateTime _lastModificationTime = DateTime.FromFileTime(0);
        DateTime _createTime = DateTime.FromFileTime(0);
        #endregion
    }

    /// <summary>
    /// A factory that creates <see cref="ITaggedData">tagged data</see> instances.
    /// </summary>
    interface ITaggedDataFactory
    {
        /// <summary>
        /// Get data for a specific tag value.
        /// </summary>
        /// <param name="tag">The tag ID to find.</param>
        /// <param name="data">The data to search.</param>
        /// <param name="offset">The offset to begin extracting data from.</param>
        /// <param name="count">The number of bytes to extract.</param>
        /// <returns>The located <see cref="ITaggedData">value found</see>, or null if not found.</returns>
        ITaggedData Create(short tag, byte[] data, int offset, int count);
    }

    /// 
    /// <summary>
    /// A class to handle the extra data field for Zip entries
    /// </summary>
    /// <remarks>
    /// Extra data contains 0 or more values each prefixed by a header tag and length.
    /// They contain zero or more bytes of actual data.
    /// The data is held internally using a copy on write strategy.  This is more efficient but
    /// means that for extra data created by passing in data can have the values modified by the caller
    /// in some circumstances.
    /// </remarks>
    sealed public class ZipExtraData : IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initialise a default instance.
        /// </summary>
        public ZipExtraData()
        {
            Clear();
        }

        /// <summary>
        /// Initialise with known extra data.
        /// </summary>
        /// <param name="data">The extra data.</param>
        public ZipExtraData(byte[] data)
        {
            if (data == null)
            {
                _data = new byte[0];
            }
            else
            {
                _data = data;
            }
        }
        #endregion

        /// <summary>
        /// Get the raw extra data value
        /// </summary>
        /// <returns>Returns the raw byte[] extra data this instance represents.</returns>
        public byte[] GetEntryData()
        {
            if (Length > ushort.MaxValue)
            {
                throw new ZipException("Data exceeds maximum length");
            }

            return (byte[])_data.Clone();
        }

        /// <summary>
        /// Clear the stored data.
        /// </summary>
        public void Clear()
        {
            if ((_data == null) || (_data.Length != 0))
            {
                _data = new byte[0];
            }
        }

        /// <summary>
        /// Gets the current extra data length.
        /// </summary>
        public int Length
        {
            get { return _data.Length; }
        }

        /// <summary>
        /// Get a read-only <see cref="Stream"/> for the associated tag.
        /// </summary>
        /// <param name="tag">The tag to locate data for.</param>
        /// <returns>Returns a <see cref="Stream"/> containing tag data or null if no tag was found.</returns>
        public Stream GetStreamForTag(int tag)
        {
            Stream result = null;
            if (Find(tag))
            {
                result = new MemoryStream(_data, _index, _readValueLength, false);
            }
            return result;
        }

        /// <summary>
        /// Get the <see cref="ITaggedData">tagged data</see> for a tag.
        /// </summary>
        /// <param name="tag">The tag to search for.</param>
        /// <returns>Returns a <see cref="ITaggedData">tagged value</see> or null if none found.</returns>
        private ITaggedData GetData(short tag)
        {
            ITaggedData result = null;
            if (Find(tag))
            {
                result = Create(tag, _data, _readValueStart, _readValueLength);
            }
            return result;
        }

        static ITaggedData Create(short tag, byte[] data, int offset, int count)
        {
            ITaggedData result = null;
            switch (tag)
            {
                case 0x000A:
                    result = new NTTaggedData();
                    break;
                case 0x5455:
                    result = new ExtendedUnixData();
                    break;
                default:
                    result = new RawTaggedData(tag);
                    break;
            }
            result.SetData(data, offset, count);
            return result;
        }

        /// <summary>
        /// Get the length of the last value found by <see cref="Find"/>
        /// </summary>
        /// <remarks>This is only valid if <see cref="Find"/> has previously returned true.</remarks>
        public int ValueLength
        {
            get { return _readValueLength; }
        }

        /// <summary>
        /// Get the index for the current read value.
        /// </summary>
        /// <remarks>This is only valid if <see cref="Find"/> has previously returned true.
        /// Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
        /// <see cref="ReadInt"/>, <see cref="ReadShort"/> and <see cref="ReadLong"/>. </remarks>
        public int CurrentReadIndex
        {
            get { return _index; }
        }

        /// <summary>
        /// Get the number of bytes remaining to be read for the current value;
        /// </summary>
        public int UnreadCount
        {
            get
            {
                if ((_readValueStart > _data.Length) ||
                    (_readValueStart < 4))
                {
                    throw new ZipException("Find must be called before calling a Read method");
                }

                return _readValueStart + _readValueLength - _index;
            }
        }

        /// <summary>
        /// Find an extra data value
        /// </summary>
        /// <param name="headerID">The identifier for the value to find.</param>
        /// <returns>Returns true if the value was found; false otherwise.</returns>
        public bool Find(int headerID)
        {
            _readValueStart = _data.Length;
            _readValueLength = 0;
            _index = 0;

            int localLength = _readValueStart;
            int localTag = headerID - 1;

            // Trailing bytes that cant make up an entry (as there arent enough
            // bytes for a tag and length) are ignored!
            while ((localTag != headerID) && (_index < _data.Length - 3))
            {
                localTag = ReadShortInternal();
                localLength = ReadShortInternal();
                if (localTag != headerID)
                {
                    _index += localLength;
                }
            }

            bool result = (localTag == headerID) && ((_index + localLength) <= _data.Length);

            if (result)
            {
                _readValueStart = _index;
                _readValueLength = localLength;
            }

            return result;
        }

        /// <summary>
        /// Add a new entry to extra data.
        /// </summary>
        /// <param name="taggedData">The <see cref="ITaggedData"/> value to add.</param>
        public void AddEntry(ITaggedData taggedData)
        {
            if (taggedData == null)
            {
                throw new ArgumentNullException("taggedData");
            }
            AddEntry(taggedData.TagID, taggedData.GetData());
        }

        /// <summary>
        /// Add a new entry to extra data
        /// </summary>
        /// <param name="headerID">The ID for this entry.</param>
        /// <param name="fieldData">The data to add.</param>
        /// <remarks>If the ID already exists its contents are replaced.</remarks>
        public void AddEntry(int headerID, byte[] fieldData)
        {
            if ((headerID > ushort.MaxValue) || (headerID < 0))
            {
                throw new ArgumentOutOfRangeException("headerID");
            }

            int addLength = (fieldData == null) ? 0 : fieldData.Length;

            if (addLength > ushort.MaxValue)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("fieldData");
#else
                throw new ArgumentOutOfRangeException("fieldData", "exceeds maximum length");
#endif
            }

            // Test for new length before adjusting data.
            int newLength = _data.Length + addLength + 4;

            if (Find(headerID))
            {
                newLength -= (ValueLength + 4);
            }

            if (newLength > ushort.MaxValue)
            {
                throw new ZipException("Data exceeds maximum length");
            }

            Delete(headerID);

            byte[] newData = new byte[newLength];
            _data.CopyTo(newData, 0);
            int index = _data.Length;
            _data = newData;
            SetShort(ref index, headerID);
            SetShort(ref index, addLength);
            if (fieldData != null)
            {
                fieldData.CopyTo(newData, index);
            }
        }

        /// <summary>
        /// Start adding a new entry.
        /// </summary>
        /// <remarks>Add data using <see cref="AddData(byte[])"/>, <see cref="AddLeShort"/>, <see cref="AddLeInt"/>, or <see cref="AddLeLong"/>.
        /// The new entry is completed and actually added by calling <see cref="AddNewEntry"/></remarks>
        /// <seealso cref="AddEntry(ITaggedData)"/>
        public void StartNewEntry()
        {
            _newEntry = new MemoryStream();
        }

        /// <summary>
        /// Add entry data added since <see cref="StartNewEntry"/> using the ID passed.
        /// </summary>
        /// <param name="headerID">The identifier to use for this entry.</param>
        public void AddNewEntry(int headerID)
        {
            byte[] newData = _newEntry.ToArray();
            _newEntry = null;
            AddEntry(headerID, newData);
        }

        /// <summary>
        /// Add a byte of data to the pending new entry.
        /// </summary>
        /// <param name="data">The byte to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddData(byte data)
        {
            _newEntry.WriteByte(data);
        }

        /// <summary>
        /// Add data to a pending new entry.
        /// </summary>
        /// <param name="data">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddData(byte[] data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _newEntry.Write(data, 0, data.Length);
        }

        /// <summary>
        /// Add a short value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeShort(int toAdd)
        {
            unchecked
            {
                _newEntry.WriteByte((byte)toAdd);
                _newEntry.WriteByte((byte)(toAdd >> 8));
            }
        }

        /// <summary>
        /// Add an integer value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeInt(int toAdd)
        {
            unchecked
            {
                AddLeShort((short)toAdd);
                AddLeShort((short)(toAdd >> 16));
            }
        }

        /// <summary>
        /// Add a long value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeLong(long toAdd)
        {
            unchecked
            {
                AddLeInt((int)(toAdd & 0xffffffff));
                AddLeInt((int)(toAdd >> 32));
            }
        }

        /// <summary>
        /// Delete an extra data field.
        /// </summary>
        /// <param name="headerID">The identifier of the field to delete.</param>
        /// <returns>Returns true if the field was found and deleted.</returns>
        public bool Delete(int headerID)
        {
            bool result = false;

            if (Find(headerID))
            {
                result = true;
                int trueStart = _readValueStart - 4;

                byte[] newData = new byte[_data.Length - (ValueLength + 4)];
                Array.Copy(_data, 0, newData, 0, trueStart);

                int trueEnd = trueStart + ValueLength + 4;
                Array.Copy(_data, trueEnd, newData, trueStart, _data.Length - trueEnd);
                _data = newData;
            }
            return result;
        }

        #region Reading Support
        /// <summary>
        /// Read a long in little endian form from the last <see cref="Find">found</see> data value
        /// </summary>
        /// <returns>Returns the long value read.</returns>
        public long ReadLong()
        {
            ReadCheck(8);
            return (ReadInt() & 0xffffffff) | (((long)ReadInt()) << 32);
        }

        /// <summary>
        /// Read an integer in little endian form from the last <see cref="Find">found</see> data value.
        /// </summary>
        /// <returns>Returns the integer read.</returns>
        public int ReadInt()
        {
            ReadCheck(4);

            int result = _data[_index] + (_data[_index + 1] << 8) +
                (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
            _index += 4;
            return result;
        }

        /// <summary>
        /// Read a short value in little endian form from the last <see cref="Find">found</see> data value.
        /// </summary>
        /// <returns>Returns the short value read.</returns>
        public int ReadShort()
        {
            ReadCheck(2);
            int result = _data[_index] + (_data[_index + 1] << 8);
            _index += 2;
            return result;
        }

        /// <summary>
        /// Read a byte from an extra data
        /// </summary>
        /// <returns>The byte value read or -1 if the end of data has been reached.</returns>
        public int ReadByte()
        {
            int result = -1;
            if ((_index < _data.Length) && (_readValueStart + _readValueLength > _index))
            {
                result = _data[_index];
                _index += 1;
            }
            return result;
        }

        /// <summary>
        /// Skip data during reading.
        /// </summary>
        /// <param name="amount">The number of bytes to skip.</param>
        public void Skip(int amount)
        {
            ReadCheck(amount);
            _index += amount;
        }

        void ReadCheck(int length)
        {
            if ((_readValueStart > _data.Length) ||
                (_readValueStart < 4))
            {
                throw new ZipException("Find must be called before calling a Read method");
            }

            if (_index > _readValueStart + _readValueLength - length)
            {
                throw new ZipException("End of extra data");
            }

            if (_index + length < 4)
            {
                throw new ZipException("Cannot read before start of tag");
            }
        }

        /// <summary>
        /// Internal form of <see cref="ReadShort"/> that reads data at any location.
        /// </summary>
        /// <returns>Returns the short value read.</returns>
        int ReadShortInternal()
        {
            if (_index > _data.Length - 2)
            {
                throw new ZipException("End of extra data");
            }

            int result = _data[_index] + (_data[_index + 1] << 8);
            _index += 2;
            return result;
        }

        void SetShort(ref int index, int source)
        {
            _data[index] = (byte)source;
            _data[index + 1] = (byte)(source >> 8);
            index += 2;
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Dispose of this instance.
        /// </summary>
        public void Dispose()
        {
            if (_newEntry != null)
            {
                _newEntry.Close();
            }
        }

        #endregion

        #region Instance Fields
        int _index;
        int _readValueStart;
        int _readValueLength;

        MemoryStream _newEntry;
        byte[] _data;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Globalization;

#if !NETCF_1_0
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    using ICSharpCode.SharpZipLib.Core;
    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    #region Keys Required Event Args
    /// <summary>
    /// Arguments used with KeysRequiredEvent
    /// </summary>
    public class KeysRequiredEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="KeysRequiredEventArgs"></see>
        /// </summary>
        /// <param name="name">The name of the file for which keys are required.</param>
        public KeysRequiredEventArgs(string name)
        {
            fileName = name;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="KeysRequiredEventArgs"></see>
        /// </summary>
        /// <param name="name">The name of the file for which keys are required.</param>
        /// <param name="keyValue">The current key value.</param>
        public KeysRequiredEventArgs(string name, byte[] keyValue)
        {
            fileName = name;
            key = keyValue;
        }

        #endregion
        #region Properties
        /// <summary>
        /// Gets the name of the file for which keys are required.
        /// </summary>
        public string FileName
        {
            get { return fileName; }
        }

        /// <summary>
        /// Gets or sets the key value
        /// </summary>
        public byte[] Key
        {
            get { return key; }
            set { key = value; }
        }
        #endregion

        #region Instance Fields
        string fileName;
        byte[] key;
        #endregion
    }
    #endregion

    #region Test Definitions
    /// <summary>
    /// The strategy to apply to testing.
    /// </summary>
    public enum TestStrategy
    {
        /// <summary>
        /// Find the first error only.
        /// </summary>
        FindFirstError,
        /// <summary>
        /// Find all possible errors.
        /// </summary>
        FindAllErrors,
    }

    /// <summary>
    /// The operation in progress reported by a <see cref="ZipTestResultHandler"/> during testing.
    /// </summary>
    /// <seealso cref="ZipFile.TestArchive(bool)">TestArchive</seealso>
    public enum TestOperation
    {
        /// <summary>
        /// Setting up testing.
        /// </summary>
        Initialising,

        /// <summary>
        /// Testing an individual entries header
        /// </summary>
        EntryHeader,

        /// <summary>
        /// Testing an individual entries data
        /// </summary>
        EntryData,

        /// <summary>
        /// Testing an individual entry has completed.
        /// </summary>
        EntryComplete,

        /// <summary>
        /// Running miscellaneous tests
        /// </summary>
        MiscellaneousTests,

        /// <summary>
        /// Testing is complete
        /// </summary>
        Complete,
    }

    /// <summary>
    /// Status returned returned by <see cref="ZipTestResultHandler"/> during testing.
    /// </summary>
    /// <seealso cref="ZipFile.TestArchive(bool)">TestArchive</seealso>
    public class TestStatus
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="TestStatus"/>
        /// </summary>
        /// <param name="file">The <see cref="ZipFile"/> this status applies to.</param>
        public TestStatus(ZipFile file)
        {
            file_ = file;
        }
        #endregion

        #region Properties

        /// <summary>
        /// Get the current <see cref="TestOperation"/> in progress.
        /// </summary>
        public TestOperation Operation
        {
            get { return operation_; }
        }

        /// <summary>
        /// Get the <see cref="ZipFile"/> this status is applicable to.
        /// </summary>
        public ZipFile File
        {
            get { return file_; }
        }

        /// <summary>
        /// Get the current/last entry tested.
        /// </summary>
        public ZipEntry Entry
        {
            get { return entry_; }
        }

        /// <summary>
        /// Get the number of errors detected so far.
        /// </summary>
        public int ErrorCount
        {
            get { return errorCount_; }
        }

        /// <summary>
        /// Get the number of bytes tested so far for the current entry.
        /// </summary>
        public long BytesTested
        {
            get { return bytesTested_; }
        }

        /// <summary>
        /// Get a value indicating wether the last entry test was valid.
        /// </summary>
        public bool EntryValid
        {
            get { return entryValid_; }
        }
        #endregion

        #region Internal API
        internal void AddError()
        {
            errorCount_++;
            entryValid_ = false;
        }

        internal void SetOperation(TestOperation operation)
        {
            operation_ = operation;
        }

        internal void SetEntry(ZipEntry entry)
        {
            entry_ = entry;
            entryValid_ = true;
            bytesTested_ = 0;
        }

        internal void SetBytesTested(long value)
        {
            bytesTested_ = value;
        }
        #endregion

        #region Instance Fields
        ZipFile file_;
        ZipEntry entry_;
        bool entryValid_;
        int errorCount_;
        long bytesTested_;
        TestOperation operation_;
        #endregion
    }

    /// <summary>
    /// Delegate invoked during <see cref="ZipFile.TestArchive(bool, TestStrategy, ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
    /// </summary>
    /// <remarks>If the message is non-null an error has occured.  If the message is null
    /// the operation as found in <see cref="TestStatus">status</see> has started.</remarks>
    public delegate void ZipTestResultHandler(TestStatus status, string message);
    #endregion

    #region Update Definitions
    /// <summary>
    /// The possible ways of <see cref="ZipFile.CommitUpdate()">applying updates</see> to an archive.
    /// </summary>
    public enum FileUpdateMode
    {
        /// <summary>
        /// Perform all updates on temporary files ensuring that the original file is saved.
        /// </summary>
        Safe,
        /// <summary>
        /// Update the archive directly, which is faster but less safe.
        /// </summary>
        Direct,
    }
    #endregion

    #region ZipFile Class
    /// <summary>
    /// This class represents a Zip archive.  You can ask for the contained
    /// entries, or get an input stream for a file entry.  The entry is
    /// automatically decompressed.
    /// 
    /// You can also update the archive adding or deleting entries.
    /// 
    /// This class is thread safe for input:  You can open input streams for arbitrary
    /// entries in different threads.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// <example>
    /// <code>
    /// using System;
    /// using System.Text;
    /// using System.Collections;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	static public void Main(string[] args)
    /// 	{
    /// 		using (ZipFile zFile = new ZipFile(args[0])) {
    /// 			Console.WriteLine("Listing of : " + zFile.Name);
    /// 			Console.WriteLine("");
    /// 			Console.WriteLine("Raw Size    Size      Date     Time     Name");
    /// 			Console.WriteLine("--------  --------  --------  ------  ---------");
    /// 			foreach (ZipEntry e in zFile) {
    /// 				if ( e.IsFile ) {
    /// 					DateTime d = e.DateTime;
    /// 					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
    /// 						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
    /// 						e.Name);
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }
    /// </code>
    /// </example>
    public class ZipFile : IEnumerable, IDisposable
    {
        #region KeyHandling

        /// <summary>
        /// Delegate for handling keys/password setting during compresion/decompression.
        /// </summary>
        public delegate void KeysRequiredEventHandler(
            object sender,
            KeysRequiredEventArgs e
        );

        /// <summary>
        /// Event handler for handling encryption keys.
        /// </summary>
        public KeysRequiredEventHandler KeysRequired;

        /// <summary>
        /// Handles getting of encryption keys when required.
        /// </summary>
        /// <param name="fileName">The file for which encryption keys are required.</param>
        void OnKeysRequired(string fileName)
        {
            if (KeysRequired != null)
            {
                KeysRequiredEventArgs krea = new KeysRequiredEventArgs(fileName, key);
                KeysRequired(this, krea);
                key = krea.Key;
            }
        }

        /// <summary>
        /// Get/set the encryption key value.
        /// </summary>
        byte[] Key
        {
            get { return key; }
            set { key = value; }
        }

#if !NETCF_1_0
        /// <summary>
        /// Password to be used for encrypting/decrypting files.
        /// </summary>
        /// <remarks>Set to null if no password is required.</remarks>
        public string Password
        {
            set
            {
                if ((value == null) || (value.Length == 0))
                {
                    key = null;
                }
                else
                {
                    rawPassword_ = value;
                    key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(value));
                }
            }
        }
#endif

        /// <summary>
        /// Get a value indicating wether encryption keys are currently available.
        /// </summary>
        bool HaveKeys
        {
            get { return key != null; }
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Opens a Zip file with the given name for reading.
        /// </summary>
        /// <param name="name">The name of the file to open.</param>
        /// <exception cref="ArgumentNullException">The argument supplied is null.</exception>
        /// <exception cref="IOException">
        /// An i/o error occurs
        /// </exception>
        /// <exception cref="ZipException">
        /// The file doesn't contain a valid zip archive.
        /// </exception>
        public ZipFile(string name)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            name_ = name;

            baseStream_ = File.Open(name, FileMode.Open, FileAccess.Read, FileShare.Read);
            isStreamOwner = true;

            try
            {
                ReadEntries();
            }
            catch
            {
                DisposeInternal(true);
                throw;
            }
        }

        /// <summary>
        /// Opens a Zip file reading the given <see cref="FileStream"/>.
        /// </summary>
        /// <param name="file">The <see cref="FileStream"/> to read archive data from.</param>
        /// <exception cref="ArgumentNullException">The supplied argument is null.</exception>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="ZipException">
        /// The file doesn't contain a valid zip archive.
        /// </exception>
        public ZipFile(FileStream file)
        {
            if (file == null)
            {
                throw new ArgumentNullException("file");
            }

            if (!file.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "file");
            }

            baseStream_ = file;
            name_ = file.Name;
            isStreamOwner = true;

            try
            {
                ReadEntries();
            }
            catch
            {
                DisposeInternal(true);
                throw;
            }
        }

        /// <summary>
        /// Opens a Zip file reading the given <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to read archive data from.</param>
        /// <exception cref="IOException">
        /// An i/o error occurs
        /// </exception>
        /// <exception cref="ZipException">
        /// The stream doesn't contain a valid zip archive.<br/>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The <see cref="Stream">stream</see> doesnt support seeking.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// The <see cref="Stream">stream</see> argument is null.
        /// </exception>
        public ZipFile(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (!stream.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "stream");
            }

            baseStream_ = stream;
            isStreamOwner = true;

            if (baseStream_.Length > 0)
            {
                try
                {
                    ReadEntries();
                }
                catch
                {
                    DisposeInternal(true);
                    throw;
                }
            }
            else
            {
                entries_ = new ZipEntry[0];
                isNewArchive_ = true;
            }
        }

        /// <summary>
        /// Initialises a default <see cref="ZipFile"/> instance with no entries and no file storage.
        /// </summary>
        internal ZipFile()
        {
            entries_ = new ZipEntry[0];
            isNewArchive_ = true;
        }

        #endregion

        #region Destructors and Closing
        /// <summary>
        /// Finalize this instance.
        /// </summary>
        ~ZipFile()
        {
            Dispose(false);
        }

        /// <summary>
        /// Closes the ZipFile.  If the stream is <see cref="IsStreamOwner">owned</see> then this also closes the underlying input stream.
        /// Once closed, no further instance methods should be called.
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An i/o error occurs.
        /// </exception>
        public void Close()
        {
            DisposeInternal(true);
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Creators
        /// <summary>
        /// Create a new <see cref="ZipFile"/> whose data will be stored in a file.
        /// </summary>
        /// <param name="fileName">The name of the archive to create.</param>
        /// <returns>Returns the newly created <see cref="ZipFile"/></returns>
        /// <exception cref="ArgumentNullException"><paramref name="fileName"></paramref> is null</exception>
        public static ZipFile Create(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            FileStream fs = File.Create(fileName);

            ZipFile result = new ZipFile();
            result.name_ = fileName;
            result.baseStream_ = fs;
            result.isStreamOwner = true;
            return result;
        }

        /// <summary>
        /// Create a new <see cref="ZipFile"/> whose data will be stored on a stream.
        /// </summary>
        /// <param name="outStream">The stream providing data storage.</param>
        /// <returns>Returns the newly created <see cref="ZipFile"/></returns>
        /// <exception cref="ArgumentNullException"><paramref name="outStream"> is null</paramref></exception>
        /// <exception cref="ArgumentException"><paramref name="outStream"> doesnt support writing.</paramref></exception>
        public static ZipFile Create(Stream outStream)
        {
            if (outStream == null)
            {
                throw new ArgumentNullException("outStream");
            }

            if (!outStream.CanWrite)
            {
                throw new ArgumentException("Stream is not writeable", "outStream");
            }

            if (!outStream.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "outStream");
            }

            ZipFile result = new ZipFile();
            result.baseStream_ = outStream;
            return result;
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
        /// If the flag is true then the stream will be closed when <see cref="Close">Close</see> is called.
        /// </summary>
        /// <remarks>
        /// The default value is true in all cases.
        /// </remarks>
        public bool IsStreamOwner
        {
            get { return isStreamOwner; }
            set { isStreamOwner = value; }
        }

        /// <summary>
        /// Get a value indicating wether
        /// this archive is embedded in another file or not.
        /// </summary>
        public bool IsEmbeddedArchive
        {
            // Not strictly correct in all circumstances currently
            get { return offsetOfFirstEntry > 0; }
        }

        /// <summary>
        /// Get a value indicating that this archive is a new one.
        /// </summary>
        public bool IsNewArchive
        {
            get { return isNewArchive_; }
        }

        /// <summary>
        /// Gets the comment for the zip file.
        /// </summary>
        public string ZipFileComment
        {
            get { return comment_; }
        }

        /// <summary>
        /// Gets the name of this zip file.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Gets the number of entries in this zip file.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The Zip file has been closed.
        /// </exception>
        [Obsolete("Use the Count property instead")]
        public int Size
        {
            get
            {
                return entries_.Length;
            }
        }

        /// <summary>
        /// Get the number of entries contained in this <see cref="ZipFile"/>.
        /// </summary>
        public long Count
        {
            get
            {
                return entries_.Length;
            }
        }

        /// <summary>
        /// Indexer property for ZipEntries
        /// </summary>
        [System.Runtime.CompilerServices.IndexerNameAttribute("EntryByIndex")]
        public ZipEntry this[int index]
        {
            get
            {
                return (ZipEntry)entries_[index].Clone();
            }
        }

        #endregion

        #region Input Handling
        /// <summary>
        /// Gets an enumerator for the Zip entries in this Zip file.
        /// </summary>
        /// <returns>Returns an <see cref="IEnumerator"/> for this archive.</returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public IEnumerator GetEnumerator()
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            return new ZipEntryEnumerator(entries_);
        }

        /// <summary>
        /// Return the index of the entry with a matching name
        /// </summary>
        /// <param name="name">Entry name to find</param>
        /// <param name="ignoreCase">If true the comparison is case insensitive</param>
        /// <returns>The index position of the matching entry or -1 if not found</returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public int FindEntry(string name, bool ignoreCase)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            // TODO: This will be slow as the next ice age for huge archives!
            for (int i = 0; i < entries_.Length; i++)
            {
                if (string.Compare(name, entries_[i].Name, ignoreCase, CultureInfo.InvariantCulture) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Searches for a zip entry in this archive with the given name.
        /// String comparisons are case insensitive
        /// </summary>
        /// <param name="name">
        /// The name to find. May contain directory components separated by slashes ('/').
        /// </param>
        /// <returns>
        /// A clone of the zip entry, or null if no entry with that name exists.
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public ZipEntry GetEntry(string name)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            int index = FindEntry(name, true);
            return (index >= 0) ? (ZipEntry)entries_[index].Clone() : null;
        }

        /// <summary>
        /// Gets an input stream for reading the given zip entry data in an uncompressed form.
        /// Normally the <see cref="ZipEntry"/> should be an entry returned by GetEntry().
        /// </summary>
        /// <param name="entry">The <see cref="ZipEntry"/> to obtain a data <see cref="Stream"/> for</param>
        /// <returns>An input <see cref="Stream"/> containing data for this <see cref="ZipEntry"/></returns>
        /// <exception cref="ObjectDisposedException">
        /// The ZipFile has already been closed
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The compression method for the entry is unknown
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// The entry is not found in the ZipFile
        /// </exception>
        public Stream GetInputStream(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            long index = entry.ZipFileIndex;
            if ((index < 0) || (index >= entries_.Length) || (entries_[index].Name != entry.Name))
            {
                index = FindEntry(entry.Name, true);
                if (index < 0)
                {
                    throw new ZipException("Entry cannot be found");
                }
            }
            return GetInputStream(index);
        }

        /// <summary>
        /// Creates an input stream reading a zip entry
        /// </summary>
        /// <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
        /// <returns>
        /// An input <see cref="Stream"/> containing data for this <paramref name="entryIndex"/>
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// The ZipFile has already been closed
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The compression method for the entry is unknown
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// The entry is not found in the ZipFile
        /// </exception>
        public Stream GetInputStream(long entryIndex)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            long start = LocateEntry(entries_[entryIndex]);
            CompressionMethod method = entries_[entryIndex].CompressionMethod;
            Stream result = new PartialInputStream(this, start, entries_[entryIndex].CompressedSize);

            if (entries_[entryIndex].IsCrypted == true)
            {
#if NETCF_1_0
				throw new ZipException("decryption not supported for Compact Framework 1.0");
#else
                result = CreateAndInitDecryptionStream(result, entries_[entryIndex]);
                if (result == null)
                {
                    throw new ZipException("Unable to decrypt this entry");
                }
#endif
            }

            switch (method)
            {
                case CompressionMethod.Stored:
                    // read as is.
                    break;

                case CompressionMethod.Deflated:
                    // No need to worry about ownership and closing as underlying stream close does nothing.
                    result = new InflaterInputStream(result, new Inflater(true));
                    break;

                default:
                    throw new ZipException("Unsupported compression method " + method);
            }

            return result;
        }

        #endregion

        #region Archive Testing
        /// <summary>
        /// Test an archive for integrity/validity
        /// </summary>
        /// <param name="testData">Perform low level data Crc check</param>
        /// <returns>true if all tests pass, false otherwise</returns>
        /// <remarks>Testing will terminate on the first error found.</remarks>
        public bool TestArchive(bool testData)
        {
            return TestArchive(testData, TestStrategy.FindFirstError, null);
        }

        /// <summary>
        /// Test an archive for integrity/validity
        /// </summary>
        /// <param name="testData">Perform low level data Crc check</param>
        /// <param name="strategy">The <see cref="TestStrategy"></see> to apply.</param>
        /// <param name="resultHandler">The <see cref="ZipTestResultHandler"></see> handler to call during testing.</param>
        /// <returns>true if all tests pass, false otherwise</returns>
        /// <exception cref="ObjectDisposedException">The object has already been closed.</exception>
        public bool TestArchive(bool testData, TestStrategy strategy, ZipTestResultHandler resultHandler)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            TestStatus status = new TestStatus(this);

            if (resultHandler != null)
            {
                resultHandler(status, null);
            }

            HeaderTest test = testData ? (HeaderTest.Header | HeaderTest.Extract) : HeaderTest.Header;

            bool testing = true;

            try
            {
                int entryIndex = 0;

                while (testing && (entryIndex < Count))
                {
                    if (resultHandler != null)
                    {
                        status.SetEntry(this[entryIndex]);
                        status.SetOperation(TestOperation.EntryHeader);
                        resultHandler(status, null);
                    }

                    try
                    {
                        TestLocalHeader(this[entryIndex], test);
                    }
                    catch (ZipException ex)
                    {
                        status.AddError();

                        if (resultHandler != null)
                        {
                            resultHandler(status,
                                string.Format("Exception during test - '{0}'", ex.Message));
                        }

                        if (strategy == TestStrategy.FindFirstError)
                        {
                            testing = false;
                        }
                    }

                    if (testing && testData && this[entryIndex].IsFile)
                    {
                        if (resultHandler != null)
                        {
                            status.SetOperation(TestOperation.EntryData);
                            resultHandler(status, null);
                        }

                        Crc32 crc = new Crc32();

                        using (Stream entryStream = this.GetInputStream(this[entryIndex]))
                        {

                            byte[] buffer = new byte[4096];
                            long totalBytes = 0;
                            int bytesRead;
                            while ((bytesRead = entryStream.Read(buffer, 0, buffer.Length)) > 0)
                            {
                                crc.Update(buffer, 0, bytesRead);

                                if (resultHandler != null)
                                {
                                    totalBytes += bytesRead;
                                    status.SetBytesTested(totalBytes);
                                    resultHandler(status, null);
                                }
                            }
                        }

                        if (this[entryIndex].Crc != crc.Value)
                        {
                            status.AddError();

                            if (resultHandler != null)
                            {
                                resultHandler(status, "CRC mismatch");
                            }

                            if (strategy == TestStrategy.FindFirstError)
                            {
                                testing = false;
                            }
                        }

                        if ((this[entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0)
                        {
                            ZipHelperStream helper = new ZipHelperStream(baseStream_);
                            DescriptorData data = new DescriptorData();
                            helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64, data);
                            if (this[entryIndex].Crc != data.Crc)
                            {
                                status.AddError();
                            }

                            if (this[entryIndex].CompressedSize != data.CompressedSize)
                            {
                                status.AddError();
                            }

                            if (this[entryIndex].Size != data.Size)
                            {
                                status.AddError();
                            }
                        }
                    }

                    if (resultHandler != null)
                    {
                        status.SetOperation(TestOperation.EntryComplete);
                        resultHandler(status, null);
                    }

                    entryIndex += 1;
                }

                if (resultHandler != null)
                {
                    status.SetOperation(TestOperation.MiscellaneousTests);
                    resultHandler(status, null);
                }

                // TODO: the 'Corrina Johns' test where local headers are missing from
                // the central directory.  They are therefore invisible to many archivers.
            }
            catch (Exception ex)
            {
                status.AddError();

                if (resultHandler != null)
                {
                    resultHandler(status, string.Format("Exception during test - '{0}'", ex.Message));
                }
            }

            if (resultHandler != null)
            {
                status.SetOperation(TestOperation.Complete);
                status.SetEntry(null);
                resultHandler(status, null);
            }

            return (status.ErrorCount == 0);
        }

        [Flags]
        enum HeaderTest
        {
            Extract = 0x01,     // Check that this header represents an entry whose data can be extracted
            Header = 0x02,     // Check that this header contents are valid
        }

        /// <summary>
        /// Test a local header against that provided from the central directory
        /// </summary>
        /// <param name="entry">
        /// The entry to test against
        /// </param>
        /// <param name="tests">The type of <see cref="HeaderTest">tests</see> to carry out.</param>
        /// <returns>The offset of the entries data in the file</returns>
        long TestLocalHeader(ZipEntry entry, HeaderTest tests)
        {
            lock (baseStream_)
            {
                bool testHeader = (tests & HeaderTest.Header) != 0;
                bool testData = (tests & HeaderTest.Extract) != 0;

                baseStream_.Seek(offsetOfFirstEntry + entry.Offset, SeekOrigin.Begin);
                if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature)
                {
                    throw new ZipException(string.Format("Wrong local header signature @{0:X}", offsetOfFirstEntry + entry.Offset));
                }

                short extractVersion = (short)ReadLEUshort();
                short localFlags = (short)ReadLEUshort();
                short compressionMethod = (short)ReadLEUshort();
                short fileTime = (short)ReadLEUshort();
                short fileDate = (short)ReadLEUshort();
                uint crcValue = ReadLEUint();
                long compressedSize = ReadLEUint();
                long size = ReadLEUint();
                int storedNameLength = ReadLEUshort();
                int extraDataLength = ReadLEUshort();

                byte[] nameData = new byte[storedNameLength];
                StreamUtils.ReadFully(baseStream_, nameData);

                byte[] extraData = new byte[extraDataLength];
                StreamUtils.ReadFully(baseStream_, extraData);

                ZipExtraData localExtraData = new ZipExtraData(extraData);

                // Extra data / zip64 checks
                if (localExtraData.Find(1))
                {
                    // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64
                    // and size or compressedSize = MaxValue, due to rogue creators.

                    size = localExtraData.ReadLong();
                    compressedSize = localExtraData.ReadLong();

                    if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0)
                    {
                        // These may be valid if patched later
                        if ((size != -1) && (size != entry.Size))
                        {
                            throw new ZipException("Size invalid for descriptor");
                        }

                        if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))
                        {
                            throw new ZipException("Compressed size invalid for descriptor");
                        }
                    }
                }
                else
                {
                    // No zip64 extra data but entry requires it.
                    if ((extractVersion >= ZipConstants.VersionZip64) &&
                        (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))
                    {
                        throw new ZipException("Required Zip64 extended information missing");
                    }
                }

                if (testData)
                {
                    if (entry.IsFile)
                    {
                        if (!entry.IsCompressionMethodSupported())
                        {
                            throw new ZipException("Compression method not supported");
                        }

                        if ((extractVersion > ZipConstants.VersionMadeBy)
                            || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))
                        {
                            throw new ZipException(string.Format("Version required to extract this entry not supported ({0})", extractVersion));
                        }

                        if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)
                        {
                            throw new ZipException("The library does not support the zip version required to extract this entry");
                        }
                    }
                }

                if (testHeader)
                {
                    if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..
                        (extractVersion != 10) &&
                        (extractVersion != 11) &&
                        (extractVersion != 20) &&
                        (extractVersion != 21) &&
                        (extractVersion != 25) &&
                        (extractVersion != 27) &&
                        (extractVersion != 45) &&
                        (extractVersion != 46) &&
                        (extractVersion != 50) &&
                        (extractVersion != 51) &&
                        (extractVersion != 52) &&
                        (extractVersion != 61) &&
                        (extractVersion != 62) &&
                        (extractVersion != 63)
                        )
                    {
                        throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})", extractVersion));
                    }

                    // Local entry flags dont have reserved bit set on.
                    if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0)
                    {
                        throw new ZipException("Reserved bit flags cannot be set.");
                    }

                    // Encryption requires extract version >= 20
                    if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))
                    {
                        throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", extractVersion));
                    }

                    // Strong encryption requires encryption flag to be set and extract version >= 50.
                    if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0)
                    {
                        if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0)
                        {
                            throw new ZipException("Strong encryption flag set but encryption flag is not set");
                        }

                        if (extractVersion < 50)
                        {
                            throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", extractVersion));
                        }
                    }

                    // Patched entries require extract version >= 27
                    if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27))
                    {
                        throw new ZipException(string.Format("Patched data requires higher version than ({0})", extractVersion));
                    }

                    // Central header flags match local entry flags.
                    if (localFlags != entry.Flags)
                    {
                        throw new ZipException("Central header/local header flags mismatch");
                    }

                    // Central header compression method matches local entry
                    if (entry.CompressionMethod != (CompressionMethod)compressionMethod)
                    {
                        throw new ZipException("Central header/local header compression method mismatch");
                    }

                    if (entry.Version != extractVersion)
                    {
                        throw new ZipException("Extract version mismatch");
                    }

                    // Strong encryption and extract version match
                    if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0)
                    {
                        if (extractVersion < 62)
                        {
                            throw new ZipException("Strong encryption flag set but version not high enough");
                        }
                    }

                    if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0)
                    {
                        if ((fileTime != 0) || (fileDate != 0))
                        {
                            throw new ZipException("Header masked set but date/time values non-zero");
                        }
                    }

                    if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0)
                    {
                        if (crcValue != (uint)entry.Crc)
                        {
                            throw new ZipException("Central header/local header crc mismatch");
                        }
                    }

                    // Crc valid for empty entry.
                    // This will also apply to streamed entries where size isnt known and the header cant be patched
                    if ((size == 0) && (compressedSize == 0))
                    {
                        if (crcValue != 0)
                        {
                            throw new ZipException("Invalid CRC for empty entry");
                        }
                    }

                    // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings
                    // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably
                    if (entry.Name.Length > storedNameLength)
                    {
                        throw new ZipException("File name length mismatch");
                    }

                    // Name data has already been read convert it and compare.
                    string localName = ZipConstants.ConvertToStringExt(localFlags, nameData);

                    // Central directory and local entry name match
                    if (localName != entry.Name)
                    {
                        throw new ZipException("Central header and local header file name mismatch");
                    }

                    // Directories have zero actual size but can have compressed size
                    if (entry.IsDirectory)
                    {
                        if (size > 0)
                        {
                            throw new ZipException("Directory cannot have size");
                        }

                        // There may be other cases where the compressed size can be greater than this?
                        // If so until details are known we will be strict.
                        if (entry.IsCrypted)
                        {
                            if (compressedSize > ZipConstants.CryptoHeaderSize + 2)
                            {
                                throw new ZipException("Directory compressed size invalid");
                            }
                        }
                        else if (compressedSize > 2)
                        {
                            // When not compressed the directory size can validly be 2 bytes
                            // if the true size wasnt known when data was originally being written.
                            // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes
                            throw new ZipException("Directory compressed size invalid");
                        }
                    }

                    if (!ZipNameTransform.IsValidName(localName, true))
                    {
                        throw new ZipException("Name is invalid");
                    }
                }

                // Tests that apply to both data and header.

                // Size can be verified only if it is known in the local header.
                // it will always be known in the central header.
                if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||
                    ((size > 0) || (compressedSize > 0)))
                {

                    if (size != entry.Size)
                    {
                        throw new ZipException(
                            string.Format("Size mismatch between central header({0}) and local header({1})",
                                entry.Size, size));
                    }

                    if (compressedSize != entry.CompressedSize &&
                        compressedSize != 0xFFFFFFFF && compressedSize != -1)
                    {
                        throw new ZipException(
                            string.Format("Compressed size mismatch between central header({0}) and local header({1})",
                            entry.CompressedSize, compressedSize));
                    }
                }

                int extraLength = storedNameLength + extraDataLength;
                return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;
            }
        }

        #endregion

        #region Updating

        const int DefaultBufferSize = 4096;

        /// <summary>
        /// The kind of update to apply.
        /// </summary>
        enum UpdateCommand
        {
            Copy,       // Copy original file contents.
            Modify,     // Change encryption, compression, attributes, name, time etc, of an existing file.
            Add,        // Add a new file to the archive.
        }

        #region Properties
        /// <summary>
        /// Get / set the <see cref="INameTransform"/> to apply to names when updating.
        /// </summary>
        public INameTransform NameTransform
        {
            get
            {
                return updateEntryFactory_.NameTransform;
            }

            set
            {
                updateEntryFactory_.NameTransform = value;
            }
        }

        /// <summary>
        /// Get/set the <see cref="IEntryFactory"/> used to generate <see cref="ZipEntry"/> values
        /// during updates.
        /// </summary>
        public IEntryFactory EntryFactory
        {
            get
            {
                return updateEntryFactory_;
            }

            set
            {
                if (value == null)
                {
                    updateEntryFactory_ = new ZipEntryFactory();
                }
                else
                {
                    updateEntryFactory_ = value;
                }
            }
        }

        /// <summary>
        /// Get /set the buffer size to be used when updating this zip file.
        /// </summary>
        public int BufferSize
        {
            get { return bufferSize_; }
            set
            {
                if (value < 1024)
                {
#if NETCF_1_0					
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "cannot be below 1024");
#endif
                }

                if (bufferSize_ != value)
                {
                    bufferSize_ = value;
                    copyBuffer_ = null;
                }
            }
        }

        /// <summary>
        /// Get a value indicating an update has <see cref="BeginUpdate()">been started</see>.
        /// </summary>
        public bool IsUpdating
        {
            get { return updates_ != null; }
        }

        /// <summary>
        /// Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
        /// </summary>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        #endregion

        #region Immediate updating
        //		TBD: Direct form of updating
        // 
        //		public void Update(IEntryMatcher deleteMatcher)
        //		{
        //		}
        //
        //		public void Update(IScanner addScanner)
        //		{
        //		}
        #endregion

        #region Deferred Updating
        /// <summary>
        /// Begin updating this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <param name="archiveStorage">The <see cref="IArchiveStorage">archive storage</see> for use during the update.</param>
        /// <param name="dataSource">The <see cref="IDynamicDataSource">data source</see> to utilise during updating.</param>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentNullException">One of the arguments provided is null</exception>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void BeginUpdate(IArchiveStorage archiveStorage, IDynamicDataSource dataSource)
        {
            if (archiveStorage == null)
            {
                throw new ArgumentNullException("archiveStorage");
            }

            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            if (IsEmbeddedArchive)
            {
                throw new ZipException("Cannot update embedded/SFX archives");
            }

            archiveStorage_ = archiveStorage;
            updateDataSource_ = dataSource;

            // NOTE: the baseStream_ may not currently support writing or seeking.

            updateIndex_ = new Hashtable();

            updates_ = new ArrayList(entries_.Length);
            foreach (ZipEntry entry in entries_)
            {
                int index = updates_.Add(new ZipUpdate(entry));
                updateIndex_.Add(entry.Name, index);
            }

            // We must sort by offset before using offset's calculated sizes
            updates_.Sort(new UpdateComparer());

            int idx = 0;
            foreach (ZipUpdate update in updates_)
            {
                //If last entry, there is no next entry offset to use
                if (idx == updates_.Count - 1)
                    break;

                update.OffsetBasedSize = ((ZipUpdate)updates_[idx + 1]).Entry.Offset - update.Entry.Offset;
                idx++;
            }
            updateCount_ = updates_.Count;

            contentsEdited_ = false;
            commentEdited_ = false;
            newComment_ = null;
        }

        /// <summary>
        /// Begin updating to this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <param name="archiveStorage">The storage to use during the update.</param>
        public void BeginUpdate(IArchiveStorage archiveStorage)
        {
            BeginUpdate(archiveStorage, new DynamicDiskDataSource());
        }

        /// <summary>
        /// Begin updating this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <seealso cref="BeginUpdate(IArchiveStorage)"/>
        /// <seealso cref="CommitUpdate"></seealso>
        /// <seealso cref="AbortUpdate"></seealso>
        public void BeginUpdate()
        {
            if (Name == null)
            {
                BeginUpdate(new MemoryArchiveStorage(), new DynamicDiskDataSource());
            }
            else
            {
                BeginUpdate(new DiskArchiveStorage(this), new DynamicDiskDataSource());
            }
        }

        /// <summary>
        /// Commit current updates, updating this archive.
        /// </summary>
        /// <seealso cref="BeginUpdate()"></seealso>
        /// <seealso cref="AbortUpdate"></seealso>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void CommitUpdate()
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            CheckUpdating();

            try
            {
                updateIndex_.Clear();
                updateIndex_ = null;

                if (contentsEdited_)
                {
                    RunUpdates();
                }
                else if (commentEdited_)
                {
                    UpdateCommentOnly();
                }
                else
                {
                    // Create an empty archive if none existed originally.
                    if (entries_.Length == 0)
                    {
                        byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipConstants.ConvertToArray(comment_);
                        using (ZipHelperStream zhs = new ZipHelperStream(baseStream_))
                        {
                            zhs.WriteEndOfCentralDirectory(0, 0, 0, theComment);
                        }
                    }
                }

            }
            finally
            {
                PostUpdateCleanup();
            }
        }

        /// <summary>
        /// Abort updating leaving the archive unchanged.
        /// </summary>
        /// <seealso cref="BeginUpdate()"></seealso>
        /// <seealso cref="CommitUpdate"></seealso>
        public void AbortUpdate()
        {
            PostUpdateCleanup();
        }

        /// <summary>
        /// Set the file comment to be recorded when the current update is <see cref="CommitUpdate">commited</see>.
        /// </summary>
        /// <param name="comment">The comment to record.</param>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void SetComment(string comment)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            CheckUpdating();

            newComment_ = new ZipString(comment);

            if (newComment_.RawLength > 0xffff)
            {
                newComment_ = null;
                throw new ZipException("Comment length exceeds maximum - 65535");
            }

            // We dont take account of the original and current comment appearing to be the same
            // as encoding may be different.
            commentEdited_ = true;
        }

        #endregion

        #region Adding Entries

        void AddUpdate(ZipUpdate update)
        {
            contentsEdited_ = true;

            int index = FindExistingUpdate(update.Entry.Name);

            if (index >= 0)
            {
                if (updates_[index] == null)
                {
                    updateCount_ += 1;
                }

                // Direct replacement is faster than delete and add.
                updates_[index] = update;
            }
            else
            {
                index = updates_.Add(update);
                updateCount_ += 1;
                updateIndex_.Add(update.Entry.Name, index);
            }
        }

        /// <summary>
        /// Add a new entry to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <param name="useUnicodeText">Ensure Unicode text is used for name and comment for this entry.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Compression method is not supported.</exception>
        public void Add(string fileName, CompressionMethod compressionMethod, bool useUnicodeText)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
            {
                throw new ArgumentOutOfRangeException("compressionMethod");
            }

            CheckUpdating();
            contentsEdited_ = true;

            ZipEntry entry = EntryFactory.MakeFileEntry(fileName);
            entry.IsUnicodeText = useUnicodeText;
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(fileName, entry));
        }

        /// <summary>
        /// Add a new entry to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <exception cref="ArgumentNullException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">The compression method is not supported.</exception>
        public void Add(string fileName, CompressionMethod compressionMethod)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
            {
                throw new ArgumentOutOfRangeException("compressionMethod");
            }

            CheckUpdating();
            contentsEdited_ = true;

            ZipEntry entry = EntryFactory.MakeFileEntry(fileName);
            entry.CompressionMethod = compressionMethod;
            AddUpdate(new ZipUpdate(fileName, entry));
        }

        /// <summary>
        /// Add a file to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        public void Add(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(fileName, EntryFactory.MakeFileEntry(fileName)));
        }

        /// <summary>
        /// Add a file to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="entryName">The name to use for the <see cref="ZipEntry"/> on the Zip file created.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        public void Add(string fileName, string entryName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(fileName, EntryFactory.MakeFileEntry(entryName)));
        }


        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        public void Add(IStaticDataSource dataSource, string entryName)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(dataSource, EntryFactory.MakeFileEntry(entryName, false)));
        }

        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();

            ZipEntry entry = EntryFactory.MakeFileEntry(entryName, false);
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(dataSource, entry));
        }

        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <param name="useUnicodeText">Ensure Unicode text is used for name and comments for this entry.</param>
        public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod, bool useUnicodeText)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();

            ZipEntry entry = EntryFactory.MakeFileEntry(entryName, false);
            entry.IsUnicodeText = useUnicodeText;
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(dataSource, entry));
        }

        /// <summary>
        /// Add a <see cref="ZipEntry"/> that contains no data.
        /// </summary>
        /// <param name="entry">The entry to add.</param>
        /// <remarks>This can be used to add directories, volume labels, or empty file entries.</remarks>
        public void Add(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            CheckUpdating();

            if ((entry.Size != 0) || (entry.CompressedSize != 0))
            {
                throw new ZipException("Entry cannot have any data");
            }

            AddUpdate(new ZipUpdate(UpdateCommand.Add, entry));
        }

        /// <summary>
        /// Add a directory entry to the archive.
        /// </summary>
        /// <param name="directoryName">The directory to add.</param>
        public void AddDirectory(string directoryName)
        {
            if (directoryName == null)
            {
                throw new ArgumentNullException("directoryName");
            }

            CheckUpdating();

            ZipEntry dirEntry = EntryFactory.MakeDirectoryEntry(directoryName);
            AddUpdate(new ZipUpdate(UpdateCommand.Add, dirEntry));
        }

        #endregion

        #region Modifying Entries
        /* Modify not yet ready for public consumption.
   Direct modification of an entry should not overwrite original data before its read.
   Safe mode is trivial in this sense.
		public void Modify(ZipEntry original, ZipEntry updated)
		{
			if ( original == null ) {
				throw new ArgumentNullException("original");
			}

			if ( updated == null ) {
				throw new ArgumentNullException("updated");
			}

			CheckUpdating();
			contentsEdited_ = true;
			updates_.Add(new ZipUpdate(original, updated));
		}
*/
        #endregion

        #region Deleting Entries
        /// <summary>
        /// Delete an entry by name
        /// </summary>
        /// <param name="fileName">The filename to delete</param>
        /// <returns>True if the entry was found and deleted; false otherwise.</returns>
        public bool Delete(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            CheckUpdating();

            bool result = false;
            int index = FindExistingUpdate(fileName);
            if ((index >= 0) && (updates_[index] != null))
            {
                result = true;
                contentsEdited_ = true;
                updates_[index] = null;
                updateCount_ -= 1;
            }
            else
            {
                throw new ZipException("Cannot find entry to delete");
            }
            return result;
        }

        /// <summary>
        /// Delete a <see cref="ZipEntry"/> from the archive.
        /// </summary>
        /// <param name="entry">The entry to delete.</param>
        public void Delete(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            CheckUpdating();

            int index = FindExistingUpdate(entry);
            if (index >= 0)
            {
                contentsEdited_ = true;
                updates_[index] = null;
                updateCount_ -= 1;
            }
            else
            {
                throw new ZipException("Cannot find entry to delete");
            }
        }

        #endregion

        #region Update Support

        #region Writing Values/Headers
        void WriteLEShort(int value)
        {
            baseStream_.WriteByte((byte)(value & 0xff));
            baseStream_.WriteByte((byte)((value >> 8) & 0xff));
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        void WriteLEUshort(ushort value)
        {
            baseStream_.WriteByte((byte)(value & 0xff));
            baseStream_.WriteByte((byte)(value >> 8));
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        void WriteLEInt(int value)
        {
            WriteLEShort(value & 0xffff);
            WriteLEShort(value >> 16);
        }

        /// <summary>
        /// Write an unsigned int in little endian byte order.
        /// </summary>
        void WriteLEUint(uint value)
        {
            WriteLEUshort((ushort)(value & 0xffff));
            WriteLEUshort((ushort)(value >> 16));
        }

        /// <summary>
        /// Write a long in little endian byte order.
        /// </summary>
        void WriteLeLong(long value)
        {
            WriteLEInt((int)(value & 0xffffffff));
            WriteLEInt((int)(value >> 32));
        }

        void WriteLEUlong(ulong value)
        {
            WriteLEUint((uint)(value & 0xffffffff));
            WriteLEUint((uint)(value >> 32));
        }

        void WriteLocalEntryHeader(ZipUpdate update)
        {
            ZipEntry entry = update.OutEntry;

            // TODO: Local offset will require adjusting for multi-disk zip files.
            entry.Offset = baseStream_.Position;

            // TODO: Need to clear any entry flags that dont make sense or throw an exception here.
            if (update.Command != UpdateCommand.Copy)
            {
                if (entry.CompressionMethod == CompressionMethod.Deflated)
                {
                    if (entry.Size == 0)
                    {
                        // No need to compress - no data.
                        entry.CompressedSize = entry.Size;
                        entry.Crc = 0;
                        entry.CompressionMethod = CompressionMethod.Stored;
                    }
                }
                else if (entry.CompressionMethod == CompressionMethod.Stored)
                {
                    entry.Flags &= ~(int)GeneralBitFlags.Descriptor;
                }

                if (HaveKeys)
                {
                    entry.IsCrypted = true;
                    if (entry.Crc < 0)
                    {
                        entry.Flags |= (int)GeneralBitFlags.Descriptor;
                    }
                }
                else
                {
                    entry.IsCrypted = false;
                }

                switch (useZip64_)
                {
                    case UseZip64.Dynamic:
                        if (entry.Size < 0)
                        {
                            entry.ForceZip64();
                        }
                        break;

                    case UseZip64.On:
                        entry.ForceZip64();
                        break;

                    case UseZip64.Off:
                        // Do nothing.  The entry itself may be using Zip64 independantly.
                        break;
                }
            }

            // Write the local file header
            WriteLEInt(ZipConstants.LocalHeaderSignature);

            WriteLEShort(entry.Version);
            WriteLEShort(entry.Flags);

            WriteLEShort((byte)entry.CompressionMethod);
            WriteLEInt((int)entry.DosTime);

            if (!entry.HasCrc)
            {
                // Note patch address for updating CRC later.
                update.CrcPatchOffset = baseStream_.Position;
                WriteLEInt((int)0);
            }
            else
            {
                WriteLEInt(unchecked((int)entry.Crc));
            }

            if (entry.LocalHeaderRequiresZip64)
            {
                WriteLEInt(-1);
                WriteLEInt(-1);
            }
            else
            {
                if ((entry.CompressedSize < 0) || (entry.Size < 0))
                {
                    update.SizePatchOffset = baseStream_.Position;
                }

                WriteLEInt((int)entry.CompressedSize);
                WriteLEInt((int)entry.Size);
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64)
            {
                ed.StartNewEntry();

                // Local entry header always includes size and compressed size.
                // NOTE the order of these fields is reversed when compared to the normal headers!
                ed.AddLeLong(entry.Size);
                ed.AddLeLong(entry.CompressedSize);
                ed.AddNewEntry(1);
            }
            else
            {
                ed.Delete(1);
            }

            entry.ExtraData = ed.GetEntryData();

            WriteLEShort(name.Length);
            WriteLEShort(entry.ExtraData.Length);

            if (name.Length > 0)
            {
                baseStream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64)
            {
                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cannot find extra data");
                }

                update.SizePatchOffset = baseStream_.Position + ed.CurrentReadIndex;
            }

            if (entry.ExtraData.Length > 0)
            {
                baseStream_.Write(entry.ExtraData, 0, entry.ExtraData.Length);
            }
        }

        int WriteCentralDirectoryHeader(ZipEntry entry)
        {
            if (entry.CompressedSize < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown csize");
            }

            if (entry.Size < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown size");
            }

            if (entry.Crc < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown crc");
            }

            // Write the central file header
            WriteLEInt(ZipConstants.CentralHeaderSignature);

            // Version made by
            WriteLEShort(ZipConstants.VersionMadeBy);

            // Version required to extract
            WriteLEShort(entry.Version);

            WriteLEShort(entry.Flags);

            unchecked
            {
                WriteLEShort((byte)entry.CompressionMethod);
                WriteLEInt((int)entry.DosTime);
                WriteLEInt((int)entry.Crc);
            }

            if ((entry.IsZip64Forced()) || (entry.CompressedSize >= 0xffffffff))
            {
                WriteLEInt(-1);
            }
            else
            {
                WriteLEInt((int)(entry.CompressedSize & 0xffffffff));
            }

            if ((entry.IsZip64Forced()) || (entry.Size >= 0xffffffff))
            {
                WriteLEInt(-1);
            }
            else
            {
                WriteLEInt((int)entry.Size);
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name is too long.");
            }

            WriteLEShort(name.Length);

            // Central header extra data is different to local header version so regenerate.
            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.CentralHeaderRequiresZip64)
            {
                ed.StartNewEntry();

                if ((entry.Size >= 0xffffffff) || (useZip64_ == UseZip64.On))
                {
                    ed.AddLeLong(entry.Size);
                }

                if ((entry.CompressedSize >= 0xffffffff) || (useZip64_ == UseZip64.On))
                {
                    ed.AddLeLong(entry.CompressedSize);
                }

                if (entry.Offset >= 0xffffffff)
                {
                    ed.AddLeLong(entry.Offset);
                }

                // Number of disk on which this file starts isnt supported and is never written here.
                ed.AddNewEntry(1);
            }
            else
            {
                // Should have already be done when local header was added.
                ed.Delete(1);
            }

            byte[] centralExtraData = ed.GetEntryData();

            WriteLEShort(centralExtraData.Length);
            WriteLEShort(entry.Comment != null ? entry.Comment.Length : 0);

            WriteLEShort(0);	// disk number
            WriteLEShort(0);	// internal file attributes

            // External file attributes...
            if (entry.ExternalFileAttributes != -1)
            {
                WriteLEInt(entry.ExternalFileAttributes);
            }
            else
            {
                if (entry.IsDirectory)
                {
                    WriteLEUint(16);
                }
                else
                {
                    WriteLEUint(0);
                }
            }

            if (entry.Offset >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);
            }
            else
            {
                WriteLEUint((uint)(int)entry.Offset);
            }

            if (name.Length > 0)
            {
                baseStream_.Write(name, 0, name.Length);
            }

            if (centralExtraData.Length > 0)
            {
                baseStream_.Write(centralExtraData, 0, centralExtraData.Length);
            }

            byte[] rawComment = (entry.Comment != null) ? Encoding.ASCII.GetBytes(entry.Comment) : new byte[0];

            if (rawComment.Length > 0)
            {
                baseStream_.Write(rawComment, 0, rawComment.Length);
            }

            return ZipConstants.CentralHeaderBaseSize + name.Length + centralExtraData.Length + rawComment.Length;
        }
        #endregion

        void PostUpdateCleanup()
        {
            updateDataSource_ = null;
            updates_ = null;
            updateIndex_ = null;

            if (archiveStorage_ != null)
            {
                archiveStorage_.Dispose();
                archiveStorage_ = null;
            }
        }

        string GetTransformedFileName(string name)
        {
            INameTransform transform = NameTransform;
            return (transform != null) ?
                transform.TransformFile(name) :
                name;
        }

        string GetTransformedDirectoryName(string name)
        {
            INameTransform transform = NameTransform;
            return (transform != null) ?
                transform.TransformDirectory(name) :
                name;
        }

        /// <summary>
        /// Get a raw memory buffer.
        /// </summary>
        /// <returns>Returns a raw memory buffer.</returns>
        byte[] GetBuffer()
        {
            if (copyBuffer_ == null)
            {
                copyBuffer_ = new byte[bufferSize_];
            }
            return copyBuffer_;
        }

        void CopyDescriptorBytes(ZipUpdate update, Stream dest, Stream source)
        {
            int bytesToCopy = GetDescriptorSize(update);

            if (bytesToCopy > 0)
            {
                byte[] buffer = GetBuffer();

                while (bytesToCopy > 0)
                {
                    int readSize = Math.Min(buffer.Length, bytesToCopy);

                    int bytesRead = source.Read(buffer, 0, readSize);
                    if (bytesRead > 0)
                    {
                        dest.Write(buffer, 0, bytesRead);
                        bytesToCopy -= bytesRead;
                    }
                    else
                    {
                        throw new ZipException("Unxpected end of stream");
                    }
                }
            }
        }

        void CopyBytes(ZipUpdate update, Stream destination, Stream source,
            long bytesToCopy, bool updateCrc)
        {
            if (destination == source)
            {
                throw new InvalidOperationException("Destination and source are the same");
            }

            // NOTE: Compressed size is updated elsewhere.
            Crc32 crc = new Crc32();
            byte[] buffer = GetBuffer();

            long targetBytes = bytesToCopy;
            long totalBytesRead = 0;

            int bytesRead;
            do
            {
                int readSize = buffer.Length;

                if (bytesToCopy < readSize)
                {
                    readSize = (int)bytesToCopy;
                }

                bytesRead = source.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    if (updateCrc)
                    {
                        crc.Update(buffer, 0, bytesRead);
                    }
                    destination.Write(buffer, 0, bytesRead);
                    bytesToCopy -= bytesRead;
                    totalBytesRead += bytesRead;
                }
            }
            while ((bytesRead > 0) && (bytesToCopy > 0));

            if (totalBytesRead != targetBytes)
            {
                throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", targetBytes, totalBytesRead));
            }

            if (updateCrc)
            {
                update.OutEntry.Crc = crc.Value;
            }
        }

        /// <summary>
        /// Get the size of the source descriptor for a <see cref="ZipUpdate"/>.
        /// </summary>
        /// <param name="update">The update to get the size for.</param>
        /// <returns>The descriptor size, zero if there isnt one.</returns>
        int GetDescriptorSize(ZipUpdate update)
        {
            int result = 0;
            if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)
            {
                result = ZipConstants.DataDescriptorSize - 4;
                if (update.Entry.LocalHeaderRequiresZip64)
                {
                    result = ZipConstants.Zip64DataDescriptorSize - 4;
                }
            }
            return result;
        }

        void CopyDescriptorBytesDirect(ZipUpdate update, Stream stream, ref long destinationPosition, long sourcePosition)
        {
            int bytesToCopy = GetDescriptorSize(update);

            while (bytesToCopy > 0)
            {
                int readSize = (int)bytesToCopy;
                byte[] buffer = GetBuffer();

                stream.Position = sourcePosition;
                int bytesRead = stream.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    stream.Position = destinationPosition;
                    stream.Write(buffer, 0, bytesRead);
                    bytesToCopy -= bytesRead;
                    destinationPosition += bytesRead;
                    sourcePosition += bytesRead;
                }
                else
                {
                    throw new ZipException("Unxpected end of stream");
                }
            }
        }

        void CopyEntryDataDirect(ZipUpdate update, Stream stream, bool updateCrc, ref long destinationPosition, ref long sourcePosition)
        {
            long bytesToCopy = update.Entry.CompressedSize;

            // NOTE: Compressed size is updated elsewhere.
            Crc32 crc = new Crc32();
            byte[] buffer = GetBuffer();

            long targetBytes = bytesToCopy;
            long totalBytesRead = 0;

            int bytesRead;
            do
            {
                int readSize = buffer.Length;

                if (bytesToCopy < readSize)
                {
                    readSize = (int)bytesToCopy;
                }

                stream.Position = sourcePosition;
                bytesRead = stream.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    if (updateCrc)
                    {
                        crc.Update(buffer, 0, bytesRead);
                    }
                    stream.Position = destinationPosition;
                    stream.Write(buffer, 0, bytesRead);

                    destinationPosition += bytesRead;
                    sourcePosition += bytesRead;
                    bytesToCopy -= bytesRead;
                    totalBytesRead += bytesRead;
                }
            }
            while ((bytesRead > 0) && (bytesToCopy > 0));

            if (totalBytesRead != targetBytes)
            {
                throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", targetBytes, totalBytesRead));
            }

            if (updateCrc)
            {
                update.OutEntry.Crc = crc.Value;
            }
        }

        int FindExistingUpdate(ZipEntry entry)
        {
            int result = -1;
            string convertedName = GetTransformedFileName(entry.Name);

            if (updateIndex_.ContainsKey(convertedName))
            {
                result = (int)updateIndex_[convertedName];
            }
            /*
                        // This is slow like the coming of the next ice age but takes less storage and may be useful
                        // for CF?
                        for (int index = 0; index < updates_.Count; ++index)
                        {
                            ZipUpdate zu = ( ZipUpdate )updates_[index];
                            if ( (zu.Entry.ZipFileIndex == entry.ZipFileIndex) &&
                                (string.Compare(convertedName, zu.Entry.Name, true, CultureInfo.InvariantCulture) == 0) ) {
                                result = index;
                                break;
                            }
                        }
             */
            return result;
        }

        int FindExistingUpdate(string fileName)
        {
            int result = -1;

            string convertedName = GetTransformedFileName(fileName);

            if (updateIndex_.ContainsKey(convertedName))
            {
                result = (int)updateIndex_[convertedName];
            }

            /*
                        // This is slow like the coming of the next ice age but takes less storage and may be useful
                        // for CF?
                        for ( int index = 0; index < updates_.Count; ++index ) {
                            if ( string.Compare(convertedName, (( ZipUpdate )updates_[index]).Entry.Name,
                                true, CultureInfo.InvariantCulture) == 0 ) {
                                result = index;
                                break;
                            }
                        }
             */

            return result;
        }

        /// <summary>
        /// Get an output stream for the specified <see cref="ZipEntry"/>
        /// </summary>
        /// <param name="entry">The entry to get an output stream for.</param>
        /// <returns>The output stream obtained for the entry.</returns>
        Stream GetOutputStream(ZipEntry entry)
        {
            Stream result = baseStream_;

            if (entry.IsCrypted == true)
            {
#if NETCF_1_0
				throw new ZipException("Encryption not supported for Compact Framework 1.0");
#else
                result = CreateAndInitEncryptionStream(result, entry);
#endif
            }

            switch (entry.CompressionMethod)
            {
                case CompressionMethod.Stored:
                    result = new UncompressedStream(result);
                    break;

                case CompressionMethod.Deflated:
                    DeflaterOutputStream dos = new DeflaterOutputStream(result, new Deflater(9, true));
                    dos.IsStreamOwner = false;
                    result = dos;
                    break;

                default:
                    throw new ZipException("Unknown compression method " + entry.CompressionMethod);
            }
            return result;
        }

        void AddEntry(ZipFile workFile, ZipUpdate update)
        {
            Stream source = null;

            if (update.Entry.IsFile)
            {
                source = update.GetSource();

                if (source == null)
                {
                    source = updateDataSource_.GetSource(update.Entry, update.Filename);
                }
            }

            if (source != null)
            {
                using (source)
                {
                    long sourceStreamLength = source.Length;
                    if (update.OutEntry.Size < 0)
                    {
                        update.OutEntry.Size = sourceStreamLength;
                    }
                    else
                    {
                        // Check for errant entries.
                        if (update.OutEntry.Size != sourceStreamLength)
                        {
                            throw new ZipException("Entry size/stream size mismatch");
                        }
                    }

                    workFile.WriteLocalEntryHeader(update);

                    long dataStart = workFile.baseStream_.Position;

                    using (Stream output = workFile.GetOutputStream(update.OutEntry))
                    {
                        CopyBytes(update, output, source, sourceStreamLength, true);
                    }

                    long dataEnd = workFile.baseStream_.Position;
                    update.OutEntry.CompressedSize = dataEnd - dataStart;

                    if ((update.OutEntry.Flags & (int)GeneralBitFlags.Descriptor) == (int)GeneralBitFlags.Descriptor)
                    {
                        ZipHelperStream helper = new ZipHelperStream(workFile.baseStream_);
                        helper.WriteDataDescriptor(update.OutEntry);
                    }
                }
            }
            else
            {
                workFile.WriteLocalEntryHeader(update);
                update.OutEntry.CompressedSize = 0;
            }

        }

        void ModifyEntry(ZipFile workFile, ZipUpdate update)
        {
            workFile.WriteLocalEntryHeader(update);
            long dataStart = workFile.baseStream_.Position;

            // TODO: This is slow if the changes don't effect the data!!
            if (update.Entry.IsFile && (update.Filename != null))
            {
                using (Stream output = workFile.GetOutputStream(update.OutEntry))
                {
                    using (Stream source = this.GetInputStream(update.Entry))
                    {
                        CopyBytes(update, output, source, source.Length, true);
                    }
                }
            }

            long dataEnd = workFile.baseStream_.Position;
            update.Entry.CompressedSize = dataEnd - dataStart;
        }

        void CopyEntryDirect(ZipFile workFile, ZipUpdate update, ref long destinationPosition)
        {
            bool skipOver = false;
            if (update.Entry.Offset == destinationPosition)
            {
                skipOver = true;
            }

            if (!skipOver)
            {
                baseStream_.Position = destinationPosition;
                workFile.WriteLocalEntryHeader(update);
                destinationPosition = baseStream_.Position;
            }

            long sourcePosition = 0;

            const int NameLengthOffset = 26;

            // TODO: Add base for SFX friendly handling
            long entryDataOffset = update.Entry.Offset + NameLengthOffset;

            baseStream_.Seek(entryDataOffset, SeekOrigin.Begin);

            // Clumsy way of handling retrieving the original name and extra data length for now.
            // TODO: Stop re-reading name and data length in CopyEntryDirect.
            uint nameLength = ReadLEUshort();
            uint extraLength = ReadLEUshort();

            sourcePosition = baseStream_.Position + nameLength + extraLength;

            if (skipOver)
            {
                if (update.OffsetBasedSize != -1)
                    destinationPosition += update.OffsetBasedSize;
                else
                    // TODO: Find out why this calculation comes up 4 bytes short on some entries in ODT (Office Document Text) archives.
                    // WinZip produces a warning on these entries:
                    // "caution: value of lrec.csize (compressed size) changed from ..."
                    destinationPosition +=
                        (sourcePosition - entryDataOffset) + NameLengthOffset +	// Header size
                        update.Entry.CompressedSize + GetDescriptorSize(update);
            }
            else
            {
                if (update.Entry.CompressedSize > 0)
                {
                    CopyEntryDataDirect(update, baseStream_, false, ref destinationPosition, ref sourcePosition);
                }
                CopyDescriptorBytesDirect(update, baseStream_, ref destinationPosition, sourcePosition);
            }
        }

        void CopyEntry(ZipFile workFile, ZipUpdate update)
        {
            workFile.WriteLocalEntryHeader(update);

            if (update.Entry.CompressedSize > 0)
            {
                const int NameLengthOffset = 26;

                long entryDataOffset = update.Entry.Offset + NameLengthOffset;

                // TODO: This wont work for SFX files!
                baseStream_.Seek(entryDataOffset, SeekOrigin.Begin);

                uint nameLength = ReadLEUshort();
                uint extraLength = ReadLEUshort();

                baseStream_.Seek(nameLength + extraLength, SeekOrigin.Current);

                CopyBytes(update, workFile.baseStream_, baseStream_, update.Entry.CompressedSize, false);
            }
            CopyDescriptorBytes(update, workFile.baseStream_, baseStream_);
        }

        void Reopen(Stream source)
        {
            if (source == null)
            {
                throw new ZipException("Failed to reopen archive - no source");
            }

            isNewArchive_ = false;
            baseStream_ = source;
            ReadEntries();
        }

        void Reopen()
        {
            if (Name == null)
            {
                throw new InvalidOperationException("Name is not known cannot Reopen");
            }

            Reopen(File.Open(Name, FileMode.Open, FileAccess.Read, FileShare.Read));
        }

        void UpdateCommentOnly()
        {
            long baseLength = baseStream_.Length;

            ZipHelperStream updateFile = null;

            if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)
            {
                Stream copyStream = archiveStorage_.MakeTemporaryCopy(baseStream_);
                updateFile = new ZipHelperStream(copyStream);
                updateFile.IsStreamOwner = true;

                baseStream_.Close();
                baseStream_ = null;
            }
            else
            {
                if (archiveStorage_.UpdateMode == FileUpdateMode.Direct)
                {
                    // TODO: archiveStorage wasnt originally intended for this use.
                    // Need to revisit this to tidy up handling as archive storage currently doesnt 
                    // handle the original stream well.
                    // The problem is when using an existing zip archive with an in memory archive storage.
                    // The open stream wont support writing but the memory storage should open the same file not an in memory one.

                    // Need to tidy up the archive storage interface and contract basically.
                    baseStream_ = archiveStorage_.OpenForDirectUpdate(baseStream_);
                    updateFile = new ZipHelperStream(baseStream_);
                }
                else
                {
                    baseStream_.Close();
                    baseStream_ = null;
                    updateFile = new ZipHelperStream(Name);
                }
            }

            using (updateFile)
            {
                long locatedCentralDirOffset =
                    updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature,
                                                        baseLength, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);
                if (locatedCentralDirOffset < 0)
                {
                    throw new ZipException("Cannot find central directory");
                }

                const int CentralHeaderCommentSizeOffset = 16;
                updateFile.Position += CentralHeaderCommentSizeOffset;

                byte[] rawComment = newComment_.RawComment;

                updateFile.WriteLEShort(rawComment.Length);
                updateFile.Write(rawComment, 0, rawComment.Length);
                updateFile.SetLength(updateFile.Position);
            }

            if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)
            {
                Reopen(archiveStorage_.ConvertTemporaryToFinal());
            }
            else
            {
                ReadEntries();
            }
        }

        /// <summary>
        /// Class used to sort updates.
        /// </summary>
        class UpdateComparer : IComparer
        {
            /// <summary>
            /// Compares two objects and returns a value indicating whether one is 
            /// less than, equal to or greater than the other.
            /// </summary>
            /// <param name="x">First object to compare</param>
            /// <param name="y">Second object to compare.</param>
            /// <returns>Compare result.</returns>
            public int Compare(
                object x,
                object y)
            {
                ZipUpdate zx = x as ZipUpdate;
                ZipUpdate zy = y as ZipUpdate;

                int result;

                if (zx == null)
                {
                    if (zy == null)
                    {
                        result = 0;
                    }
                    else
                    {
                        result = -1;
                    }
                }
                else if (zy == null)
                {
                    result = 1;
                }
                else
                {
                    int xCmdValue = ((zx.Command == UpdateCommand.Copy) || (zx.Command == UpdateCommand.Modify)) ? 0 : 1;
                    int yCmdValue = ((zy.Command == UpdateCommand.Copy) || (zy.Command == UpdateCommand.Modify)) ? 0 : 1;

                    result = xCmdValue - yCmdValue;
                    if (result == 0)
                    {
                        long offsetDiff = zx.Entry.Offset - zy.Entry.Offset;
                        if (offsetDiff < 0)
                        {
                            result = -1;
                        }
                        else if (offsetDiff == 0)
                        {
                            result = 0;
                        }
                        else
                        {
                            result = 1;
                        }
                    }
                }
                return result;
            }
        }

        void RunUpdates()
        {
            long sizeEntries = 0;
            long endOfStream = 0;
            bool directUpdate = false;
            long destinationPosition = 0; // NOT SFX friendly

            ZipFile workFile;

            if (IsNewArchive)
            {
                workFile = this;
                workFile.baseStream_.Position = 0;
                directUpdate = true;
            }
            else if (archiveStorage_.UpdateMode == FileUpdateMode.Direct)
            {
                workFile = this;
                workFile.baseStream_.Position = 0;
                directUpdate = true;

                // Sort the updates by offset within copies/modifies, then adds.
                // This ensures that data required by copies will not be overwritten.
                updates_.Sort(new UpdateComparer());
            }
            else
            {
                workFile = ZipFile.Create(archiveStorage_.GetTemporaryOutput());
                workFile.UseZip64 = UseZip64;

                if (key != null)
                {
                    workFile.key = (byte[])key.Clone();
                }
            }

            try
            {
                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        switch (update.Command)
                        {
                            case UpdateCommand.Copy:
                                if (directUpdate)
                                {
                                    CopyEntryDirect(workFile, update, ref destinationPosition);
                                }
                                else
                                {
                                    CopyEntry(workFile, update);
                                }
                                break;

                            case UpdateCommand.Modify:
                                // TODO: Direct modifying of an entry will take some legwork.
                                ModifyEntry(workFile, update);
                                break;

                            case UpdateCommand.Add:
                                if (!IsNewArchive && directUpdate)
                                {
                                    workFile.baseStream_.Position = destinationPosition;
                                }

                                AddEntry(workFile, update);

                                if (directUpdate)
                                {
                                    destinationPosition = workFile.baseStream_.Position;
                                }
                                break;
                        }
                    }
                }

                if (!IsNewArchive && directUpdate)
                {
                    workFile.baseStream_.Position = destinationPosition;
                }

                long centralDirOffset = workFile.baseStream_.Position;

                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        sizeEntries += workFile.WriteCentralDirectoryHeader(update.OutEntry);
                    }
                }

                byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipConstants.ConvertToArray(comment_);
                using (ZipHelperStream zhs = new ZipHelperStream(workFile.baseStream_))
                {
                    zhs.WriteEndOfCentralDirectory(updateCount_, sizeEntries, centralDirOffset, theComment);
                }

                endOfStream = workFile.baseStream_.Position;

                // And now patch entries...
                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        // If the size of the entry is zero leave the crc as 0 as well.
                        // The calculated crc will be all bits on...
                        if ((update.CrcPatchOffset > 0) && (update.OutEntry.CompressedSize > 0))
                        {
                            workFile.baseStream_.Position = update.CrcPatchOffset;
                            workFile.WriteLEInt((int)update.OutEntry.Crc);
                        }

                        if (update.SizePatchOffset > 0)
                        {
                            workFile.baseStream_.Position = update.SizePatchOffset;
                            if (update.OutEntry.LocalHeaderRequiresZip64)
                            {
                                workFile.WriteLeLong(update.OutEntry.Size);
                                workFile.WriteLeLong(update.OutEntry.CompressedSize);
                            }
                            else
                            {
                                workFile.WriteLEInt((int)update.OutEntry.CompressedSize);
                                workFile.WriteLEInt((int)update.OutEntry.Size);
                            }
                        }
                    }
                }
            }
            catch
            {
                workFile.Close();
                if (!directUpdate && (workFile.Name != null))
                {
                    File.Delete(workFile.Name);
                }
                throw;
            }

            if (directUpdate)
            {
                workFile.baseStream_.SetLength(endOfStream);
                workFile.baseStream_.Flush();
                isNewArchive_ = false;
                ReadEntries();
            }
            else
            {
                baseStream_.Close();
                Reopen(archiveStorage_.ConvertTemporaryToFinal());
            }
        }

        void CheckUpdating()
        {
            if (updates_ == null)
            {
                throw new InvalidOperationException("BeginUpdate has not been called");
            }
        }

        #endregion

        #region ZipUpdate class
        /// <summary>
        /// Represents a pending update to a Zip file.
        /// </summary>
        class ZipUpdate
        {
            #region Constructors
            public ZipUpdate(string fileName, ZipEntry entry)
            {
                command_ = UpdateCommand.Add;
                entry_ = entry;
                filename_ = fileName;
            }

            [Obsolete]
            public ZipUpdate(string fileName, string entryName, CompressionMethod compressionMethod)
            {
                command_ = UpdateCommand.Add;
                entry_ = new ZipEntry(entryName);
                entry_.CompressionMethod = compressionMethod;
                filename_ = fileName;
            }

            [Obsolete]
            public ZipUpdate(string fileName, string entryName)
                : this(fileName, entryName, CompressionMethod.Deflated)
            {
                // Do nothing.
            }

            [Obsolete]
            public ZipUpdate(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod)
            {
                command_ = UpdateCommand.Add;
                entry_ = new ZipEntry(entryName);
                entry_.CompressionMethod = compressionMethod;
                dataSource_ = dataSource;
            }

            public ZipUpdate(IStaticDataSource dataSource, ZipEntry entry)
            {
                command_ = UpdateCommand.Add;
                entry_ = entry;
                dataSource_ = dataSource;
            }

            public ZipUpdate(ZipEntry original, ZipEntry updated)
            {
                throw new ZipException("Modify not currently supported");
                /*
                    command_ = UpdateCommand.Modify;
                    entry_ = ( ZipEntry )original.Clone();
                    outEntry_ = ( ZipEntry )updated.Clone();
                */
            }

            public ZipUpdate(UpdateCommand command, ZipEntry entry)
            {
                command_ = command;
                entry_ = (ZipEntry)entry.Clone();
            }


            /// <summary>
            /// Copy an existing entry.
            /// </summary>
            /// <param name="entry">The existing entry to copy.</param>
            public ZipUpdate(ZipEntry entry)
                : this(UpdateCommand.Copy, entry)
            {
                // Do nothing.
            }
            #endregion

            /// <summary>
            /// Get the <see cref="ZipEntry"/> for this update.
            /// </summary>
            /// <remarks>This is the source or original entry.</remarks>
            public ZipEntry Entry
            {
                get { return entry_; }
            }

            /// <summary>
            /// Get the <see cref="ZipEntry"/> that will be written to the updated/new file.
            /// </summary>
            public ZipEntry OutEntry
            {
                get
                {
                    if (outEntry_ == null)
                    {
                        outEntry_ = (ZipEntry)entry_.Clone();
                    }

                    return outEntry_;
                }
            }

            /// <summary>
            /// Get the command for this update.
            /// </summary>
            public UpdateCommand Command
            {
                get { return command_; }
            }

            /// <summary>
            /// Get the filename if any for this update.  Null if none exists.
            /// </summary>
            public string Filename
            {
                get { return filename_; }
            }

            /// <summary>
            /// Get/set the location of the size patch for this update.
            /// </summary>
            public long SizePatchOffset
            {
                get { return sizePatchOffset_; }
                set { sizePatchOffset_ = value; }
            }

            /// <summary>
            /// Get /set the location of the crc patch for this update.
            /// </summary>
            public long CrcPatchOffset
            {
                get { return crcPatchOffset_; }
                set { crcPatchOffset_ = value; }
            }

            /// <summary>
            /// Get/set the size calculated by offset.
            /// Specifically, the difference between this and next entry's starting offset.
            /// </summary>
            public long OffsetBasedSize
            {
                get { return _offsetBasedSize; }
                set { _offsetBasedSize = value; }
            }

            public Stream GetSource()
            {
                Stream result = null;
                if (dataSource_ != null)
                {
                    result = dataSource_.GetSource();
                }

                return result;
            }

            #region Instance Fields
            ZipEntry entry_;
            ZipEntry outEntry_;
            UpdateCommand command_;
            IStaticDataSource dataSource_;
            string filename_;
            long sizePatchOffset_ = -1;
            long crcPatchOffset_ = -1;
            long _offsetBasedSize = -1;
            #endregion
        }

        #endregion
        #endregion

        #region Disposing

        #region IDisposable Members
        void IDisposable.Dispose()
        {
            Close();
        }
        #endregion

        void DisposeInternal(bool disposing)
        {
            if (!isDisposed_)
            {
                isDisposed_ = true;
                entries_ = new ZipEntry[0];

                if (IsStreamOwner && (baseStream_ != null))
                {
                    lock (baseStream_)
                    {
                        baseStream_.Close();
                    }
                }

                PostUpdateCleanup();
            }
        }

        /// <summary>
        /// Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources;
        /// false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            DisposeInternal(disposing);
        }

        #endregion

        #region Internal routines
        #region Reading
        /// <summary>
        /// Read an unsigned short in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="EndOfStreamException">
        /// The stream ends prematurely
        /// </exception>
        ushort ReadLEUshort()
        {
            int data1 = baseStream_.ReadByte();

            if (data1 < 0)
            {
                throw new EndOfStreamException("End of stream");
            }

            int data2 = baseStream_.ReadByte();

            if (data2 < 0)
            {
                throw new EndOfStreamException("End of stream");
            }


            return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));
        }

        /// <summary>
        /// Read a uint in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        uint ReadLEUint()
        {
            return (uint)(ReadLEUshort() | (ReadLEUshort() << 16));
        }

        ulong ReadLEUlong()
        {
            return ReadLEUint() | ((ulong)ReadLEUint() << 32);
        }

        #endregion
        // NOTE this returns the offset of the first byte after the signature.
        long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)
        {
            using (ZipHelperStream les = new ZipHelperStream(baseStream_))
            {
                return les.LocateBlockWithSignature(signature, endLocation, minimumBlockSize, maximumVariableData);
            }
        }

        /// <summary>
        /// Search for and read the central directory of a zip file filling the entries array.
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The central directory is malformed or cannot be found
        /// </exception>
        void ReadEntries()
        {
            // Search for the End Of Central Directory.  When a zip comment is
            // present the directory will start earlier
            // 
            // The search is limited to 64K which is the maximum size of a trailing comment field to aid speed.
            // This should be compatible with both SFX and ZIP files but has only been tested for Zip files
            // If a SFX file has the Zip data attached as a resource and there are other resources occuring later then
            // this could be invalid.
            // Could also speed this up by reading memory in larger blocks.			

            if (baseStream_.CanSeek == false)
            {
                throw new ZipException("ZipFile stream must be seekable");
            }

            long locatedEndOfCentralDir = LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature,
                baseStream_.Length, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);

            if (locatedEndOfCentralDir < 0)
            {
                throw new ZipException("Cannot find central directory");
            }

            // Read end of central directory record
            ushort thisDiskNumber = ReadLEUshort();
            ushort startCentralDirDisk = ReadLEUshort();
            ulong entriesForThisDisk = ReadLEUshort();
            ulong entriesForWholeCentralDir = ReadLEUshort();
            ulong centralDirSize = ReadLEUint();
            long offsetOfCentralDir = ReadLEUint();
            uint commentSize = ReadLEUshort();

            if (commentSize > 0)
            {
                byte[] comment = new byte[commentSize];

                StreamUtils.ReadFully(baseStream_, comment);
                comment_ = ZipConstants.ConvertToString(comment);
            }
            else
            {
                comment_ = string.Empty;
            }

            bool isZip64 = false;

            // Check if zip64 header information is required.
            if ((thisDiskNumber == 0xffff) ||
                (startCentralDirDisk == 0xffff) ||
                (entriesForThisDisk == 0xffff) ||
                (entriesForWholeCentralDir == 0xffff) ||
                (centralDirSize == 0xffffffff) ||
                (offsetOfCentralDir == 0xffffffff))
            {
                isZip64 = true;

                long offset = LocateBlockWithSignature(ZipConstants.Zip64CentralDirLocatorSignature, locatedEndOfCentralDir, 0, 0x1000);
                if (offset < 0)
                {
                    throw new ZipException("Cannot find Zip64 locator");
                }

                // number of the disk with the start of the zip64 end of central directory 4 bytes 
                // relative offset of the zip64 end of central directory record 8 bytes 
                // total number of disks 4 bytes 
                ReadLEUint(); // startDisk64 is not currently used
                ulong offset64 = ReadLEUlong();
                uint totalDisks = ReadLEUint();

                baseStream_.Position = (long)offset64;
                long sig64 = ReadLEUint();

                if (sig64 != ZipConstants.Zip64CentralFileHeaderSignature)
                {
                    throw new ZipException(string.Format("Invalid Zip64 Central directory signature at {0:X}", offset64));
                }

                // NOTE: Record size = SizeOfFixedFields + SizeOfVariableData - 12.
                ulong recordSize = ReadLEUlong();
                int versionMadeBy = ReadLEUshort();
                int versionToExtract = ReadLEUshort();
                uint thisDisk = ReadLEUint();
                uint centralDirDisk = ReadLEUint();
                entriesForThisDisk = ReadLEUlong();
                entriesForWholeCentralDir = ReadLEUlong();
                centralDirSize = ReadLEUlong();
                offsetOfCentralDir = (long)ReadLEUlong();

                // NOTE: zip64 extensible data sector (variable size) is ignored.
            }

            entries_ = new ZipEntry[entriesForThisDisk];

            // SFX/embedded support, find the offset of the first entry vis the start of the stream
            // This applies to Zip files that are appended to the end of an SFX stub.
            // Or are appended as a resource to an executable.
            // Zip files created by some archivers have the offsets altered to reflect the true offsets
            // and so dont require any adjustment here...
            // TODO: Difficulty with Zip64 and SFX offset handling needs resolution - maths?
            if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize)))
            {
                offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);
                if (offsetOfFirstEntry <= 0)
                {
                    throw new ZipException("Invalid embedded zip archive");
                }
            }

            baseStream_.Seek(offsetOfFirstEntry + offsetOfCentralDir, SeekOrigin.Begin);

            for (ulong i = 0; i < entriesForThisDisk; i++)
            {
                if (ReadLEUint() != ZipConstants.CentralHeaderSignature)
                {
                    throw new ZipException("Wrong Central Directory signature");
                }

                int versionMadeBy = ReadLEUshort();
                int versionToExtract = ReadLEUshort();
                int bitFlags = ReadLEUshort();
                int method = ReadLEUshort();
                uint dostime = ReadLEUint();
                uint crc = ReadLEUint();
                long csize = (long)ReadLEUint();
                long size = (long)ReadLEUint();
                int nameLen = ReadLEUshort();
                int extraLen = ReadLEUshort();
                int commentLen = ReadLEUshort();

                int diskStartNo = ReadLEUshort();  // Not currently used
                int internalAttributes = ReadLEUshort();  // Not currently used

                uint externalAttributes = ReadLEUint();
                long offset = ReadLEUint();

                byte[] buffer = new byte[Math.Max(nameLen, commentLen)];

                StreamUtils.ReadFully(baseStream_, buffer, 0, nameLen);
                string name = ZipConstants.ConvertToStringExt(bitFlags, buffer, nameLen);

                ZipEntry entry = new ZipEntry(name, versionToExtract, versionMadeBy, (CompressionMethod)method);
                entry.Crc = crc & 0xffffffffL;
                entry.Size = size & 0xffffffffL;
                entry.CompressedSize = csize & 0xffffffffL;
                entry.Flags = bitFlags;
                entry.DosTime = (uint)dostime;
                entry.ZipFileIndex = (long)i;
                entry.Offset = offset;
                entry.ExternalFileAttributes = (int)externalAttributes;

                if ((bitFlags & 8) == 0)
                {
                    entry.CryptoCheckValue = (byte)(crc >> 24);
                }
                else
                {
                    entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);
                }

                if (extraLen > 0)
                {
                    byte[] extra = new byte[extraLen];
                    StreamUtils.ReadFully(baseStream_, extra);
                    entry.ExtraData = extra;
                }

                entry.ProcessExtraData(false);

                if (commentLen > 0)
                {
                    StreamUtils.ReadFully(baseStream_, buffer, 0, commentLen);
                    entry.Comment = ZipConstants.ConvertToStringExt(bitFlags, buffer, commentLen);
                }

                entries_[i] = entry;
            }
        }

        /// <summary>
        /// Locate the data for a given entry.
        /// </summary>
        /// <returns>
        /// The start offset of the data.
        /// </returns>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The stream ends prematurely
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The local header signature is invalid, the entry and central header file name lengths are different
        /// or the local and entry compression methods dont match
        /// </exception>
        long LocateEntry(ZipEntry entry)
        {
            return TestLocalHeader(entry, HeaderTest.Extract);
        }

#if !NETCF_1_0
        Stream CreateAndInitDecryptionStream(Stream baseStream, ZipEntry entry)
        {
            CryptoStream result = null;

            if ((entry.Version < ZipConstants.VersionStrongEncryption)
                || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0)
            {
                PkzipClassicManaged classicManaged = new PkzipClassicManaged();

                OnKeysRequired(entry.Name);
                if (HaveKeys == false)
                {
                    throw new ZipException("No password available for encrypted stream");
                }

                result = new CryptoStream(baseStream, classicManaged.CreateDecryptor(key, null), CryptoStreamMode.Read);
                CheckClassicPassword(result, entry);
            }
            else
            {
#if !NET_1_1 && !NETCF_2_0
                if (entry.Version == ZipConstants.VERSION_AES)
                {
                    //
                    OnKeysRequired(entry.Name);
                    if (HaveKeys == false)
                    {
                        throw new ZipException("No password available for AES encrypted stream");
                    }
                    int saltLen = entry.AESSaltLen;
                    byte[] saltBytes = new byte[saltLen];
                    int saltIn = baseStream.Read(saltBytes, 0, saltLen);
                    if (saltIn != saltLen)
                        throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);
                    //
                    byte[] pwdVerifyRead = new byte[2];
                    baseStream.Read(pwdVerifyRead, 0, 2);
                    int blockSize = entry.AESKeySize / 8;	// bits to bytes

                    ZipAESTransform decryptor = new ZipAESTransform(rawPassword_, saltBytes, blockSize, false);
                    byte[] pwdVerifyCalc = decryptor.PwdVerifier;
                    if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])
                        throw new Exception("Invalid password for AES");
                    result = new ZipAESStream(baseStream, decryptor, CryptoStreamMode.Read);
                }
                else
#endif
                {
                    throw new ZipException("Decryption method not supported");
                }
            }

            return result;
        }

        Stream CreateAndInitEncryptionStream(Stream baseStream, ZipEntry entry)
        {
            CryptoStream result = null;
            if ((entry.Version < ZipConstants.VersionStrongEncryption)
                || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0)
            {
                PkzipClassicManaged classicManaged = new PkzipClassicManaged();

                OnKeysRequired(entry.Name);
                if (HaveKeys == false)
                {
                    throw new ZipException("No password available for encrypted stream");
                }

                // Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream
                // which doesnt do this.
                result = new CryptoStream(new UncompressedStream(baseStream),
                    classicManaged.CreateEncryptor(key, null), CryptoStreamMode.Write);

                if ((entry.Crc < 0) || (entry.Flags & 8) != 0)
                {
                    WriteEncryptionHeader(result, entry.DosTime << 16);
                }
                else
                {
                    WriteEncryptionHeader(result, entry.Crc);
                }
            }
            return result;
        }

        static void CheckClassicPassword(CryptoStream classicCryptoStream, ZipEntry entry)
        {
            byte[] cryptbuffer = new byte[ZipConstants.CryptoHeaderSize];
            StreamUtils.ReadFully(classicCryptoStream, cryptbuffer);
            if (cryptbuffer[ZipConstants.CryptoHeaderSize - 1] != entry.CryptoCheckValue)
            {
                throw new ZipException("Invalid password");
            }
        }
#endif

        static void WriteEncryptionHeader(Stream stream, long crcValue)
        {
            byte[] cryptBuffer = new byte[ZipConstants.CryptoHeaderSize];
            Random rnd = new Random();
            rnd.NextBytes(cryptBuffer);
            cryptBuffer[11] = (byte)(crcValue >> 24);
            stream.Write(cryptBuffer, 0, cryptBuffer.Length);
        }

        #endregion

        #region Instance Fields
        bool isDisposed_;
        string name_;
        string comment_;
        string rawPassword_;
        Stream baseStream_;
        bool isStreamOwner;
        long offsetOfFirstEntry;
        ZipEntry[] entries_;
        byte[] key;
        bool isNewArchive_;

        // Default is dynamic which is not backwards compatible and can cause problems
        // with XP's built in compression which cant read Zip64 archives.
        // However it does avoid the situation were a large file is added and cannot be completed correctly.
        // Hint: Set always ZipEntry size before they are added to an archive and this setting isnt needed.
        UseZip64 useZip64_ = UseZip64.Dynamic;

        #region Zip Update Instance Fields
        ArrayList updates_;
        long updateCount_; // Count is managed manually as updates_ can contain nulls!
        Hashtable updateIndex_;
        IArchiveStorage archiveStorage_;
        IDynamicDataSource updateDataSource_;
        bool contentsEdited_;
        int bufferSize_ = DefaultBufferSize;
        byte[] copyBuffer_;
        ZipString newComment_;
        bool commentEdited_;
        IEntryFactory updateEntryFactory_ = new ZipEntryFactory();
        #endregion
        #endregion

        #region Support Classes
        /// <summary>
        /// Represents a string from a <see cref="ZipFile"/> which is stored as an array of bytes.
        /// </summary>
        class ZipString
        {
            #region Constructors
            /// <summary>
            /// Initialise a <see cref="ZipString"/> with a string.
            /// </summary>
            /// <param name="comment">The textual string form.</param>
            public ZipString(string comment)
            {
                comment_ = comment;
                isSourceString_ = true;
            }

            /// <summary>
            /// Initialise a <see cref="ZipString"/> using a string in its binary 'raw' form.
            /// </summary>
            /// <param name="rawString"></param>
            public ZipString(byte[] rawString)
            {
                rawComment_ = rawString;
            }
            #endregion

            /// <summary>
            /// Get a value indicating the original source of data for this instance.
            /// True if the source was a string; false if the source was binary data.
            /// </summary>
            public bool IsSourceString
            {
                get { return isSourceString_; }
            }

            /// <summary>
            /// Get the length of the comment when represented as raw bytes.
            /// </summary>
            public int RawLength
            {
                get
                {
                    MakeBytesAvailable();
                    return rawComment_.Length;
                }
            }

            /// <summary>
            /// Get the comment in its 'raw' form as plain bytes.
            /// </summary>
            public byte[] RawComment
            {
                get
                {
                    MakeBytesAvailable();
                    return (byte[])rawComment_.Clone();
                }
            }

            /// <summary>
            /// Reset the comment to its initial state.
            /// </summary>
            public void Reset()
            {
                if (isSourceString_)
                {
                    rawComment_ = null;
                }
                else
                {
                    comment_ = null;
                }
            }

            void MakeTextAvailable()
            {
                if (comment_ == null)
                {
                    comment_ = ZipConstants.ConvertToString(rawComment_);
                }
            }

            void MakeBytesAvailable()
            {
                if (rawComment_ == null)
                {
                    rawComment_ = ZipConstants.ConvertToArray(comment_);
                }
            }

            /// <summary>
            /// Implicit conversion of comment to a string.
            /// </summary>
            /// <param name="zipString">The <see cref="ZipString"/> to convert to a string.</param>
            /// <returns>The textual equivalent for the input value.</returns>
            static public implicit operator string(ZipString zipString)
            {
                zipString.MakeTextAvailable();
                return zipString.comment_;
            }

            #region Instance Fields
            string comment_;
            byte[] rawComment_;
            bool isSourceString_;
            #endregion
        }

        /// <summary>
        /// An <see cref="IEnumerator">enumerator</see> for <see cref="ZipEntry">Zip entries</see>
        /// </summary>
        class ZipEntryEnumerator : IEnumerator
        {
            #region Constructors
            public ZipEntryEnumerator(ZipEntry[] entries)
            {
                array = entries;
            }

            #endregion
            #region IEnumerator Members
            public object Current
            {
                get
                {
                    return array[index];
                }
            }

            public void Reset()
            {
                index = -1;
            }

            public bool MoveNext()
            {
                return (++index < array.Length);
            }
            #endregion
            #region Instance Fields
            ZipEntry[] array;
            int index = -1;
            #endregion
        }

        /// <summary>
        /// An <see cref="UncompressedStream"/> is a stream that you can write uncompressed data
        /// to and flush, but cannot read, seek or do anything else to.
        /// </summary>
        class UncompressedStream : Stream
        {
            #region Constructors
            public UncompressedStream(Stream baseStream)
            {
                baseStream_ = baseStream;
            }

            #endregion

            /// <summary>
            /// Close this stream instance.
            /// </summary>
            public override void Close()
            {
                // Do nothing
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports reading.
            /// </summary>
            public override bool CanRead
            {
                get
                {
                    return false;
                }
            }

            /// <summary>
            /// Write any buffered data to underlying storage.
            /// </summary>
            public override void Flush()
            {
                baseStream_.Flush();
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports writing.
            /// </summary>
            public override bool CanWrite
            {
                get
                {
                    return baseStream_.CanWrite;
                }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports seeking.
            /// </summary>
            public override bool CanSeek
            {
                get
                {
                    return false;
                }
            }

            /// <summary>
            /// Get the length in bytes of the stream.
            /// </summary>
            public override long Length
            {
                get
                {
                    return 0;
                }
            }

            /// <summary>
            /// Gets or sets the position within the current stream.
            /// </summary>
            public override long Position
            {
                get
                {
                    return baseStream_.Position;
                }

                set
                {
                }
            }

            /// <summary>
            /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            /// </summary>
            /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
            /// <returns>
            /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            /// </returns>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override int Read(byte[] buffer, int offset, int count)
            {
                return 0;
            }

            /// <summary>
            /// Sets the position within the current stream.
            /// </summary>
            /// <param name="offset">A byte offset relative to the origin parameter.</param>
            /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            /// <returns>
            /// The new position within the current stream.
            /// </returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Seek(long offset, SeekOrigin origin)
            {
                return 0;
            }

            /// <summary>
            /// Sets the length of the current stream.
            /// </summary>
            /// <param name="value">The desired length of the current stream in bytes.</param>
            /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override void SetLength(long value)
            {
            }

            /// <summary>
            /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            /// </summary>
            /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            /// <param name="count">The number of bytes to be written to the current stream.</param>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override void Write(byte[] buffer, int offset, int count)
            {
                baseStream_.Write(buffer, offset, count);
            }

            #region Instance Fields
            Stream baseStream_;
            #endregion
        }

        /// <summary>
        /// A <see cref="PartialInputStream"/> is an <see cref="InflaterInputStream"/>
        /// whose data is only a part or subsection of a file.
        /// </summary>
        class PartialInputStream : Stream
        {
            #region Constructors
            /// <summary>
            /// Initialise a new instance of the <see cref="PartialInputStream"/> class.
            /// </summary>
            /// <param name="zipFile">The <see cref="ZipFile"/> containing the underlying stream to use for IO.</param>
            /// <param name="start">The start of the partial data.</param>
            /// <param name="length">The length of the partial data.</param>
            public PartialInputStream(ZipFile zipFile, long start, long length)
            {
                start_ = start;
                length_ = length;

                // Although this is the only time the zipfile is used
                // keeping a reference here prevents premature closure of
                // this zip file and thus the baseStream_.

                // Code like this will cause apparently random failures depending
                // on the size of the files and when garbage is collected.
                //
                // ZipFile z = new ZipFile (stream);
                // Stream reader = z.GetInputStream(0);
                // uses reader here....
                zipFile_ = zipFile;
                baseStream_ = zipFile_.baseStream_;
                readPos_ = start;
                end_ = start + length;
            }
            #endregion

            /// <summary>
            /// Read a byte from this stream.
            /// </summary>
            /// <returns>Returns the byte read or -1 on end of stream.</returns>
            public override int ReadByte()
            {
                if (readPos_ >= end_)
                {
                    // -1 is the correct value at end of stream.
                    return -1;
                }

                lock (baseStream_)
                {
                    baseStream_.Seek(readPos_++, SeekOrigin.Begin);
                    return baseStream_.ReadByte();
                }
            }

            /// <summary>
            /// Close this <see cref="PartialInputStream">partial input stream</see>.
            /// </summary>
            /// <remarks>
            /// The underlying stream is not closed.  Close the parent ZipFile class to do that.
            /// </remarks>
            public override void Close()
            {
                // Do nothing at all!
            }

            /// <summary>
            /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            /// </summary>
            /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
            /// <returns>
            /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            /// </returns>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override int Read(byte[] buffer, int offset, int count)
            {
                lock (baseStream_)
                {
                    if (count > end_ - readPos_)
                    {
                        count = (int)(end_ - readPos_);
                        if (count == 0)
                        {
                            return 0;
                        }
                    }

                    baseStream_.Seek(readPos_, SeekOrigin.Begin);
                    int readCount = baseStream_.Read(buffer, offset, count);
                    if (readCount > 0)
                    {
                        readPos_ += readCount;
                    }
                    return readCount;
                }
            }

            /// <summary>
            /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            /// </summary>
            /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            /// <param name="count">The number of bytes to be written to the current stream.</param>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            /// <summary>
            /// When overridden in a derived class, sets the length of the current stream.
            /// </summary>
            /// <param name="value">The desired length of the current stream in bytes.</param>
            /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            /// <summary>
            /// When overridden in a derived class, sets the position within the current stream.
            /// </summary>
            /// <param name="offset">A byte offset relative to the origin parameter.</param>
            /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            /// <returns>
            /// The new position within the current stream.
            /// </returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Seek(long offset, SeekOrigin origin)
            {
                long newPos = readPos_;

                switch (origin)
                {
                    case SeekOrigin.Begin:
                        newPos = start_ + offset;
                        break;

                    case SeekOrigin.Current:
                        newPos = readPos_ + offset;
                        break;

                    case SeekOrigin.End:
                        newPos = end_ + offset;
                        break;
                }

                if (newPos < start_)
                {
                    throw new ArgumentException("Negative position is invalid");
                }

                if (newPos >= end_)
                {
                    throw new IOException("Cannot seek past end");
                }
                readPos_ = newPos;
                return readPos_;
            }

            /// <summary>
            /// Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            /// </summary>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            public override void Flush()
            {
                // Nothing to do.
            }

            /// <summary>
            /// Gets or sets the position within the current stream.
            /// </summary>
            /// <value></value>
            /// <returns>The current position within the stream.</returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Position
            {
                get { return readPos_ - start_; }
                set
                {
                    long newPos = start_ + value;

                    if (newPos < start_)
                    {
                        throw new ArgumentException("Negative position is invalid");
                    }

                    if (newPos >= end_)
                    {
                        throw new InvalidOperationException("Cannot seek past end");
                    }
                    readPos_ = newPos;
                }
            }

            /// <summary>
            /// Gets the length in bytes of the stream.
            /// </summary>
            /// <value></value>
            /// <returns>A long value representing the length of the stream in bytes.</returns>
            /// <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Length
            {
                get { return length_; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports writing.
            /// </summary>
            /// <value>false</value>
            /// <returns>true if the stream supports writing; otherwise, false.</returns>
            public override bool CanWrite
            {
                get { return false; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports seeking.
            /// </summary>
            /// <value>true</value>
            /// <returns>true if the stream supports seeking; otherwise, false.</returns>
            public override bool CanSeek
            {
                get { return true; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports reading.
            /// </summary>
            /// <value>true.</value>
            /// <returns>true if the stream supports reading; otherwise, false.</returns>
            public override bool CanRead
            {
                get { return true; }
            }

#if !NET_1_0 && !NET_1_1 && !NETCF_1_0
            /// <summary>
            /// Gets a value that determines whether the current stream can time out.
            /// </summary>
            /// <value></value>
            /// <returns>A value that determines whether the current stream can time out.</returns>
            public override bool CanTimeout
            {
                get { return baseStream_.CanTimeout; }
            }
#endif
            #region Instance Fields
            ZipFile zipFile_;
            Stream baseStream_;
            long start_;
            long length_;
            long readPos_;
            long end_;
            #endregion
        }
        #endregion
    }

    #endregion

    #region DataSources
    /// <summary>
    /// Provides a static way to obtain a source of data for an entry.
    /// </summary>
    public interface IStaticDataSource
    {
        /// <summary>
        /// Get a source of data by creating a new stream.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> to use for compression input.</returns>
        /// <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        Stream GetSource();
    }

    /// <summary>
    /// Represents a source of data that can dynamically provide
    /// multiple <see cref="Stream">data sources</see> based on the parameters passed.
    /// </summary>
    public interface IDynamicDataSource
    {
        /// <summary>
        /// Get a data source.
        /// </summary>
        /// <param name="entry">The <see cref="ZipEntry"/> to get a source for.</param>
        /// <param name="name">The name for data if known.</param>
        /// <returns>Returns a <see cref="Stream"/> to use for compression input.</returns>
        /// <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        Stream GetSource(ZipEntry entry, string name);
    }

    /// <summary>
    /// Default implementation of a <see cref="IStaticDataSource"/> for use with files stored on disk.
    /// </summary>
    public class StaticDiskDataSource : IStaticDataSource
    {
        /// <summary>
        /// Initialise a new instnace of <see cref="StaticDiskDataSource"/>
        /// </summary>
        /// <param name="fileName">The name of the file to obtain data from.</param>
        public StaticDiskDataSource(string fileName)
        {
            fileName_ = fileName;
        }

        #region IDataSource Members

        /// <summary>
        /// Get a <see cref="Stream"/> providing data.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> provising data.</returns>
        public Stream GetSource()
        {
            return File.Open(fileName_, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        #endregion
        #region Instance Fields
        string fileName_;
        #endregion
    }


    /// <summary>
    /// Default implementation of <see cref="IDynamicDataSource"/> for files stored on disk.
    /// </summary>
    public class DynamicDiskDataSource : IDynamicDataSource
    {
        /// <summary>
        /// Initialise a default instance of <see cref="DynamicDiskDataSource"/>.
        /// </summary>
        public DynamicDiskDataSource()
        {
        }

        #region IDataSource Members
        /// <summary>
        /// Get a <see cref="Stream"/> providing data for an entry.
        /// </summary>
        /// <param name="entry">The entry to provide data for.</param>
        /// <param name="name">The file name for data if known.</param>
        /// <returns>Returns a stream providing data; or null if not available</returns>
        public Stream GetSource(ZipEntry entry, string name)
        {
            Stream result = null;

            if (name != null)
            {
                result = File.Open(name, FileMode.Open, FileAccess.Read, FileShare.Read);
            }

            return result;
        }

        #endregion
    }

    #endregion

    #region Archive Storage
    /// <summary>
    /// Defines facilities for data storage when updating Zip Archives.
    /// </summary>
    public interface IArchiveStorage
    {
        /// <summary>
        /// Get the <see cref="FileUpdateMode"/> to apply during updates.
        /// </summary>
        FileUpdateMode UpdateMode { get; }

        /// <summary>
        /// Get an empty <see cref="Stream"/> that can be used for temporary output.
        /// </summary>
        /// <returns>Returns a temporary output <see cref="Stream"/></returns>
        /// <seealso cref="ConvertTemporaryToFinal"></seealso>
        Stream GetTemporaryOutput();

        /// <summary>
        /// Convert a temporary output stream to a final stream.
        /// </summary>
        /// <returns>The resulting final <see cref="Stream"/></returns>
        /// <seealso cref="GetTemporaryOutput"/>
        Stream ConvertTemporaryToFinal();

        /// <summary>
        /// Make a temporary copy of the original stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        Stream MakeTemporaryCopy(Stream stream);

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The current stream.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>This may be the current stream passed.</remarks>
        Stream OpenForDirectUpdate(Stream stream);

        /// <summary>
        /// Dispose of this instance.
        /// </summary>
        void Dispose();
    }

    /// <summary>
    /// An abstract <see cref="IArchiveStorage"/> suitable for extension by inheritance.
    /// </summary>
    abstract public class BaseArchiveStorage : IArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="BaseArchiveStorage"/> class.
        /// </summary>
        /// <param name="updateMode">The update mode.</param>
        protected BaseArchiveStorage(FileUpdateMode updateMode)
        {
            updateMode_ = updateMode;
        }
        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets a temporary output <see cref="Stream"/>
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        /// <seealso cref="ConvertTemporaryToFinal"></seealso>
        public abstract Stream GetTemporaryOutput();

        /// <summary>
        /// Converts the temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        /// <seealso cref="GetTemporaryOutput"/>
        public abstract Stream ConvertTemporaryToFinal();

        /// <summary>
        /// Make a temporary copy of a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to make a copy of.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public abstract Stream MakeTemporaryCopy(Stream stream);

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to open for direct update.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        public abstract Stream OpenForDirectUpdate(Stream stream);

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public abstract void Dispose();

        /// <summary>
        /// Gets the update mode applicable.
        /// </summary>
        /// <value>The update mode.</value>
        public FileUpdateMode UpdateMode
        {
            get
            {
                return updateMode_;
            }
        }

        #endregion

        #region Instance Fields
        FileUpdateMode updateMode_;
        #endregion
    }

    /// <summary>
    /// An <see cref="IArchiveStorage"/> implementation suitable for hard disks.
    /// </summary>
    public class DiskArchiveStorage : BaseArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="DiskArchiveStorage"/> class.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="updateMode">The update mode.</param>
        public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode)
            : base(updateMode)
        {
            if (file.Name == null)
            {
                throw new ZipException("Cant handle non file archives");
            }

            fileName_ = file.Name;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DiskArchiveStorage"/> class.
        /// </summary>
        /// <param name="file">The file.</param>
        public DiskArchiveStorage(ZipFile file)
            : this(file, FileUpdateMode.Safe)
        {
        }
        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets a temporary output <see cref="Stream"/> for performing updates on.
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        public override Stream GetTemporaryOutput()
        {
            if (temporaryName_ != null)
            {
                temporaryName_ = GetTempFileName(temporaryName_, true);
                temporaryStream_ = File.Open(temporaryName_, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
            }
            else
            {
                // Determine where to place files based on internal strategy.
                // Currently this is always done in system temp directory.
                temporaryName_ = Path.GetTempFileName();
                temporaryStream_ = File.Open(temporaryName_, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
            }

            return temporaryStream_;
        }

        /// <summary>
        /// Converts a temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        public override Stream ConvertTemporaryToFinal()
        {
            if (temporaryStream_ == null)
            {
                throw new ZipException("No temporary stream has been created");
            }

            Stream result = null;

            string moveTempName = GetTempFileName(fileName_, false);
            bool newFileCreated = false;

            try
            {
                temporaryStream_.Close();
                File.Move(fileName_, moveTempName);
                File.Move(temporaryName_, fileName_);
                newFileCreated = true;
                File.Delete(moveTempName);

                result = File.Open(fileName_, FileMode.Open, FileAccess.Read, FileShare.Read);
            }
            catch (Exception)
            {
                result = null;

                // Try to roll back changes...
                if (!newFileCreated)
                {
                    File.Move(moveTempName, fileName_);
                    File.Delete(temporaryName_);
                }

                throw;
            }

            return result;
        }

        /// <summary>
        /// Make a temporary copy of a stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public override Stream MakeTemporaryCopy(Stream stream)
        {
            stream.Close();

            temporaryName_ = GetTempFileName(fileName_, true);
            File.Copy(fileName_, temporaryName_, true);

            temporaryStream_ = new FileStream(temporaryName_,
                FileMode.Open,
                FileAccess.ReadWrite);
            return temporaryStream_;
        }

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The current stream.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>If the <paramref name="current"/> stream is not null this is used as is.</remarks>
        public override Stream OpenForDirectUpdate(Stream stream)
        {
            Stream result;
            if ((stream == null) || !stream.CanWrite)
            {
                if (stream != null)
                {
                    stream.Close();
                }

                result = new FileStream(fileName_,
                        FileMode.Open,
                        FileAccess.ReadWrite);
            }
            else
            {
                result = stream;
            }

            return result;
        }

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public override void Dispose()
        {
            if (temporaryStream_ != null)
            {
                temporaryStream_.Close();
            }
        }

        #endregion

        #region Internal routines
        static string GetTempFileName(string original, bool makeTempFile)
        {
            string result = null;

            if (original == null)
            {
                result = Path.GetTempFileName();
            }
            else
            {
                int counter = 0;
                int suffixSeed = DateTime.Now.Second;

                while (result == null)
                {
                    counter += 1;
                    string newName = string.Format("{0}.{1}{2}.tmp", original, suffixSeed, counter);
                    if (!File.Exists(newName))
                    {
                        if (makeTempFile)
                        {
                            try
                            {
                                // Try and create the file.
                                using (FileStream stream = File.Create(newName))
                                {
                                }
                                result = newName;
                            }
                            catch
                            {
                                suffixSeed = DateTime.Now.Second;
                            }
                        }
                        else
                        {
                            result = newName;
                        }
                    }
                }
            }
            return result;
        }
        #endregion

        #region Instance Fields
        Stream temporaryStream_;
        string fileName_;
        string temporaryName_;
        #endregion
    }

    /// <summary>
    /// An <see cref="IArchiveStorage"/> implementation suitable for in memory streams.
    /// </summary>
    public class MemoryArchiveStorage : BaseArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MemoryArchiveStorage"/> class.
        /// </summary>
        public MemoryArchiveStorage()
            : base(FileUpdateMode.Direct)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MemoryArchiveStorage"/> class.
        /// </summary>
        /// <param name="updateMode">The <see cref="FileUpdateMode"/> to use</param>
        /// <remarks>This constructor is for testing as memory streams dont really require safe mode.</remarks>
        public MemoryArchiveStorage(FileUpdateMode updateMode)
            : base(updateMode)
        {
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get the stream returned by <see cref="ConvertTemporaryToFinal"/> if this was in fact called.
        /// </summary>
        public MemoryStream FinalStream
        {
            get { return finalStream_; }
        }

        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets the temporary output <see cref="Stream"/>
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        public override Stream GetTemporaryOutput()
        {
            temporaryStream_ = new MemoryStream();
            return temporaryStream_;
        }

        /// <summary>
        /// Converts the temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        public override Stream ConvertTemporaryToFinal()
        {
            if (temporaryStream_ == null)
            {
                throw new ZipException("No temporary stream has been created");
            }

            finalStream_ = new MemoryStream(temporaryStream_.ToArray());
            return finalStream_;
        }

        /// <summary>
        /// Make a temporary copy of the original stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public override Stream MakeTemporaryCopy(Stream stream)
        {
            temporaryStream_ = new MemoryStream();
            stream.Position = 0;
            StreamUtils.Copy(stream, temporaryStream_, new byte[4096]);
            return temporaryStream_;
        }

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The original source stream</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>If the <paramref name="stream"/> passed is not null this is used;
        /// otherwise a new <see cref="MemoryStream"/> is returned.</remarks>
        public override Stream OpenForDirectUpdate(Stream stream)
        {
            Stream result;
            if ((stream == null) || !stream.CanWrite)
            {

                result = new MemoryStream();

                if (stream != null)
                {
                    stream.Position = 0;
                    StreamUtils.Copy(stream, result, new byte[4096]);

                    stream.Close();
                }
            }
            else
            {
                result = stream;
            }

            return result;
        }

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public override void Dispose()
        {
            if (temporaryStream_ != null)
            {
                temporaryStream_.Close();
            }
        }

        #endregion

        #region Instance Fields
        MemoryStream temporaryStream_;
        MemoryStream finalStream_;
        #endregion
    }

    #endregion
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;
    /// <summary>
    /// Holds data pertinent to a data descriptor.
    /// </summary>
    public class DescriptorData
    {
        /// <summary>
        /// Get /set the compressed size of data.
        /// </summary>
        public long CompressedSize
        {
            get { return compressedSize; }
            set { compressedSize = value; }
        }

        /// <summary>
        /// Get / set the uncompressed size of data
        /// </summary>
        public long Size
        {
            get { return size; }
            set { size = value; }
        }

        /// <summary>
        /// Get /set the crc value.
        /// </summary>
        public long Crc
        {
            get { return crc; }
            set { crc = (value & 0xffffffff); }
        }

        #region Instance Fields
        long size;
        long compressedSize;
        long crc;
        #endregion
    }

    class EntryPatchData
    {
        public long SizePatchOffset
        {
            get { return sizePatchOffset_; }
            set { sizePatchOffset_ = value; }
        }

        public long CrcPatchOffset
        {
            get { return crcPatchOffset_; }
            set { crcPatchOffset_ = value; }
        }

        #region Instance Fields
        long sizePatchOffset_;
        long crcPatchOffset_;
        #endregion
    }

    /// <summary>
    /// This class assists with writing/reading from Zip files.
    /// </summary>
    internal class ZipHelperStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Initialise an instance of this class.
        /// </summary>
        /// <param name="name">The name of the file to open.</param>
        public ZipHelperStream(string name)
        {
            stream_ = new FileStream(name, FileMode.Open, FileAccess.ReadWrite);
            isOwner_ = true;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipHelperStream"/>.
        /// </summary>
        /// <param name="stream">The stream to use.</param>
        public ZipHelperStream(Stream stream)
        {
            stream_ = stream;
        }
        #endregion

        /// <summary>
        /// Get / set a value indicating wether the the underlying stream is owned or not.
        /// </summary>
        /// <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        public bool IsStreamOwner
        {
            get { return isOwner_; }
            set { isOwner_ = value; }
        }

        #region Base Stream Methods
        public override bool CanRead
        {
            get { return stream_.CanRead; }
        }

        public override bool CanSeek
        {
            get { return stream_.CanSeek; }
        }

#if !NET_1_0 && !NET_1_1 && !NETCF_1_0
        public override bool CanTimeout
        {
            get { return stream_.CanTimeout; }
        }
#endif

        public override long Length
        {
            get { return stream_.Length; }
        }

        public override long Position
        {
            get { return stream_.Position; }
            set { stream_.Position = value; }
        }

        public override bool CanWrite
        {
            get { return stream_.CanWrite; }
        }

        public override void Flush()
        {
            stream_.Flush();
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            return stream_.Seek(offset, origin);
        }

        public override void SetLength(long value)
        {
            stream_.SetLength(value);
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            return stream_.Read(buffer, offset, count);
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            stream_.Write(buffer, offset, count);
        }

        /// <summary>
        /// Close the stream.
        /// </summary>
        /// <remarks>
        /// The underlying stream is closed only if <see cref="IsStreamOwner"/> is true.
        /// </remarks>
        override public void Close()
        {
            Stream toClose = stream_;
            stream_ = null;
            if (isOwner_ && (toClose != null))
            {
                isOwner_ = false;
                toClose.Close();
            }
        }
        #endregion

        // Write the local file header
        // TODO: ZipHelperStream.WriteLocalHeader is not yet used and needs checking for ZipFile and ZipOuptutStream usage
        void WriteLocalHeader(ZipEntry entry, EntryPatchData patchData)
        {
            CompressionMethod method = entry.CompressionMethod;
            bool headerInfoAvailable = true; // How to get this?
            bool patchEntryHeader = false;

            WriteLEInt(ZipConstants.LocalHeaderSignature);

            WriteLEShort(entry.Version);
            WriteLEShort(entry.Flags);
            WriteLEShort((byte)method);
            WriteLEInt((int)entry.DosTime);

            if (headerInfoAvailable == true)
            {
                WriteLEInt((int)entry.Crc);
                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLEInt(-1);
                    WriteLEInt(-1);
                }
                else
                {
                    WriteLEInt(entry.IsCrypted ? (int)entry.CompressedSize + ZipConstants.CryptoHeaderSize : (int)entry.CompressedSize);
                    WriteLEInt((int)entry.Size);
                }
            }
            else
            {
                if (patchData != null)
                {
                    patchData.CrcPatchOffset = stream_.Position;
                }
                WriteLEInt(0);	// Crc

                if (patchData != null)
                {
                    patchData.SizePatchOffset = stream_.Position;
                }

                // For local header both sizes appear in Zip64 Extended Information
                if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
                {
                    WriteLEInt(-1);
                    WriteLEInt(-1);
                }
                else
                {
                    WriteLEInt(0);	// Compressed size
                    WriteLEInt(0);	// Uncompressed size
                }
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64 && (headerInfoAvailable || patchEntryHeader))
            {
                ed.StartNewEntry();
                if (headerInfoAvailable)
                {
                    ed.AddLeLong(entry.Size);
                    ed.AddLeLong(entry.CompressedSize);
                }
                else
                {
                    ed.AddLeLong(-1);
                    ed.AddLeLong(-1);
                }
                ed.AddNewEntry(1);

                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cant find extra data");
                }

                if (patchData != null)
                {
                    patchData.SizePatchOffset = ed.CurrentReadIndex;
                }
            }
            else
            {
                ed.Delete(1);
            }

            byte[] extra = ed.GetEntryData();

            WriteLEShort(name.Length);
            WriteLEShort(extra.Length);

            if (name.Length > 0)
            {
                stream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
            {
                patchData.SizePatchOffset += stream_.Position;
            }

            if (extra.Length > 0)
            {
                stream_.Write(extra, 0, extra.Length);
            }
        }

        /// <summary>
        /// Locates a block with the desired <paramref name="signature"/>.
        /// </summary>
        /// <param name="signature">The signature to find.</param>
        /// <param name="endLocation">Location, marking the end of block.</param>
        /// <param name="minimumBlockSize">Minimum size of the block.</param>
        /// <param name="maximumVariableData">The maximum variable data.</param>
        /// <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        public long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)
        {
            long pos = endLocation - minimumBlockSize;
            if (pos < 0)
            {
                return -1;
            }

            long giveUpMarker = Math.Max(pos - maximumVariableData, 0);

            // TODO: This loop could be optimised for speed.
            do
            {
                if (pos < giveUpMarker)
                {
                    return -1;
                }
                Seek(pos--, SeekOrigin.Begin);
            } while (ReadLEInt() != signature);

            return Position;
        }

        /// <summary>
        /// Write Zip64 end of central directory records (File header and locator).
        /// </summary>
        /// <param name="noOfEntries">The number of entries in the central directory.</param>
        /// <param name="sizeEntries">The size of entries in the central directory.</param>
        /// <param name="centralDirOffset">The offset of the dentral directory.</param>
        public void WriteZip64EndOfCentralDirectory(long noOfEntries, long sizeEntries, long centralDirOffset)
        {
            long centralSignatureOffset = stream_.Position;
            WriteLEInt(ZipConstants.Zip64CentralFileHeaderSignature);
            WriteLELong(44);    // Size of this record (total size of remaining fields in header or full size - 12)
            WriteLEShort(ZipConstants.VersionMadeBy);   // Version made by
            WriteLEShort(ZipConstants.VersionZip64);   // Version to extract
            WriteLEInt(0);      // Number of this disk
            WriteLEInt(0);      // number of the disk with the start of the central directory
            WriteLELong(noOfEntries);       // No of entries on this disk
            WriteLELong(noOfEntries);       // Total No of entries in central directory
            WriteLELong(sizeEntries);       // Size of the central directory
            WriteLELong(centralDirOffset);  // offset of start of central directory
            // zip64 extensible data sector not catered for here (variable size)

            // Write the Zip64 end of central directory locator
            WriteLEInt(ZipConstants.Zip64CentralDirLocatorSignature);

            // no of the disk with the start of the zip64 end of central directory
            WriteLEInt(0);

            // relative offset of the zip64 end of central directory record
            WriteLELong(centralSignatureOffset);

            // total number of disks
            WriteLEInt(1);
        }

        /// <summary>
        /// Write the required records to end the central directory.
        /// </summary>
        /// <param name="noOfEntries">The number of entries in the directory.</param>
        /// <param name="sizeEntries">The size of the entries in the directory.</param>
        /// <param name="startOfCentralDirectory">The start of the central directory.</param>
        /// <param name="comment">The archive comment.  (This can be null).</param>
        public void WriteEndOfCentralDirectory(long noOfEntries, long sizeEntries,
            long startOfCentralDirectory, byte[] comment)
        {

            if ((noOfEntries >= 0xffff) ||
                (startOfCentralDirectory >= 0xffffffff) ||
                (sizeEntries >= 0xffffffff))
            {
                WriteZip64EndOfCentralDirectory(noOfEntries, sizeEntries, startOfCentralDirectory);
            }

            WriteLEInt(ZipConstants.EndOfCentralDirectorySignature);

            // TODO: ZipFile Multi disk handling not done
            WriteLEShort(0);                    // number of this disk
            WriteLEShort(0);                    // no of disk with start of central dir


            // Number of entries
            if (noOfEntries >= 0xffff)
            {
                WriteLEUshort(0xffff);  // Zip64 marker
                WriteLEUshort(0xffff);
            }
            else
            {
                WriteLEShort((short)noOfEntries);          // entries in central dir for this disk
                WriteLEShort((short)noOfEntries);          // total entries in central directory
            }

            // Size of the central directory
            if (sizeEntries >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);    // Zip64 marker
            }
            else
            {
                WriteLEInt((int)sizeEntries);
            }


            // offset of start of central directory
            if (startOfCentralDirectory >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);    // Zip64 marker
            }
            else
            {
                WriteLEInt((int)startOfCentralDirectory);
            }

            int commentLength = (comment != null) ? comment.Length : 0;

            if (commentLength > 0xffff)
            {
                throw new ZipException(string.Format("Comment length({0}) is too long can only be 64K", commentLength));
            }

            WriteLEShort(commentLength);

            if (commentLength > 0)
            {
                Write(comment, 0, comment.Length);
            }
        }

        #region LE value reading/writing
        /// <summary>
        /// Read an unsigned short in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        public int ReadLEShort()
        {
            int byteValue1 = stream_.ReadByte();

            if (byteValue1 < 0)
            {
                throw new EndOfStreamException();
            }

            int byteValue2 = stream_.ReadByte();
            if (byteValue2 < 0)
            {
                throw new EndOfStreamException();
            }

            return byteValue1 | (byteValue2 << 8);
        }

        /// <summary>
        /// Read an int in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        public int ReadLEInt()
        {
            return ReadLEShort() | (ReadLEShort() << 16);
        }

        /// <summary>
        /// Read a long in little endian byte order.
        /// </summary>
        /// <returns>The value read.</returns>
        public long ReadLELong()
        {
            return (uint)ReadLEInt() | ((long)ReadLEInt() << 32);
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEShort(int value)
        {
            stream_.WriteByte((byte)(value & 0xff));
            stream_.WriteByte((byte)((value >> 8) & 0xff));
        }

        /// <summary>
        /// Write a ushort in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUshort(ushort value)
        {
            stream_.WriteByte((byte)(value & 0xff));
            stream_.WriteByte((byte)(value >> 8));
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEInt(int value)
        {
            WriteLEShort(value);
            WriteLEShort(value >> 16);
        }

        /// <summary>
        /// Write a uint in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUint(uint value)
        {
            WriteLEUshort((ushort)(value & 0xffff));
            WriteLEUshort((ushort)(value >> 16));
        }

        /// <summary>
        /// Write a long in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLELong(long value)
        {
            WriteLEInt((int)value);
            WriteLEInt((int)(value >> 32));
        }

        /// <summary>
        /// Write a ulong in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUlong(ulong value)
        {
            WriteLEUint((uint)(value & 0xffffffff));
            WriteLEUint((uint)(value >> 32));
        }

        #endregion

        /// <summary>
        /// Write a data descriptor.
        /// </summary>
        /// <param name="entry">The entry to write a descriptor for.</param>
        /// <returns>Returns the number of descriptor bytes written.</returns>
        public int WriteDataDescriptor(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            int result = 0;

            // Add data descriptor if flagged as required
            if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)
            {
                // The signature is not PKZIP originally but is now described as optional
                // in the PKZIP Appnote documenting trhe format.
                WriteLEInt(ZipConstants.DataDescriptorSignature);
                WriteLEInt(unchecked((int)(entry.Crc)));

                result += 8;

                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLELong(entry.CompressedSize);
                    WriteLELong(entry.Size);
                    result += 16;
                }
                else
                {
                    WriteLEInt((int)entry.CompressedSize);
                    WriteLEInt((int)entry.Size);
                    result += 8;
                }
            }

            return result;
        }

        /// <summary>
        /// Read data descriptor at the end of compressed data.
        /// </summary>
        /// <param name="zip64">if set to <c>true</c> [zip64].</param>
        /// <param name="data">The data to fill in.</param>
        /// <returns>Returns the number of bytes read in the descriptor.</returns>
        public void ReadDataDescriptor(bool zip64, DescriptorData data)
        {
            int intValue = ReadLEInt();

            // In theory this may not be a descriptor according to PKZIP appnote.
            // In practise its always there.
            if (intValue != ZipConstants.DataDescriptorSignature)
            {
                throw new ZipException("Data descriptor signature not found");
            }

            data.Crc = ReadLEInt();

            if (zip64)
            {
                data.CompressedSize = ReadLELong();
                data.Size = ReadLELong();
            }
            else
            {
                data.CompressedSize = ReadLEInt();
                data.Size = ReadLEInt();
            }
        }

        #region Instance Fields
        bool isOwner_;
        Stream stream_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;

#if !NETCF_1_0
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    /// <summary>
    /// This is an InflaterInputStream that reads the files baseInputStream an zip archive
    /// one after another.  It has a special method to get the zip entry of
    /// the next file.  The zip entry contains information about the file name
    /// size, compressed size, Crc, etc.
    /// It includes support for Stored and Deflated entries.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// 
    /// <example> This sample shows how to read a zip file
    /// <code lang="C#">
    /// using System;
    /// using System.Text;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	public static void Main(string[] args)
    /// 	{
    /// 		using ( ZipInputStream s = new ZipInputStream(File.OpenRead(args[0]))) {
    ///
    /// 			ZipEntry theEntry;
    /// 			const int size = 2048;
    /// 			byte[] data = new byte[2048];
    /// 			
    /// 			while ((theEntry = s.GetNextEntry()) != null) {
    ///                 if ( entry.IsFile ) {
    /// 				    Console.Write("Show contents (y/n) ?");
    /// 				    if (Console.ReadLine() == "y") {
    /// 				    	while (true) {
    /// 				    		size = s.Read(data, 0, data.Length);
    /// 				    		if (size > 0) {
    /// 				    			Console.Write(new ASCIIEncoding().GetString(data, 0, size));
    /// 				    		} else {
    /// 				    			break;
    /// 				    		}
    /// 				    	}
    /// 				    }
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }
    /// </code>
    /// </example>
    public class ZipInputStream : InflaterInputStream
    {
        #region Instance Fields

        /// <summary>
        /// Delegate for reading bytes from a stream. 
        /// </summary>
        delegate int ReadDataHandler(byte[] b, int offset, int length);

        /// <summary>
        /// The current reader this instance.
        /// </summary>
        ReadDataHandler internalReader;

        Crc32 crc = new Crc32();
        ZipEntry entry;

        long size;
        int method;
        int flags;
        string password;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new Zip input stream, for reading a zip archive.
        /// </summary>
        /// <param name="baseInputStream">The underlying <see cref="Stream"/> providing data.</param>
        public ZipInputStream(Stream baseInputStream)
            : base(baseInputStream, new Inflater(true))
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
        }

        /// <summary>
        /// Creates a new Zip input stream, for reading a zip archive.
        /// </summary>
        /// <param name="baseInputStream">The underlying <see cref="Stream"/> providing data.</param>
        /// <param name="bufferSize">Size of the buffer.</param>
        public ZipInputStream(Stream baseInputStream, int bufferSize)
            : base(baseInputStream, new Inflater(true), bufferSize)
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
        }
        #endregion

        /// <summary>
        /// Optional password used for encryption when non-null
        /// </summary>
        /// <value>A password for all encrypted <see cref="ZipEntry">entries </see> in this <see cref="ZipInputStream"/></value>
        public string Password
        {
            get
            {
                return password;
            }
            set
            {
                password = value;
            }
        }


        /// <summary>
        /// Gets a value indicating if there is a current entry and it can be decompressed
        /// </summary>
        /// <remarks>
        /// The entry can only be decompressed if the library supports the zip features required to extract it.
        /// See the <see cref="ZipEntry.Version">ZipEntry Version</see> property for more details.
        /// </remarks>
        public bool CanDecompressEntry
        {
            get
            {
                return (entry != null) && entry.CanDecompress;
            }
        }

        /// <summary>
        /// Advances to the next entry in the archive
        /// </summary>
        /// <returns>
        /// The next <see cref="ZipEntry">entry</see> in the archive or null if there are no more entries.
        /// </returns>
        /// <remarks>
        /// If the previous entry is still open <see cref="CloseEntry">CloseEntry</see> is called.
        /// </remarks>
        /// <exception cref="InvalidOperationException">
        /// Input stream is closed
        /// </exception>
        /// <exception cref="ZipException">
        /// Password is not set, password is invalid, compression method is invalid,
        /// version required to extract is not supported
        /// </exception>
        public ZipEntry GetNextEntry()
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed.");
            }

            if (entry != null)
            {
                CloseEntry();
            }

            int header = inputBuffer.ReadLeInt();

            if (header == ZipConstants.CentralHeaderSignature ||
                header == ZipConstants.EndOfCentralDirectorySignature ||
                header == ZipConstants.CentralHeaderDigitalSignature ||
                header == ZipConstants.ArchiveExtraDataSignature ||
                header == ZipConstants.Zip64CentralFileHeaderSignature)
            {
                // No more individual entries exist
                Close();
                return null;
            }

            // -jr- 07-Dec-2003 Ignore spanning temporary signatures if found
            // Spanning signature is same as descriptor signature and is untested as yet.
            if ((header == ZipConstants.SpanningTempSignature) || (header == ZipConstants.SpanningSignature))
            {
                header = inputBuffer.ReadLeInt();
            }

            if (header != ZipConstants.LocalHeaderSignature)
            {
                throw new ZipException("Wrong Local header signature: 0x" + String.Format("{0:X}", header));
            }

            short versionRequiredToExtract = (short)inputBuffer.ReadLeShort();

            flags = inputBuffer.ReadLeShort();
            method = inputBuffer.ReadLeShort();
            uint dostime = (uint)inputBuffer.ReadLeInt();
            int crc2 = inputBuffer.ReadLeInt();
            csize = inputBuffer.ReadLeInt();
            size = inputBuffer.ReadLeInt();
            int nameLen = inputBuffer.ReadLeShort();
            int extraLen = inputBuffer.ReadLeShort();

            bool isCrypted = (flags & 1) == 1;

            byte[] buffer = new byte[nameLen];
            inputBuffer.ReadRawBuffer(buffer);

            string name = ZipConstants.ConvertToStringExt(flags, buffer);

            entry = new ZipEntry(name, versionRequiredToExtract);
            entry.Flags = flags;

            entry.CompressionMethod = (CompressionMethod)method;

            if ((flags & 8) == 0)
            {
                entry.Crc = crc2 & 0xFFFFFFFFL;
                entry.Size = size & 0xFFFFFFFFL;
                entry.CompressedSize = csize & 0xFFFFFFFFL;

                entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);

            }
            else
            {

                // This allows for GNU, WinZip and possibly other archives, the PKZIP spec
                // says these values are zero under these circumstances.
                if (crc2 != 0)
                {
                    entry.Crc = crc2 & 0xFFFFFFFFL;
                }

                if (size != 0)
                {
                    entry.Size = size & 0xFFFFFFFFL;
                }

                if (csize != 0)
                {
                    entry.CompressedSize = csize & 0xFFFFFFFFL;
                }

                entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);
            }

            entry.DosTime = dostime;

            // If local header requires Zip64 is true then the extended header should contain
            // both values.

            // Handle extra data if present.  This can set/alter some fields of the entry.
            if (extraLen > 0)
            {
                byte[] extra = new byte[extraLen];
                inputBuffer.ReadRawBuffer(extra);
                entry.ExtraData = extra;
            }

            entry.ProcessExtraData(true);
            if (entry.CompressedSize >= 0)
            {
                csize = entry.CompressedSize;
            }

            if (entry.Size >= 0)
            {
                size = entry.Size;
            }

            if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size)))
            {
                throw new ZipException("Stored, but compressed != uncompressed");
            }

            // Determine how to handle reading of data if this is attempted.
            if (entry.IsCompressionMethodSupported())
            {
                internalReader = new ReadDataHandler(InitialRead);
            }
            else
            {
                internalReader = new ReadDataHandler(ReadingNotSupported);
            }

            return entry;
        }

        /// <summary>
        /// Read data descriptor at the end of compressed data. 
        /// </summary>
        void ReadDataDescriptor()
        {
            if (inputBuffer.ReadLeInt() != ZipConstants.DataDescriptorSignature)
            {
                throw new ZipException("Data descriptor signature not found");
            }

            entry.Crc = inputBuffer.ReadLeInt() & 0xFFFFFFFFL;

            if (entry.LocalHeaderRequiresZip64)
            {
                csize = inputBuffer.ReadLeLong();
                size = inputBuffer.ReadLeLong();
            }
            else
            {
                csize = inputBuffer.ReadLeInt();
                size = inputBuffer.ReadLeInt();
            }
            entry.CompressedSize = csize;
            entry.Size = size;
        }

        /// <summary>
        /// Complete cleanup as the final part of closing.
        /// </summary>
        /// <param name="testCrc">True if the crc value should be tested</param>
        void CompleteCloseEntry(bool testCrc)
        {
            StopDecrypting();

            if ((flags & 8) != 0)
            {
                ReadDataDescriptor();
            }

            size = 0;

            if (testCrc &&
                ((crc.Value & 0xFFFFFFFFL) != entry.Crc) && (entry.Crc != -1))
            {
                throw new ZipException("CRC mismatch");
            }

            crc.Reset();

            if (method == (int)CompressionMethod.Deflated)
            {
                inf.Reset();
            }
            entry = null;
        }

        /// <summary>
        /// Closes the current zip entry and moves to the next one.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The stream is closed
        /// </exception>
        /// <exception cref="ZipException">
        /// The Zip stream ends early
        /// </exception>
        public void CloseEntry()
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed");
            }

            if (entry == null)
            {
                return;
            }

            if (method == (int)CompressionMethod.Deflated)
            {
                if ((flags & 8) != 0)
                {
                    // We don't know how much we must skip, read until end.
                    byte[] tmp = new byte[4096];

                    // Read will close this entry
                    while (Read(tmp, 0, tmp.Length) > 0)
                    {
                    }
                    return;
                }

                csize -= inf.TotalIn;
                inputBuffer.Available += inf.RemainingInput;
            }

            if ((inputBuffer.Available > csize) && (csize >= 0))
            {
                inputBuffer.Available = (int)((long)inputBuffer.Available - csize);
            }
            else
            {
                csize -= inputBuffer.Available;
                inputBuffer.Available = 0;
                while (csize != 0)
                {
                    long skipped = base.Skip(csize);

                    if (skipped <= 0)
                    {
                        throw new ZipException("Zip archive ends early.");
                    }

                    csize -= skipped;
                }
            }

            CompleteCloseEntry(false);
        }

        /// <summary>
        /// Returns 1 if there is an entry available
        /// Otherwise returns 0.
        /// </summary>
        public override int Available
        {
            get
            {
                return entry != null ? 1 : 0;
            }
        }

        /// <summary>
        /// Returns the current size that can be read from the current entry if available
        /// </summary>
        /// <exception cref="ZipException">Thrown if the entry size is not known.</exception>
        /// <exception cref="InvalidOperationException">Thrown if no entry is currently available.</exception>
        public override long Length
        {
            get
            {
                if (entry != null)
                {
                    if (entry.Size >= 0)
                    {
                        return entry.Size;
                    }
                    else
                    {
                        throw new ZipException("Length not available for the current entry");
                    }
                }
                else
                {
                    throw new InvalidOperationException("No current entry");
                }
            }

        }

        /// <summary>
        /// Reads a byte from the current zip entry.
        /// </summary>
        /// <returns>
        /// The byte or -1 if end of stream is reached.
        /// </returns>
        public override int ReadByte()
        {
            byte[] b = new byte[1];
            if (Read(b, 0, 1) <= 0)
            {
                return -1;
            }
            return b[0] & 0xff;
        }

        /// <summary>
        /// Handle attempts to read by throwing an <see cref="InvalidOperationException"/>.
        /// </summary>
        /// <param name="destination">The destination array to store data in.</param>
        /// <param name="offset">The offset at which data read should be stored.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>Returns the number of bytes actually read.</returns>
        int ReadingNotAvailable(byte[] destination, int offset, int count)
        {
            throw new InvalidOperationException("Unable to read from this stream");
        }

        /// <summary>
        /// Handle attempts to read from this entry by throwing an exception
        /// </summary>
        int ReadingNotSupported(byte[] destination, int offset, int count)
        {
            throw new ZipException("The compression method for this entry is not supported");
        }

        /// <summary>
        /// Perform the initial read on an entry which may include 
        /// reading encryption headers and setting up inflation.
        /// </summary>
        /// <param name="destination">The destination to fill with data read.</param>
        /// <param name="offset">The offset to start reading at.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>The actual number of bytes read.</returns>
        int InitialRead(byte[] destination, int offset, int count)
        {
            if (!CanDecompressEntry)
            {
                throw new ZipException("Library cannot extract this entry. Version required is (" + entry.Version.ToString() + ")");
            }

            // Handle encryption if required.
            if (entry.IsCrypted)
            {
#if NETCF_1_0
				throw new ZipException("Encryption not supported for Compact Framework 1.0");
#else
                if (password == null)
                {
                    throw new ZipException("No password set.");
                }

                // Generate and set crypto transform...
                PkzipClassicManaged managed = new PkzipClassicManaged();
                byte[] key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(password));

                inputBuffer.CryptoTransform = managed.CreateDecryptor(key, null);

                byte[] cryptbuffer = new byte[ZipConstants.CryptoHeaderSize];
                inputBuffer.ReadClearTextBuffer(cryptbuffer, 0, ZipConstants.CryptoHeaderSize);

                if (cryptbuffer[ZipConstants.CryptoHeaderSize - 1] != entry.CryptoCheckValue)
                {
                    throw new ZipException("Invalid password");
                }

                if (csize >= ZipConstants.CryptoHeaderSize)
                {
                    csize -= ZipConstants.CryptoHeaderSize;
                }
                else if ((entry.Flags & (int)GeneralBitFlags.Descriptor) == 0)
                {
                    throw new ZipException(string.Format("Entry compressed size {0} too small for encryption", csize));
                }
#endif
            }
            else
            {
#if !NETCF_1_0
                inputBuffer.CryptoTransform = null;
#endif
            }

            if ((csize > 0) || ((flags & (int)GeneralBitFlags.Descriptor) != 0))
            {
                if ((method == (int)CompressionMethod.Deflated) && (inputBuffer.Available > 0))
                {
                    inputBuffer.SetInflaterInput(inf);
                }

                internalReader = new ReadDataHandler(BodyRead);
                return BodyRead(destination, offset, count);
            }
            else
            {
                internalReader = new ReadDataHandler(ReadingNotAvailable);
                return 0;
            }
        }

        /// <summary>
        /// Read a block of bytes from the stream.
        /// </summary>
        /// <param name="buffer">The destination for the bytes.</param>
        /// <param name="offset">The index to start storing data.</param>
        /// <param name="count">The number of bytes to attempt to read.</param>
        /// <returns>Returns the number of bytes read.</returns>
        /// <remarks>Zero bytes read means end of stream.</remarks>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if ((buffer.Length - offset) < count)
            {
                throw new ArgumentException("Invalid offset/count combination");
            }

            return internalReader(buffer, offset, count);
        }

        /// <summary>
        /// Reads a block of bytes from the current zip entry.
        /// </summary>
        /// <returns>
        /// The number of bytes read (this may be less than the length requested, even before the end of stream), or 0 on end of stream.
        /// </returns>
        /// <exception name="IOException">
        /// An i/o error occured.
        /// </exception>
        /// <exception cref="ZipException">
        /// The deflated stream is corrupted.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The stream is not open.
        /// </exception>
        int BodyRead(byte[] buffer, int offset, int count)
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed");
            }

            if ((entry == null) || (count <= 0))
            {
                return 0;
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException("Offset + count exceeds buffer size");
            }

            bool finished = false;

            switch (method)
            {
                case (int)CompressionMethod.Deflated:
                    count = base.Read(buffer, offset, count);
                    if (count <= 0)
                    {
                        if (!inf.IsFinished)
                        {
                            throw new ZipException("Inflater not finished!");
                        }
                        inputBuffer.Available = inf.RemainingInput;

                        // A csize of -1 is from an unpatched local header
                        if ((flags & 8) == 0 &&
                            (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size))
                        {
                            throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);
                        }
                        inf.Reset();
                        finished = true;
                    }
                    break;

                case (int)CompressionMethod.Stored:
                    if ((count > csize) && (csize >= 0))
                    {
                        count = (int)csize;
                    }

                    if (count > 0)
                    {
                        count = inputBuffer.ReadClearTextBuffer(buffer, offset, count);
                        if (count > 0)
                        {
                            csize -= count;
                            size -= count;
                        }
                    }

                    if (csize == 0)
                    {
                        finished = true;
                    }
                    else
                    {
                        if (count < 0)
                        {
                            throw new ZipException("EOF in stored block");
                        }
                    }
                    break;
            }

            if (count > 0)
            {
                crc.Update(buffer, offset, count);
            }

            if (finished)
            {
                CompleteCloseEntry(true);
            }

            return count;
        }

        /// <summary>
        /// Closes the zip input stream
        /// </summary>
        public override void Close()
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
            crc = null;
            entry = null;

            base.Close();
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;

    using ICSharpCode.SharpZipLib.Core;
    /// <summary>
    /// ZipNameTransform transforms names as per the Zip file naming convention.
    /// </summary>
    /// <remarks>The use of absolute names is supported although its use is not valid 
    /// according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
    public class ZipNameTransform : INameTransform
    {
        #region Constructors
        /// <summary>
        /// Initialize a new instance of <see cref="ZipNameTransform"></see>
        /// </summary>
        public ZipNameTransform()
        {
        }

        /// <summary>
        /// Initialize a new instance of <see cref="ZipNameTransform"></see>
        /// </summary>
        /// <param name="trimPrefix">The string to trim from the front of paths if found.</param>
        public ZipNameTransform(string trimPrefix)
        {
            TrimPrefix = trimPrefix;
        }
        #endregion

        /// <summary>
        /// Static constructor.
        /// </summary>
        static ZipNameTransform()
        {
            char[] invalidPathChars;
#if NET_1_0 || NET_1_1 || NETCF_1_0
			invalidPathChars = Path.InvalidPathChars;
#else
            invalidPathChars = Path.GetInvalidPathChars();
#endif
            int howMany = invalidPathChars.Length + 2;

            InvalidEntryCharsRelaxed = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryCharsRelaxed, 0, invalidPathChars.Length);
            InvalidEntryCharsRelaxed[howMany - 1] = '*';
            InvalidEntryCharsRelaxed[howMany - 2] = '?';

            howMany = invalidPathChars.Length + 4;
            InvalidEntryChars = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryChars, 0, invalidPathChars.Length);
            InvalidEntryChars[howMany - 1] = ':';
            InvalidEntryChars[howMany - 2] = '\\';
            InvalidEntryChars[howMany - 3] = '*';
            InvalidEntryChars[howMany - 4] = '?';
        }

        /// <summary>
        /// Transform a windows directory name according to the Zip file naming conventions.
        /// </summary>
        /// <param name="name">The directory name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformDirectory(string name)
        {
            name = TransformFile(name);
            if (name.Length > 0)
            {
                if (!name.EndsWith("/"))
                {
                    name += "/";
                }
            }
            else
            {
                throw new ZipException("Cannot have an empty directory name");
            }
            return name;
        }

        /// <summary>
        /// Transform a windows file name according to the Zip file naming conventions.
        /// </summary>
        /// <param name="name">The file name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformFile(string name)
        {
            if (name != null)
            {
                string lowerName = name.ToLower();
                if ((trimPrefix_ != null) && (lowerName.IndexOf(trimPrefix_) == 0))
                {
                    name = name.Substring(trimPrefix_.Length);
                }

                name = name.Replace(@"\", "/");
                name = WindowsPathUtils.DropPathRoot(name);

                // Drop any leading slashes.
                while ((name.Length > 0) && (name[0] == '/'))
                {
                    name = name.Remove(0, 1);
                }

                // Drop any trailing slashes.
                while ((name.Length > 0) && (name[name.Length - 1] == '/'))
                {
                    name = name.Remove(name.Length - 1, 1);
                }

                // Convert consecutive // characters to /
                int index = name.IndexOf("//");
                while (index >= 0)
                {
                    name = name.Remove(index, 1);
                    index = name.IndexOf("//");
                }

                name = MakeValidName(name, '_');
            }
            else
            {
                name = string.Empty;
            }
            return name;
        }

        /// <summary>
        /// Get/set the path prefix to be trimmed from paths if present.
        /// </summary>
        /// <remarks>The prefix is trimmed before any conversion from
        /// a windows path is done.</remarks>
        public string TrimPrefix
        {
            get { return trimPrefix_; }
            set
            {
                trimPrefix_ = value;
                if (trimPrefix_ != null)
                {
                    trimPrefix_ = trimPrefix_.ToLower();
                }
            }
        }

        /// <summary>
        /// Force a name to be valid by replacing invalid characters with a fixed value
        /// </summary>
        /// <param name="name">The name to force valid</param>
        /// <param name="replacement">The replacement character to use.</param>
        /// <returns>Returns a valid name</returns>
        static string MakeValidName(string name, char replacement)
        {
            int index = name.IndexOfAny(InvalidEntryChars);
            if (index >= 0)
            {
                StringBuilder builder = new StringBuilder(name);

                while (index >= 0)
                {
                    builder[index] = replacement;

                    if (index >= name.Length)
                    {
                        index = -1;
                    }
                    else
                    {
                        index = name.IndexOfAny(InvalidEntryChars, index + 1);
                    }
                }
                name = builder.ToString();
            }

            if (name.Length > 0xffff)
            {
                throw new PathTooLongException();
            }

            return name;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a zip entry.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <param name="relaxed">If true checking is relaxed about windows file names and absolute paths.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>Zip path names are actually in Unix format, and should only contain relative paths.
        /// This means that any path stored should not contain a drive or
        /// device letter, or a leading slash.  All slashes should forward slashes '/'.
        /// An empty name is valid for a file where the input comes from standard input.
        /// A null name is not considered valid.
        /// </remarks>
        public static bool IsValidName(string name, bool relaxed)
        {
            bool result = (name != null);

            if (result)
            {
                if (relaxed)
                {
                    result = name.IndexOfAny(InvalidEntryCharsRelaxed) < 0;
                }
                else
                {
                    result =
                        (name.IndexOfAny(InvalidEntryChars) < 0) &&
                        (name.IndexOf('/') != 0);
                }
            }

            return result;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a zip entry.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>Zip path names are actually in unix format,
        /// and should only contain relative paths if a path is present.
        /// This means that the path stored should not contain a drive or
        /// device letter, or a leading slash.  All slashes should forward slashes '/'.
        /// An empty name is valid where the input comes from standard input.
        /// A null name is not considered valid.
        /// </remarks>
        public static bool IsValidName(string name)
        {
            bool result =
                (name != null) &&
                (name.IndexOfAny(InvalidEntryChars) < 0) &&
                (name.IndexOf('/') != 0)
                ;
            return result;
        }

        #region Instance Fields
        string trimPrefix_;
        #endregion

        #region Class Fields
        static readonly char[] InvalidEntryChars;
        static readonly char[] InvalidEntryCharsRelaxed;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Collections;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// This is a DeflaterOutputStream that writes the files into a zip
    /// archive one after another.  It has a special method to start a new
    /// zip entry.  The zip entries contains information about the file name
    /// size, compressed size, CRC, etc.
    /// 
    /// It includes support for Stored and Deflated entries.
    /// This class is not thread safe.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// <example> This sample shows how to create a zip file
    /// <code>
    /// using System;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Core;
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	public static void Main(string[] args)
    /// 	{
    /// 		string[] filenames = Directory.GetFiles(args[0]);
    /// 		byte[] buffer = new byte[4096];
    /// 		
    /// 		using ( ZipOutputStream s = new ZipOutputStream(File.Create(args[1])) ) {
    /// 		
    /// 			s.SetLevel(9); // 0 - store only to 9 - means best compression
    /// 		
    /// 			foreach (string file in filenames) {
    /// 				ZipEntry entry = new ZipEntry(file);
    /// 				s.PutNextEntry(entry);
    ///
    /// 				using (FileStream fs = File.OpenRead(file)) {
    ///						StreamUtils.Copy(fs, s, buffer);
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }	
    /// </code>
    /// </example>
    public class ZipOutputStream : DeflaterOutputStream
    {
        #region Constructors
        /// <summary>
        /// Creates a new Zip output stream, writing a zip archive.
        /// </summary>
        /// <param name="baseOutputStream">
        /// The output stream to which the archive contents are written.
        /// </param>
        public ZipOutputStream(Stream baseOutputStream)
            : base(baseOutputStream, new Deflater(Deflater.DEFAULT_COMPRESSION, true))
        {
        }

        /// <summary>
        /// Creates a new Zip output stream, writing a zip archive.
        /// </summary>
        /// <param name="baseOutputStream">The output stream to which the archive contents are written.</param>
        /// <param name="bufferSize">Size of the buffer to use.</param>
        public ZipOutputStream(Stream baseOutputStream, int bufferSize)
            : base(baseOutputStream, new Deflater(Deflater.DEFAULT_COMPRESSION, true), bufferSize)
        {
        }
        #endregion

        /// <summary>
        /// Gets a flag value of true if the central header has been added for this archive; false if it has not been added.
        /// </summary>
        /// <remarks>No further entries can be added once this has been done.</remarks>
        public bool IsFinished
        {
            get
            {
                return entries == null;
            }
        }

        /// <summary>
        /// Set the zip file comment.
        /// </summary>
        /// <param name="comment">
        /// The comment text for the entire archive.
        /// </param>
        /// <exception name ="ArgumentOutOfRangeException">
        /// The converted comment is longer than 0xffff bytes.
        /// </exception>
        public void SetComment(string comment)
        {
            // TODO: Its not yet clear how to handle unicode comments here.
            byte[] commentBytes = ZipConstants.ConvertToArray(comment);
            if (commentBytes.Length > 0xffff)
            {
                throw new ArgumentOutOfRangeException("comment");
            }
            zipComment = commentBytes;
        }

        /// <summary>
        /// Sets the compression level.  The new level will be activated
        /// immediately.
        /// </summary>
        /// <param name="level">The new compression level (1 to 9).</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Level specified is not supported.
        /// </exception>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Deflater"/>
        public void SetLevel(int level)
        {
            deflater_.SetLevel(level);
            defaultCompressionLevel = level;
        }

        /// <summary>
        /// Get the current deflater compression level
        /// </summary>
        /// <returns>The current compression level</returns>
        public int GetLevel()
        {
            return deflater_.GetLevel();
        }

        /// <summary>
        /// Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
        /// </summary>
        /// <remarks>Older archivers may not understand Zip64 extensions.
        /// If backwards compatability is an issue be careful when adding <see cref="ZipEntry.Size">entries</see> to an archive.
        /// Setting this property to off is workable but less desirable as in those circumstances adding a file
        /// larger then 4GB will fail.</remarks>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        private void WriteLeShort(int value)
        {
            unchecked
            {
                baseOutputStream_.WriteByte((byte)(value & 0xff));
                baseOutputStream_.WriteByte((byte)((value >> 8) & 0xff));
            }
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        private void WriteLeInt(int value)
        {
            unchecked
            {
                WriteLeShort(value);
                WriteLeShort(value >> 16);
            }
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        private void WriteLeLong(long value)
        {
            unchecked
            {
                WriteLeInt((int)value);
                WriteLeInt((int)(value >> 32));
            }
        }

        /// <summary>
        /// Starts a new Zip entry. It automatically closes the previous
        /// entry if present.
        /// All entry elements bar name are optional, but must be correct if present.
        /// If the compression method is stored and the output is not patchable
        /// the compression for that entry is automatically changed to deflate level 0
        /// </summary>
        /// <param name="entry">
        /// the entry.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// if entry passed is null.
        /// </exception>
        /// <exception cref="System.IO.IOException">
        /// if an I/O error occured.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        /// if stream was finished
        /// </exception>
        /// <exception cref="ZipException">
        /// Too many entries in the Zip file<br/>
        /// Entry name is too long<br/>
        /// Finish has already been called<br/>
        /// </exception>
        public void PutNextEntry(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            if (entries == null)
            {
                throw new InvalidOperationException("ZipOutputStream was finished");
            }

            if (curEntry != null)
            {
                CloseEntry();
            }

            if (entries.Count == int.MaxValue)
            {
                throw new ZipException("Too many entries for Zip file");
            }

            CompressionMethod method = entry.CompressionMethod;
            int compressionLevel = defaultCompressionLevel;

            // Clear flags that the library manages internally
            entry.Flags &= (int)GeneralBitFlags.UnicodeText;
            patchEntryHeader = false;

            bool headerInfoAvailable;

            // No need to compress - definitely no data.
            if (entry.Size == 0)
            {
                entry.CompressedSize = entry.Size;
                entry.Crc = 0;
                method = CompressionMethod.Stored;
                headerInfoAvailable = true;
            }
            else
            {
                headerInfoAvailable = (entry.Size >= 0) && entry.HasCrc;

                // Switch to deflation if storing isnt possible.
                if (method == CompressionMethod.Stored)
                {
                    if (!headerInfoAvailable)
                    {
                        if (!CanPatchEntries)
                        {
                            // Can't patch entries so storing is not possible.
                            method = CompressionMethod.Deflated;
                            compressionLevel = 0;
                        }
                    }
                    else // entry.size must be > 0
                    {
                        entry.CompressedSize = entry.Size;
                        headerInfoAvailable = entry.HasCrc;
                    }
                }
            }

            if (headerInfoAvailable == false)
            {
                if (CanPatchEntries == false)
                {
                    // Only way to record size and compressed size is to append a data descriptor
                    // after compressed data.

                    // Stored entries of this form have already been converted to deflating.
                    entry.Flags |= 8;
                }
                else
                {
                    patchEntryHeader = true;
                }
            }

            if (Password != null)
            {
                entry.IsCrypted = true;
                if (entry.Crc < 0)
                {
                    // Need to append a data descriptor as the crc isnt available for use
                    // with encryption, the date is used instead.  Setting the flag
                    // indicates this to the decompressor.
                    entry.Flags |= 8;
                }
            }

            entry.Offset = offset;
            entry.CompressionMethod = (CompressionMethod)method;

            curMethod = method;
            sizePatchPos = -1;

            if ((useZip64_ == UseZip64.On) || ((entry.Size < 0) && (useZip64_ == UseZip64.Dynamic)))
            {
                entry.ForceZip64();
            }

            // Write the local file header
            WriteLeInt(ZipConstants.LocalHeaderSignature);

            WriteLeShort(entry.Version);
            WriteLeShort(entry.Flags);
            WriteLeShort((byte)entry.CompressionMethodForHeader);
            WriteLeInt((int)entry.DosTime);

            // TODO: Refactor header writing.  Its done in several places.
            if (headerInfoAvailable == true)
            {
                WriteLeInt((int)entry.Crc);
                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLeInt(-1);
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt(entry.IsCrypted ? (int)entry.CompressedSize + ZipConstants.CryptoHeaderSize : (int)entry.CompressedSize);
                    WriteLeInt((int)entry.Size);
                }
            }
            else
            {
                if (patchEntryHeader)
                {
                    crcPatchPos = baseOutputStream_.Position;
                }
                WriteLeInt(0);	// Crc

                if (patchEntryHeader)
                {
                    sizePatchPos = baseOutputStream_.Position;
                }

                // For local header both sizes appear in Zip64 Extended Information
                if (entry.LocalHeaderRequiresZip64 || patchEntryHeader)
                {
                    WriteLeInt(-1);
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt(0);	// Compressed size
                    WriteLeInt(0);	// Uncompressed size
                }
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64)
            {
                ed.StartNewEntry();
                if (headerInfoAvailable)
                {
                    ed.AddLeLong(entry.Size);
                    ed.AddLeLong(entry.CompressedSize);
                }
                else
                {
                    ed.AddLeLong(-1);
                    ed.AddLeLong(-1);
                }
                ed.AddNewEntry(1);

                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cant find extra data");
                }

                if (patchEntryHeader)
                {
                    sizePatchPos = ed.CurrentReadIndex;
                }
            }
            else
            {
                ed.Delete(1);
            }

#if !NET_1_1 && !NETCF_2_0
            if (entry.AESKeySize > 0)
            {
                AddExtraDataAES(entry, ed);
            }
#endif
            byte[] extra = ed.GetEntryData();

            WriteLeShort(name.Length);
            WriteLeShort(extra.Length);

            if (name.Length > 0)
            {
                baseOutputStream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
            {
                sizePatchPos += baseOutputStream_.Position;
            }

            if (extra.Length > 0)
            {
                baseOutputStream_.Write(extra, 0, extra.Length);
            }

            offset += ZipConstants.LocalHeaderBaseSize + name.Length + extra.Length;
            // Fix offsetOfCentraldir for AES
            if (entry.AESKeySize > 0)
                offset += entry.AESOverheadSize;

            // Activate the entry.
            curEntry = entry;
            crc.Reset();
            if (method == CompressionMethod.Deflated)
            {
                deflater_.Reset();
                deflater_.SetLevel(compressionLevel);
            }
            size = 0;

            if (entry.IsCrypted)
            {
#if !NET_1_1 && !NETCF_2_0
                if (entry.AESKeySize > 0)
                {
                    WriteAESHeader(entry);
                }
                else
#endif
                {
                    if (entry.Crc < 0)
                    {			// so testing Zip will says its ok
                        WriteEncryptionHeader(entry.DosTime << 16);
                    }
                    else
                    {
                        WriteEncryptionHeader(entry.Crc);
                    }
                }
            }
        }

        /// <summary>
        /// Closes the current entry, updating header and footer information as required
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An I/O error occurs.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        /// No entry is active.
        /// </exception>
        public void CloseEntry()
        {
            if (curEntry == null)
            {
                throw new InvalidOperationException("No open entry");
            }

            long csize = size;

            // First finish the deflater, if appropriate
            if (curMethod == CompressionMethod.Deflated)
            {
                if (size >= 0)
                {
                    base.Finish();
                    csize = deflater_.TotalOut;
                }
                else
                {
                    deflater_.Reset();
                }
            }

            // Write the AES Authentication Code (a hash of the compressed and encrypted data)
            if (curEntry.AESKeySize > 0)
            {
                baseOutputStream_.Write(AESAuthCode, 0, 10);
            }

            if (curEntry.Size < 0)
            {
                curEntry.Size = size;
            }
            else if (curEntry.Size != size)
            {
                throw new ZipException("size was " + size + ", but I expected " + curEntry.Size);
            }

            if (curEntry.CompressedSize < 0)
            {
                curEntry.CompressedSize = csize;
            }
            else if (curEntry.CompressedSize != csize)
            {
                throw new ZipException("compressed size was " + csize + ", but I expected " + curEntry.CompressedSize);
            }

            if (curEntry.Crc < 0)
            {
                curEntry.Crc = crc.Value;
            }
            else if (curEntry.Crc != crc.Value)
            {
                throw new ZipException("crc was " + crc.Value + ", but I expected " + curEntry.Crc);
            }

            offset += csize;

            if (curEntry.IsCrypted)
            {
                if (curEntry.AESKeySize > 0)
                {
                    curEntry.CompressedSize += curEntry.AESOverheadSize;

                }
                else
                {
                    curEntry.CompressedSize += ZipConstants.CryptoHeaderSize;
                }
            }

            // Patch the header if possible
            if (patchEntryHeader)
            {
                patchEntryHeader = false;

                long curPos = baseOutputStream_.Position;
                baseOutputStream_.Seek(crcPatchPos, SeekOrigin.Begin);
                WriteLeInt((int)curEntry.Crc);

                if (curEntry.LocalHeaderRequiresZip64)
                {

                    if (sizePatchPos == -1)
                    {
                        throw new ZipException("Entry requires zip64 but this has been turned off");
                    }

                    baseOutputStream_.Seek(sizePatchPos, SeekOrigin.Begin);
                    WriteLeLong(curEntry.Size);
                    WriteLeLong(curEntry.CompressedSize);
                }
                else
                {
                    WriteLeInt((int)curEntry.CompressedSize);
                    WriteLeInt((int)curEntry.Size);
                }
                baseOutputStream_.Seek(curPos, SeekOrigin.Begin);
            }

            // Add data descriptor if flagged as required
            if ((curEntry.Flags & 8) != 0)
            {
                WriteLeInt(ZipConstants.DataDescriptorSignature);
                WriteLeInt(unchecked((int)curEntry.Crc));

                if (curEntry.LocalHeaderRequiresZip64)
                {
                    WriteLeLong(curEntry.CompressedSize);
                    WriteLeLong(curEntry.Size);
                    offset += ZipConstants.Zip64DataDescriptorSize;
                }
                else
                {
                    WriteLeInt((int)curEntry.CompressedSize);
                    WriteLeInt((int)curEntry.Size);
                    offset += ZipConstants.DataDescriptorSize;
                }
            }

            entries.Add(curEntry);
            curEntry = null;
        }

        void WriteEncryptionHeader(long crcValue)
        {
            offset += ZipConstants.CryptoHeaderSize;

            InitializePassword(Password);

            byte[] cryptBuffer = new byte[ZipConstants.CryptoHeaderSize];
            Random rnd = new Random();
            rnd.NextBytes(cryptBuffer);
            cryptBuffer[11] = (byte)(crcValue >> 24);

            EncryptBlock(cryptBuffer, 0, cryptBuffer.Length);
            baseOutputStream_.Write(cryptBuffer, 0, cryptBuffer.Length);
        }

#if !NET_1_1 && !NETCF_2_0
        private static void AddExtraDataAES(ZipEntry entry, ZipExtraData extraData)
        {

            // Vendor Version: AE-1 IS 1. AE-2 is 2. With AE-2 no CRC is required and 0 is stored.
            const int VENDOR_VERSION = 2;
            // Vendor ID is the two ASCII characters "AE".
            const int VENDOR_ID = 0x4541; //not 6965;
            extraData.StartNewEntry();
            // Pack AES extra data field see http://www.winzip.com/aes_info.htm
            //extraData.AddLeShort(7);							// Data size (currently 7)
            extraData.AddLeShort(VENDOR_VERSION);				// 2 = AE-2
            extraData.AddLeShort(VENDOR_ID);					// "AE"
            extraData.AddData(entry.AESEncryptionStrength);		//  1 = 128, 2 = 192, 3 = 256
            extraData.AddLeShort((int)entry.CompressionMethod); // The actual compression method used to compress the file
            extraData.AddNewEntry(0x9901);
        }

        // Replaces WriteEncryptionHeader for AES
        //
        private void WriteAESHeader(ZipEntry entry)
        {
            byte[] salt;
            byte[] pwdVerifier;
            InitializeAESPassword(entry, Password, out salt, out pwdVerifier);
            // File format for AES:
            // Size (bytes)   Content
            // ------------   -------
            // Variable       Salt value
            // 2              Password verification value
            // Variable       Encrypted file data
            // 10             Authentication code
            //
            // Value in the "compressed size" fields of the local file header and the central directory entry
            // is the total size of all the items listed above. In other words, it is the total size of the
            // salt value, password verification value, encrypted data, and authentication code.
            baseOutputStream_.Write(salt, 0, salt.Length);
            baseOutputStream_.Write(pwdVerifier, 0, pwdVerifier.Length);
        }
#endif

        /// <summary>
        /// Writes the given buffer to the current entry.
        /// </summary>
        /// <param name="buffer">The buffer containing data to write.</param>
        /// <param name="offset">The offset of the first byte to write.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <exception cref="ZipException">Archive size is invalid</exception>
        /// <exception cref="System.InvalidOperationException">No entry is active.</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (curEntry == null)
            {
                throw new InvalidOperationException("No open entry.");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if ((buffer.Length - offset) < count)
            {
                throw new ArgumentException("Invalid offset/count combination");
            }

            crc.Update(buffer, offset, count);
            size += count;

            switch (curMethod)
            {
                case CompressionMethod.Deflated:
                    base.Write(buffer, offset, count);
                    break;

                case CompressionMethod.Stored:
                    if (Password != null)
                    {
                        CopyAndEncrypt(buffer, offset, count);
                    }
                    else
                    {
                        baseOutputStream_.Write(buffer, offset, count);
                    }
                    break;
            }
        }

        void CopyAndEncrypt(byte[] buffer, int offset, int count)
        {
            const int CopyBufferSize = 4096;
            byte[] localBuffer = new byte[CopyBufferSize];
            while (count > 0)
            {
                int bufferCount = (count < CopyBufferSize) ? count : CopyBufferSize;

                Array.Copy(buffer, offset, localBuffer, 0, bufferCount);
                EncryptBlock(localBuffer, 0, bufferCount);
                baseOutputStream_.Write(localBuffer, 0, bufferCount);
                count -= bufferCount;
                offset += bufferCount;
            }
        }

        /// <summary>
        /// Finishes the stream.  This will write the central directory at the
        /// end of the zip file and flush the stream.
        /// </summary>
        /// <remarks>
        /// This is automatically called when the stream is closed.
        /// </remarks>
        /// <exception cref="System.IO.IOException">
        /// An I/O error occurs.
        /// </exception>
        /// <exception cref="ZipException">
        /// Comment exceeds the maximum length<br/>
        /// Entry name exceeds the maximum length
        /// </exception>
        public override void Finish()
        {
            if (entries == null)
            {
                return;
            }

            if (curEntry != null)
            {
                CloseEntry();
            }

            long numEntries = entries.Count;
            long sizeEntries = 0;

            foreach (ZipEntry entry in entries)
            {
                WriteLeInt(ZipConstants.CentralHeaderSignature);
                WriteLeShort(ZipConstants.VersionMadeBy);
                WriteLeShort(entry.Version);
                WriteLeShort(entry.Flags);
                WriteLeShort((short)entry.CompressionMethodForHeader);
                WriteLeInt((int)entry.DosTime);
                WriteLeInt((int)entry.Crc);

                if (entry.IsZip64Forced() ||
                    (entry.CompressedSize >= uint.MaxValue))
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.CompressedSize);
                }

                if (entry.IsZip64Forced() ||
                    (entry.Size >= uint.MaxValue))
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.Size);
                }

                byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

                if (name.Length > 0xffff)
                {
                    throw new ZipException("Name too long.");
                }

                ZipExtraData ed = new ZipExtraData(entry.ExtraData);

                if (entry.CentralHeaderRequiresZip64)
                {
                    ed.StartNewEntry();
                    if (entry.IsZip64Forced() ||
                        (entry.Size >= 0xffffffff))
                    {
                        ed.AddLeLong(entry.Size);
                    }

                    if (entry.IsZip64Forced() ||
                        (entry.CompressedSize >= 0xffffffff))
                    {
                        ed.AddLeLong(entry.CompressedSize);
                    }

                    if (entry.Offset >= 0xffffffff)
                    {
                        ed.AddLeLong(entry.Offset);
                    }

                    ed.AddNewEntry(1);
                }
                else
                {
                    ed.Delete(1);
                }

#if !NET_1_1 && !NETCF_2_0
                if (entry.AESKeySize > 0)
                {
                    AddExtraDataAES(entry, ed);
                }
#endif
                byte[] extra = ed.GetEntryData();

                byte[] entryComment =
                    (entry.Comment != null) ?
                    ZipConstants.ConvertToArray(entry.Flags, entry.Comment) :
                    new byte[0];

                if (entryComment.Length > 0xffff)
                {
                    throw new ZipException("Comment too long.");
                }

                WriteLeShort(name.Length);
                WriteLeShort(extra.Length);
                WriteLeShort(entryComment.Length);
                WriteLeShort(0);	// disk number
                WriteLeShort(0);	// internal file attributes
                // external file attributes

                if (entry.ExternalFileAttributes != -1)
                {
                    WriteLeInt(entry.ExternalFileAttributes);
                }
                else
                {
                    if (entry.IsDirectory)
                    {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)
                        WriteLeInt(16);
                    }
                    else
                    {
                        WriteLeInt(0);
                    }
                }

                if (entry.Offset >= uint.MaxValue)
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.Offset);
                }

                if (name.Length > 0)
                {
                    baseOutputStream_.Write(name, 0, name.Length);
                }

                if (extra.Length > 0)
                {
                    baseOutputStream_.Write(extra, 0, extra.Length);
                }

                if (entryComment.Length > 0)
                {
                    baseOutputStream_.Write(entryComment, 0, entryComment.Length);
                }

                sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;
            }

            using (ZipHelperStream zhs = new ZipHelperStream(baseOutputStream_))
            {
                zhs.WriteEndOfCentralDirectory(numEntries, sizeEntries, offset, zipComment);
            }

            entries = null;
        }

        #region Instance Fields
        /// <summary>
        /// The entries for the archive.
        /// </summary>
        ArrayList entries = new ArrayList();

        /// <summary>
        /// Used to track the crc of data added to entries.
        /// </summary>
        Crc32 crc = new Crc32();

        /// <summary>
        /// The current entry being added.
        /// </summary>
        ZipEntry curEntry;

        int defaultCompressionLevel = Deflater.DEFAULT_COMPRESSION;

        CompressionMethod curMethod = CompressionMethod.Deflated;

        /// <summary>
        /// Used to track the size of data for an entry during writing.
        /// </summary>
        long size;

        /// <summary>
        /// Offset to be recorded for each entry in the central header.
        /// </summary>
        long offset;

        /// <summary>
        /// Comment for the entire archive recorded in central header.
        /// </summary>
        byte[] zipComment = new byte[0];

        /// <summary>
        /// Flag indicating that header patching is required for the current entry.
        /// </summary>
        bool patchEntryHeader;

        /// <summary>
        /// Position to patch crc
        /// </summary>
        long crcPatchPos = -1;

        /// <summary>
        /// Position to patch size.
        /// </summary>
        long sizePatchPos = -1;

        // Default is dynamic which is not backwards compatible and can cause problems
        // with XP's built in compression which cant read Zip64 archives.
        // However it does avoid the situation were a large file is added and cannot be completed correctly.
        // NOTE: Setting the size for entries before they are added is the best solution!
        UseZip64 useZip64_ = UseZip64.Dynamic;
        #endregion
    }
}

#if !NET_1_1 && !NETCF_2_0
namespace ICSharpCode.SharpZipLib.Encryption
{

    // Framework version 2.0 required for Rfc2898DeriveBytes 

    using System;
    using System.Security.Cryptography;
    /// <summary>
    /// Transforms stream using AES in CTR mode
    /// </summary>
    internal class ZipAESTransform : ICryptoTransform
    {

        private const int PWD_VER_LENGTH = 2;

        // WinZip use iteration count of 1000 for PBKDF2 key generation
        private const int KEY_ROUNDS = 1000;

        // For 128-bit AES (16 bytes) the encryption is implemented as expected.
        // For 256-bit AES (32 bytes) WinZip do full 256 bit AES of the nonce to create the encryption
        // block but use only the first 16 bytes of it, and discard the second half.
        private const int ENCRYPT_BLOCK = 16;

        private int _blockSize;
        private ICryptoTransform _encryptor;
        private readonly byte[] _counterNonce;
        private byte[] _encryptBuffer;
        private int _encrPos;
        private byte[] _pwdVerifier;
        private HMACSHA1 _hmacsha1;
        private bool _finalised;

        private bool _writeMode;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="key">Password string</param>
        /// <param name="saltBytes">Random bytes, length depends on encryption strength.
        /// 128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.</param>
        /// <param name="blockSize">The encryption strength, in bytes eg 16 for 128 bits.</param>
        /// <param name="writeMode">True when creating a zip, false when reading. For the AuthCode.</param>
        ///
        public ZipAESTransform(string key, byte[] saltBytes, int blockSize, bool writeMode)
        {

            if (blockSize != 16 && blockSize != 32)	// 24 valid for AES but not supported by Winzip
                throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
            if (saltBytes.Length != blockSize / 2)
                throw new Exception("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);
            // initialise the encryption buffer and buffer pos
            _blockSize = blockSize;
            _encryptBuffer = new byte[_blockSize];
            _encrPos = ENCRYPT_BLOCK;

            // Performs the equivalent of derive_key in Dr Brian Gladman's pwd2key.c
            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(key, saltBytes, KEY_ROUNDS);
            RijndaelManaged rm = new RijndaelManaged();
            rm.Mode = CipherMode.ECB;			// No feedback from cipher for CTR mode
            _counterNonce = new byte[_blockSize];
            byte[] byteKey1 = pdb.GetBytes(_blockSize);
            byte[] byteKey2 = pdb.GetBytes(_blockSize);
            _encryptor = rm.CreateEncryptor(byteKey1, byteKey2);
            _pwdVerifier = pdb.GetBytes(PWD_VER_LENGTH);
            //
            _hmacsha1 = new HMACSHA1(byteKey2);
            _writeMode = writeMode;
        }

        /// <summary>
        /// Implement the ICryptoTransform method.
        /// </summary>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {

            // Pass the data stream to the hash algorithm for generating the Auth Code.
            // This does not change the inputBuffer. Do this before decryption for read mode.
            if (!_writeMode)
            {
                _hmacsha1.TransformBlock(inputBuffer, inputOffset, inputCount, inputBuffer, inputOffset);
            }
            // Encrypt with AES in CTR mode. Regards to Dr Brian Gladman for this.
            int ix = 0;
            while (ix < inputCount)
            {
                if (_encrPos == ENCRYPT_BLOCK)
                {
                    /* increment encryption nonce   */
                    int j = 0;
                    while (++_counterNonce[j] == 0)
                    {
                        ++j;
                    }
                    /* encrypt the nonce to form next xor buffer    */
                    _encryptor.TransformBlock(_counterNonce, 0, _blockSize, _encryptBuffer, 0);
                    _encrPos = 0;
                }
                outputBuffer[ix + outputOffset] = (byte)(inputBuffer[ix + inputOffset] ^ _encryptBuffer[_encrPos++]);
                //
                ix++;
            }
            if (_writeMode)
            {
                // This does not change the buffer. 
                _hmacsha1.TransformBlock(outputBuffer, outputOffset, inputCount, outputBuffer, outputOffset);
            }
            return inputCount;
        }

        /// <summary>
        /// Returns the 2 byte password verifier
        /// </summary>
        public byte[] PwdVerifier
        {
            get
            {
                return _pwdVerifier;
            }
        }

        /// <summary>
        /// Returns the 10 byte AUTH CODE to be checked or appended immediately following the AES data stream.
        /// </summary>
        public byte[] GetAuthCode()
        {
            // We usually don't get advance notice of final block. Hash requres a TransformFinal.
            if (!_finalised)
            {
                byte[] dummy = new byte[0];
                _hmacsha1.TransformFinalBlock(dummy, 0, 0);
                _finalised = true;
            }
            return _hmacsha1.Hash;
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Not implemented.
        /// </summary>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {

            throw new NotImplementedException("ZipAESTransform.TransformFinalBlock");
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return _blockSize;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return _blockSize;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            _encryptor.Dispose();
        }

        #endregion

    }
}
#endif


#if !NET_1_1 && !NETCF_2_0
namespace ICSharpCode.SharpZipLib.Encryption
{
    using System;
    using System.IO;
    using System.Security.Cryptography;
    // Based on information from http://www.winzip.com/aes_info.htm
    // and http://www.gladman.me.uk/cryptography_technology/fileencrypt/

    /// <summary>
    /// Encrypts and decrypts AES ZIP
    /// </summary>
    internal class ZipAESStream : CryptoStream
    {

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="stream">The stream on which to perform the cryptographic transformation.</param>
        /// <param name="transform">Instance of ZipAESTransform</param>
        /// <param name="mode">Read or Write</param>
        public ZipAESStream(Stream stream, ZipAESTransform transform, CryptoStreamMode mode)
            : base(stream, transform, mode)
        {

            _stream = stream;
            _transform = transform;
            _slideBuffer = new byte[1024];

            _blockAndAuth = CRYPTO_BLOCK_SIZE + AUTH_CODE_LENGTH;

            // mode:
            //  CryptoStreamMode.Read means we read from "stream" and pass decrypted to our Read() method.
            //  Write bypasses this stream and uses the Transform directly.
            if (mode != CryptoStreamMode.Read)
            {
                throw new Exception("ZipAESStream only for read");
            }
        }

        // The final n bytes of the AES stream contain the Auth Code.
        private const int AUTH_CODE_LENGTH = 10;

        private Stream _stream;
        private ZipAESTransform _transform;
        private byte[] _slideBuffer;
        private int _slideBufStartPos;
        private int _slideBufFreePos;
        // Blocksize is always 16 here, even for AES-256 which has transform.InputBlockSize of 32.
        private const int CRYPTO_BLOCK_SIZE = 16;
        private int _blockAndAuth;

        /// <summary>
        /// Reads a sequence of bytes from the current CryptoStream into buffer,
        /// and advances the position within the stream by the number of bytes read.
        /// </summary>
        public override int Read(byte[] outBuffer, int offset, int count)
        {
            int nBytes = 0;
            while (nBytes < count)
            {
                // Calculate buffer quantities vs read-ahead size, and check for sufficient free space
                int byteCount = _slideBufFreePos - _slideBufStartPos;

                // Need to handle final block and Auth Code specially, but don't know total data length.
                // Maintain a read-ahead equal to the length of (crypto block + Auth Code). 
                // When that runs out we can detect these final sections.
                int lengthToRead = _blockAndAuth - byteCount;
                if (_slideBuffer.Length - _slideBufFreePos < lengthToRead)
                {
                    // Shift the data to the beginning of the buffer
                    int iTo = 0;
                    for (int iFrom = _slideBufStartPos; iFrom < _slideBufFreePos; iFrom++, iTo++)
                    {
                        _slideBuffer[iTo] = _slideBuffer[iFrom];
                    }
                    _slideBufFreePos -= _slideBufStartPos;		// Note the -=
                    _slideBufStartPos = 0;
                }
                int obtained = _stream.Read(_slideBuffer, _slideBufFreePos, lengthToRead);
                _slideBufFreePos += obtained;

                // Recalculate how much data we now have
                byteCount = _slideBufFreePos - _slideBufStartPos;
                if (byteCount >= _blockAndAuth)
                {
                    // At least a 16 byte block and an auth code remains.
                    _transform.TransformBlock(_slideBuffer,
                                              _slideBufStartPos,
                                              CRYPTO_BLOCK_SIZE,
                                              outBuffer,
                                              offset);
                    nBytes += CRYPTO_BLOCK_SIZE;
                    offset += CRYPTO_BLOCK_SIZE;
                    _slideBufStartPos += CRYPTO_BLOCK_SIZE;
                }
                else
                {
                    // Last round.
                    if (byteCount > AUTH_CODE_LENGTH)
                    {
                        // At least one byte of data plus auth code
                        int finalBlock = byteCount - AUTH_CODE_LENGTH;
                        _transform.TransformBlock(_slideBuffer,
                                                  _slideBufStartPos,
                                                  finalBlock,
                                                  outBuffer,
                                                  offset);

                        nBytes += finalBlock;
                        _slideBufStartPos += finalBlock;
                    }
                    else if (byteCount < AUTH_CODE_LENGTH)
                        throw new Exception("Internal error missed auth code");	// Coding bug
                    // Final block done. Check Auth code.
                    byte[] calcAuthCode = _transform.GetAuthCode();
                    for (int i = 0; i < AUTH_CODE_LENGTH; i++)
                    {
                        if (calcAuthCode[i] != _slideBuffer[_slideBufStartPos + i])
                        {
                            throw new Exception("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n"
                                + "The file may be damaged.");
                        }
                    }

                    break;	// Reached the auth code
                }
            }
            return nBytes;
        }

        /// <summary>
        /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream. </param>
        /// <param name="offset">The byte offset in buffer at which to begin copying bytes to the current stream. </param>
        /// <param name="count">The number of bytes to be written to the current stream. </param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            // ZipAESStream is used for reading but not for writing. Writing uses the ZipAESTransform directly.
            throw new NotImplementedException();
        }
    }
}
#endif

#if !NETCF_1_0
namespace ICSharpCode.SharpZipLib.Encryption
{
    using System;
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Checksums;
    /// <summary>
    /// PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
    /// While it has been superceded by more recent and more powerful algorithms, its still in use and 
    /// is viable for preventing casual snooping
    /// </summary>
    public abstract class PkzipClassic : SymmetricAlgorithm
    {
        /// <summary>
        /// Generates new encryption keys based on given seed
        /// </summary>
        /// <param name="seed">The seed value to initialise keys with.</param>
        /// <returns>A new key value.</returns>
        static public byte[] GenerateKeys(byte[] seed)
        {
            if (seed == null)
            {
                throw new ArgumentNullException("seed");
            }

            if (seed.Length == 0)
            {
                throw new ArgumentException("Length is zero", "seed");
            }

            uint[] newKeys = new uint[] {
                0x12345678,
                0x23456789,
                0x34567890
             };

            for (int i = 0; i < seed.Length; ++i)
            {
                newKeys[0] = Crc32.ComputeCrc32(newKeys[0], seed[i]);
                newKeys[1] = newKeys[1] + (byte)newKeys[0];
                newKeys[1] = newKeys[1] * 134775813 + 1;
                newKeys[2] = Crc32.ComputeCrc32(newKeys[2], (byte)(newKeys[1] >> 24));
            }

            byte[] result = new byte[12];
            result[0] = (byte)(newKeys[0] & 0xff);
            result[1] = (byte)((newKeys[0] >> 8) & 0xff);
            result[2] = (byte)((newKeys[0] >> 16) & 0xff);
            result[3] = (byte)((newKeys[0] >> 24) & 0xff);
            result[4] = (byte)(newKeys[1] & 0xff);
            result[5] = (byte)((newKeys[1] >> 8) & 0xff);
            result[6] = (byte)((newKeys[1] >> 16) & 0xff);
            result[7] = (byte)((newKeys[1] >> 24) & 0xff);
            result[8] = (byte)(newKeys[2] & 0xff);
            result[9] = (byte)((newKeys[2] >> 8) & 0xff);
            result[10] = (byte)((newKeys[2] >> 16) & 0xff);
            result[11] = (byte)((newKeys[2] >> 24) & 0xff);
            return result;
        }
    }

    /// <summary>
    /// PkzipClassicCryptoBase provides the low level facilities for encryption
    /// and decryption using the PkzipClassic algorithm.
    /// </summary>
    class PkzipClassicCryptoBase
    {
        /// <summary>
        /// Transform a single byte 
        /// </summary>
        /// <returns>
        /// The transformed value
        /// </returns>
        protected byte TransformByte()
        {
            uint temp = ((keys[2] & 0xFFFF) | 2);
            return (byte)((temp * (temp ^ 1)) >> 8);
        }

        /// <summary>
        /// Set the key schedule for encryption/decryption.
        /// </summary>
        /// <param name="keyData">The data use to set the keys from.</param>
        protected void SetKeys(byte[] keyData)
        {
            if (keyData == null)
            {
                throw new ArgumentNullException("keyData");
            }

            if (keyData.Length != 12)
            {
                throw new InvalidOperationException("Key length is not valid");
            }

            keys = new uint[3];
            keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
            keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
            keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
        }

        /// <summary>
        /// Update encryption keys 
        /// </summary>		
        protected void UpdateKeys(byte ch)
        {
            keys[0] = Crc32.ComputeCrc32(keys[0], ch);
            keys[1] = keys[1] + (byte)keys[0];
            keys[1] = keys[1] * 134775813 + 1;
            keys[2] = Crc32.ComputeCrc32(keys[2], (byte)(keys[1] >> 24));
        }

        /// <summary>
        /// Reset the internal state.
        /// </summary>
        protected void Reset()
        {
            keys[0] = 0;
            keys[1] = 0;
            keys[2] = 0;
        }

        #region Instance Fields
        uint[] keys;
        #endregion
    }

    /// <summary>
    /// PkzipClassic CryptoTransform for encryption.
    /// </summary>
    class PkzipClassicEncryptCryptoTransform : PkzipClassicCryptoBase, ICryptoTransform
    {
        /// <summary>
        /// Initialise a new instance of <see cref="PkzipClassicEncryptCryptoTransform"></see>
        /// </summary>
        /// <param name="keyBlock">The key block to use.</param>
        internal PkzipClassicEncryptCryptoTransform(byte[] keyBlock)
        {
            SetKeys(keyBlock);
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Transforms the specified region of the specified byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the byte array to use as data.</param>
        /// <returns>The computed transform.</returns>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {
            byte[] result = new byte[inputCount];
            TransformBlock(inputBuffer, inputOffset, inputCount, result, 0);
            return result;
        }

        /// <summary>
        /// Transforms the specified region of the input byte array and copies 
        /// the resulting transform to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write the transform.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>The number of bytes written.</returns>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            for (int i = inputOffset; i < inputOffset + inputCount; ++i)
            {
                byte oldbyte = inputBuffer[i];
                outputBuffer[outputOffset++] = (byte)(inputBuffer[i] ^ TransformByte());
                UpdateKeys(oldbyte);
            }
            return inputCount;
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            Reset();
        }

        #endregion
    }


    /// <summary>
    /// PkzipClassic CryptoTransform for decryption.
    /// </summary>
    class PkzipClassicDecryptCryptoTransform : PkzipClassicCryptoBase, ICryptoTransform
    {
        /// <summary>
        /// Initialise a new instance of <see cref="PkzipClassicDecryptCryptoTransform"></see>.
        /// </summary>
        /// <param name="keyBlock">The key block to decrypt with.</param>
        internal PkzipClassicDecryptCryptoTransform(byte[] keyBlock)
        {
            SetKeys(keyBlock);
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Transforms the specified region of the specified byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the byte array to use as data.</param>
        /// <returns>The computed transform.</returns>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {
            byte[] result = new byte[inputCount];
            TransformBlock(inputBuffer, inputOffset, inputCount, result, 0);
            return result;
        }

        /// <summary>
        /// Transforms the specified region of the input byte array and copies 
        /// the resulting transform to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write the transform.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>The number of bytes written.</returns>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            for (int i = inputOffset; i < inputOffset + inputCount; ++i)
            {
                byte newByte = (byte)(inputBuffer[i] ^ TransformByte());
                outputBuffer[outputOffset++] = newByte;
                UpdateKeys(newByte);
            }
            return inputCount;
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            Reset();
        }

        #endregion
    }

    /// <summary>
    /// Defines a wrapper object to access the Pkzip algorithm. 
    /// This class cannot be inherited.
    /// </summary>
    public sealed class PkzipClassicManaged : PkzipClassic
    {
        /// <summary>
        /// Get / set the applicable block size in bits.
        /// </summary>
        /// <remarks>The only valid block size is 8.</remarks>
        public override int BlockSize
        {
            get
            {
                return 8;
            }

            set
            {
                if (value != 8)
                {
                    throw new CryptographicException("Block size is invalid");
                }
            }
        }

        /// <summary>
        /// Get an array of legal <see cref="KeySizes">key sizes.</see>
        /// </summary>
        public override KeySizes[] LegalKeySizes
        {
            get
            {
                KeySizes[] keySizes = new KeySizes[1];
                keySizes[0] = new KeySizes(12 * 8, 12 * 8, 0);
                return keySizes;
            }
        }

        /// <summary>
        /// Generate an initial vector.
        /// </summary>
        public override void GenerateIV()
        {
            // Do nothing.
        }

        /// <summary>
        /// Get an array of legal <see cref="KeySizes">block sizes</see>.
        /// </summary>
        public override KeySizes[] LegalBlockSizes
        {
            get
            {
                KeySizes[] keySizes = new KeySizes[1];
                keySizes[0] = new KeySizes(1 * 8, 1 * 8, 0);
                return keySizes;
            }
        }

        /// <summary>
        /// Get / set the key value applicable.
        /// </summary>
        public override byte[] Key
        {
            get
            {
                if (key_ == null)
                {
                    GenerateKey();
                }

                return (byte[])key_.Clone();
            }

            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                if (value.Length != 12)
                {
                    throw new CryptographicException("Key size is illegal");
                }

                key_ = (byte[])value.Clone();
            }
        }

        /// <summary>
        /// Generate a new random key.
        /// </summary>
        public override void GenerateKey()
        {
            key_ = new byte[12];
            Random rnd = new Random();
            rnd.NextBytes(key_);
        }

        /// <summary>
        /// Create an encryptor.
        /// </summary>
        /// <param name="rgbKey">The key to use for this encryptor.</param>
        /// <param name="rgbIV">Initialisation vector for the new encryptor.</param>
        /// <returns>Returns a new PkzipClassic encryptor</returns>
        public override ICryptoTransform CreateEncryptor(
            byte[] rgbKey,
            byte[] rgbIV)
        {
            key_ = rgbKey;
            return new PkzipClassicEncryptCryptoTransform(Key);
        }

        /// <summary>
        /// Create a decryptor.
        /// </summary>
        /// <param name="rgbKey">Keys to use for this new decryptor.</param>
        /// <param name="rgbIV">Initialisation vector for the new decryptor.</param>
        /// <returns>Returns a new decryptor.</returns>
        public override ICryptoTransform CreateDecryptor(
            byte[] rgbKey,
            byte[] rgbIV)
        {
            key_ = rgbKey;
            return new PkzipClassicDecryptCryptoTransform(Key);
        }

        #region Instance Fields
        byte[] key_;
        #endregion
    }
}
#endif]]></ProjectItem>
          <ProjectItem
            Name="Project"
            Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="3.0" schemaVersion="1.0">
	<msb:PropertyGroup>
		<msb:Language>msBuild</msb:Language>
		<msb:CodeName>ST_db9c914794964d28bf6f1d7116dd222f</msb:CodeName>
		<msb:DisplayName>ST_db9c914794964d28bf6f1d7116dd222f</msb:DisplayName>
		<msb:ProjectId>{F063C9E2-CECE-4FAC-B368-DB2E6CE4C087}</msb:ProjectId>
	</msb:PropertyGroup>
	<msb:ItemGroup>
		<msb:Project Include="ST_db9c914794964d28bf6f1d7116dd222f.csproj"/>
		<msb:File Include="Properties\Settings.settings"/>
		<msb:File Include="Properties\AssemblyInfo.cs"/>
		<msb:File Include="Properties\Resources.resx"/>
		<msb:File Include="Properties\Resources.Designer.cs"/>
		<msb:File Include="Properties\Settings.Designer.cs"/>
		<msb:File Include="ScriptMain.cs"/>
	</msb:ItemGroup>
</c:Project>]]></ProjectItem>
          <ProjectItem
            Name="Properties\AssemblyInfo.cs"
            Encoding="UTF8"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_db9c914794964d28bf6f1d7116dd222f")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ST_db9c914794964d28bf6f1d7116dd222f")]
[assembly: AssemblyCopyright("Copyright @  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem>
          <ProjectItem
            Name="Properties\Settings.settings"
            Encoding="UTF8"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem>
          <ProjectItem
            Name="Properties\Resources.Designer.cs"
            Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_db9c914794964d28bf6f1d7116dd222f.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_db9c914794964d28bf6f1d7116dd222f.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="ST_db9c914794964d28bf6f1d7116dd222f.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_db9c914794964d28bf6f1d7116dd222f.Properties {
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if ((resourceMan == null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_db9c914794964d28bf6f1d7116dd222f.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem>
          <BinaryItem
            Name="ST_db9c914794964d28bf6f1d7116dd222f.dll">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
WQAACioAAAATMAQAPwAAAFUAABEEBWpZCgYWai8DFWoqBg4EalkWaijTAAAKCwYHLwMVaioCBiUX
alkKFm+rAAAKJgIoJgIABgMz4gJvXgAACioAEzACAHsAAAA5AAARAnsUAQAEb14AAAoKAiBQSwYG
KCoCAAYCHyxqKCwCAAYCHzMoKAIABgIfLSgoAgAGAhYoKgIABgIWKCoCAAYCAygsAgAGAgMoLAIA
BgIEKCwCAAYCBSgsAgAGAiBQSwYHKCoCAAYCFigqAgAGAgYoLAIABgIXKCoCAAYqABMwBADVAAAA
FgAAEQMg//8AAGovCgUVbi8FBBVuMgkCAwQFKCMCAAYCIFBLBQYoKgIABgIWKCgCAAYCFigoAgAG
AyD//wAAajIYAiD//wAAKCkCAAYCIP//AAAoKQIABisQAgNoKCgCAAYCA2goKAIABgQVbjIJAhUo
KwIABisIAgRpKCoCAAYFFW4yCQIVKCsCAAYrCAIFaSgqAgAGDgQtAxYrBA4EjmkKBiD//wAAMRZy
ZR8AcAaMPwAAASi3AAAKcyYBAAZ6AgYoKAIABgYWMQ0CDgQWDgSOaW9ZAAAKKgAAABMwAwAwAAAA
FgAAEQJ7FAEABG+lAAAKJRYvBnNYAAAKegJ7FAEABG+lAAAKCgYWLwZzWAAACnoGHmJgKkYCKCUC
AAYCKCUCAAYfEGJgKk4CKCYCAAZuAigmAgAGah8gYmAqpgJ7FAEABAMg/wAAAF/Sb6cAAAoCexQB
AAQDHmMg/wAAAF/Sb6cAAAoqjgJ7FAEABAMg/wAAAF/Sb6cAAAoCexQBAAQDHmPSb6cAAAoqSgID
KCgCAAYCAx8QYygoAgAGKmoCAyD//wAAX9EoKQIABgIDHxBk0SgpAgAGKlICA2koKgIABgIDHyBj
aSgqAgAGKl4CAxVuX20oKwIABgIDHyBkbSgrAgAGKgATMAIAfQAAABYAABEDLQtyOAYAcHMsAAAK
ehYKA2/eAAAGHl8sYQIgUEsHCCgqAgAGAgNv+gAABmkoKgIABgYeWAoDb+8AAAYsHwIDb/gAAAYo
LAIABgIDb/YAAAYoLAIABgYfEFgKKx4CA2/4AAAGaSgqAgAGAgNv9gAABmkoKgIABgYeWAoGKgAA
ABMwAgBcAAAAAAAAAAIoJgIABiBQSwcILgtyxR8AcHMmAQAGegQCKCYCAAZqbwkCAAYDLBkEAign
AgAGbwUCAAYEAignAgAGbwcCAAYqBAIoJgIABmpvBQIABgQCKCYCAAZqbwcCAAYqrgJzLQMABn0W
AQAEAgMXc5gCAAYo9QIABgIC/gY8AgAGc4sDAAZ9FQEABCqyAnMtAwAGfRYBAAQCAxdzmAIABgQo
9gIABgIC/gY8AgAGc4sDAAZ9FQEABCoeAnsbAQAEKiICA30bAQAEKloCexcBAAQsDAJ7FwEABG/s
AAAGKhYqAAAAEzADADYDAABWAAARAnsWAQAELQtyDSAAcHMwAAAKegJ7FwEABCwGAig4AgAGAnvd
AQAEb/ECAAYKBiBQSwECLiAGIFBLBQYuGAYgUEsFBS4QBiBQSwYHLggGIFBLBgYzCAJvrwAAChQq
BiBQSzAwLggGIFBLBwgzDAJ73QEABG/xAgAGCgYgUEsDBC4gch0gAHByXyAAcAaMPwAAASi3AAAK
KNQAAApzJgEABnoCe90BAARv8AIABmgLAgJ73QEABG/wAgAGfRoBAAQCAnvdAQAEb/ACAAZ9GQEA
BAJ73QEABG/xAgAGDAJ73QEABG/xAgAGDQICe90BAARv8QIABmp93wEABAICe90BAARv8QIABmp9
GAEABAJ73QEABG/wAgAGAnvdAQAEb/ACAAYTBAJ7GgEABBdfF/4BEwWNQQAAARMGAnvdAQAEEQZv
7AIABiYCexoBAAQRBijOAAAGEwcCEQcHc9QAAAZ9FwEABAJ7FwEABAJ7GgEABG/fAAAGAnsXAQAE
AnsZAQAEb/0AAAYCexoBAAQeXy1QAnsXAQAECWoVbl9v+wAABgJ7FwEABAJ7GAEABBVuX2/3AAAG
AnsXAQAEAnvfAQAEFW5fb/kAAAYCexcBAAQJHxhjIP8AAABf0m/dAAAGK2AJLBACexcBAAQJahVu
X2/7AAAGAnsYAQAELBQCexcBAAQCexgBAAQVbl9v9wAABgJ73wEABCwUAnsXAQAEAnvfAQAEFW5f
b/kAAAYCexcBAAQIHmQg/wAAAF/Sb90AAAYCexcBAAQIbm/yAAAGEQQWMSQRBI1BAAABEwgCe90B
AAQRCG/sAgAGJgJ7FwEABBEIbwABAAYCexcBAAQXbwYBAAYCexcBAARv+AAABhZqMhECAnsXAQAE
b/gAAAZ93wEABAJ7FwEABG/2AAAGFmoyEQICexcBAARv9gAABn0YAQAEAnsZAQAELTMRBS0OAnvf
AQAEAnsYAQAEMxYRBSwdAnvfAQAEHwxqWQJ7GAEABC4LcmsgAHBzJgEABnoCexcBAARvDAEABiwU
AgL+Bj4CAAZziwMABn0VAQAEKxICAv4GPQIABnOLAwAGfRUBAAQCexcBAAQqAAATMAMArwAAAAAA
AAACe90BAARv8QIABiBQSwcILgtyxR8AcHMmAQAGegJ7FwEABAJ73QEABG/xAgAGahVuX2/7AAAG
AnsXAQAEb+8AAAYsJAICe90BAARv8gIABn3fAQAEAgJ73QEABG/yAgAGfRgBAAQrJAICe90BAARv
8QIABmp93wEABAICe90BAARv8QIABmp9GAEABAJ7FwEABAJ73wEABG/5AAAGAnsXAQAEAnsYAQAE
b/cAAAYqABMwAgB9AAAAAAAAAAIo+gIABgJ7GgEABB5fLAYCKDYCAAYCFmp9GAEABAMsNQJ7FgEA
BG8nAwAGFW5fAnsXAQAEb/oAAAYuGgJ7FwEABG/6AAAGFWouC3KADABwcyYBAAZ6AnsWAQAEbykD
AAYCexkBAAQeMwsCe9wBAARvmQIABgIUfRcBAAQqAAAAEzAEAB8BAABXAAARAnsWAQAELQtyuSAA
cHMwAAAKegJ7FwEABC0BKgJ7GQEABB4zWQJ7GgEABB5fLBogABAAAI1BAAABCgIGFgaOaW8qAAAK
FjDyKgICe98BAAQCe9wBAARvqgIABll93wEABAJ73QEABCVv6AIABgJ73AEABG+rAgAGWG/pAgAG
AnvdAQAEb+gCAAZqAnvfAQAEMSsCe98BAAQWajIhAnvdAQAEAnvdAQAEb+gCAAZqAnvfAQAEWWlv
6QIABitaAgJ73wEABAJ73QEABG/oAgAGall93wEABAJ73QEABBZv6QIABisrAgJ73wEABCj5AgAG
CwcWajALcscgAHBzJgEABnoCAnvfAQAEB1l93wEABAJ73wEABC3NAhYoNwIABioyAnsXAQAELQIW
Khcq5gJ7FwEABCwmAnsXAQAEb/YAAAYWajIMAnsXAQAEb/YAAAYqcvcgAHBzJgEABnpyTSEAcHMw
AAAKegAAEzAEAB8AAAADAAARF41BAAABCgIGFhdvKgAAChYwAhUqBhaRIP8AAABfKi5ybyEAcHMw
AAAKei5yryEAcHMmAQAGegATMAQAcAEAAFgAABECKDQCAAYtKHIdIgBwAnsXAQAEb+sAAAYKEgAo
1QAACnKPIgBwKNYAAApzJgEABnoCexcBAARv2AAABjm4AAAAAnsbAQAELQtykyIAcHMmAQAGenMz
AAAGCwJ7GwEABCjPAAAGKBIAAAYMAnvdAQAEBwgUb8kAAApv8wIABh8MjUEAAAENAnvdAQAECRYf
DG/uAgAGJgkfC5ECexcBAARv3AAABi4LclceAHBzJgEABnoCe98BAAQfDGoyEgICe98BAAQfDGpZ
fd8BAAQrNgJ7FwEABG/eAAAGHl8tJ3K1IgBwAnvfAQAEjGYAAAEotwAACnMmAQAGegJ73QEABBRv
8wIABgJ73wEABBZqMAoCexoBAAQeXyxEAnsZAQAEHjMfAnvdAQAEb+gCAAYWMRECe90BAAQCe9wB
AARv6gIABgIC/gZAAgAGc4sDAAZ9FQEABAIDBAUoQAIABioCAv4GPAIABnOLAwAGfRUBAAQWKhMw
BABYAAAAAAAAAAMtC3IUBABwcywAAAp6BBYvEHIiBABwchsjAHBzVwAACnoFFi8QcjAEAHByGyMA
cHNXAAAKegOOaQRZBS8LckEjAHBzfgAACnoCexUBAAQDBAVvjAMABioTMAQA3wEAABcAABECexYB
AAQtC3K5IABwczAAAAp6AnsXAQAELAQFFjACFioEBVgDjmkxC3KDIwBwc34AAAp6FgoCexkBAAQL
BzkQAQAABx5AdwEAAAIDBAUoCgMABhADBRY9ZQEAAAJ73AEABG+nAgAGLQtyySMAcHMmAQAGegJ7
3QEABAJ73AEABG+rAgAGb+kCAAYCexoBAAQeXzqtAAAAAnvcAQAEb6oCAAYCe98BAAQuFAJ73wEA
BBVuLgoCe98BAAQVajMTAnvcAQAEb6kCAAYCexgBAAQucx6NEQAAASUWcvcjAHCiJRcCe98BAASM
ZgAAAaIlGHIXJABwoiUZAnsYAQAEjGYAAAGiJRpyGyQAcKIlGwJ73AEABG+qAgAGjGYAAAGiJRxy
FyQAcKIlHQJ73AEABG+pAgAGjGYAAAGiKB0AAApzJgEABnoCe9wBAARvmQIABhcKK24FagJ73wEA
BDETAnvfAQAEFmoyCQJ73wEABGkQAwUWMTICe90BAAQDBAVv7gIABhADBRYxHgICe98BAAQFall9
3wEABAICexgBAAQFall9GAEABAJ73wEABC0EFworDwUWLwtyJyQAcHMmAQAGegUWMQ4CexYBAAQD
BAVvLAMABgYsBwIXKDcCAAYFKp4CAv4GPAIABnOLAwAGfRUBAAQCFH0WAQAEAhR9FwEABAIoCQMA
Bio6AigaAAAKAgMoSAIABioAABMwBQCLAAAAJgAAEShvAAAKCgaOaRhYCweNUQAAAYAeAQAEBhZ+
HgEABBYGjmkodwAACn4eAQAEBxdZHyqdfh4BAAQHGFkfP50GjmkaWAsHjVEAAAGAHQEABAYWfh0B
AAQWBo5pKHcAAAp+HQEABAcXWR86nX4dAQAEBxhZH1ydfh0BAAQHGVkfKp1+HQEABAcaWR8/nSru
AgMoRgIABhABA289AAAKFjEcA3JwBQBwb3IAAAotGgNycAUAcCjUAAAKEAErC3IeBQBwcyYBAAZ6
AyoAEzADANsAAABZAAARAznMAAAAA2/XAAAKCgJ7HAEABCwhBgJ7HAEABG95AAAKLRMDAnscAQAE
bz0AAApvYQAAChABA3IaBQBwcnAFAHBveAAAChABAyiQAAAGEAErCgMWF29iAAAKEAEDbz0AAAoW
MR4DFm8+AAAKHy8u4isRAwNvPQAAChdZF29iAAAKEAEDbz0AAAoWMRIDA289AAAKF1lvPgAACh8v
LtQDck8kAHBveQAACgsrFgMHF29iAAAKEAEDck8kAHBveQAACgsHFi/mAx9fKEkCAAYQASsHfnUA
AAoQAQMqHgJ7HAEABCqGAgN9HAEABAJ7HAEABCwRAgJ7HAEABG/XAAAKfRwBAAQqAAAAEzAEAF4A
AAAnAAARAn4dAQAEb3AAAAoKBhYyOQJzegAACgsrJAcGA297AAAKBgJvPQAACjIEFQorDwJ+HQEA
BAYXWG98AAAKCgYWL9gHb0EAAAoQAAJvPQAACiD//wAAMQZzfQAACnoCKgAAEzACADsAAAAOAAAR
AhT+AwoGLDEDLBECfh4BAARvcAAAChb+BAorHQJ+HQEABG9wAAAKFi8NAh8vb9gAAAoW/gMrARYK
Bip+AiwaAn4dAQAEb3AAAAoWLwwCHy9v2AAAChb+AyoWKgATMAQAVgAAAAAAAAACczsAAAp9HwEA
BAJzLQMABn0gAQAEAhV9IgEABAIefSMBAAQCFo1BAAABfSYBAAQCFWp9KAEABAIVan0pAQAEAhh9
KgEABAIDFRdzYQIABijFAgAGKgAAEzAEAFcAAAAAAAAAAnM7AAAKfR8BAAQCcy0DAAZ9IAEABAIV
fSIBAAQCHn0jAQAEAhaNQQAAAX0mAQAEAhVqfSgBAAQCFWp9KQEABAIYfSoBAAQCAxUXc2ECAAYE
KMYCAAYqKgJ7HwEABBT+ASoAABMwAgAkAAAAAwAAEQMozwAABgoGjmkg//8AADELclUkAHBzVQAA
CnoCBn0mAQAEKlICe88BAAQDb2wCAAYCA30iAQAEKjICe88BAARvbQIABioeAnsqAQAEKiICA30q
AQAEKqYCe9ABAAQDIP8AAABf0m+nAAAKAnvQAQAEAx5jIP8AAABf0m+nAAAKKkoCAyhUAgAGAgMf
EGMoVAIABipSAgNpKFUCAAYCAx8gY2koVQIABioAAAATMAQAOQQAAFoAABEDLQtyOAYAcHMsAAAK
egJ7HwEABC0LcmUkAHBzMAAACnoCeyEBAAQsBgIoWAIABgJ7HwEABG9IAAAKIP///38zC3KfJABw
cyYBAAZ6A2/8AAAGCgJ7IgEABAsDJW/eAAAGIAAIAABfb98AAAYCFn0nAQAEA2/2AAAGLRoDA2/2
AAAGb/kAAAYDFmpv+wAABhYKFwwrOwNv9gAABhZqMggDb9cAAAYrARYMBi0kCC0OAijKAgAGLRke
ChYLKxMDA2/2AAAGb/kAAAYDb9cAAAYMCC0fAijKAgAGLRADJW/eAAAGHmBv3wAABisHAhd9JwEA
BAIoywIABiwfAxdv2QAABgNv+gAABhZqLw4DJW/eAAAGHmBv3wAABgMCeyUBAARv4wAABgMGb/0A
AAYCBn0jAQAEAhVqfSkBAAQCeyoBAAQXLhMDb/YAAAYWai8PAnsqAQAEGDMGA2/tAAAGAiBQSwME
KFUCAAYCA2/rAAAGKFQCAAYCA2/eAAAGKFQCAAYCA2/+AAAG0ihUAgAGAgNv8QAABmkoVQIABggs
WAIDb/oAAAZpKFUCAAYDb+8AAAYsEwIVKFUCAAYCFShVAgAGOJcAAAACA2/YAAAGLQkDb/gAAAZp
KwoDb/gAAAZpHwxYKFUCAAYCA2/2AAAGaShVAgAGK2cCeycBAAQsEQICe9ABAARvXgAACn0oAQAE
AhYoVQIABgJ7JwEABCwRAgJ70AEABG9eAAAKfSkBAAQDb+8AAAYtCAJ7JwEABCwQAhUoVQIABgIV
KFUCAAYrDgIWKFUCAAYCFihVAgAGA2/eAAAGA2/1AAAGKNAAAAYNCY5pIP//AAAxC3I3FwBwcyYB
AAZ6A2//AAAGc0wBAAYTBANv7wAABixtEQRvWQEABggsHBEEA2/2AAAGb18BAAYRBANv+AAABm9f
AQAGKxIRBBVqb18BAAYRBBVqb18BAAYRBBdvWgEABhEEF29WAQAGLQtyHR8AcHMmAQAGegJ7JwEA
BCwZAhEEb1QBAAZqfSkBAAQrCREEF29gAQAGJgNvAQEABhYxCAMRBChaAgAGEQRvTQEABhMFAgmO
aShUAgAGAhEFjmkoVAIABgmOLBACe9ABAAQJFgmOaW9ZAAAKA2/vAAAGLCACeycBAAQsGAICeykB
AAQCe9ABAARvXgAAClh9KQEABBEFjiwSAnvQAQAEEQUWEQWOaW9ZAAAKAgJ7JQEABB8eCY5pWBEF
jmlYalh9JQEABANvAQEABhYxFAICeyUBAAQDbwUBAAZqWH0lAQAEAgN9IQEABAJ7IAEABG8pAwAG
Bh4zFwJ7zwEABG9iAgAGAnvPAQAEB29sAgAGAhZqfSQBAAQDb9gAAAYsNwNvAQEABhYxCAIDKFsC
AAYqA2/6AAAGFmovEAIDb/EAAAYfEGIoWQIABioCA2/6AAAGKFkCAAYqAAAAEzAEAL0DAABVAAAR
AnshAQAELQty2yQAcHMwAAAKegJ7JAEABAoCeyMBAAQeMykCeyQBAAQWajIUAijHAgAGAnvPAQAE
b2UCAAYKKwsCe88BAARvYgIABgJ7IQEABG8BAQAGFjEUAnvQAQAEAnvNAQAEFh8Kb1kAAAoCeyEB
AARv9gAABhZqLxMCeyEBAAQCeyQBAARv9wAABitVAnshAQAEb/YAAAYCeyQBAAQuQhqNEQAAASUW
cvckAHCiJRcCeyQBAASMZgAAAaIlGHILJQBwoiUZAnshAQAEb/YAAAaMZgAAAaIoHQAACnMmAQAG
egJ7IQEABG/4AAAGFmovDgJ7IQEABAZv+QAABitLAnshAQAEb/gAAAYGLj0ajREAAAElFnIvJQBw
oiUXBoxmAAABoiUYcgslAHCiJRkCeyEBAARv+AAABoxmAAABoigdAAAKcyYBAAZ6AnshAQAEb/oA
AAYWai8YAnshAQAEAnsgAQAEbycDAAZv+wAABitfAnshAQAEb/oAAAYCeyABAARvJwMABi5HGo0R
AAABJRZyWSUAcKIlFwJ7IAEABG8nAwAGjGYAAAGiJRhyCyUAcKIlGQJ7IQEABG/6AAAGjGYAAAGi
KB0AAApzJgEABnoCAnslAQAEBlh9JQEABAJ7IQEABG/YAAAGLEMCeyEBAARvAQEABhYxIAJ7IQEA
BCVv+AAABgJ7IQEABG8FAQAGalhv+QAABisVAnshAQAEJW/4AAAGHwxqWG/5AAAGAnsnAQAEOcMA
AAACFn0nAQAEAnvQAQAEb14AAAoLAnvQAQAEAnsoAQAEFm+rAAAKJgICeyEBAARv+gAABmkoVQIA
BgJ7IQEABG/vAAAGLEwCeykBAAQVajMLcmslAHBzJgEABnoCe9ABAAQCeykBAAQWb6sAAAomAgJ7
IQEABG/2AAAGKFYCAAYCAnshAQAEb/gAAAYoVgIABiskAgJ7IQEABG/4AAAGaShVAgAGAgJ7IQEA
BG/2AAAGaShVAgAGAnvQAQAEBxZvqwAACiYCeyEBAARv3gAABh5fOZIAAAACIFBLBwgoVQIABgIC
eyEBAARv+gAABmkoVQIABgJ7IQEABG/vAAAGLDQCAnshAQAEb/gAAAYoVgIABgICeyEBAARv9gAA
BihWAgAGAgJ7JQEABB8Yalh9JQEABCs0AgJ7IQEABG/4AAAGaShVAgAGAgJ7IQEABG/2AAAGaShV
AgAGAgJ7JQEABB8Qalh9JQEABAJ7HwEABAJ7IQEABG9CAAAKJgIUfSEBAAQqAAAAEzAEAFQAAAAD
AAARAgJ7JQEABB8Malh9JQEABAICKMsCAAYozgIABh8MjUEAAAEKczUAAAoGbzYAAAoGHwsDHxhj
0pwCBhYGjmkozQIABgJ70AEABAYWBo5pb1kAAAoq8gNvWQEABgMYb10BAAYDIEFFAABvXQEABgMC
bwMBAAZvWwEABgMCb/wAAAZvXQEABgMgAZkAAG9aAQAGKgAAABMwBQAyAAAAWwAAEQIDAijLAgAG
EgASASjPAgAGAnvQAQAEBhYGjmlvWQAACgJ70AEABAcWB45pb1kAAAoqAAATMAQAsgAAAFwAABEC
eyEBAAQtC3LPJQBwczAAAAp6Ay0LchQEAHBzLAAACnoEFi8QciIEAHByGyMAcHNXAAAKegUWLxBy
MAQAcHIbIwBwc1cAAAp6A45pBFkFLwtyQSMAcHN+AAAKegJ7IAEABAMEBW8sAwAGAgJ7JAEABAVq
WH0kAQAEAnsjAQAECgYsDgYeMyoCAwQFKOECAAYqAijLAgAGLAoCAwQFKF0CAAYqAnvQAQAEAwQF
b1kAAAoqAAATMAUATgAAAF0AABEgABAAAI1BAAABCis8BSAAEAAAMgcgABAAACsBBQsDBAYWByh3
AAAKAgYWByjNAgAGAnvQAQAEBhYHb1kAAAoFB1kQAwQHWBACBRYwwCoAABswBQAVAwAAXgAAEQJ7
HwEABC0BKgJ7IQEABCwGAihYAgAGAnsfAQAEb0gAAApqChZqCwJ7HwEABG9JAAAKDDiEAgAACG9K
AAAKdCcAAAINAiBQSwECKFUCAAYCHzMoVAIABgIJb+sAAAYoVAIABgIJb94AAAYoVAIABgIJb/4A
AAZoKFQCAAYCCW/xAAAGaShVAgAGAglv+gAABmkoVQIABglv7gAABi0KCW/4AAAGFW4yCQIVKFUC
AAYrDQIJb/gAAAZpKFUCAAYJb+4AAAYtCglv9gAABhVuMgkCFShVAgAGKw0CCW/2AAAGaShVAgAG
CW/eAAAGCW/1AAAGKNAAAAYTBBEEjmkg//8AADELcu0lAHBzJgEABnoJb/8AAAZzTAEABhMFCW/w
AAAGLGYRBW9ZAQAGCW/uAAAGLQoJb/YAAAYVbjINEQUJb/YAAAZvXwEABglv7gAABi0KCW/4AAAG
FW4yDREFCW/4AAAGb18BAAYJb+IAAAYVbjINEQUJb+IAAAZvXwEABhEFF29aAQAGKwkRBRdvYAEA
BiYJbwEBAAYWMQgJEQUoWgIABhEFb00BAAYTBglvCAEABi0IFo1BAAABKxEJb94AAAYJbwgBAAYo
0AAABhMHEQeOaSD//wAAMQtyCyYAcHMmAQAGegIRBI5pKFQCAAYCEQaOaShUAgAGAhEHjmkoVAIA
BgIWKFQCAAYCFihUAgAGCW/kAAAGFS4OAglv5AAABihVAgAGKxkJbwoBAAYsCgIfEChVAgAGKwcC
FihVAgAGCW/iAAAGFW4yCQIVKFUCAAYrDQIJb+IAAAZpKFUCAAYRBI4sEgJ70AEABBEEFhEEjmlv
WQAAChEGjiwSAnvQAQAEEQYWEQaOaW9ZAAAKEQeOLBICe9ABAAQRBxYRB45pb1kAAAoHHy4RBI5p
WBEGjmlYEQeOaVhqWAsIb0wAAAo6cf3//94UCHUTAAABEwgRCCwHEQhvEAAACtwCe9ABAARzEQIA
BhMJEQkGBwJ7JQEABAJ7JgEABG8kAgAG3gwRCSwHEQlvEAAACtwCFH0fAQAEKgAAAEE0AAACAAAA
MwAAAJYCAADJAgAAFAAAAAAAAAACAAAA6gIAABcAAAABAwAADAAAAAAAAAAmAhUWKGECAAYqJgID
FihhAgAGKhMwAgBbAAAAAAAAAAIoGgAACgMVMwUcEAErFAMWMgUDHwkxC3IvJgBwc1UAAAp6AnOW
AgAGfT4BAAQCAns+AQAEc3UCAAZ9PwEABAIEfTsBAAQCFihuAgAGAgMobAIABgIoYgIABirKAgJ7
OwEABC0DFisCHxB9PAEABAIWan09AQAEAns+AQAEb7gCAAYCez8BAARvegIABioyAns/AQAEb3wC
AAYqMgJ7PwEABG99AgAGKh4Cez0BAAQqPgICezwBAAQaYH08AQAEKkICAns8AQAEHwxgfTwBAAQq
YgJ7PAEABB8eMwwCez4BAARvwQIABioWKjICez8BAARveAIABioyAgMWA45pKGsCAAYqkgJ7PAEA
BB5fLAtyOyYAcHMwAAAKegJ7PwEABAMEBW93AgAGKuoDFTMFHBABKxQDFjIFAx8JMQtyLyYAcHNV
AAAKegJ7OgEABAMuEwIDfToBAAQCez8BAAQDb4ACAAYqHgJ7OgEABCo2Ans/AQAEA29/AgAGKjIC
AxYDjmkocAIABioAEzAEANwBAABfAAARBQoCezwBAAQffzMLcmsmAHBzMAAACnoCezwBAAQfEDya
AAAAIAB4AAALAns6AQAEF1kXYwwIFjIECBkxAhkMBwgcYmALAns8AQAEF18sBQcfIGALBx8fBx8f
XVlYCwJ7PgEABAdvwAIABgJ7PAEABBdfLDgCez8BAARvfAIABg0Cez8BAARvewIABgJ7PgEABAkf
EGNvwAIABgJ7PgEABAkg//8AAF9vwAIABgIfEAJ7PAEABB8MX2B9PAEABAJ7PgEABAMEBW/CAgAG
EwQEEQRYEAICAns9AQAEEQRqWH09AQAEBREEWRADBTnoAAAAAns8AQAEHx472wAAAAJ7PwEABAJ7
PAEABBpfFv4DAns8AQAEHl8W/gNvdgIABi2eAns8AQAEHxAzBAYFWSoCezwBAAQfFDNDAns6AQAE
LC4eAns+AQAEb70CAAZlHV9YEwUrFQJ7PgEABBgfCm+/AgAGEQUfClkTBREFFjDmAh8QfTwBAAQ4
Q////wJ7PAEABB8cQDb///8Cez4BAARvvgIABgJ7OwEABC0wAns/AQAEb3wCAAYTBgJ7PgEABBEG
HxBjb8ACAAYCez4BAAQRBiD//wAAX2/AAgAGAh8efTwBAAQ45v7//wYFWSoyAgMWA45pKHICAAYq
kgJ7PAEABCwGc9kAAAp6Ahd9PAEABAJ7PwEABAMEBW95AgAGKgAAEzADAIgAAAAAAAAAIP//AAAg
+/8AACiKAAAKgFIBAAQfCo0/AAABJdD2AQAEKC4AAAqAVgEABB8KjT8AAAEl0P0BAAQoLgAACoBX
AQAEHwqNPwAAASXQ9wEABCguAAAKgFgBAAQfCo0/AAABJdAFAgAEKC4AAAqAWQEABB8KjT8AAAEl
0AQCAAQoLgAACoBaAQAEKhMwBABlAAAAFgAAEQIocwIABgIDfXQBAAQCA3OKAgAGfXUBAAQCcyED
AAZ9dgEABAIgAAABAI1BAAABfWkBAAQCIACAAACNZwAAAX1hAQAEAiAAgAAAjWcAAAF9YgEABAIC
FyUKfWcBAAQGfWYBAAQqAAAAEzADAHMAAABgAAARAiiBAgAGAywQAntyAQAEAntzAQAE/gErARYL
AntvAQAEDAhFAwAAAAIAAAANAAAAGAAAACshAgcEKIYCAAYKKyECBwQohwIABgorFgIHBCiIAgAG
CisLcosmAHBzMAAACnoCe3QBAARvwQIABgZfLY8GKgATMAIAdAAAABYAABEDLQtyFAQAcHMsAAAK
egQWLwtyIgQAcHNVAAAKegUWLwtyMAQAcHNVAAAKegJ7cgEABAJ7cwEABC8LcsMmAHBzMAAACnoE
BVgKBAYwBgYDjmkxC3IwBABwc1UAAAp6AgN9cAEABAIEfXIBAAQCBn1zAQAEKj4Ce3MBAAQCe3IB
AAT+ASoTMAUAhwAAAAAAAAACe3YBAAQDBAVvJQMABgUZLwEqBSD6fgAAMRIEBSD6fgAAWVgQAiD6
fgAAEAMDBAJ7aQEABAJ7ZwEABAUodwAACgIoggIABgUXWRADKxUCKIMCAAYmAgJ7ZwEABBdYfWcB
AAQFF1klEAMWMOICAntnAQAEGFh9ZwEABAICe2cBAAR9ZgEABCoAEzAEAHYAAABhAAARAnt1AQAE
b4sCAAYCe3YBAARvIgMABgICFyUKfWcBAAQGfWYBAAQCFn1oAQAEAhZqfXEBAAQCFn1lAQAEAhh9
ZAEABBYLKw0Ce2EBAAQHFp0HF1gLByAAgAAAMusWDCsNAntiAQAECBadCBdYDAggAIAAADLrKjIC
e3YBAARvIgMABio2Ant2AQAEbyADAAZpKh4Ce3EBAAQqHgJ7agEABCoiAgN9agEABCoAABMwBQCK
AQAAFgAAEQMWMgUDHwkxC3IvJgBwc1UAAAp6An5WAQAEA5R9bgEABAJ+VwEABAOUfWwBAAQCflgB
AAQDlH1tAQAEAn5ZAQAEA5R9awEABH5aAQAEA5QCe28BAAQ7LwEAAAJ7bwEABAoGRQMAAAAFAAAA
TwAAAJMAAAA4BAEAAAJ7ZwEABAJ7ZgEABDExAnt1AQAEAntpAQAEAntmAQAEAntnAQAEAntmAQAE
WRZvjgIABgICe2cBAAR9ZgEABAIoggIABji6AAAAAntnAQAEAntmAQAEPqkAAAACe3UBAAQCe2kB
AAQCe2YBAAQCe2cBAAQCe2YBAARZFm+PAgAGAgJ7ZwEABH1mAQAEK3YCe2UBAAQsIQJ7dQEABAJ7
aQEABAJ7ZwEABBdZkSD/AAAAX2+RAgAGJgJ7ZwEABAJ7ZgEABDExAnt1AQAEAntpAQAEAntmAQAE
AntnAQAEAntmAQAEWRZvjwIABgICe2cBAAR9ZgEABAIWfWUBAAQCGH1kAQAEAn5aAQAEA5R9bwEA
BCoAABMwBQDjAAAAFgAAEQJ7ZwEABCD6/gAAP6UAAAACKIQCAAY4mgAAACAAAAEAAntoAQAEWQJ7
ZwEABFkKBgJ7cwEABAJ7cgEABFkxDgJ7cwEABAJ7cgEABFkKAntwAQAEAntyAQAEAntpAQAEAntn
AQAEAntoAQAEWAYodwAACgJ7dgEABAJ7cAEABAJ7cgEABAZvJQMABgICe3IBAAQGWH1yAQAEAgJ7
cQEABAZqWH1xAQAEAgJ7aAEABAZYfWgBAAQCe2gBAAQgBgEAAC8RAntyAQAEAntzAQAEP0j///8C
e2gBAAQZMgYCKIICAAYqmgICe2kBAAQCe2cBAASRG2ICe2kBAAQCe2cBAAQXWJFhfWABAAQqAAAT
MAQAWgAAAGIAABECe2ABAAQbYgJ7aQEABAJ7ZwEABBhYkWEg/38AAF8LAntiAQAEAntnAQAEIP9/
AABfAnthAQAEB5IlCp0Ce2EBAAQHAntnAQAEaJ0CB31gAQAEBiD//wAAXyoAABMwBQDHAAAALAAA
EQJ7aQEABCAAgAAAAntpAQAEFiAAgAAAKHcAAAoCAntjAQAEIACAAABZfWMBAAQCAntnAQAEIACA
AABZfWcBAAQCAntmAQAEIACAAABZfWYBAAQWCisuAnthAQAEBpIg//8AAF8LAnthAQAEBgcgAIAA
AC8DFisHByAAgAAAWWidBhdYCgYgAIAAADLKFgwrLgJ7YgEABAiSIP//AABfDQJ7YgEABAgJIACA
AAAvAxYrBwkgAIAAAFlonQgXWAwIIACAAAAyyioAEzAEAF4CAABjAAARAntrAQAECgJ7bQEABAsC
e2IBAAQMAntnAQAEDQJ7ZwEABAJ7ZAEABFgTBQJ7ZAEABBgoiwAAChMGAntnAQAEIPp+AABZFiiL
AAAKEwcCe2cBAAQgAgEAAFgXWRMIAntpAQAEEQUXWZETCQJ7aQEABBEFkRMKEQYCe24BAAQyBAYY
YwoHAntoAQAEMQcCe2gBAAQLAntpAQAEAxEGWJERCkB5AQAAAntpAQAEAxEGWBdZkREJQGUBAAAC
e2kBAAQDkQJ7aQEABAmRQFABAAACe2kBAAQDF1iRAntpAQAECRdYkUA3AQAAAxhYEwQJGFgNAntp
AQAECRdYJQ2RAntpAQAEEQQXWCUTBJFA0gAAAAJ7aQEABAkXWCUNkQJ7aQEABBEEF1glEwSRQLMA
AAACe2kBAAQJF1glDZECe2kBAAQRBBdYJRMEkUCUAAAAAntpAQAECRdYJQ2RAntpAQAEEQQXWCUT
BJEzeAJ7aQEABAkXWCUNkQJ7aQEABBEEF1glEwSRM1wCe2kBAAQJF1glDZECe2kBAAQRBBdYJRME
kTNAAntpAQAECRdYJQ2RAntpAQAEEQQXWCUTBJEzJAJ7aQEABAkXWCUNkQJ7aQEABBEEF1glEwSR
MwgJEQg/D////wkRBTExAgN9YwEABAkTBQkCe2cBAARZEwYRBgcvPwJ7aQEABBEFF1mREwkCe2kB
AAQRBZETCgJ7ZwEABA0IAyD/fwAAX5Ig//8AAF8lEAERBzEKBhdZJQo6Vf7//wIRBgJ7aAEABCiK
AAAKfWQBAAQCe2QBAAQZ/gQW/gEqAAATMAUAnwAAAGQAABEDLQoCe2gBAAQtAhYqAgJ7ZwEABAJ7
aAEABFh9ZwEABAIWfWgBAAQCe2cBAAQCe2YBAARZCgZ+UgEABC8dAntmAQAEIACAAAAvDQYg+n4A
AP4EFv4BKwQWKwEXA2AsPgQLBn5SAQAEMQh+UgEABAoWCwJ7dQEABAJ7aQEABAJ7ZgEABAYHb44C
AAYCAntmAQAEBlh9ZgEABAcW/gEqFyoAEzAFAAUCAABlAAARAntoAQAEIAYBAAA83AEAAAM61gEA
ABYqAntoAQAELTMCe3UBAAQCe2kBAAQCe2YBAAQCe2cBAAQCe2YBAARZBG+PAgAGAgJ7ZwEABH1m
AQAEFioCe2cBAAQg+v4AADEGAiiEAgAGAntoAQAEGT/sAAAAAiiDAgAGJQo53wAAAAJ7agEABBg7
0wAAAAJ7ZwEABAZZIPp+AAA9wQAAAAIGKIUCAAY5tQAAAAJ7dQEABAJ7ZwEABAJ7YwEABFkCe2QB
AARvkgIABgsCAntoAQAEAntkAQAEWX1oAQAEAntkAQAEAntsAQAEMEQCe2gBAAQZMjsrFQICe2cB
AAQXWH1nAQAEAiiDAgAGJgICe2QBAAQXWQwIfWQBAAQIFjDXAgJ7ZwEABBdYfWcBAAQrIgICe2cB
AAQCe2QBAARYfWcBAAQCe2gBAAQYMgYCKIICAAYCGH1kAQAEBy1AOI4AAAACe3UBAAQCe2kBAAQC
e2cBAASRIP8AAABfb5ECAAYmAgJ7ZwEABBdYfWcBAAQCAntoAQAEF1l9aAEABAJ7dQEABG+QAgAG
LEYELAsCe2gBAAQW/gErARYNAnt1AQAEAntpAQAEAntmAQAEAntnAQAEAntmAQAEWQlvjwIABgIC
e2cBAAR9ZgEABAkW/gEqAntoAQAEIAYBAAD+BBb+AQNgOhX+//8XKgAAABMwBQBsAgAAZgAAEQJ7
aAEABCAGAQAAPEMCAAADOj0CAAAWKgJ7aAEABC1jAntlAQAELCECe3UBAAQCe2kBAAQCe2cBAAQX
WZEg/wAAAF9vkQIABiYCFn1lAQAEAnt1AQAEAntpAQAEAntmAQAEAntnAQAEAntmAQAEWQRvjwIA
BgICe2cBAAR9ZgEABBYqAntnAQAEIPr+AAAyBgIohAIABgJ7YwEABAoCe2QBAAQLAntoAQAEGTJh
AiiDAgAGDAJ7agEABBguUQgsTgJ7ZwEABAhZIPp+AAAwPwIIKIUCAAYsNgJ7ZAEABBswLQJ7agEA
BBcuHQJ7ZAEABBkzGwJ7ZwEABAJ7YwEABFkgABAAADEHAhh9ZAEABAcZP4QAAAACe2QBAAQHMHsC
e3UBAAQCe2cBAAQXWQZZB2+SAgAGJgcYWQsCAntnAQAEF1h9ZwEABAICe2gBAAQXWX1oAQAEAnto
AQAEGTIHAiiDAgAGJgcXWSULFjDMAgJ7ZwEABBdYfWcBAAQCAntoAQAEF1l9aAEABAIWfWUBAAQC
GH1kAQAEK0wCe2UBAAQsIQJ7dQEABAJ7aQEABAJ7ZwEABBdZkSD/AAAAX2+RAgAGJgIXfWUBAAQC
AntnAQAEF1h9ZwEABAICe2gBAAQXWX1oAQAEAnt1AQAEb5ACAAYsYQJ7ZwEABAJ7ZgEABFkNAntl
AQAELAQJF1kNBCwTAntoAQAELQsCe2UBAAQW/gErARYTBAJ7dQEABAJ7aQEABAJ7ZgEABAkRBG+P
AgAGAgJ7ZgEABAlYfWYBAAQRBBb+ASoCe2gBAAQgBgEAAP4EFv4BA2A6rv3//xcqEzAEADQBAAAW
AAARHxONPwAAASXQ+AEABCguAAAKgH8BAAQfEI1BAAABJdD/AQAEKC4AAAqAgAEABCAeAQAAjWcA
AAGAgQEABCAeAQAAjUEAAAGAggEABBYKKx5+gQEABAYfMAZYHmIokwIABp1+ggEABAYlF1gKHpwG
IJAAAAAy2isifoEBAAQGIAABAAAGWB1iKJMCAAadfoIBAAQGJRdYCh8JnAYgAAEAADLWKyJ+gQEA
BAYgAP///wZYHwliKJMCAAadfoIBAAQGJRdYCh2cBiAYAQAAMtYrHn6BAQAEBh+oBlgeYiiTAgAG
nX6CAQAEBiUXWAoenAYgHgEAADLaHx6NZwAAAYCDAQAEHx6NQQAAAYCEAQAEFgorHH6DAQAEBgYf
C2IokwIABp1+hAEABAYbnAYXWAoGHx4y3yoTMAUAZwAAAAAAAAACKBoAAAoCA32FAQAEAgIgHgEA
ACABAQAAHw9zjwMABn2GAQAEAgIfHhcfD3OPAwAGfYcBAAQCAh8TGh1zjwMABn2IAQAEAiAAQAAA
jWcAAAF9iQEABAIgAEAAAI1BAAABfYoBAAQqwgIWfYsBAAQCFn2MAQAEAnuGAQAEb5ADAAYCe4cB
AARvkAMABgJ7iAEABG+QAwAGKhMwBAC0AAAAFgAAEQJ7iAEABG+UAwAGAnuGAQAEb5QDAAYCe4cB
AARvlAMABgJ7hQEABAJ7hgEABHs7AgAEIAEBAABZG2+/AgAGAnuFAQAEAnuHAQAEezsCAAQXWRtv
vwIABgJ7hQEABAMaWRpvvwIABhYKKyMCe4UBAAQCe4gBAAR7OQIABH5/AQAEBpSRGW+/AgAGBhdY
CgYDMtkCe4YBAAQCe4gBAARvmAMABgJ7hwEABAJ7iAEABG+YAwAGKhMwBQDPAAAAZwAAERYKOKsA
AAACe4oBAAQGkSD/AAAAXwsCe4kBAAQGkgwIJRdZDCx8ByiUAgAGDQJ7hgEABAlvkQMABgkgBQEA
AFkaWxMEEQQWMR0RBBswGAJ7hQEABAcXEQQfH19iF1lfEQRvvwIABggolQIABhMFAnuHAQAEEQVv
kQMABhEFGFsXWRMEEQQWMSYCe4UBAAQIFxEEHx9fYhdZXxEEb78CAAYrDAJ7hgEABAdvkQMABgYX
WAoGAnuLAQAEP0n///8Ce4YBAAQgAAEAAG+RAwAGKgATMAQATQAAAAAAAAACe4UBAAQOBC0DFisB
FxlvvwIABgJ7hQEABG++AgAGAnuFAQAEBW+6AgAGAnuFAQAEBWZvugIABgJ7hQEABAMEBW+8AgAG
AiiLAgAGKgAAABMwBQCyAQAAZwAAEQJ7hgEABHs4AgAEIAABAACPZwAAASVIF1hoUwJ7hgEABG+V
AwAGAnuHAQAEb5UDAAYCe4YBAAQCe4gBAARvlwMABgJ7hwEABAJ7iAEABG+XAwAGAnuIAQAEb5UD
AAYaCh8SDSseAnuIAQAEezkCAAR+fwEABAmUkRYxBAkXWAoJF1kNCQYw3h8OBhlaWAJ7iAEABG+W
AwAGWAJ7hgEABG+WAwAGWAJ7hwEABG+WAwAGWAJ7jAEABFgLAnuMAQAEDBYTBCsgCAJ7hgEABHs4
AgAEEQSSfoIBAAQRBJFaWAwRBBdYEwQRBCAeAQAAMtcWEwUrIAgCe4cBAAR7OAIABBEFkn6EAQAE
EQWRWlgMEQUXWBMFEQUfHjLaBwgyAggLBBYyFAUaWAcZYy8MAgMEBQ4EKI4CAAYqBwgzTQJ7hQEA
BBgOBC0DFisBF1gZb78CAAYCe4YBAAR+gQEABH6CAQAEb5MDAAYCe4cBAAR+gwEABH6EAQAEb5MD
AAYCKI0CAAYCKIsCAAYqAnuFAQAEGg4ELQMWKwEXWBlvvwIABgIGKIwCAAYCKI0CAAYCKIsCAAYq
RgJ7iwEABCAAQAAA/gQW/gEqEzAEAEYAAAAWAAARAnuJAQAEAnuLAQAEFp0Ce4oBAAQCAnuLAQAE
CgYXWH2LAQAEBgPSnAJ7hgEABHs4AgAEA49nAAABJUgXWGhTAiiQAgAGKgAAEzAEAK4AAABhAAAR
AnuJAQAEAnuLAQAEA2idAnuKAQAEAgJ7iwEABAwIF1h9iwEABAgEGVnSnAQZWSiUAgAGCgJ7hgEA
BHs4AgAEBo9nAAABJUgXWGhTBiAJAQAAMh4GIB0BAAAvFgICe4wBAAQGIAUBAABZGltYfYwBAAQD
F1kolQIABgsCe4cBAAR7OAIABAePZwAAASVIF1hoUwcaMhICAnuMAQAEBxhbF1lYfYwBAAQCKJAC
AAYq4n6AAQAEAh8PX5EfDGJ+gAEABAIaYx8PX5EeYmB+gAEABAIeYx8PX5EaYmB+gAEABAIfDGOR
YGgqABMwAgAnAAAAFgAAEQIg/wAAADMGIB0BAAAqIAEBAAAKKwkGGlgKAhdjEAACHi/zBgJYKgAT
MAIAFQAAABYAABEWCisJBhhYCgIXYxAAAhov8wYCWCoyAiAAAAEAKLcCAAYqIgIWKJgCAAYq8gIo
GgAACgIDfacBAAQCcyEDAAZ9rQEABAJzFQMABn2oAQAEAnMUAwAGfakBAAQCAy0DFisBGH2eAQAE
KhMwAgBgAAAAAAAAAAICe6cBAAQtAxYrARh9ngEABAIWan2mAQAEAhZqfaUBAAQCe6gBAARvHgMA
BgJ7qQEABG8TAwAGAhR9qgEABAIUfasBAAQCFH2sAQAEAhZ9pAEABAJ7rQEABG8iAwAGKhMwAwB5
AAAAFgAAEQJ7qAEABB8QbxYDAAYKBhYvAhYqAnuoAQAEHxBvFwMABgYeYgYeY2Ag//8AAF8KBh8f
XSwLchEnAHBzAwAABnoGIAAPAABfIAAIAAAuC3JBJwBwcwMAAAZ6Bh8gXy0JAhh9ngEABCsPAhd9
ngEABAIfIH2gAQAEFyoAAAATMAMASgAAABYAABErPQJ7qAEABB5vFgMABgoGFi8CFioCe6gBAAQe
bxcDAAYCAnufAQAEHmIGYH2fAQAEAgJ7oAEABB5ZfaABAAQCe6ABAAQWMLoWKgAAGzAEAOABAABo
AAARAnupAQAEbxADAAYKOMIBAAACe54BAAQMCB1ZRQQAAAAfAAAAlAAAAOMAAAAkAQAAOJMBAAAC
e6kBAAQHbwsDAAYGF1klCiACAQAALwIXKgJ7qwEABAJ7qAEABG+1AgAGJQsgAP///18sywcgAQEA
AC8dBxYvAhYqAhR9rAEABAIUfasBAAQCGH2eAQAEFyoAAn6NAQAEByABAQAAWZR9oQEABAJ+jgEA
BAcgAQEAAFmUfaABAATeDCZydycAcHMDAAAGegJ7oAEABBYxPgIefZ4BAAQCe6gBAAQCe6ABAARv
FgMABg0JFi8CFioCe6gBAAQCe6ABAARvFwMABgICe6EBAAQJWH2hAQAEAh8JfZ4BAAQCe6wBAAQC
e6gBAARvtQIABgsHFi8CFioAAn6PAQAEB5R9ogEABAJ+kAEABAeUfaABAATeDCZypycAcHMDAAAG
egJ7oAEABBYxQgIfCn2eAQAEAnuoAQAEAnugAQAEbxYDAAYTBBEEFi8CFioCe6gBAAQCe6ABAARv
FwMABgICe6IBAAQRBFh9ogEABAJ7qQEABAJ7oQEABAJ7ogEABG8NAwAGBgJ7oQEABFkKAh19ngEA
BCsLctMnAHBzAwAABnoGIAIBAAA8M/7//xcqARwAAAAAkAAouAAMEAAAAQAALAEcSAEMEAAAARMw
BACpAAAAFgAAESs9AnuoAQAEHm8WAwAGCgYWLwIWKgJ7qAEABB5vFwMABgICe58BAAQeYgZgfZ8B
AAQCAnugAQAEHll9oAEABAJ7oAEABBYwugJ7rQEABG8gAwAGaQJ7nwEABC5DGo0RAAABJRZy/ycA
cKIlFwJ7rQEABG8gAwAGaYw/AAABoiUYcjkoAHCiJRkCe58BAASMPwAAAaIoHQAACnMDAAAGegIf
DH2eAQAEFioAAAATMAMAPQIAACwAABECe54BAAQKBkUNAAAABQAAAAwAAAAaAAAA8wAAACIBAABk
AQAAqgEAAOgBAADoAQAA6AEAAOgBAAATAAAA7wEAADjsAQAAAiiaAgAGKgIomwIABioCKJ0CAAYq
AnukAQAELC8Ce6cBAAQsCgIfDH2eAQAEFioCe6gBAARvGwMABgIfIH2gAQAEAh8LfZ4BAAQXKgJ7
qAEABBlvFgMABgsHFi8CFioCe6gBAAQZbxcDAAYHF18sBwIXfaQBAAQHF2MKBkUDAAAAAgAAABYA
AAA1AAAAK0cCe6gBAARvGwMABgIZfZ4BAAQrSQJ+xAEABH2rAQAEAn7FAQAEfawBAAQCHX2eAQAE
KyoCc60CAAZ9qgEABAIcfZ4BAAQrFnJFKABwB4w/AAABKJQAAApzAwAABnoXKgICe6gBAAQfEG8W
AwAGJQp9owEABAYWLwIWKgJ7qAEABB8QbxcDAAYCGn2eAQAEAnuoAQAEHxBvFgMABgwIFi8CFioC
e6gBAAQfEG8XAwAGCAJ7owEABCD//wAAYS4Lcm0oAHBzAwAABnoCG32eAQAEAnupAQAEAnuoAQAE
AnujAQAEbw4DAAYNAgJ7owEABAlZfaMBAAQCe6MBAAQtCQIYfZ4BAAQXKgJ7qAEABG8cAwAGFv4B
KgJ7qgEABAJ7qAEABG+uAgAGLQIWKgICe6oBAARvrwIABn2rAQAEAgJ7qgEABG+wAgAGfawBAAQC
HX2eAQAEAiicAgAGKhYqcqEoAHBzAwAABnoyAgMWA45pKKACAAYqAAATMAQAjQAAAAAAAAADLQty
FAQAcHMsAAAKegQWLwty2ygAcHNVAAAKegUWLwtyMAQAcHNVAAAKegIopgIABi0LcucoAHBzMAAA
CnoCe60BAAQDBAVvJQMABgJ7rQEABG8gAwAGaQJ7nwEABC4LchkpAHBzAwAABnoCe60BAARvIgMA
BgJ7qQEABAMEBW8PAwAGAhh9ngEABCoyAgMWA45pKKICAAYqegJ7qAEABAMEBW8fAwAGAgJ7pgEA
BAVqWH2mAQAEKmoDLQtyFAQAcHMsAAAKegIDFgOOaSikAgAGKhMwBADOAAAANAAAEQMtC3IUBABw
cywAAAp6BRYvEHIwBABwckMpAHBzVwAACnoEFi8QciIEAHBydSkAcHNXAAAKegQFWAOOaTELcqkp
AHBzfgAACnoFLRECKKcCAAYtBwIongIABiYWKhYKAnueAQAEHwsuQwJ7qQEABAMEBW8SAwAGCwcW
MTACe60BAAQDBAdvJQMABgQHWBACBgdYCgICe6UBAAQHalh9pQEABAUHWRADBS0CBioCKJ4CAAYt
qwJ7qQEABG8RAwAGFjEKAnueAQAEHwszkwYqMgJ7qAEABG8cAwAGKlYCe54BAAQXMwoCe6ABAAQW
/gEqFipuAnueAQAEHwwzDwJ7qQEABG8RAwAGFv4BKhYqcgIopgIABi0NAnutAQAEbyADAAZpKgJ7
nwEABCoeAnulAQAEKj4Ce6YBAAQCKKsCAAZqWSoyAnuoAQAEbxoDAAYqABMwAwBdAAAAAAAAAB8d
jT8AAAEl0AMCAAQoLgAACoCNAQAEHx2NPwAAASXQ/AEABCguAAAKgI4BAAQfHo0/AAABJdACAgAE
KC4AAAqAjwEABB8ejT8AAAEl0P4BAAQoLgAACoCQAQAEKgAAABMwBQB7AgAAaQAAEQJ7ugEABAoG
RQYAAAACAAAAOgAAAJIAAAAUAQAAfQEAAMMBAAAr2QIDG28WAwAGfbsBAAQCe7sBAAQWLwIWKgIC
e7sBAAQgAQEAAFh9uwEABAMbbxcDAAYCF326AQAEAgMbbxYDAAZ9vAEABAJ7vAEABBYvAhYqAgJ7
vAEABBdYfbwBAAQDG28XAwAGAgJ7uwEABAJ7vAEABFh9vgEABAICe74BAASNQQAAAX24AQAEAhh9
ugEABAIDGm8WAwAGfb0BAAQCe70BAAQWLwIWKgICe70BAAQaWH29AQAEAxpvFwMABgIfE41BAAAB
fbcBAAQCFn3BAQAEAhl9ugEABCs4AxlvFgMABgsHFi8CFioDGW8XAwAGAnu3AQAEfrYBAAQCe8EB
AASUB9KcAgJ7wQEABBdYfcEBAAQCe8EBAAQCe70BAAQyugICe7cBAARzswIABn25AQAEAhR9twEA
BAIWfcEBAAQCGn26AQAEKzMCe7gBAAQCAnvBAQAECgYXWH3BAQAEBgII0iUNfcABAAQJnAJ7wQEA
BAJ7vgEABDMCFyoCe7kBAAQDb7UCAAYlDB/wXyy6CBYvAhYqCB8RMgkCFn3AAQAEKw4Ce8EBAAQt
BnMCAAAGegIIHxBZfb8BAAQCG326AQAEfrUBAAQCe78BAASUEwQDEQRvFgMABhMFEQUWLwIWKgMR
BG8XAwAGEQV+tAEABAJ7vwEABJRYEwUCe8EBAAQRBVgCe74BAAQxJHMCAAAGegJ7uAEABAICe8EB
AAQKBhdYfcEBAAQGAnvAAQAEnBEFJRdZEwUWMNgCe8EBAAQCe74BAAQzAhcqAhp9ugEABDiF/f//
ABMwBQAnAAAAAwAAEQJ7uwEABI1BAAABCgJ7uAEABBYGFgJ7uwEABCh3AAAKBnOzAgAGKgATMAUA
LAAAAAMAABECe7wBAASNQQAAAQoCe7gBAAQCe7sBAAQGFgJ7vAEABCh3AAAKBnOzAgAGKhMwAwBE
AAAAAAAAABmNPwAAASXQAQIABCguAAAKgLQBAAQZjT8AAAEl0AACAAQoLgAACoC1AQAEHxONPwAA
ASXQ+AEABCguAAAKgLYBAAQqGzAEAJQAAABdAAARICABAACNQQAAAQoWCysIBgclF1gLHpwHIJAA
AAAy8CsJBgclF1gLHwmcByAAAQAAMu8rCAYHJRdYCx2cByAYAQAAMvArCAYHJRdYCx6cByAgAQAA
MvAGc7MCAAaAxAEABB8gjUEAAAEKFgsrCAYHJRdYCxucBx8gMvMGc7MCAAaAxQEABN4MJnLhKQBw
cwMAAAZ6KgEQAAAAAAAAh4cADBAAAAE6AigaAAAKAgMotAIABioAEzAGANEBAABqAAARHxCNPwAA
AQofEI0/AAABCxYTBSseAxEFkRMGEQYWMQ0GEQaPPwAAASVKF1hUEQUXWBMFEQUDjmky2xYMIAAC
AAANFxMHK0cHEQcInggGEQeUHxARB1kfH19iWAwRBx8KMiYHEQeUIID/AQBfEwgIIID/AQBfEwkJ
EQkRCFkfEBEHWR8fX2NYDREHF1gTBxEHHw8xswIJjWcAAAF9wwEABCAAAgAAEwQfDxMKK2AIIID/
AQBfEwsIBhEKlB8QEQpZHx9fYlkMCCCA/wEAXxMMKzACe8MBAAQRDCiTAgAGEQRlGmIRCmBonREE
FxEKHwlZHx9fYlgTBBEMIIAAAABYEwwRDBELMsoRChdZEwoRCh8KL5oWEw04qwAAAAMRDZETDhEO
OZgAAAAHEQ6UDAgokwIABhMPEQ4fCTAoAnvDAQAEEQ8RDRpiEQ5gaJ0RDxcRDh8fX2JYEw8RDyAA
AgAAMtorTQJ7wwEABBEPIP8BAABfkhMQFxEQHw9fHx9fYhMRERAaY2UTEAJ7wwEABBEQEQ8fCWNg
EQ0aYhEOYGidEQ8XEQ4fH19iWBMPEQ8RETLXBxEOCBcfEBEOWR8fX2JYnhENF1gTDRENA45pP0v/
//8qAAAAEzAEAMoAAABnAAARAx8JbxYDAAYlChY/hAAAAAJ7wwEABAaSJQsWMg4DBx8PX28XAwAG
BxpjKgcaY2UMBx8PXw0DCW8WAwAGJQoWMhwCe8MBAAQIBh8JY2CSCwMHHw9fbxcDAAYHGmMqA28Z
AwAGEwQDEQRvFgMABgoCe8MBAAQIBh8JY2CSCwcfD18RBDAOAwcfD19vFwMABgcaYyoVKgNvGQMA
BhMFAxEFbxYDAAYKAnvDAQAEBpILBxYyFgcfD18RBTAOAwcfD19vFwMABgcaYyoVKjICIAAQAAAo
twIABipOAigaAAAKAgONQQAAAX3GAQAEKgATMAUAGgAAABYAABECAgIWJQp9ygEABAYlCn3IAQAE
Bn3HAQAEKgAAEzAEABsAAAAWAAARAnvGAQAEAgJ7yAEABAoGF1h9yAEABAYD0pwqABMwBAA3AAAA
FgAAEQJ7xgEABAICe8gBAAQKBhdYfcgBAAQGA9KcAnvGAQAEAgJ7yAEABAoGF1h9yAEABAYDHmPS
nCoAEzAEAHEAAAAWAAARAnvGAQAEAgJ7yAEABAoGF1h9yAEABAYD0pwCe8YBAAQCAnvIAQAECgYX
WH3IAQAEBgMeY9KcAnvGAQAEAgJ7yAEABAoGF1h9yAEABAYDHxBj0pwCe8YBAAQCAnvIAQAECgYX
WH3IAQAEBgMfGGPSnCqOAwQCe8YBAAQCe8gBAAQFKHcAAAoCAnvIAQAEBVh9yAEABCoeAnvKAQAE
KgAAABMwBABhAAAAFgAAEQJ7ygEABBYxSQJ7xgEABAICe8gBAAQKBhdYfcgBAAQGAnvJAQAE0pwC
e8oBAAQeMSECe8YBAAQCAnvIAQAECgYXWH3IAQAEBgJ7yQEABB5k0pwCFn3JAQAEAhZ9ygEABCoA
AAATMAUAjwAAABYAABECAnvJAQAEAwJ7ygEABB8fX2JgfckBAAQCAnvKAQAEBFh9ygEABAJ7ygEA
BB8QMl4Ce8YBAAQCAnvIAQAECgYXWH3IAQAEBgJ7yQEABNKcAnvGAQAEAgJ7yAEABAoGF1h9yAEA
BAYCe8kBAAQeZNKcAgJ7yQEABB8QZH3JAQAEAgJ7ygEABB8QWX3KAQAEKgATMAQANwAAABYAABEC
e8YBAAQCAnvIAQAECgYXWH3IAQAEBgMeY9KcAnvGAQAEAgJ7yAEABAoGF1h9yAEABAYD0pwqKgJ7
yAEABBb+ASoAABMwBQCrAAAAFgAAEQJ7ygEABB4yOwJ7xgEABAICe8gBAAQKBhdYfcgBAAQGAnvJ
AQAE0pwCAnvJAQAEHmR9yQEABAICe8oBAAQeWX3KAQAEBQJ7yAEABAJ7xwEABFkxMwJ7yAEABAJ7
xwEABFkQAwJ7xgEABAJ7xwEABAMEBSh3AAAKAhZ9xwEABAIWfcgBAAQrIgJ7xgEABAJ7xwEABAME
BSh3AAAKAgJ7xwEABAVYfccBAAQFKgATMAUAOQAAAAMAABECe8gBAAQCe8cBAARZjUEAAAEKAnvG
AQAEAnvHAQAEBhYGjmkodwAACgIWfccBAAQCFn3IAQAEBipKAgNzXwIABiAAAgAAKMYCAAYqOgID
BCAAAgAAKMYCAAYqABMwAgBvAAAAAAAAAAIXfdIBAAQCKNAAAAoDLQtyQSoAcHMsAAAKegNvsgAA
Ci0QcmMqAHByQSoAcHMtAAAKegQtC3KNKgBwcywAAAp6BSAAAgAALwtynyoAcHNVAAAKegIDfdAB
AAQCBY1BAAABfc4BAAQCBH3PAQAEKgATMAQAwwAAABYAABECe88BAARvZwIABitIAnvPAQAEAnvO
AQAEFgJ7zgEABI5pb3ACAAYKBhYxNgJ7zAEABCwOAgJ7zgEABBYGKM0CAAYCe9ABAAQCe84BAAQW
Bm9ZAAAKAnvPAQAEb2gCAAYsqwJ7zwEABG9oAgAGLQtytSoAcHMDAAAGegJ70AEABG9aAAAKAnvM
AQAELDUCe8wBAAR1AwAAAiwWAgJ7zAEABHQDAAACbwgAAAZ9zQEABAJ7zAEABG8QAAAKAhR9zAEA
BCoeAnvSAQAEKiICA33SAQAEKjICe9ABAARvXAAACioeAnvLAQAEKm4DLBADbz0AAAotCAIUfcsB
AAQqAgN9ywEABCpKAnvMAQAEAxYFAxZvJQAACiYqEzAEACEAAABrAAARczMAAAYKAyjPAAAGKBIA
AAYLAgYHFG8iAAAKfcwBAAQqAAAAEzAFAFcAAAAWAAARBQNvBAEABo1BAAABUX7TAQAELQpz2gAA
CoDTAQAEftMBAAQFUG/bAAAKA28BAQAGHlsKAgQFUAYXcwUAAAZ9zAEABA4EAnvMAQAEdAMAAAJv
BwAABlEqABMwBABwAAAAFgAAEStIAnvPAQAEAnvOAQAEFgJ7zgEABI5pb3ACAAYKBhYxNgJ7zAEA
BCwOAgJ7zgEABBYGKM0CAAYCe9ABAAQCe84BAAQWBm9ZAAAKAnvPAQAEb2kCAAYsqwJ7zwEABG9p
AgAGLQty5yoAcHMDAAAGeioKFioyAnvQAQAEb7IAAAoqMgJ70AEABG9dAAAKKjICe9ABAARvXgAA
CiouckMrAHBzkwAACnoucoMrAHBzkwAACnouctMrAHBzkwAACnouci0sAHBzkwAACnoucoUsAHBz
kwAACnouctUsAHBzkwAACnouckMtAHBzkwAACnp2AnvPAQAEb2YCAAYCKNACAAYCe9ABAARvWgAA
CiobMAIATAAAAAAAAAACe9EBAAQtQwIXfdEBAAQCb8cCAAYCe8wBAAQsGAIo3wIABgJ7zAEABG8Q
AAAKAhR9zAEABN4UAnvSAQAELAsCe9ABAARvrwAACtwqARAAAAIADwAoNwAUAAAAAJICe8wBAAR1
AwAAAiwWAgJ7zAEABHQDAAACbwgAAAZ9zQEABCoAAAATMAQAFQAAAAMAABEXjUEAAAEKBhYDnAIG
FhdvWQAACipWAnvPAQAEAwQFb2sCAAYCKNACAAYqNgIDIAAQAAAo4wIABirWAigaAAAKAgN92wEA
BAQgAAQAAC8HIAAEAAAQAgIEjUEAAAF91QEABAICe9UBAAR91wEABCoeAnvUAQAEKh4Ce9UBAAQq
HgJ71gEABCoeAnvXAQAEKh4Ce9kBAAQqIgIDfdkBAAQqwgJ72QEABBYxJgMCe9cBAAQCe9YBAAQC
e9kBAARZAnvZAQAEb6ICAAYCFn3ZAQAEKgAAABMwBwCNAAAANAAAEQIWfdQBAAQCe9UBAASOaQor
LwJ72wEABAJ71QEABAJ71AEABAZvKgAACgsHFjEWAgJ71AEABAdYfdQBAAQGB1kKBhYwzQJ72gEA
BCwnAgJ72gEABAJ71QEABBYCe9QBAAQCe9cBAAQWbyUAAAp91gEABCsMAgJ71AEABH3WAQAEAgJ7
1gEABH3ZAQAEKjICAxYDjmko7QIABioAABMwBQBzAAAAYQAAEQUWLwtyey0AcHNVAAAKegQKBQsr
WAJ72QEABBYwEQIo6wIABgJ72QEABBYwAhYqBwJ72QEABCiKAAAKDAJ71QEABAJ71AEABAJ72QEA
BFkDBggodwAACgYIWAoHCFkLAgJ72QEABAhZfdkBAAQHFjCkBSoAEzAFAHMAAABhAAARBRYvC3J7
LQBwc1UAAAp6BAoFCytYAnvZAQAEFjARAijrAgAGAnvZAQAEFjACFioHAnvZAQAEKIoAAAoMAnvX
AQAEAnvWAQAEAnvZAQAEWQMGCCh3AAAKBghYCgcIWQsCAnvZAQAECFl92QEABAcWMKQFKgATMAQA
RgAAAAAAAAACe9kBAAQWMBoCKOsCAAYCe9kBAAQWMAtyiS0AcHMmAQAGegJ71QEABAJ71AEABAJ7
2QEABFmRAgJ72QEABBdZfdkBAAQqQgIo7wIABgIo7wIABh5iYCpGAijwAgAGAijwAgAGHxBiYCpO
AijxAgAGbgIo8QIABmofIGJgKgAAABMwBwCuAAAAAAAAAAIDfdoBAAQCe9oBAAQ5gwAAAAJ71QEA
BAJ71wEABDMnAnvYAQAELRMCAnvVAQAEjmmNQQAAAX3YAQAEAgJ72AEABH3XAQAEAgJ71AEABH3W
AQAEAnvZAQAEFjFRAnvaAQAEAnvVAQAEAnvUAQAEAnvZAQAEWQJ72QEABAJ71wEABAJ71AEABAJ7
2QEABFlvJQAACiYqAgJ71QEABH3XAQAEAgJ71AEABH3WAQAEKkoCA3OXAgAGIAAQAAAo9gIABio6
AgMEIAAQAAAo9gIABioTMAMAVAAAAAAAAAACF33hAQAEAijQAAAKAy0LcqUtAHBzLAAACnoELQty
xS0AcHMsAAAKegUWMAtynyoAcHNVAAAKegIDfd4BAAQCBH3cAQAEAgMFc+MCAAZ93QEABCoeAnvh
AQAEKiICA33hAQAEKgAAABMwBABxAAAAbAAAEQMWajALcjAEAHBzVQAACnoCe94BAARvXAAACiwQ
AnveAQAEAxdvqwAACiYDKiAACAAACgMGai8DA2kKBo1BAAABCxcMAw0rHAkGai8DCWkKAnveAQAE
BxYGbyoAAAoMCQhqWQ0JFmoxBAgWMNsDCVkqNgJ73QEABBRv8wIABipGAnvcAQAEb6cCAAYtAhcq
FioAAAATMAIARAAAAAAAAAACe90BAARv6AIABhYwJAJ73QEABG/rAgAGAnvdAQAEb+gCAAYWMAty
1y0AcHMDAAAGegJ73QEABAJ73AEABG/qAgAGKjICe94BAARv0QAACio2AnvdAQAEb+QCAAZqKjIC
e94BAARvXgAACioucvUtAHBzkwAACnoyAnveAQAEb1oAAAoqLnJLLgBwc5MAAAp6LnJxLgBwc5MA
AAp6LnLJLgBwc5MAAAp6LnIZLwBwc5MAAAp6LnJxLwBwc5MAAAp6jgJ74AEABC0aAhd94AEABAJ7
4QEABCwLAnveAQAEb68AAAoqAAAAEzAEAGkAAAA0AAARAnvcAQAEb6YCAAYsC3LLLwBwcwMAAAZ6
BQoCe9wBAAQDBAZvpAIABgsEB1gQAgYHWQoGLDACe9wBAARvpwIABi0jAnvcAQAEb6UCAAYsCAIo
/AIABivDBy3Acu8vAHBzJgEABnoFBlkqAAAAEzAEAFAAAAAWAAARAgJ75gEABAoGF1h95gEABAYg
AIAAADMLchkwAHBzMAAACnoCe+QBAAQCAnvlAQAECgYXWH3lAQAEBgPSnAICe+UBAAQg/38AAF99
5QEABCoTMAYATAAAABYAABErQAJ75AEABAICe+UBAAQKBhdYfeUBAAQGAnvkAQAEAyUXWBABkZwC
AnvlAQAEIP9/AABffeUBAAQDIP9/AABfEAEEJRdZEAIWMLcqEzAGAKsAAABhAAARAgJ75gEABANY
JQx95gEABAggAIAAADELchkwAHBzMAAACnoCe+UBAAQEWSD/fwAAXwogAIAAAANZCwYHMGMCe+UB
AAQHL1oDBDBMAnvkAQAEBgJ75AEABAJ75QEABAModwAACgICe+UBAAQDWH3lAQAEKgJ75AEABAIC
e+UBAAQMCBdYfeUBAAQIAnvkAQAEBiUXWAqRnAMlF1kQARYw0yoCBgMEKAwDAAYqABMwBgCVAAAA
NAAAEQQgAIAAAAJ75gEABFkoigAACgNvGgMABiiKAAAKEAIgAIAAAAJ75QEABFkLBAcxLQMCe+QB
AAQCe+UBAAQHbx0DAAYKBgczKQYDAnvkAQAEFgQHWW8dAwAGWAorFAMCe+QBAAQCe+UBAAQEbx0D
AAYKAgJ75QEABAZYIP9/AABffeUBAAQCAnvmAQAEBlh95gEABAYqAAAAEzAFAFQAAAAAAAAAAy0L
cjEwAHBzLAAACnoCe+YBAAQWMQZz2QAACnoFIACAAAAxEgQFIACAAABZWBACIACAAAAQAwMEAnvk
AQAEFgUodwAACgIFIP9/AABffeUBAAQqNiAAgAAAAnvmAQAEWSoeAnvmAQAEKgAAEzAFAIcAAABh
AAARAnvlAQAECgUCe+YBAAQxCgJ75gEABBADKxYCe+UBAAQCe+YBAARZBVgg/38AAF8KBQsFBlkM
CBYxHQJ75AEABCAAgAAACFkDBAgodwAACgQIWBACBhADAnvkAQAEBgVZAwQFKHcAAAoCAnvmAQAE
B1l95gEABAJ75gEABBYvBnPZAAAKegcqABMwBAARAAAAFgAAEQICFiUKfeUBAAQGfeYBAAQqXgIg
AIAAAI1BAAABfeQBAAQCKBoAAAoqAAAAEzAHAJEAAAAWAAARAnvrAQAEAy91AnvoAQAEAnvpAQAE
MwIVKgICe+oBAAQCe+cBAAQCAnvoAQAECgYXWH3oAQAEBpEg/wAAAF8Ce+cBAAQCAnvoAQAECgYX
WH3oAQAEBpEg/wAAAF8eYmACe+sBAAQfH19iYH3qAQAEAgJ76wEABB8QWH3rAQAEAnvqAQAEbhcD
Hx9fYhdZal9pKoICAnvqAQAEAx8fX2R96gEABAICe+sBAAQDWX3rAQAEKk4CAygWAwAGJRYyBwID
KBcDAAYqHgJ76wEABCpeAnvpAQAEAnvoAQAEWQJ76wEABBljWCqiAgJ76gEABAJ76wEABB1fHx9f
ZH3qAQAEAgJ76wEABB/4X33rAQAEKj4Ce+gBAAQCe+kBAAT+ASoAEzAFAOUAAABhAAARBRYvC3J7
LQBwc1UAAAp6AnvrAQAEHV8sC3JHMABwczAAAAp6FgorNAMEJRdYEAICe+oBAATSnAICe+oBAAQe
ZH3qAQAEAgJ76wEABB5ZfesBAAQFF1kQAwYXWAoCe+sBAAQWMQQFFjC/BS0CBioCe+kBAAQCe+gB
AARZCwUHMQMHEAMCe+cBAAQCe+gBAAQDBAUodwAACgICe+gBAAQFWH3oAQAEAnvoAQAEAnvpAQAE
WRdfLCsCAnvnAQAEAgJ76AEABAwIF1h96AEABAiRIP8AAABffeoBAAQCHn3rAQAEBgVYKgAAABMw
BQAhAAAAFgAAEQIWfeoBAAQCAgIWJQp96wEABAYlCn3pAQAEBn3oAQAEKgAAABMwBgC2AAAAFgAA
EQMtC3IUBABwcywAAAp6BBYvEHIiBABwchsjAHBzVwAACnoFFi8QcjAEAHByGyMAcHNXAAAKegJ7
6AEABAJ76QEABC8LcsMmAHBzMAAACnoEBVgKBAYwBgYDjmkxC3IwBABwc1UAAAp6BRdfLDMCAnvq
AQAEAwQlF1gQApEg/wAAAF8Ce+sBAAQfH19iYH3qAQAEAgJ76wEABB5YfesBAAQCA33nAQAEAgR9
6AEABAIGfekBAAQqIgJ77QEABG4qNgIoGgAACgIoIgMABioiAhd97QEABCoAABMwAwA+AAAAbQAA
EQJ77QEABCD//wAAXwoCe+0BAAQfEGQLBgMg/wAAAF9YIPH/AABeCgYHWCDx/wAAXgsCBx8QYgZY
fe0BAAQqagMtC3IUBABwcywAAAp6AgMWA45pKCUDAAYqAAAAEzAFAM4AAABuAAARAy0LchQEAHBz
LAAACnoEFi8QciIEAHByhzAAcHNXAAAKegUWLxByMAQAcHKHMABwc1cAAAp6BAOOaTIQciIEAHBy
rTAAcHNXAAAKegQFWAOOaTEQcjAEAHBy6TAAcHNXAAAKegJ77QEABCD//wAAXwoCe+0BAAQfEGQL
K0Ag2A4AAAwIBTECBQwFCFkQAysVBgMEJRdYEAKRIP8AAABfWAoHBlgLCBdZJQwWL+MGIPH/AABe
Cgcg8f8AAF4LBRYwvAIHHxBiBmB97QEABCpSfu8BAAQCA2Eg/wAAAF+VAh5kYSoiAnvwAQAEbiom
AgNtffABAAQqIgIWffABAAQqABMwBABEAAAAAAAAAAICe/ABAAQVYX3wAQAEAn7vAQAEAnvwAQAE
bgNqYSD/AAAAal/UlQJ78AEABB5kYX3wAQAEAgJ78AEABBVhffABAAQqagMtC3IUBABwcywAAAp6
AgMWA45pKCwDAAYqABMwBwCLAAAAAAAAAAMtC3IUBABwcywAAAp6BRYvEHIwBABwchExAHBzVwAA
CnoEFjIIBAVYA45pMQtyIgQAcHNVAAAKegICe/ABAAQVYX3wAQAEKyoCfu8BAAQCe/ABAAQDBCUX
WBACkWEg/wAAAF+VAnvwAQAEHmRhffABAAQFF1klEAMWL80CAnvwAQAEFWF98AEABCpuIAABAACN
RwAAASXQ+QEABCguAAAKgO8BAAQqNgIoGgAACgIoNQMABioiAhV98gEABComAnvyAQAEZmoqEzAE
ADIAAAAWAAARAnvyAQAEHxhjA2EKBhYvCCAAAQAABlgKAgJ78gEABB5ian7xAQAEBpVuYWl98gEA
BCpqAy0LchQEAHBzLAAACnoCAxYDjmkoOQMABioAAAATMAUAZAAAABYAABEDLQtyFAQAcHMsAAAK
egQWLxByIgQAcHJPMQBwc1cAAAp6BRYvEHIwBABwck8xAHBzVwAACnoEBVgDjmkxC3IwBABwc1UA
AAp6FgorEgIDBCUXWBACkSg3AwAGBhdYCgYFMuoqbiAAAQAAjUcAAAEl0PsBAAQoLgAACoDxAQAE
KhMwBABzAAAAbwAAEQIo3AAAChZv3QAACgIo3AAACm/eAAAKcoExAHBv3wAACm/gAAAKb0EAAAoK
BnKdMQBwKFsAAAoMEgJytzEAcCjhAAAKcskxAHAo4gAACgsCKNwAAApv3gAACnLTMQBwb98AAAoH
b+MAAAoCBgcoPAMABioAGzAEAAcBAABwAAARBChpAAAKLAYEKMcAAAoDH1xv5AAACgoGFi8F3eYA
AAADFgZvPwAACgty9TEAcAwHKGwAAAotBd3KAAAABwgo5QAACg0EKGQAAApzTAIABhMEEQQfCW9Q
AgAGIAAQAACNQQAAARMFCRMGFhMHK2MRBhEHmiUocwAACnPTAAAGEwgRCChbAAAKb/QAAAYRBBEI
b1cCAAYo5gAAChMJEQkRBRYRBY5pbyoAAAoTChEEEQUWEQpvWQAAChEKFjDf3gwRCSwHEQlvEAAA
CtwRBxdYEwcRBxEGjmkylREEb8cCAAYRBG+vAAAK3gwRBCwHEQRvEAAACtzeDyYCKNwAAAoXb90A
AAreACoAASgAAAIAnAAjvwAMAAAAAAIAUQCY6QAMAAAAAAAAAAD39wAPEAAAAR4CKOcAAAoqrn7z
AQAELR5yATIAcNBZAAACKEYAAApv6AAACnPpAAAKgPMBAAR+8wEABCoafvQBAAQqHgKA9AEABCoa
fvUBAAQqHgIo6gAACiouc0MDAAaA9QEABCoAABMwAwCDAAAAcQAAEQN1ZQAAAgoEdWUAAAILBi0L
By0EFgwraRUMK2UHLQQXDCteBm9ZAwAGLAwGb1kDAAYXLgMXKwEWB29ZAwAGLAwHb1kDAAYXLgMX
KwEWDQlZDAgtLQZvVwMABm/iAAAGB29XAwAGb+IAAAZZEwQRBBZqLwQVDCsKEQQtBBYMKwIXDAgq
0gIVan0pAgAEAhVqfSoCAAQCFWp9KwIABAIoGgAACgIYfSYCAAQCBH0kAgAEAgN9KAIABCoTMAIA
RQAAAAAAAAACFWp9KQIABAIVan0qAgAEAhVqfSsCAAQCKBoAAAoCGH0mAgAEAgRz0wAABn0kAgAE
AnskAgAEBW/9AAAGAgN9KAIABCoqAgMEHihQAwAGKhMwAgBFAAAAAAAAAAIVan0pAgAEAhVqfSoC
AAQCFWp9KwIABAIoGgAACgIYfSYCAAQCBHPTAAAGfSQCAAQCeyQCAAQFb/0AAAYCA30nAgAEKtIC
FWp9KQIABAIVan0qAgAEAhVqfSsCAAQCKBoAAAoCGH0mAgAEAgR9JAIABAIDfScCAAQqpgIVan0p
AgAEAhVqfSoCAAQCFWp9KwIABAIoGgAACnJzMgBwcyYBAAZ63gIVan0pAgAEAhVqfSoCAAQCFWp9
KwIABAIoGgAACgIDfSYCAAQCBG8NAQAGdCcAAAJ9JAIABComAhYDKFUDAAYqHgJ7JAIABCqWAnsl
AgAELRYCAnskAgAEbw0BAAZ0JwAAAn0lAgAEAnslAgAEKh4CeyYCAAQqHgJ7KAIABCoeAnspAgAE
KiICA30pAgAEKh4CeyoCAAQqIgIDfSoCAAQqHgJ7KwIABCoiAgN9KwIABCoAEzABABgAAAAgAAAR
FAoCeycCAAQsDAJ7JwIABG/hAQAGCgYqVgIoGgAACgIDfSwCAAQCF30uAgAEKjoCKBoAAAoCA30t
AgAEKh4Cey4CAAQqPgIoaQMABgJ7LQIABI5pKl4CKGkDAAYCey0CAARvNAAACnQBAAAbKmICey4C
AAQsCAIUfS0CAAQqAhR9LAIABCpqAnssAgAELRECAnstAgAEKMwAAAZ9LAIABCpqAnstAgAELREC
AnssAgAEKM8AAAZ9LQIABCo2Am9oAwAGAnssAgAEKlYCFX0wAgAEAigaAAAKAgN9LwIABCo6Ansv
AgAEAnswAgAEmioiAhV9MAIABCoTMAMAHAAAABYAABECAnswAgAEF1gKBn0wAgAEBgJ7LwIABI5p
/gQqOgIo0AAACgIDfTECAAQqMgJ7MQIABG9aAAAKKjICezECAARvsgAACioOFmoqMgJ7MQIABG9e
AAAKKj4CezECAAQDBAVvWQAACir2AijQAAAKAgR9NAIABAIFfTUCAAQCA30yAgAEAgJ7MgIABHv1
AAAEfTMCAAQCBH02AgAEAgQFWH03AgAEKhswBABaAAAAcgAAEQJ7NgIABAJ7NwIABDICFSoCezMC
AAQKFgsGEgEouAAACgJ7MwIABAICezYCAAQMCBdqWH02AgAECBZvqwAACiYCezMCAARvpQAACg3e
CgcsBgYougAACtwJKgAAARAAAAIAGQA1TgAKAAAAABswBAB+AAAAcwAAEQJ7MwIABAoWCwYSASi4
AAAKBWoCezcCAAQCezYCAARZMRcCezcCAAQCezYCAARZaRADBS0EFg3eQwJ7MwIABAJ7NgIABBZv
qwAACiYCezMCAAQDBAVvKgAACgwIFjEPAgJ7NgIABAhqWH02AgAECA3eCgcsBgYougAACtwJKgAA
ARAAAAIACQBpcgAKAAAAABpz6wAACnoAEzACAHAAAAA5AAARAns2AgAECgRFAwAAAAIAAAANAAAA
GAAAACsfAns0AgAEA1gKKxQCezYCAAQDWAorCQJ7NwIABANYCgYCezQCAAQvC3KxMgBwc34AAAp6
BgJ7NwIABDILcusyAHBz7AAACnoCBn02AgAEAns2AgAEKjoCezYCAAQCezQCAARZKgATMAIAOQAA
ADkAABECezQCAAQDWAoGAns0AgAELwtysTIAcHN+AAAKegYCezcCAAQyC3LrMgBwczAAAAp6AgZ9
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
BAJ7PQIABBEEF1klEwSULPACez0CAAQRBI8/AAABJUoXWVQCez0CAAQRBBdYJRMEjz8AAAElShdY
VAgXAns+AgAEF1kRBFkfH19iWQwIFjEMEQQCez4CAAQXWTK0CBYwoAJ7PQIABAJ7PgIABBdZjz8A
AAElSghYVAJ7PQIABAJ7PgIABBhZjz8AAAElSghZVBgHWhMFAns+AgAEEwsrRAJ7PQIABBELF1mU
EwwrKhgDEQUlF1gTBZRaEw0DEQ0XWJQVMxQCezkCAAQDEQ2UEQvSnBEMF1kTDBEMFjDREQsXWRML
EQstuCoAAABCU0pCAQABAAAAAAAMAAAAdjQuMC4zMDMxOQAAAAAFAGwAAADAeQAAI34AACx6AABA
SgAAI1N0cmluZ3MAAAAAbMQAAFQzAAAjVVMAwPcAABAAAAAjR1VJRAAAAND3AADcFAAAI0Jsb2IA
AAAAAAAAAgAAAVefoisJCwAAAPoBMwAWAAABAAAAbgAAAHMAAABCAgAAmQMAAIoDAAAaAAAA7AAA
ANAAAAArAAAABwAAAHYAAAA1AAAA2AAAAC8BAAACAAAAAgAAABAAAAABAAAABAAAAAEAAAAYAAAA
AQAAAAAAQSoBAAAAAAAGAG8gzjcGAP4gzjcGAIMfkzcPAKw4AAAGALAfqS8GACwgqS8GAA0gqS8G
AOUgqS8GAI8gqS8GAKggqS8GANkfqS8GAPQfBSUGAAExVCwGANwxfS8GAOJEfS8GAFQxVCwGAOI/
VCwGABotykYGAJUXVCwGAH0AykYGALQ6ykYGAIYRykYGAB4rykYGAP8rOAgGAD4VykYGAFssykYG
AB87ykYGALA7VCwGALkeVCwGADxBVCwGADIoVCwGALhD5zwGAEwxVCwGALszeUQGANg25zwGAKAZ
VCwGALgxOAgGAMcfVCwGAC0uVCwGALUqOAgGABc6OAgGAKAtVCwGAGAgVCwGAPsWVCwGAAYyOAgG
APkrOAgGAEkgqS8GAIkX5zwGAKEX5zwGAOI15zwGAI0uOAgGAKIzykYKAMMgEykKAEIdEykGAGYf
kzcGAHU07jcGAMExaC8OANse+ykOAJcf+ykOAHUdUy8GAEsfzjcGAG4bVCwGAOMAVCwGAHAlVCwG
AFohVCwGAE8VykYGALs6ykYGAG4sykYGAGEwVCwGANYwVCwGAOIAVCwGAJI9zjcGADhGVCwGAKsX
VCwGABYxVCwGADIwykYGAJAsVCwGAMtIOAgOALdFyDwOAPo8yDwGAKAyVCwGAHMbVCwGAL4XVCwG
ANYmOAgGAM0xOAgGAI8wVCwGAOwwOAgGAFIYOAgGAMIeVCwGAAEVOAgGAK89OAgGAHgbOAgGAMEw
OAgGANQkeUQGADQRqCQGAPIxaC8GAMImVCwGAHkwVCwGAHEEVCwGAEkwVCwGACg3qCQGAEQCVCwG
ACUDVCwGAEMCVCwGAAU3ykYKAOkpEykSAIY5GxsSAAYXGxsGAOtGqS8GABgwOAgAAAAAEgQAAAAA
AQABAAEgEACrMA4QNQABAAEAAAAQAJssaDFFAAEABQAAABAAlSpoMV0ADQAPAIEAEAA3EGgxaQAV
ABIAAAAQAF4daDFFABUAFAAAABAAYi1oMRgAFgAZAAAAEAA/LWgxGAAWACEAAQEQAHIRaDEUABYA
KQABABAAhzuKG3EAFwA0AAEAEACVO4obcQAZADgAAQAQAKc7ihsoAB0APwABABAAcjuKG3EAHgBB
AAEBAACGNYobdQAhAEYAAQEAAOw0iht1ACEASgABAQAAKjWKG3UAIQBOAAEBAADXNIobdQAhAFIA
AQEAABI1iht1ACEAVgABAQAA/zSKG3UAIQBaAAEAEACeNYobRQAhAF4AoQAAAKssihsAACkAaQCh
AAAAWjaKGwAAKQBrAAEAEAAqNoobRQApAGwAAQAQAE82ihtFACwAdQABABAARzaKG2AALQB3AAEA
EAA1NoobYAAxAIMAAQEQAEM8ihtFADMAiQCBABAAMjyKG0UAMwCPAAEAEACHPhkyRQAzAJEAAQAQ
AFQyGTJFADoAmQChAAAAnEcZMgAASwC2AAEAAADvLBkyRQBLALwAAQEAAOsBGTKpAFAAyQABAQAA
lhMZMqkAVADJAAEBAAB8LBkyqQBaAMkAAQEAADw7GTKpAGkAyQABARAAWD4ZMkUAeQDJAAEBAAAP
BRkyqQCdANMAAQAQAElJGTJFALMA0wABABAAzEcZMkUAxgARAQEgEAAwMRkyCADMACQBoQAAAD0P
GTIAAMwAKAEBABAAVg8ZMkUAzAArAQEAEADiDxkyRQDOADIBAQAQAEkPGTJFANIAPwGgAAAAiUcZ
MgAA1QBKAQEBEAANDxkyRQDVAEsBAQAQAFw7GTJxANoAagEBAQAAtEYZMqkA3ABvAQEBAAA7Lxky
qQDfAG8BAQAQAMo+GTJFAOYAbwEBAQAASjUZMnUA7AB6AQEBAAAZFRkyqQDsAH4BAQAQACEYGTJF
AO8AfgGhAAAAhxQZMgAABwHhAaEAAAB0FBkyAAAHAeIBAQAQAK8UGTJFAAcB4wEBABAAmRQZMkUA
CAHlAaEAAABjFhkyAAAIAecBgQAQAHMWGTJFAAgB7QEBABAAhhYZMvAACQH0AQEAEACZFhky8AAM
AfwBAQAQAKYPGTJFAA4BBAIAABAAjQ8ZMkUAEQELAgAAEAArKxkyYQATARACAQAQAGgrGTJEARUB
MAIBAAAA3iwZMkUAHAFCAgEAEAC3KxkyPAEfAUwCAQAQAPs1qy5FACsBXwIBABAAZT6rLkUAQAFz
AgEBAACYRqsuqQBbAXUCAQAQAEMbqy4YAV8BdQIBAAAAFS6rLkUAdwGJAgEAEAC5JKsuOAGNAZYC
AQAQAA02qy5FAI0BlwIAABAADDOrLkUArgGtAgEAAACxFasuRQDCAbICAQAQAOozqy5FAMYBtgIB
ABAAxytdPGEAywHEAgEAEAAbNF08RQDUAeICAQAQAHcrXTxhANwB9AIBABAAH0VdPEUA4gELAwEA
EADGNl08RQDnARUDAQEQANoAkzxFAOwBIAMBARAA1ACTPEUA7gEmA6EAAACwLZM8AADxAS8DAQAQ
AH8EkzxFAPEBNAMBABAAeC5BJNkA8wE7AwAAEAD1N1M5RQDzAT4DAAEQAFM7UznxAPUBQgMAAQAA
GwQAAEUA9gFFAwIBAAA3HwAAqQAGAkUDAgEAAJAeAAB1AAoCRQMDAQAAozEAAKkACgJJAwIBAADc
JQAAqQARAkkDAgEAAEY7AACpABkCSQMCAQAAbTUAAHUAHQJJAwMBAACWQwAAqQAdAk0DAwEAAE8T
AACpACACTQMDABAA7DUAAEUAJAJNAwMAEABLHgAARQAkAk8DAwAQAEIlAABFACwCYgMDABAA8jYA
AEUALwJrAwMAEACiKgAAYQAxAm8DAwAQAFUrAABhADICfAMDAQAAxzQAAHUAOAKLAwMAEAAMFgAA
RQA4Ao8DAwEAAEo+AACpAEACmgMTAQAAsAAAAPkAQwKaAxMBAAAIAwAA+QBDApoDEwEAADcAAAD5
AEMCmgMTAQAAWwMAAPkAQwKaAxMBAADqAgAA+QBDApoDEwEAABkAAAD5AEMCmgMTAQAAdAEAAPkA
QwKaA1GALAdXCVGAhwhXCVGAUgdXCQEAQCNXCQEAdzdaCSEAZhReCQEAAjReCQEAMT1XCQEAlTRe
CQEAmQBiCQEADRJmCQEAMxVmCVGAGwdXCQEABixpCQEAlS1tCQEA3TNeCQEAOj1XCQEABz1XCVGA
sgVXCQEAJChXCQEAHT9xCQEAdg5eCQEAMwvXAgEAuwtmCQEAMwvXAgEAWgp1CQEAzw11CQEAuwtm
CQEANw1mCQEAMwvXAgEAlgx4CQEAuwtmCQYAtEh8CQYASxiACQYA7ReECQYAtxuICQYAqRuMCQEA
5QyQCQEA/QyQCQEAlgtmCQEADg3XAgEAcA2UCQEAfA2UCQEA8QyZCQEAnQt1CQEAsgt1CQEASAud
AQEAUQudAQEAnQt1CQEAsgt1CQYAtEh8CQYASxiACQYAwj2dCQYA7ReECQYAtxuICQYAqRuMCQEA
8QuhCQEAuwtmCQEAuwxeCQEALgymCQEABwurCQEAnQ7XAgEA5QyZCQEA/QyZCQEAawuwCQEAWgu1
CQEAmQ1mCQEAsw1mCQEAFg1mCQEAkQ26CQEAjw6+CQEAVQzCCQEAMgrGCQEAwwrXAlGA0yZXCQEA
HUjXAgEA5jtmCQEAlDLLCTEAgD3OCQYGPApXCVaAdiTGCVaA5C3GCVaALxDGCQYGPApXCVaA/xHS
CVaAQRLSCVaAxQHSCVaANAHSCVaAvwjSCQYGPApXCVaAWRvXCVaANxDXCVaAyjfXCVaAGQHXCVaA
wwPXCVaAowDXCVaAiAPXCVaAEgHXCVaAVAPXCVaAShLXCVaAlSbXCVaAjSbXCVaASgLXCVaAqTHX
CQYGPApXCVaAjBLcCVaAvRPcCVaATDfcCVaAdwLcCVaAlhHcCVaAkjHcCVaAgAPcCVaA2QPcCVaA
CgTcCVaAEADcCVaArETcCVaAyz3cCVaAuxHcCVaAYwHcCVaAhwLcCVaA70VXCVaADQpXCVaAizFX
CVaAHghXCVaAkghXCVaA9AFXCVaAwiJXCVaAQghXCVaAtyNXCVaAvCNXCVaAVwhXCVaA1iJXCVaA
UAhXCVaApyJXCVaASQhXCVaAayNXCVaA0wVXCVaAYRxXCVaAigZXCVaA4htXCVaAmAZXCVaAKxxX
CVaAuQZXCVaArRxXCVaAxQZXCVaAsgZXCVaAdhxXCVaAQRxXCVaAvAFXCVaAjRxXCVaAyBtXCVaA
DRxXCVaApAZXCVaAxRxXCVaAkQZXCREAUxZXCQYGPApXCVaATD3hCVaAvw7hCVaAVTzhCVaA5kXh
CVaATzzhCVaA1QnhCVaAMAHhCVaArCbhCVaAJyzhCVaAlyzhCVaAmgnhCVaAaAnhCVaAPh3hCVaA
hhDhCVaAND/hCVaA3D7hCVaA/AjhCVaADizhCVaAAQDhCVaACQrhCVaAvwjhCQEAqzHmCQEADzpX
CQEA/UXrCQEAPhnXAgEAPCTuCQEAmCLuCQEA0T/rCQEAghDxCQEAvxrxCQEAxBPSCQEAxQ5eCQEA
H0LXAgEATTtXCQEAh0V1CQEAAUF1CQEAJgpmCQEAdgv0CQEApTJXCQEA7idXCQEAawzCCQEAOQud
AQEA3Av3CQEARg5mCQEAUg1XCQEAYQ1XCQEAoyT8CQEACBBeCQEATDv/CQEAhBqdAQEACxudAQEA
xxmdAQEACxudAQEAbhqdAQEAxxmdAQEAsEVXCQEA0EJXCQEAYidXCQEA5UkECgEACBBeCQEA0xjX
AgEAc0ZeCQYGPApXCVaAtzYJClaAoT0JCgYGPApXCVaAgSUOClaAhzMOClaA/g8OClaAER8OClaA
pj4OClaAFh8OCgEAEAurCQEAuA4TCgEAkQpmCQEAJg5XCQEAhAp1CQEAiwwOCgYGPApXCVaAFhYY
ClaAJ0AYCgYA4BEdClGAmiNXCQEATgpmCQEAMwvXAgEAEA7XAgEAtgrXAgEAAwxpCQEA1DVmCQEA
kUl1CQEALg0iCgEAc0ZeCQEAiAtmCQEAMgrGCQEASQ2UCQEAGQ51CQEAXQ4oCgEA9wotCgEAzQoy
CgEAZQpmCQEApgtXCQEArwxeCQEABA43CgEAdQpmCQEAew6+CQEAFgvXAgEA6woYCgEAPAxpCQEA
FgvXAgEAIAvXAgEAPAwECgEADwwECgEAPCR1CQEAmCJ1CQEAghB1CQEA5w11CQEA1w11CQEA0gxm
CQEATQxpCQEAkzM8CgEAghBBCgEAGEoTCgEAPCR1CQEAxBNXCQEATTtXCQEALxTXAgEAag7XAjEA
gD3OCTEA5hLOCQEASzmUCQEAghBBCgEAUkkTCgEAESpXCQEAuhPSCQEAPCR1CQEAAUF1CQEA+kFe
CQEAbDNmCQEAGD11CQEAJD11CQEAMgrGCVaADQhXCVaAwQRXCVaA+QdXCVaA6gdXCVaA8gRXCVGA
bAlXCVGA4wZXCVGA1gZXCVGAcwVXCVGAZQVXCVGAfgVXCVGAVgVXCVGARgVXCVGAKgVXCVGAOQVX
CQEAOypXCQEAgzZmCQEA8B5XCQEAz0N1CQEAySRGCgEAUhtLClaAzAZmCVaARQdXCVaAyQhXCVaA
1ghXCVaAgwlXCVaAcAdXCVaA+QZXCVaA7wZXCVaAVAlXCVaAkQVXCVaAYAdXCVaAXglXCVaAqAVX
CVaAZgdXCVaAjwlXCVaAigRXCVaAzAlXCVaAlwVXCRYAxAVXCVaA4wRXCVaApAlXCVaA/AlXCRYA
AwdQChYAHQpQChYADwdQChYA4AdQChYAdARQCgYGPApXCVaANEFUClaA1RFUClaA/kZUClGAfjJX
CQEATiZXCQEAJBFZCgEA+0RZCgEA4EJXCQEANi5XCQEAcRdmCQEA60JXCQEA/0JXCQEAHxFXCQEA
OUVeCQEAwUZUCgEAgy5XCQEAN0pXCQEARydXCQEAPCdXCQEAuy9XCQEAfiReCQEA3C11CQEAcSRX
CQEAKBNXCQEAySRGCgEAJS5dCgEAwTRiClGAiQVXCVGAmAdXCVGArwdXCVGApAdXCVGAeANXCVGA
BwBXCVGAjwNXCVGAggdXCTEAfghQCjEAuR1eCREATzhZChEA7iZeCREAQjhZChEA4CZeCQYAySRG
CgEAnhVnCgEACBZnCgEAqhVnCgEAhyRZCgEAjSReCQEAHUFXCQEAPz5XCTEA9QhQCjEA5AlQCjEA
sQlQCjEA3QlQClGAXghXCVGAdwlXCVGA4AhXCVGAhgBXCVGAHQFXCVGA1QRXCVGAbAhXCVGAxgdX
CVGAJQlXCVGAuAlXCVGAPAlXCVGAuAdXCVGAzARXCQEAbRVXCQEArDRXCQEA9j1XCQEAcydXCQEA
pkNXCQEAPy5XCQEAuChmCQEAz0N1CQEA3C11CQEAKDNmCQEAMkRsCgEALEVxCgEAHjN2CgEA4xV7
CgEACBZ7CgEAwTRiClGAkwdXCVGAjQdXCVGAkgdXCVGA7ghXCVGA9whXCVGAAQlXCTEAcS5QCjEA
Jj5QCjEAfghQCgEAtTxeCQEAvDxeCQEAqhV7CgEAbRVXCQEAqy1XCQEApS1XCQEAqi1XCQEArC1X
CQEAgSpXCQEAWS70CQEAgjdXCVGA1QdXCQEAERZZChYA1RV7ChYA/BV7CgEAuwxeCQEAAkNXCQEA
aBNXCQEART7xCQEAgEJXCQEALxTXAgEAegxaCQQA4BReCQEAuwxeCQQA2wyACgQAHAxpCQEARApm
CQEAwwxmCREAOxOFCgEAuSdXCQEA2g9eCQEAmydXCQEA2EReCQEAxkReCQEAfxdXCQEAhS1aCQEA
mitpCQQAeiSKCgQALzSPCgEARStpCQQAOyR1CQEAGBJmCQEA1DVmCVGA4SNXCVGA6ShXCQEAOUVe
CQEAMRNXCQEAyBFXCQEAVQ5eCQEAMg5XCQEAnQpXCQEAuwzxCQEAoQxXCVGAJQXxCQEAui3xCVGA
ZRHxCTEA8hZxCQEAghDxCTEA5xZxCQEAZRBXCREA5y2UChEABh2ZChEAVhSeCjMBTgKjCjMB6QCj
CjMBmgOoCjMBOgGtCjMBVACyCjMBKwOtCjMBOgS3CjMBwQKjCjMB5gW8CjMBmATBCjMBmAKyCjMB
DwayCjMBOAa8CjMBYQa3CjMBkwGjCjMB4QOjCgYGPApXCVaAukKwCVaAmDawCVaA6T6wCQYGPAr0
CVaAWRvmCVaAJSTmCVaAiSLmCVaAfhDmCVaAFhvmCVaAKjrmCQYGPApXCVaA6Bn3CVaAsBD3CVaA
vBn3CVaAnhD3CVaA/Br3CVaA2RD3CVaABxP3CQYGPAr0CVaAcxr/CVaAEBv/CVaAvBn/CQYGPApX
CVaA2j/GClaAjDPGCgYGPApXCVaAQEfLClaAd0bLClaAPRHLCgEAuA4TCgEArg4TCgEAqArLCgEA
3wrQCgEALwvXAgEA5w11CQEA1w11CQEAYSJ1CQEAEA7XAgEA+A1eCQEAzAtmCQEAPkYiCgEAsUVX
CQEAAwxpCQEABwurCQEAAwxpCQEAPw51CQEA6Qt1CQEAiA11CQEAsQp1CQYAUj1ZCgYAzSdeCQYA
jjhXCQYAmjhXCQEAuzhZCgEAnD5QCgEAwydXCQEAdiZdCgYGPApXCVaAuj3VClaAwBvVClAgAAAA
AIQYGzccAAEAWiAAAAAAhhgbNwYAAwBiIAAAAACGGBs3EAADAGsgAAAAAIYYGzckAAQAeCAAAAAA
hhgbN9oKBgCEIQAAAADmAY4obgAKAEoiAAAAAIYIhTSHAA8AVCIAAAAAhgDsFIcADwCRIgAAAADm
AXoofgAPAJ0iAAAAAOYJGSMlARIAnSIAAAAA5gksIyUBEgClIgAAAADmCRM8iAESAKUiAAAAAOYJ
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
BAA0FQAAAQAvNAAAAgDoQAAAAwCJQgAABAA7NAAABQD0QAAAAQAvNAAAAgDoQAAAAwCJQgAAAQAH
LAAAAgCWLQAAAwBtFQAAAQARNAAAAgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQBtEQAA
AQDzDwAAAQBzJgAAAQDOKAAAAQAvNAAAAgDoQAAAAwCJQgAAAQAvNAAAAgDoQAAAAwCJQgAABAA7
NAAABQD0QAAAAQDOKAAAAQAvNAAAAgDoQAAAAwCJQgAAAQAvNAAAAgDoQAAAAwCJQgAABAA7NAAA
BQD0QAAAAQDOIQAAAQDOIQAAAQBURgAAAgDrCQAAAQBURgAAAgDrCQAAAQA+GQAAAQDOIQAAAQA+
GQAAAgAvEgAAAwBZQAAAAQDOIQAAAQA+GQAAAgClOQAAAQA+GQAAAgA/JAAAAQDOIQAAAQDpPwAA
AgDEEwAAAQDWMwAAAgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQDpPwAAAgDE
EwAAAQDWMwAAAgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQDpPwAAAgDEEwAA
AQDWMwAAAgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQDpPwAAAgDEEwAAAQDW
MwAAAgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQDpPwAAAgDEEwAAAQDWMwAA
AgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQDpPwAAAgDEEwAAAQDWMwAAAgA/
JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBYQQAAAQB2NgAAAQAfNgAAAgBmNgAAAQAfNgAA
AQAfNgAAAgBmNgAAAQDVSAAAAgA/JAAAAQBXGAAAAgA/JAAAAQBXGAAAAQBXGAAAAQDVSAAAAgCl
OQAAAQDVSAAAAgDaHQAAAQDVSAAAAgDaHQAAAQA+GQAAAQA+GQAAAQA+GQAAAQB2NgAAAQD9LgAA
AQCPQwAAAQBUKQAAAQA+GQAAAQA+GQAAAQA+GQAAAQB2NgAAAQA+GQAAAQB2NgAAAgBjIwAAAwAE
JAAAAQB2NgAAAgD6HQAAAwAaHgAAAQB2NgAAAgBjIwAAAwAEJAAABAD6HQAABQAaHgAAAQA+GQAA
AQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQB2NgAAAgBjIwAAAwAEJAAAAQA+GQAAAQDOIQAAAQDO
IQAAAQAHLAAAAgBqNAAAAQAHLAAAAgBqNAAAAwABQQAABACUQgAAAQDZFAAAAgAULwAAAwBqNAAA
AQDZFAAAAgAULwAAAwBqNAAABAA6NQAABQCwKQAABgDWMwAABwA+GQAAAQDZFAAAAgAULwAAAwBq
NAAABAA6NQAABQCwKQAABgDWMwAABwA+GQAACABNQAAAAQDbJgAAAQDVSAAAAgA/JAAAAQBXGAAA
AgA/JAAAAQBXGAAAAQBXGAAAAQDVSAAAAgClOQAAAQDOIQAAAQCVPgAAAQDOIQAAAQDOIQAAAQDO
IQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQCrGAAAAgDpRwAAAwDaHQAABAAfNgAABQBmNgAA
AQCrGAAAAgDpRwAAAwDaHQAABAAfNgAAAQDsKwAAAgDpRwAAAwDaHQAABAAfNgAABQBmNgAAAQCr
GAAAAgDFSAAAAwAfNgAAAQCrGAAAAgDFSAAAAwBBHwAABACpHgAABQAfNgAABgBmNgAABwCZGQAA
AQCaKwAAAgDFSAAAAwBBHwAABACpHgAABQAfNgAABgBmNgAABwCZGQAACADUNQAAAQDWMwAAAgA/
JAAAAQDWMwAAAgA/JAAAAQA+GQAAAgAHLAAAAQAYSgAAAgDmGAAAAQAYSgAAAQAUMgAAAQA+GQAA
AQDTGAAAAQDTGAAAAgAvLAAAAQAeGQAAAQAeGQAAAgAvLAAAAQDOIQAAAQAeSAAAAQDOIQAAAQDO
IQAAAQA+GQAAAQA+GQAAAQA+GQAAAQA+GQAAAgDDQQAAAQDOIQAAAQDOIQAAAQAJEAAAAgCUQgAA
AQAJEAAAAQBNOwAAAgAJEAAAAwCUQgAAAQBNOwAAAgAJEAAAAQCGNwAAAQBNOwAAAgCGNwAAAQA+
GQAAAQA+GQAAAgC4PwAAAQA+GQAAAgC4PwAAAwD7MQAABADEEwAAAQAYSgAAAQDOIQAAAQDOIQAA
AQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQCWOgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDO
IQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDqMgAAAQArDwAAAQDOIQAAAQDEEwAA
AQA+GQAAAQDoJQAAAQA2GwAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDT
GAAAAQDTGAAAAgAvLAAAAQAeGQAAAQAeGQAAAgAvLAAAAQAUMgAAAgDzRAAAAQDJFgAAAQDJFgAA
AgBeMQAAAQAJEAAAAgABQQAAAwCUQgAAAQCkJAAAAQDOIQAAAQAJEAAAAgABQQAAAwCUQgAAAQDO
IQAAAQAJEAAAAgCxRQAAAwCUQgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQAJEAAA
AgCxRQAAAwCUQgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQCkJAAAAgAJEAAAAwABQQAABACU
QgAAAQAJEAAAAQCkJAAAAQCkJAAAAQCkJAAAAgAJEAAAAwABQQAABACUQgAAAQAcBQAAAQBkDwAA
AQAcBQAAAgBvDwAAAQAcBQAAAQAJEAAAAQAJEAAAAQA7EQAAAQA7EQAAAQA7EQAAAQAcBQAAAQCa
QgAAAQDNJwAAAQCxRQAAAgDZFAAAAQA+GQAAAQA+GQAAAgDFIQAAAQDOIQAAAQBXGAAAAQBJLwAA
AQAYSgAAAQDOIQAAAQDpPwAAAgDEEwAAAQDVPgAAAgDJFgAAAQDVPgAAAgDJFgAAAwBAKAAABADp
PwAAAQBYQQAAAQDTGAAAAQDOIQAAAQDOIQAAAQA+GQAAAQBXGAAAAQAHLAAAAQDTGAAAAQA7KwAA
AQDOIQAAAQCxRQAAAQA+GQAAAgCNHQAAAQA+GQAAAQAYSgAAAQClRQAAAQDFDwAAAQDFDwAAAgDB
RgAAAwBfNQAAAQAYSgAAAgC5PgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQCuFgAAAgDEFAAA
AQCuFgAAAQAfQgAAAQCCHgAAAQDTGAAAAgCoEwAAAwCFRAAAAQDTGAAAAgCoEwAAAQDTGAAAAQDT
GAAAAgAsGQAAAQDEFAAAAgAsGQAAAQDEFAAAAgAsGQAAAwCoEwAAAQDEFAAAAgAsGQAAAwCoEwAA
BACFRAAAAQAYSgAAAQAeGQAAAQDTGAAAAQAYSgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDO
IQAAAQDOIQAAAQCCHgAAAQAYSgAAAQA+GQAAAQA+GQAAAQCCHgAAAgChQwAAAwDZFAAAAQCCHgAA
AgAULwAAAwDZFAAABAAnRwAABQBbEAAAAQCCHgAAAQCCHgAAAgAHLAAAAwAEMAAABAD1LwAAAQCC
HgAAAgAHLAAAAwBbEAAABAAEMAAABQD1LwAAAQAYSgAAAQDTGAAAAQAYSgAAAQAKGAAAAgCCHgAA
AQAKGAAAAgCCHgAAAQAKGAAAAgCCHgAAAwAEMAAAAQAKGAAAAgCCHgAAAQDZFAAAAQCOJQAAAQCO
JQAAAQDkHAAAAgAILwAAAwAIIwAABAB5DwAAAQAYSgAAAQDAKgAAAgAYSgAAAQDAKgAAAgAYSgAA
AQAXKwAAAgAYSgAAAQAHLAAAAgBzIQAAAQAYSgAAAgA+GQAAAQDTGAAAAQAYSgAAAgA+GQAAAQAH
LAAAAQAHLAAAAQAoFQAAAQAHLAAAAQAHLAAAAQBXGAAAAgAoFQAAAQBXGAAAAQAHLAAAAQAHLAAA
AQBUKQAAAgAxGAAAAQAoFQAAAQAHLAAAAQAHLAAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQDO
IQAAAQA+GQAAAQAHLAAAAQDOIQAAAQDOIQAAAQABQQAAAgCYLgAAAQDOIQAAAQBqNAAAAgABQQAA
AwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQAYSgAAAgCcDwAAAQDkHAAAAgAILwAAAwAIIwAABAB5
DwAAAQArOQAAAgAfOQAAAwDXQAAAAQArOQAAAgAfOQAAAwB3SAAABAAfQgAAAQDOIQAAAQDOIQAA
AQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQAYSgAAAQA9AgAAAgAJEAAAAQBFKwAAAQBFKwAAAgCs
IwAAAQDOIQAAAQB6EAAAAQAULwAAAgABQQAAAwCUQgAAAQAULwAAAgABQQAAAwCUQgAAAQAULwAA
AgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQDbRQAAAQA+
GQAAAQA+GQAAAQDOIQAAAQA+GQAAAgDDQQAAAQA+GQAAAgD/EgAAAQA+GQAAAQCmKwAAAQCmKwAA
AgCsIwAAAQAfQgAAAQA7KgAAAQDOIQAAAQDOIQAAAQDOIQAAAQDOIQAAAQAYSgAAAQBzIQAAAQAY
SgAAAgArDwAAAQAYSgAAAQBqNAAAAgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQA7KgAA
AQA7KgAAAgCDNgAAAQAyRAAAAQAyRAAAAgABQQAAAwCUQgAAAQA7KgAAAQDBRgAAAQBWRAAAAQBW
RAAAAgABQQAAAwDNJwAAAQB+RwAAAQB+RwAAAgCxRQAAAwCUQgAAAQDJJAAAAQC8JgAAAgClJgAA
AQBqNAAAAgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwDNJwAAAQDOIQAAAQA7KgAAAQBUJgAAAQC8
JgAAAgClJgAAAQC8JgAAAgClJgAAAQC8JgAAAgClJgAAAQDJJAAAAQCCOAAAAQAGEgAAAgB8QAAA
AwAjJwAABADEKAAAAQAGEgAAAgB8QAAAAwAjJwAABADEKAAAAQB/KQAAAQBNFAAAAgDNJwAAAQDF
HQAAAQDNJwAAAQBNFAAAAQAoMwAAAQBqNAAAAQBqNAAAAgCxRQAAAwCUQgAAAQBqNAAAAQBqNAAA
AgCxRQAAAwCUQgAAAQBqNAAAAQBqNAAAAgABQQAAAwCUQgAAAQAyRAAAAQAHPAAAAQAHPAAAAQAy
RAAAAQCsIwAAAQDOIQAAAQDOIQAAAQDOIQAAAQDXKAAAAgABQQAAAwDNJwAAAQAtEAAAAgCUQgAA
AQAgPwAAAQBWRAAAAgABQQAAAwDNJwAAAQCmKwAAAQCmKwAAAgAENgAAAQCmKwAAAgAENgAAAwCs
IwAAAQDOIQAAAQDOIQAAAQBqNAAAAgABQQAAAwDNJwAAAQAvFAAAAQAYSgAAAgAjFAIAAwArQQIA
BACWNAAAAQDOIQAAAQABQQAAAgCYLgAAAQDOIQAAAQBqNAAAAgABQQAAAwCUQgAAAQBqNAAAAgAB
QQAAAwCUQgAABABAKAAABQDwHgAAAQBqNAAAAgABQQAAAwCUQgAABABAKAAABQDwHgAAAQDOIQAA
AQBqNAAAAgABQQAAAwCUQgAAAQAHLAAAAQAHLAAAAgCsIwAAAQDOIQAAAQAWNgAAAQBqNAAAAQAR
NAAAAgABQQAAAwDNJwAAAQARNAAAAgABQQAAAwDNJwAAAQDOIQAAAQBFKwAAAQBFKwAAAgB6JAAA
AQBFKwAAAgAWNgAAAwCsIwAAAQDOIQAAAQCUQgAAAQDOIQAAAQABQQAAAgCYLgAAAQDOIQAAAQBq
NAAAAgABQQAAAwCUQgAAAQDOIQAAAQBqNAAAAgABQQAAAwCUQgAABABAKAAABQDwHgAAAQBqNAAA
AgABQQAAAwCUQgAAAQDOIQAAAQD2QgAAAgDNJwAAAwBNFAAAAQDNJwAAAgBNFAAAAQAyRAAAAgDN
JwAAAQB+RwAAAgABQQAAAwDNJwAAAQBWRAAAAgABQQAAAwBhLgAAAQCAQgAAAQCAQgAAAQCAQgAA
AQBWRAAAAgABQQAAAwDNJwAAAQBqNAAAAgABQQAAAwCUQgAAAQDOIQAAAQBqNAAAAQBqNAAAAgAB
QQAAAwCUQgAAAQBUEAAAAgDOIQAAAQDOIQAAAQDOIQAAAQBqNAAAAQBqNAAAAgABQQAAAwCUQgAA
AQDOIQAAAQBqNAAAAQBqNAAAAgABQQAAAwCUQgAAAQDOIQAAAQBqNAAAAQBqNAAAAgABQQAAAwCU
QgAAAQDJMwAAAgBKMgAAAQDOIQAAAQDpPwAAAgDEEwAAAQDTGAAAAQDTGAAAAgBAKAAAAwDpPwAA
AQBYQQAAAQDpPwAAAgDEEwAAAQDWMwAAAgA/JAAAAQDWMwAAAgA/JAAAAwBAKAAABADpPwAAAQBY
QQAAAQDpRQAAAgA+SgAAAQDTGAAAAgAYSgAAAQDTGAAAAgAsGQAAAwCoEwAAAQDTGAAAAgAsGQAA
AQDEFAAAAgAsGQAAAwCoEwAAAQDEFAAAAgAYSgAAAQBUKQAAAgA5EgAAAQBdEwAAAgAYSgAAAQAY
SgAAAQDOIQAAAQDOIQAAAQDOIQAAAQAfQgAAAQBtJQAAAQBMJQAAAQBLOQAAAQDAKgAAAQDOIQAA
AQBqNAAAAgABQQAAAwCUQgAAAQABQQAAAgCYLgAAAQDOIQAAAQBqNAAAAgABQQAAAwCUQgAAAQAp
GAAAAgACQwAAAwDNJwAAAQBqNAAAAgABQQAAAwCUQgAAAQBqNAAAAgABQQAAAwCUQgAAAQDOIQAA
AQABQQAAAgCYLgAAAQDOIQAAAQDpPwAAAgDEEwAAAQAtEAAAAgABQQAAAwDNJwAAAQAtEAAAAgAB
QQAAAwDNJwAABABAKAAABQDpPwAAAQBYQQAAAQB2JgAAAgCNPAAAAwCjOAAABADDJwAAAQBoFQAA
AQBrOAAAAgD5OwAAAQCqFQAAAQCqFQAAAQCmNwMASQADAE0ABwBJAAcATQAIAEkACABNABcAWAAY
AFgAIABUACcAsQAoAHwAKwCoACwAqAAtAKgALwBNADYAwQA2AE0AOQDcADoA4AA8AOwAQwBUAFQA
WAFVAFgBVwBYAWQAyQBnAI0ACQAbNwEAEQAbNwYAGQAbNwoAKQAbNxAAMQAbNxAAOQAbNxAAQQAb
NxAASQAbNxAAUQAbNxAAWQAbNxAAYQAbNxAAMQEbNxAAWQEbNwYAeQEbNxAAiQAyJAYAmQCxHQYA
MQEbNwYAqQEbNwYAuQEbNwYA2QEbNxUA6QEbNwYAaQAbNxwAaQAbNwYAaQAbNxAAaQAbNyQAiQAb
NwYAAQIiPzYAgQAbNxAAAQIiPz0AqQAbN0MAsQAbNwYA0QD4FEsAGQLbOlIA0QBnN1gAoQAbN2EA
IQKOKG4AkQCOKG4AIQJ6KH4AIQJ5JocAKQIbNxAAuQAbN4wAwQAaEaMAKQIbNwYAMQIbNxAACQEb
N7EAQQIfRrcA0QAbNwYAWQIbNxAAYQIbNxAA2QAbN8YA0QBbRgYASQJoG80AaQIbNwYAaQLuOmEA
0QBERocA4QAbNwYAcQK2OQsBcQLOOAsBAQEbNwYAeQIbNxUBAQL8JiUBAQJYPSkBAQJ3JS4BEQEb
NwYAiQA5JUEBAQE9EUUBSQJpJEoBEQFlE1gBEQEHJwEAkQLQF18BAQE2RmgBAQFKQiUBAQHkNn0B
GQEnQs0AeQJdJoMBGQFwRIgBoQLHJpgBIQGzIZ0BIQG8IZ0BKQEbNxAAKQH8JqkBqQLTGa0BIQGd
KbMBIQGHKbMBsQIbNxAAIQH4LbMBsQIbN7EAuQIbNwYAwQAxH8sBwQC2JgYAIQEAReABwQDdKIgB
wQD8JqkBwQDbL6kBIQGaL+YBOQH4LfIBAQJ3JQMCAQIMIi4BOQG+NzACwQKJHjcCyQI7G0kCwQJl
LloCoQINGZgBAQIeSn8CwQLDPpwCwQLlGaECwQKIOqkCcQLDPpwCcQIsSLkCqQLKOcACoQJsPcYC
AQIcR8sCMQIbN7EAAQIFKIMBoQLHGJgBoQI7G9ECAQIxStcCAQKCG9oCSQJAR+YCAQI4FPoCAQJp
JAADEQEbNxAAEQFiPQUDAQIcRwsD6QIbNwYACQEbNxAA8QLRJBID8QJWJRkD8QLQAyED8QLbOicD
+QIpES0D+QIrHTMDyQHuMTkDAQMbFiUBCQN0Lk0DCQNMRU0DIQEYKFMDCQN0LlMDCQNMRVMDIQEb
N1kDIQGFMiUBIQEOKCUBIQELRiUBIQGKNyUBIQEcISUBIQFxEyUBEQMbNxAAAQIiP2wDIQFDGX8D
IQECGq0BOQEbN4YDIQHPL48DIQH2Ga0BiQBeG80AoQJXEpwCoQKuQpgBqQK/PogBqQKWGq0BqQLB
EK0BqQLlGq0BqQLVEK0BqQKsEK0BaQEbNxAAcQEbN8wDwQAnISUBcQEbNwYAwQA7Ie8DOQGtN/QD
cQE2RocAIQEbN8YAwQDkKAUEIQFQGakBIQGQEKkBSQKxMSsEwQCYHQYAQQFkGEEBGQMqJEEEwQAf
H4gBIQMbNxAAyQEWHUwEAQKCG1IEgQC9FkEBAQI5P4UEKQN9NqQEAQI5P6sEKQMmQUEEiQEbNwYA
AQEbNwEAiQE9EccEAQEIQ80EAQEVLNQEiQGOMgYAAQEeLOEE8QI7ByEDwQDoLxoFiQFnRjEFiQEV
LDYFwQB9JxoFwQL2HpMFuQIbNxAA0QBXN1gAoQK3GOEFwQIHIuwFwQJAR/IFQQEbN/kFAQI5PxEG
cQEbN2EAwQAbNwYAwQD3EIgBwQDYQ4gBCQNMRS0GAQIiP9EC+QE5JUEBAQIiP1EGAQKeNkEBAQJp
JF0GWQIbNwYAoQEbNwYASQPbOmEAsQHuPS4HUQNJQQEAUQOCOTQHWQMVLDoHYQNfIc0AIQE5JUEH
AQIiP0YHYQNpIU4HAQJlJF0GcQK2OWoHwQIDETcCsQEbNwYAkQLnRnEHwQEbN3cH4QEbNwYAEQMb
NwYAcQMbNxAACAAEAOMHCAAIAOgHCAAMAO0HCAA0APIHCABMAO0HCAAsAfcHCABEAfwHCABIAQEI
CABMAeMHCABUAfwHCABYAQYICABcAQsICABgARAICABkARUICABsAfwHCABwAQEICAB0ARoICAB4
AR8ICAB8ASQICACAASkICACEAS4ICACIATMICACMATgICACQAT0ICACUAUIICACYAUcICACcAUwI
CACgAVEICACoAQEICACsAVYICACwAQYICAC0Ae0HCAC4AVsICAC8AWAICADAAWUICADEAWoICADI
AW8ICADMAXQICADQAXkICADUAX4ICADYAYMICADcAYgICADgAY0ICADkAZIICADoAZIICADsAZcI
CADwAZcICAD0AZIICAD4AZwICAD8AaEICAAAAqEICAAEAqYICAAIAu0HCAAMAu0HCAAQAqsICAAU
AqsICAAYArAICAAcArAICAAgArUICAAkArUICAAoAroICAAsAroICAAwAr8ICAA0Ar8ICAA4AsQI
CAA8AsQICABAAr8ICABEAr8ICABIAskICABMAskICABQAs4ICABUAs4ICABYAtMICABcAtMICABg
AtgICABkAtgICABoAt0ICABsAt0ICAB4AvwHCAB8AgEICACAAuMHCACEAuIICACIAucICACMAuwI
CACQAlYICACUAvEICACYAgYICACcAgsICACgAvIHCACkAhAICACoArUICACsAvYICACwAvsICAC0
AgAJCAC4Au0HCAC8AgUJCADAAgoJCADEAg8JCADIAhUICAB0A/wHCAB4AwEICACAA/wHCACEAwEI
CACIA+MHCACMA+IICACQA+cICACUA+wICAC0A/wHCAC4AwEICADAA34ICACsBAsICACwBAEICAC0
BBQJCAC4BPwHCAC8BAYICADABAEICADEBOcICADIBAYICADMBPwHCADQBAEICADUBO0HCADYBBkJ
CADcBB4JCADgBKEICADkBCMJAgAABSgJCAAEBfwHCAAIBQEICAAMBeMHCAAQBVsICAAUBQYICAAY
BSoJCAAcBeIICAAgBQAJCAAkBY0ICAAoBS8JCAAsBQAJCAAwBY0ICAA0BS8JCAA4BewICAA8BTQJ
CABABTkJCABEBT4JCABMBfwHCABQBQEICABUBeMHCABwBfwHCAB0BQEICAB4BeMHCAB8BX4ICADc
BYgICADgBUMJCADkBaEICADoBQ8JCADsBe0HCADwBQUJCAD0BQoJCAD4BWoICABEBvwHCABIBgEI
CABMBuMHCABQBuIICABUBucICABYBuwICABcBlYICABgBvEICABkBgYICABoBgsICABsBvIHCABw
BhAICAB0BrUICAC4BvwHCAC8BgEICADABuMHCADEBuIICADIBucICADMBuwICAAIBwAJCACIB40I
CACMBy8JCQCwB0gJCQC4BxQJCAAcCPwHCAAgCAEICAAkCOMHBQAsCCgJBQAwCE0JBQA0CE8JBQA4
CFEJBQA8CFMJBQBACFUJCABICPwHCABMCAEICABQCOMHCABUCOIICABYCOcICABcCOwICABgCFYI
BQBoCE0JBQBsCE8JBQBwCFEJCAB4CAEICAB8COMHCACECPwHCACICAEICACMCOMHCAAECfwHCAAI
CQEILgALAFERLgATAFoRLgAbAHkRLgAjAIIRLgArAKsRLgAzAKsRLgA7AKsRLgBDAIIRLgBLALER
LgBTAKsRLgBbAMgRQwNjAH8UgwRrAAEIwwZzAKMUAwuTAAEIIwubAAEIYwurAAEIwwtrAAEIAwxr
AAEIQwxrAAEIqQ5jALUUQQ9jACkSgQ9jAEgSARBjAHESYRBjAJYSoRBjALoS4RBjAOESIRFjAA0T
YRFjAC8ToRFjAFUT4RFjAHgTIRJjAJ8TQRJjAMgToRJjAPATIRNjACEUYRNjAE8UCRijAHkRKRij
AHkRwBpjABISoT6rAAEIAGqLAAEIIGqLAAEIQGqLAAEIAQAMAAAAbQABABAAAABuAAEAKAAAAG8A
AQBMAAAAcAABAHQAAABxAAEAeAAAAHIAAQAABAAAcwArAGcAeQCWAKsAwQDUANgA3wDkAOsA8gD5
ABEBHQE0AXQBjAGTAaIBvQHCAcYB0wH8AQgCEAIYAiACKAI+AlUCagJ5AoUCkAKxAuAC8wI/A0QD
YwNyA5sDogOwA70D1QP4Aw0EGAQeBCMEMwQ7BEYEXARgBGkEiwSyBNkE5wT1BAEFBgUOBR8FLAU7
BUMFTwVYBWAFZgVyBZgFngWlBcgF2gXlBQQGGQYoBjMGQQZHBlgGYgZxBngGfgaEBp0GpwatBrMG
uAbHBswG0wbbBuQG7Ab1BgwHEwcbByAHJgdTB38HiweTB5sHpAe/BwMAAQAHAAYACAAKAAkADgAK
ABIACwAUAAwAGQANABoAGQAdABoAIQAdACMAHgAkAB8AKwAgACwAJQAvACcAMAAoAE8AKgBVACsA
VgAsAFgALQBdAC8AYQAwAGUAMwBnADYAbQA7AH0APAB+AD4AfwA/AIAAQACDAEEAhQBCAIwAQwCQ
AEQAkQBFAJMASACYAEsAmwBOAKIATwCkAFAArABRALIAUwC5AFQAvABVAL0AVgC+AFcAvwBZAMAA
WgDCAGUAwwBmAMoAZwDNAGgAzgBpANMAAACJNKMQAAAdI6gQAAAwI6gQAAAXPKwQAAAILawQAAAI
LawQAAAdI6gQAAAwI6gQAAAXPKwQAAAILawQAAAdI6gQAAAwI6gQAAAXPKwQAAA2I6gQAAAaO7AQ
AAAGO7AQAABvRqMQAAAxGbYQAAD1JKwQAAAxGbYQAAD1JKwQAAABH7oQAAAlEr4QAABSQL4QAACU
OawQAAAxGbYQAABUMcIQAAD1JKwQAABbI74QAAD8I74QAADyHccQAAASHscQAABbI74QAAD8I74Q
AADYKc0QAAD8OKwQAAAmFLYQAAD2LNMQAADPR9gQAADrAd0QAABhP6wQAACdP6wQAAD2LNMQAAAP
SLYQAADUO6wQAAC3QeMQAABDFucQAABzEKwQAACCEqwQAACqRKwQAACiIesQAABGO6gQAAB6Rb4Q
AAD6QL4QAAD4OagQAADvRagQAADjSKwQAABQLKgQAACjLqgQAADgPawQAAAFAqwQAAAiAqwQAAC3
Gr4QAACgGccQAAAxGbYQAAAlJL4QAACJIr4QAAB+EL4QAACWE+8QAAA1M+8QAAAhD6MQAAAfJKgQ
AADYJ+sQAABOLqgQAAApIqgQAAAXQrYQAACmSKwQAABCGKwQAAD2LNMQAADsJfUQAACLGccQAABk
OqgQAACIOqgQAACqRKwQAAAJBfsQAAAJBfsQAAADEKMQAAAJBfsQAABzGscQAAAQG8cQAAC8GccQ
AACCFf8QAAAJBfsQAABZGscQAAC8GccQAAD8GscQAADGJ6gQAABnJ6gQAABURagQAABYQqgQAADK
GLYQAABvRqMQAAA/LwURAABSGAsRAAASShERAABoQqgQAADaEr4QAAAdE6wQAABvRqMQAAAmFLYQ
AAAMP6wQAADGNawQAADYIawQAAD6IawQAADrQbYQAAAxGbYQAAAlJKgQAACOQr4QAACYRRcRAAD2
LNMQAADPR9gQAAChI6gQAACqJawQAADrAd0QAAAdFR4RAAAdFR4RAADPKiQRAACJIr4QAAAlJL4Q
AAB+EL4QAADHQL4QAACgQL4QAADGNawQAAD7EKwQAADhKKwQAADcQ6wQAADGJ74QAAAPML4QAAAj
H6wQAAAmFLYQAABfSawQAAB1F6gQAADGJ74QAADQRbYQAACiEawQAADrAd0QAAC7NKgQAADULb4Q
AADGQ74QAACiEawQAADrQ6wQAAC7NKgQAADULb4QAAC4RioRAADrQ6wQAABcR6wQAACiEawQAAC7
NKgQAADGQ74QAADULb4QAAD+Q6gQAAB3QqgQAACxEawQAADGNawQAAA7OawQAAAmFLYQAAD7EKwQ
AADhKKwQAAAjH6wQAADGJ74QAAAPML4QAACvJ6gQAADSD6MQAACLJ6gQAADORKMQAAB1F6gQAAB1
LTARAADGNawQAAB1F6gQAAD7EKwQAADhKKwQAAAjH6wQAADGJ74QAAAPML4QAAAFPqgQAAClOqgQ
AADrQ6wQAADIIb4QAADIIb4QAADIIb4QAADIIb4QAAB1NDURAAA2HTsRAAA0QUERAAASShERAACo
SRERAABVE0cRAAA6GbYQAADHQL4QAACgQL4QAABRIr4QAAAjJawQAACvJ6gQAAAUQqMQAAArQk0R
AAD7EKwQAAAjH6wQAADhKKwQAADGJ74QAAAPML4QAAAPML4QAADGJ74QAAAjH6wQAADhKKwQAAD7
EKwQAADcQ6wQAgAHAAMAAgAKAAUAAgALAAcAAgAMAAkAAgANAAsAAgAcAA0AAgAdAA8AAgAeABEA
AgAfABMAAgAkABUAAgAlABcAAgAmABkAAgAnABsAAgApAB0AAQAqAB0AAgArAB8AAgAtACEAAgAu
ACMAAQAvACMAAgA1ACUAAgA2ACcAAQA3ACcAAgA5ACkAAgA6ACsAAQA7ACsAAgA8AC0AAgA9AC8A
AgA+ADEAAgBAADMAAgBCADUAAgBDADcAAgBEADkAAQBFADkAAgB7ADsAAQB8ADsAAgB9AD0AAQB+
AD0AAgB/AD8AAQCAAD8AAgCBAEEAAQCCAEEAAgCFAEMAAQCGAEMAAgCHAEUAAQCIAEUAAgCWAEcA
AQCXAEcAAgCbAEkAAQCcAEkAAgCdAEsAAQCeAEsAAgCfAE0AAQCgAE0AAgChAE8AAQCiAE8AAgCj
AFEAAQCkAFEAAgClAFMAAQCmAFMAAgCnAFUAAQCoAFUAAgC6AFcAAQC7AFcAAgC+AFkAAQC/AFkA
AgDAAFsAAQDBAFsAAgDHAF0AAQDIAF0AAgDJAF8AAQDKAF8AAgDXAGEAAgDYAGMAAQDZAGMAAgDa
AGUAAQDbAGUAAgDcAGcAAQDdAGcAAgDeAGkAAQDfAGkAAgDgAGsAAQDhAGsAAgDiAG0AAQDjAG0A
AgDkAG8AAQDlAG8AAgDmAHEAAgDnAHMAAgDpAHUAAQDqAHUAAgDrAHcAAgDsAHkAAgDvAHsAAgDw
AH0AAgDxAH8AAQDyAH8AAgDzAIEAAQD0AIEAAgD1AIMAAgD2AIUAAQD3AIUAAgD4AIcAAQD5AIcA
AgD6AIkAAQD7AIkAAgD8AIsAAQD9AIsAAgD+AI0AAgD/AI8AAQAAAY8AAgABAZEAAQACAZEAAgAD
AZMAAgAEAZUAAgAFAZcAAgAIAZkAAQAJAZkAAgAKAZsAAgALAZ0AAgAUAZ8AAQAVAZ8AAgAWAaEA
AQAXAaEAAgAYAaMAAQAZAaMAAgAaAaUAAQAbAaUAAgAcAacAAQAdAacAAgAeAakAAQAfAakAAgAo
AasAAgAsAa0AAQAtAa0AAgAwAa8AAQAxAa8AAgAyAbEAAgA2AbMAAQA3AbMAAgA4AbUAAQA5AbUA
AgA6AbcAAQA7AbcAAgA8AbkAAQA9AbkAAgA/AbsAAgBDAb0AAQBEAb0AAgBFAb8AAQBGAb8AAgBH
AcEAAQBIAcEAAgBPAcMAAgBTAcUAAgBUAccAAgBVAckAAgBsAcsAAgBtAc0AAQBuAc0AAgBwAc8A
AgBxAdEAAgByAdMAAgBzAdUAAgB0AdcAAgB1AdkAAgB/AdsAAQCAAdsAAQCBAd0AAgCCAd8AAgCL
AeEAAQCMAeEAAgCNAeMAAgCOAeUAAgCPAecAAgCQAekAAgCRAesAAgCSAe0AAgCTAe8AAgCcAfEA
AQCdAfEAAgCeAfMAAQCfAfMAAgCgAfUAAQChAfUAAgCiAfcAAgCjAfkAAQCkAfkAAgDnAfsAAgDz
Af0AAgD+Af8AAgAEAgEBAQAFAgEBAgAGAgMBAQAHAgMBAgAIAgUBAQAJAgUBAgALAgcBAQAMAgcB
AgANAgkBAQAOAgkBAgASAgsBAQATAgsBAgAUAg0BAgAVAg8BAgAWAhEBAgAXAhMBAgAYAhUBAQAZ
AhUBAgAaAhcBAgAyAhkBAQAzAhkBAgA0AhsBAgA5Ah0BAgA6Ah8BAgBHAiEBAQBIAiEBAgBOAiMB
AgBSAiUBAQBTAiUBAgBjAicBAgBkAikBAgBlAisBAgBoAi0BAgBpAi8BAgB8AjEBAgB9AjMBAgB+
AjUBAQB/AjUBAgClAjcBAgCmAjkBAgCnAjsBAgCoAj0BAgCpAj8BAgCqAkEBAgCrAkMBAgC9AkUB
AgDBAkcBAgDIAkkBAQDJAkkBAgDKAksBAgDLAk0BAQDMAk0BAgDRAk8BAgDSAlEBAgDTAlMBAgDU
AlUBAgDVAlcBAQDWAlcBAgDkAlkBAgDlAlsBAgDmAl0BAgDnAl8BAgDoAmEBAQDpAmEBAQDzAmMB
AgD3AmUBAQD4AmUBAgD7AmcBAgD9AmkBAgD+AmsBAgD/Am0BAgAAA28BAgABA3EBAQACA3EBAgAZ
A3MBAgAaA3UBAgAcA3cBAgAgA3kBAgAnA3sBAQAoA3sBAgAvA30BAgA2A38BAgA/A4EBAgBAA4MB
AQBBA4MBAgBCA4UBAgBXA4cBAgBYA4kBAgBZA4sBAgBaA40BAgBbA48BAQBcA48BAgBdA5EBAQBe
A5EBAgBfA5MBAQBgA5MBAgBkA5UBAgBlA5cBAgBmA5kBAgBsA5sBAgBxA50BAgBzA58BAgB0A6EB
AgB1A6MBAgB2A6UBAQB3A6UBAgCEA6cBAQCFA6cBAgCGA6kBAgCHA6sBAgCIA60BAgCJA68BAgCK
A7EBNgAOAx8ANgCoAyEA0QBxAcgXAgD2AfAXAgD3ARgYAgD4AWgYAgD5AWgcAgD6AXgcAgD7AXgg
AgD8AfAgAgD9ARghAgD+AZAhAgD/AaAhAgAAArAhAgABAsAhAgACAjgiAgADArAiAgAEAtgiAgAF
AgSAAAABAAAAtBpwhgAAAAAAAEEkAAAEAAAAAAAAAAAAAADRByYQAAAAAA4AAAAAAAAAAAAAANoH
9CgAAAAABAAAAAAAAAAAAAAA0QdULAAAAAAOAAAAAAAAAAAAAADaBwYJAAAAAAAAAAABAAAA/zcA
AFwAHgBdAB4AXgAnAF8AKABgACwAYQA2AGIANgBjADYAZAA2AGUANgBmADYAZwA2AGgANgBpADYA
agBCAGsASQBsAFgAbQBbAG4AWwBvAFsAcABbAHEAWwByAFsAcwBbAIcAVAEAAAAAAE9TNDAwAFJF
UF8zXzEwAFVudXNlZDEwAF9fU3RhdGljQXJyYXlJbml0VHlwZVNpemU9MTIwAF9fU3RhdGljQXJy
YXlJbml0VHlwZVNpemU9NDAANjE5NTEwMTRGQjE3QzVCRjc0RjQ1NDAxQ0E1QzZENEM3MjA1Q0Yx
MQBITUFDU0hBMQBERUNPREVfU1RPUkVEX0xFTjEAX2htYWNzaGExAFRyaXBsZURlczExMgBfX1N0
YXRpY0FycmF5SW5pdFR5cGVTaXplPTEyAENvbXB1dGVDcmMzMgBBZGxlcjMyAFVJbnQzMgAwM0I1
NjlDMzhFM0NENkI3MjAzODg5MTlENDM3MzVBOTA0MDEyQzUyAEFlczE5MgBSQzIAREVDT0RFX1NU
T1JFRF9MRU4yAE9TMgBCWmlwMgAzNzNCNDk0RjIxMEM2NTYxMzRDNTcyOEQ1NTFENEM5N0IwMTNF
QjMzAFJlc2VydmVkUGt3YXJlMTQAX19TdGF0aWNBcnJheUluaXRUeXBlU2l6ZT0xMDI0AERCN0M3
NjNDOTY3MEREMEY2RUQzNEI3NUIzNDEwQTM5RDgzNUY5NjQAQ0VOU0lHNjQARGVmbGF0ZTY0AEZv
cmNlWmlwNjQAZ2V0X1VzZVppcDY0AHNldF9Vc2VaaXA2NABWZXJzaW9uWmlwNjQAZ2V0X0xvY2Fs
SGVhZGVyUmVxdWlyZXNaaXA2NABnZXRfQ2VudHJhbEhlYWRlclJlcXVpcmVzWmlwNjQAemlwNjQA
VUludDY0AFJDNAAwMEM0MEIzRjAxM0VEQTYwMzkwRjJFODQ5QzQ1ODE4MTVBOTQxOUU0AFJlc2Vy
dmVkUEt3YXJlNABSZXNlcnZlZFBrd2FyZTE1AEE1ODZGNTZCQTUzRkFDRTMyMDE0NEFEQTQwQTE1
QTMzQjI3MTUwMjUANkJDNEVBQjBENjA0QzhENDU5OTAyMUFENjExQzVEQkE3RkY3RTMwNgBfX1N0
YXRpY0FycmF5SW5pdFR5cGVTaXplPTExNgBfX1N0YXRpY0FycmF5SW5pdFR5cGVTaXplPTE2AElu
dDE2ADYzRTlFQkY2RUVCODE0RkM2QUMyNjc3QURGNkVBOTQ0NDAzQzk2MzYAQWVzMjU2AF9fU3Rh
dGljQXJyYXlJbml0VHlwZVNpemU9NzYAUkVQXzNfNgBVbnVzZWQ3AEFlczEyOABSRVBfMTFfMTM4
ADFGREM4REI1NjdGNUFBQTcwNjhEMEQyQTYwMUNENzE2NTdDQkRGMzgAVHJpcGxlRGVzMTY4AGdl
dF9VVEY4AFVudXNlZDgARUQwMzIwMjY0NzJGRjc3QThBMTdCQTRBRkYzRkM1N0FGNEI0QkY3OQBV
bnVzZWQ5ADxNb2R1bGU+ADxQcml2YXRlSW1wbGVtZW50YXRpb25EZXRhaWxzPgA2N0MwRTc4NEYz
NjU0QjAwOEE4MUUyOTg4NTg4Q0Y0OTU2Q0NGM0RBAFdyaXRlU2hvcnRNU0IAR0MAQ09NUFJfRlVO
QwBTdHJhbmdlQ1JDAE1JTl9MT09LQUhFQUQAODlDRTBFOEVBNTkwRkQzNzI4M0Q2QkVGRDlFNjgw
NUM4QzQ3QURCRABCRVNUX1NQRUVEAEZJTklTSEVEAERFQ09ERV9TVE9SRUQAREVGTEFURV9TVE9S
RUQAREVGTEFURUQAZ2V0X1RhZ0lEAHNldF9UYWdJRABIb3N0U3lzdGVtSUQAaGVhZGVySUQAQkFT
RQBGSU5JU0hFRF9TVEFURQBDTE9TRURfU1RBVEUARklOSVNISU5HX1NUQVRFAEZMVVNISU5HX1NU
QVRFAFNFVERJQ1RfU1RBVEUASU5JVF9TVEFURQBCVVNZX1NUQVRFAEJVRlNJWkUAV1NJWkUAUEVO
RElOR19CVUZfU0laRQBIQVNIX1NJWkUAQ1JZUFRPX0JMT0NLX1NJWkUATUFYX0JMT0NLX1NJWkUA
Q1JZUFRPX0hFQURFUl9TSVpFADc5RDUyMUU2RTNFNTUxMDMwMDVFOUNDM0ZBNDNCMzE3NEZBRjA5
MEYAQjU2NEE3QTQzM0VFMURBNTBDNUUxNTJBOTlGMjVEQkMwOUJBODM1RgBEMDY4ODMyRTZCMTNB
NjIzOTE2NzA5QzFFMEUyNUFEQ0JFN0I0NTVGAEQ4RTRBQ0JDMkQ5NTdDMzM0NEEzQ0FENjlGQ0Y5
QTYwQzgwMzREQkYATE9DU0lHAEVORFNJRwBTUEFOTklOR1NJRwBDRU5ESUdJVEFMU0lHAENFTlNJ
RwBTUEFOVEVNUFNJRwBFWFRTSUcAREVCVUdHSU5HAElTX0ZJTklTSElORwBJU19GTFVTSElORwBN
SU5fTUFUQ0gATUFYX01BVENIAEdPT0RfTEVOR1RIAE5JQ0VfTEVOR1RIAEFVVEhfQ09ERV9MRU5H
VEgAUFdEX1ZFUl9MRU5HVEgAZ2V0X0FTQ0lJAFNUT1JFRF9CTE9DSwBFTkNSWVBUX0JMT0NLAFdN
QVNLAEhBU0hfTUFTSwBERUZBVUxUX01FTV9MRVZFTABFT0ZfU1lNQk9MAEROVU0AQkxOVU0ATElU
RVJBTF9OVU0AQklUTEVOX05VTQBESVNUX05VTQBERUNPREVfQ0hLU1VNAERFQ09ERV9IVUZGTUFO
AE1BWF9CSVRMRU4ATUFYX0NIQUlOAE5PX0NPTVBSRVNTSU9OAERFRkFVTFRfQ09NUFJFU1NJT04A
QkVTVF9DT01QUkVTU0lPTgBWRVJTSU9OX1NUUk9OR19FTkNSWVBUSU9OAFN5c3RlbS5JTwBMT0NI
RFIARU5ESERSAENFTkhEUgBFWFRIRFIAREVDT0RFX0hFQURFUgBERUNPREVfRFlOX0hFQURFUgBC
TF9PUkRFUgBLRVlfUk9VTkRTAFZFUlNJT05fQUVTAEFkZEV4dHJhRGF0YUFFUwBHZXRBdXRoQ29k
ZUlmQUVTAFdpblppcEFFUwBTVEFUSUNfVFJFRVMARFlOX1RSRUVTAERFQ09ERV9CTE9DS1MAQkxM
RU5TAENQTEVOUwBCZU9TAFJFUFMATWljcm9zb2Z0LlNxbFNlcnZlci5NYW5hZ2VkRFRTAERFQ09E
RV9IVUZGTUFOX0xFTkJJVFMAREVDT0RFX0hVRkZNQU5fRElTVEJJVFMATUFYX1dCSVRTAEhBU0hf
QklUUwBNVlMASVNfU0VURElDVABERUNPREVfRElDVABQUkVTRVRfRElDVABIQVNIX1NISUZUAFdp
bmRvd3NOVABERUZMQVRFX0ZBU1QAQ1BESVNUAERFQ09ERV9IVUZGTUFOX0RJU1QATUFYX0RJU1QA
QXRhcmlTVABDUERFWFQAQ1BMRVhUAHJnYklWAEdlbmVyYXRlSVYAREVGTEFURV9TTE9XAE9TWABW
RVJTSU9OX01BREVfQlkATUFYX0xBWlkAZm9yY2VaaXA2NF8AdXNlWmlwNjRfAHZhbHVlX18AaXND
bG9zZWRfAGlzRGlzcG9zZWRfAHByb2Nlc3NlZF8AY29udGVudHNFZGl0ZWRfAGNvbW1lbnRFZGl0
ZWRfAGJ5dGVzVGVzdGVkXwBlbnRyeVZhbGlkXwB3aW5kb3dFbmRfAGNvbW1hbmRfAGVuZF8AcmF3
UGFzc3dvcmRfAHBhc3N3b3JkXwB1cGRhdGVEYXRhU291cmNlXwBkYXRhU291cmNlXwB1cGRhdGVN
b2RlXwBhcmNoaXZlU3RvcmFnZV8AemlwRmlsZV8AZmlsZV8AZmlsZU5hbWVfAHRlbXBvcmFyeU5h
bWVfAGZpbGVuYW1lXwBmaXhlZERhdGVUaW1lXwBtaW5EYXRlXwBtYXhEYXRlXwBjb25maXJtRGVs
ZWdhdGVfAG92ZXJ3cml0ZV8AY3J5cHRvQ2hlY2tWYWx1ZV8AaXNOZXdBcmNoaXZlXwBhbGl2ZV8A
bWluU2l6ZV8AYnVmZmVyU2l6ZV8AbWF4U2l6ZV8AY29udGludWVSdW5uaW5nXwBpc1NvdXJjZVN0
cmluZ18AdGltZVNldHRpbmdfAGxlbmd0aF8AcHJvZ3Jlc3NJbnRlcnZhbF8AYmFzZVN0cmVhbV8A
ZmluYWxTdHJlYW1fAGJhc2VPdXRwdXRTdHJlYW1fAG91dHB1dFN0cmVhbV8AdGVtcG9yYXJ5U3Ry
ZWFtXwBzdHJlYW1fAGV4dHJhY3ROYW1lVHJhbnNmb3JtXwBuYW1lVHJhbnNmb3JtXwBjcnlwdG9U
cmFuc2Zvcm1fAG9wZXJhdGlvbl8AZXhjZXB0aW9uXwBiaXRzSW5CdWZmZXJfAGNvcHlCdWZmZXJf
AGJ1ZmZlcl8AaXNTdHJlYW1Pd25lcl8AaXNPd25lcl8AZGVmbGF0ZXJfAGZpbGVGaWx0ZXJfAG5h
bWVGaWx0ZXJfAGRpcmVjdG9yeUZpbHRlcl8AZmlsdGVyXwBjcmVhdGVFbXB0eURpcmVjdG9yaWVz
XwBlbnRyaWVzXwBoYXNNYXRjaGluZ0ZpbGVzXwB1cGRhdGVzXwBnZXRBdHRyaWJ1dGVzXwBzZXRB
dHRyaWJ1dGVzXwBpbmNsdXNpb25zXwBleGNsdXNpb25zXwByZWFkUG9zXwBldmVudHNfAHJlc3Rv
cmVEYXRlVGltZU9uRXh0cmFjdF8AcmVzdG9yZUF0dHJpYnV0ZXNPbkV4dHJhY3RfAHRhcmdldF8A
Y3JjUGF0Y2hPZmZzZXRfAHNpemVQYXRjaE9mZnNldF8AcmF3Q29tbWVudF8AbmV3Q29tbWVudF8A
Y29tbWVudF8AdXBkYXRlQ291bnRfAGVycm9yQ291bnRfAHdpbmRvd1N0YXJ0XwBzdGFydF8AaXNV
bmljb2RlVGV4dF8Ad2luZG93XwB1cGRhdGVJbmRleF8AdHJpbVByZWZpeF8Aa2V5XwB1cGRhdGVF
bnRyeUZhY3RvcnlfAGVudHJ5RmFjdG9yeV8Ac291cmNlRGlyZWN0b3J5XwBvdXRFbnRyeV8AZW50
cnlfAEFtaWdhAGV4dHJhAGdldF9EYXRhAHNldF9EYXRhAFByb2Nlc3NBRVNFeHRyYURhdGEAZ2V0
X0V4dHJhRGF0YQBzZXRfRXh0cmFEYXRhAFppcEV4dHJhRGF0YQBQcm9jZXNzRXh0cmFEYXRhAGV4
dHJhRGF0YQBBZGREYXRhAElUYWdnZWREYXRhAE5UVGFnZ2VkRGF0YQBSYXdUYWdnZWREYXRhAHRh
Z2dlZERhdGEAZmllbGREYXRhAG1heGltdW1WYXJpYWJsZURhdGEARW50cnlQYXRjaERhdGEAcGF0
Y2hEYXRhAERlc2NyaXB0b3JEYXRhAEdldERhdGEAU2V0RGF0YQB0ZXN0RGF0YQBnZXRfUmF3RGF0
YQByYXdEYXRhAEV4dGVuZGVkVW5peERhdGEAa2V5RGF0YQBHZXRFbnRyeURhdGEAX2RhdGEASUNT
aGFycENvZGUuU2hhcnBaaXBMaWIAbXNjb3JsaWIARHluYW1pYwBQa3ppcENsYXNzaWMAZ2V0X0Ny
YwBzZXRfQ3JjAG9sZENyYwB1cGRhdGVDcmMAZ2xvYmFsQ3JjAGdldF9IYXNDcmMAdGVzdENyYwBj
cmMAQWNvcm5SaXNjAFRvRmlsZVRpbWVVdGMAQ3JlYXRlVGltZVV0YwBnZXRfTGFzdFdyaXRlVGlt
ZVV0YwBnZXRfQ3JlYXRpb25UaW1lVXRjAGdldF9MYXN0QWNjZXNzVGltZVV0YwBJbml0aWFsUmVh
ZABnZXRfQ2FuUmVhZABPcGVuUmVhZABCZWdpblJlYWQAQm9keVJlYWQAbG9va2FoZWFkAGdldF9D
dXJyZW50VGhyZWFkAHRvQWRkAElzWmlwNjRGb3JjZWQASXNJbmNsdWRlZABJc0V4Y2x1ZGVkAENy
Y1NlZWQAc2VlZABQa3ppcENsYXNzaWNNYW5hZ2VkAFJpam5kYWVsTWFuYWdlZABQYXRjaGVkAGdl
dF9Jc0ZpbmlzaGVkAGdldF9Jc0ZsdXNoZWQASGVhZGVyTWFza2VkAHdpbmRvd0ZpbGxlZABGaWx0
ZXJlZABPbktleXNSZXF1aXJlZABEZWZsYXRlU3RvcmVkAENvcHlTdG9yZWQAc3RvcmVkAF9maW5h
bGlzZWQAaXNDbG9zZWQAZ2V0X1Byb2Nlc3NlZABwcm9jZXNzZWQAdXBkYXRlZABEZWZsYXRlZABS
QzJDb3JyZWN0ZWQASXNQYXRoUm9vdGVkAFNwbGl0UXVvdGVkAGdldF9Jc0NyeXB0ZWQAc2V0X0lz
Q3J5cHRlZABFbmNyeXB0ZWQASXNDb21wcmVzc2lvbk1ldGhvZFN1cHBvcnRlZABSZWFkaW5nTm90
U3VwcG9ydGVkAGdldF9CeXRlc1Rlc3RlZABTZXRCeXRlc1Rlc3RlZABJbnZhbGlkRW50cnlDaGFy
c1JlbGF4ZWQAcmVsYXhlZABGaXhlZABOYW1lSXNWYWxpZABnZXRfRW50cnlWYWxpZABpbnB1dEVu
ZAB3aW5kb3dFbmQAX2Flc1JuZABnZXRfQ29tbWFuZABVcGRhdGVDb21tYW5kAGNvbW1hbmQAQXBw
ZW5kAEZpbmQAZ2V0X1NlY29uZABnZXRfQ29tcHJlc3Npb25NZXRob2QAc2V0X0NvbXByZXNzaW9u
TWV0aG9kAGNvbXByZXNzaW9uTWV0aG9kAGN1ck1ldGhvZABtZXRob2QASW5pdGlhbGl6ZUFFU1Bh
c3N3b3JkAGdldF9QYXNzd29yZABzZXRfUGFzc3dvcmQAQ2hlY2tDbGFzc2ljUGFzc3dvcmQASW5p
dGlhbGl6ZVBhc3N3b3JkAHJhd1Bhc3N3b3JkAHBhc3N3b3JkAFJlcGxhY2UAR2V0RnJlZVNwYWNl
AGRpc3RhbmNlAGRlZmF1bHRJbnN0YW5jZQBfY291bnRlck5vbmNlAElEeW5hbWljRGF0YVNvdXJj
ZQBJU3RhdGljRGF0YVNvdXJjZQBEeW5hbWljRGlza0RhdGFTb3VyY2UAU3RhdGljRGlza0RhdGFT
b3VyY2UAZGF0YVNvdXJjZQBHZXRTb3VyY2UAc291cmNlAEFFU0F1dGhDb2RlAEdldEF1dGhDb2Rl
AHNldF9Nb2RlAEZpbGVNb2RlAGdldF9VcGRhdGVNb2RlAEZpbGVVcGRhdGVNb2RlAHVwZGF0ZU1v
ZGUAX3dyaXRlTW9kZQBDcnlwdG9TdHJlYW1Nb2RlAENpcGhlck1vZGUARGNvZGUATGNvZGUARGVj
b2RlAG1vZGUAZ2V0X0luY2x1ZGUAc2V0X0luY2x1ZGUAQnVpbGRUcmVlAFdyaXRlVHJlZQBsaXRl
cmFsVHJlZQBibFRyZWUASW5mbGF0ZXJIdWZmbWFuVHJlZQBCdWlsZExpdExlblRyZWUAZGVmTGl0
TGVuVHJlZQBsaXRsZW5UcmVlAEJ1aWxkRGlzdFRyZWUAZGVmRGlzdFRyZWUAZGlzdFRyZWUAdHJl
ZQBTYWZlAGdldF9PRU1Db2RlUGFnZQBnZXRfRGVmYXVsdENvZGVQYWdlAHNldF9EZWZhdWx0Q29k
ZVBhZ2UAZGVmYXVsdENvZGVQYWdlAElBcmNoaXZlU3RvcmFnZQBCYXNlQXJjaGl2ZVN0b3JhZ2UA
RGlza0FyY2hpdmVTdG9yYWdlAE1lbW9yeUFyY2hpdmVTdG9yYWdlAGFyY2hpdmVTdG9yYWdlAGdl
dF9NZXNzYWdlAG1lc3NhZ2UARW5kSW52b2tlAEJlZ2luSW52b2tlAGNyYzMyVGFibGUAQ3JjVGFi
bGUASUNsb25lYWJsZQBWYXJpYWJsZQBnZXRfQXZhaWxhYmxlAHNldF9BdmFpbGFibGUATWFrZUJ5
dGVzQXZhaWxhYmxlAEdldEF2YWlsYWJsZQBSZWFkaW5nTm90QXZhaWxhYmxlAE1ha2VUZXh0QXZh
aWxhYmxlAHByZXZBdmFpbGFibGUAYXZhaWxhYmxlAElFbnVtZXJhYmxlAElEaXNwb3NhYmxlAEhh
c2h0YWJsZQBSdW50aW1lRmllbGRIYW5kbGUAUnVudGltZVR5cGVIYW5kbGUAR2V0VHlwZUZyb21I
YW5kbGUAZ2V0X0ZpbGUAT25Db21wbGV0ZWRGaWxlAE9uQ29tcGxldGVGaWxlAHdvcmtGaWxlAFRy
YW5zZm9ybUZpbGUAWmlwRmlsZQB6aXBGaWxlAG1ha2VUZW1wRmlsZQBnZXRfSXNGaWxlAE9uUHJv
Y2Vzc0ZpbGUAZmlsZQBDb21waWxlAGdldF9OYW1lAE1ha2VWYWxpZE5hbWUASXNWYWxpZE5hbWUA
Z2V0X0ZpbGVOYW1lAEdldFRyYW5zZm9ybWVkRmlsZU5hbWUAemlwRmlsZU5hbWUAR2V0VGVtcEZp
bGVOYW1lAEdldEZpbGVOYW1lAGZpbGVOYW1lAENsZWFuTmFtZQB0YXJnZXROYW1lAEdldFRyYW5z
Zm9ybWVkRGlyZWN0b3J5TmFtZQBHZXREaXJlY3RvcnlOYW1lAGRpcmVjdG9yeU5hbWUAZW50cnlO
YW1lAGdldF9GaWxlbmFtZQBGcm9tRmlsZVRpbWUAVG9GaWxlVGltZQBnZXRfRGF0ZVRpbWUAc2V0
X0RhdGVUaW1lAGdldF9GaXhlZERhdGVUaW1lAHNldF9GaXhlZERhdGVUaW1lAHJlc3RvcmVEYXRl
VGltZQBnZXRfQ3JlYXRlVGltZQBzZXRfQ3JlYXRlVGltZQBfY3JlYXRlVGltZQBnZXRfTGFzdFdy
aXRlVGltZQBTZXRMYXN0V3JpdGVUaW1lAFRvTG9jYWxUaW1lAFRvVW5pdmVyc2FsVGltZQBnZXRf
TW9kaWZpY2F0aW9uVGltZQBzZXRfTW9kaWZpY2F0aW9uVGltZQBnZXRfTGFzdE1vZGlmaWNhdGlv
blRpbWUAc2V0X0xhc3RNb2RpZmljYXRpb25UaW1lAF9sYXN0TW9kaWZpY2F0aW9uVGltZQBfbW9k
aWZpY2F0aW9uVGltZQBnZXRfQ3JlYXRpb25UaW1lAGdldF9Eb3NUaW1lAHNldF9Eb3NUaW1lAGRv
c1RpbWUAZ2V0X0FjY2Vzc1RpbWUAc2V0X0FjY2Vzc1RpbWUAZ2V0X0xhc3RBY2Nlc3NUaW1lAHNl
dF9MYXN0QWNjZXNzVGltZQBfbGFzdEFjY2Vzc1RpbWUATWljcm9zb2Z0LlNxbFNlcnZlci5EdHMu
UnVudGltZQBDb21iaW5lAERlZmxhdGVyRW5naW5lAGVuZ2luZQBOb25lAE1lbWJlcndpc2VDbG9u
ZQBWYWx1ZVR5cGUARmlsZVNoYXJlAENvbXBhcmUASUNTaGFycENvZGUuU2hhcnBaaXBMaWIuQ29y
ZQBPbkZpbGVGYWlsdXJlAE9uRGlyZWN0b3J5RmFpbHVyZQBBcmNoaXZlRXh0cmFEYXRhU2lnbmF0
dXJlAFNwYW5uaW5nU2lnbmF0dXJlAExvY2F0ZUJsb2NrV2l0aFNpZ25hdHVyZQBDZW50cmFsSGVh
ZGVyRGlnaXRhbFNpZ25hdHVyZQBTcGFubmluZ1RlbXBTaWduYXR1cmUAWmlwNjRDZW50cmFsRmls
ZUhlYWRlclNpZ25hdHVyZQBMb2NhbEhlYWRlclNpZ25hdHVyZQBDZW50cmFsSGVhZGVyU2lnbmF0
dXJlAFppcDY0Q2VudHJhbERpckxvY2F0b3JTaWduYXR1cmUARGF0YURlc2NyaXB0b3JTaWduYXR1
cmUARW5kT2ZDZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlAHNpZ25hdHVyZQBnZXRfQ3VsdHVyZQBz
ZXRfQ3VsdHVyZQByZXNvdXJjZUN1bHR1cmUAZ2V0X0ludmFyaWFudEN1bHR1cmUAZ2V0X0N1cnJl
bnRDdWx0dXJlAFZzZQBWU1RBUlRTY3JpcHRPYmplY3RNb2RlbEJhc2UAUGt6aXBDbGFzc2ljQ3J5
cHRvQmFzZQBBcHBsaWNhdGlvblNldHRpbmdzQmFzZQBpZ25vcmVDYXNlAENsb3NlAFN5c3RlbS5J
RGlzcG9zYWJsZS5EaXNwb3NlAGJpdDRSZXZlcnNlAHRvUmV2ZXJzZQBCaXRSZXZlcnNlAHJlY3Vy
c2UAZ2V0X01pbkRhdGUAc2V0X01pbkRhdGUAbWluRGF0ZQBnZXRfTWF4RGF0ZQBzZXRfTWF4RGF0
ZQBtYXhEYXRlAEFkZFVwZGF0ZQBGaW5kRXhpc3RpbmdVcGRhdGUAQmVnaW5VcGRhdGUAWmlwVXBk
YXRlAE9wZW5Gb3JEaXJlY3RVcGRhdGUAQ29tbWl0VXBkYXRlAEFib3J0VXBkYXRlAHVwZGF0ZQBD
cmVhdGUAQ29uZmlybU92ZXJ3cml0ZURlbGVnYXRlAGNvbmZpcm1EZWxlZ2F0ZQBNdWx0aWNhc3RE
ZWxlZ2F0ZQBEZWZsYXRlAEluZmxhdGUARWRpdG9yQnJvd3NhYmxlU3RhdGUAc3RhdGUARGVsZXRl
AGdldF9QZXJjZW50Q29tcGxldGUARW50cnlDb21wbGV0ZQBnZXRfQ2FuV3JpdGUAQmVnaW5Xcml0
ZQBPdmVyd3JpdGUAb3ZlcndyaXRlAENvbXBpbGVyR2VuZXJhdGVkQXR0cmlidXRlAERlYnVnZ2Vy
Tm9uVXNlckNvZGVBdHRyaWJ1dGUARGVidWdnYWJsZUF0dHJpYnV0ZQBFZGl0b3JCcm93c2FibGVB
dHRyaWJ1dGUAQXNzZW1ibHlUaXRsZUF0dHJpYnV0ZQBPYnNvbGV0ZUF0dHJpYnV0ZQBBc3NlbWJs
eVRyYWRlbWFya0F0dHJpYnV0ZQBUYXJnZXRGcmFtZXdvcmtBdHRyaWJ1dGUAQXNzZW1ibHlDb25m
aWd1cmF0aW9uQXR0cmlidXRlAEFzc2VtYmx5RGVzY3JpcHRpb25BdHRyaWJ1dGUARGVmYXVsdE1l
bWJlckF0dHJpYnV0ZQBGbGFnc0F0dHJpYnV0ZQBDb21waWxhdGlvblJlbGF4YXRpb25zQXR0cmli
dXRlAEFzc2VtYmx5UHJvZHVjdEF0dHJpYnV0ZQBBc3NlbWJseUNvcHlyaWdodEF0dHJpYnV0ZQBT
U0lTU2NyaXB0VGFza0VudHJ5UG9pbnRBdHRyaWJ1dGUAQXNzZW1ibHlDb21wYW55QXR0cmlidXRl
AFJ1bnRpbWVDb21wYXRpYmlsaXR5QXR0cmlidXRlAGdldF9NaW51dGUAUmVhZEJ5dGUAUmVhZExl
Qnl0ZQBXcml0ZUJ5dGUAVHJhbnNmb3JtQnl0ZQBBbGlnblRvQnl0ZQBnZXRfVmFsdWUAc2V0X1Zh
bHVlAGNyY1ZhbHVlAElzVmFsaWRWYWx1ZQBnZXRfQ3J5cHRvQ2hlY2tWYWx1ZQBzZXRfQ3J5cHRv
Q2hlY2tWYWx1ZQBNaW5WYWx1ZQBNYXhWYWx1ZQBrZXlWYWx1ZQB2YWx1ZQBnZXRfSXNFbWJlZGRl
ZEFyY2hpdmUAVGVzdEFyY2hpdmUAZ2V0X0lzTmV3QXJjaGl2ZQBNb3ZlAFJlbW92ZQBnZXRfU2l6
ZQBzZXRfU2l6ZQBnZXRfQUVTT3ZlcmhlYWRTaXplAGdldF9PZmZzZXRCYXNlZFNpemUAc2V0X09m
ZnNldEJhc2VkU2l6ZQBfb2Zmc2V0QmFzZWRTaXplAGdldF9Db21wcmVzc2VkU2l6ZQBzZXRfQ29t
cHJlc3NlZFNpemUAY29tcHJlc3NlZFNpemUARW5kT2ZDZW50cmFsUmVjb3JkQmFzZVNpemUATG9j
YWxIZWFkZXJCYXNlU2l6ZQBDZW50cmFsSGVhZGVyQmFzZVNpemUAZ2V0X0Jsb2NrU2l6ZQBzZXRf
QmxvY2tTaXplAG1pbmltdW1CbG9ja1NpemUAZ2V0X0lucHV0QmxvY2tTaXplAGdldF9PdXRwdXRC
bG9ja1NpemUAX2Jsb2NrU2l6ZQBnZXRfTWluU2l6ZQBzZXRfTWluU2l6ZQBtaW5TaXplAENyeXB0
b0hlYWRlclNpemUAZ2V0X0J1ZmZlclNpemUAc2V0X0J1ZmZlclNpemUARGVmYXVsdEJ1ZmZlclNp
emUAYnVmZmVyU2l6ZQBaaXA2NERhdGFEZXNjcmlwdG9yU2l6ZQBHZXREZXNjcmlwdG9yU2l6ZQBX
aW5kb3dTaXplAGdldF9NYXhTaXplAHNldF9NYXhTaXplAG1heFNpemUAZ2V0X0FFU0tleVNpemUA
c2V0X0FFU0tleVNpemUAU3VwcHJlc3NGaW5hbGl6ZQBjc2l6ZQBTVF9kYjljOTE0Nzk0OTY0ZDI4
YmY2ZjFkNzExNmRkMjIyZgBMYXN0SW5kZXhPZgBpbnB1dE9mZgBpbmYAaW5wdXRCdWYAZF9idWYA
bF9idWYAR2V0U3RyZWFtRm9yVGFnAF90YWcAU3lzdGVtLlRocmVhZGluZwBEZWZsYXRlclBlbmRp
bmcAcGVuZGluZwBHZXRFbmNvZGluZwBnZXRfQ29udGludWVSdW5uaW5nAHNldF9Db250aW51ZVJ1
bm5pbmcAU3lzdGVtLlJ1bnRpbWUuVmVyc2lvbmluZwBnZXRfSXNTb3VyY2VTdHJpbmcAQ29udmVy
dFRvU3RyaW5nAFppcFN0cmluZwB6aXBTdHJpbmcAR2V0U3RyaW5nAEluc2VydFN0cmluZwByYXdT
dHJpbmcAU3Vic3RyaW5nAEluaXRpYWxpc2luZwBkaXNwb3NpbmcAQ2hlY2tVcGRhdGluZwBnZXRf
SXNVcGRhdGluZwBTdG9wRGVjcnlwdGluZwBnZXRfU2V0dGluZwBzZXRfU2V0dGluZwBUaW1lU2V0
dGluZwB0aW1lU2V0dGluZwBSZWFkTEVMb25nAFdyaXRlTEVMb25nAFJlYWRMb25nAFJlYWRMZUxv
bmcAQWRkTGVMb25nAFdyaXRlTGVMb25nAFJlYWRMRVVsb25nAFdyaXRlTEVVbG9uZwBpbnNfaABj
dXJNYXRjaABJc01hdGNoAEZpbmRMb25nZXN0TWF0Y2gAZGgAZ2V0X0hhc2gAVXBkYXRlSGFzaABU
d29maXNoAEJsb3dmaXNoAEZpbmlzaABmaW5pc2gATWFjaW50b3NoAEZsdXNoAGZsdXNoAE1hdGgA
R2V0RnVsbFBhdGgATWF4UGF0aABwYXRoAHN0YXRpY0RMZW5ndGgAc3RhdGljTExlbmd0aABnZXRf
TGVuZ3RoAHNldF9MZW5ndGgAR2V0RW5jb2RlZExlbmd0aABzdG9yZWRMZW5ndGgAQnVpbGRMZW5n
dGgAZ29vZExlbmd0aABuaWNlTGVuZ3RoAGdldF9WYWx1ZUxlbmd0aABfcmVhZFZhbHVlTGVuZ3Ro
AHJlcExlbmd0aABTZXRMZW5ndGgAZ2V0X0NsZWFyVGV4dExlbmd0aABjbGVhclRleHRMZW5ndGgA
Z2V0X1Jhd0xlbmd0aAByYXdMZW5ndGgAbWF4TGVuZ3RoAGxlbmd0aABnZXRfQUVTRW5jcnlwdGlv
blN0cmVuZ3RoAF9hZXNFbmNyeXB0aW9uU3RyZW5ndGgARW5kc1dpdGgAZ2V0X01vbnRoAERheXNJ
bk1vbnRoAF9ibG9ja0FuZEF1dGgAQXN5bmNDYWxsYmFjawBjYWxsYmFjawBSZWFkQ2hlY2sARmx1
c2hTdG9yZWRCbG9jawBXcml0ZUJsb2NrAEZsdXNoQmxvY2sAVHJhbnNmb3JtRmluYWxCbG9jawBU
cmFuc2Zvcm1CbG9jawBDb21wcmVzc0Jsb2NrAEVuY3J5cHRCbG9jawBpc0xhc3RCbG9jawBsYXN0
QmxvY2sAa2V5QmxvY2sAYmxvY2sAZ2V0X0NhblNlZWsAV2luZG93TWFzawBNaWNyb3NvZnQuU3Fs
U2VydmVyLlNjcmlwdFRhc2sATWljcm9zb2Z0LlNxbFNlcnZlci5EdHMuVGFza3MuU2NyaXB0VGFz
awBDb252ZXJ0VGVtcG9yYXJ5VG9GaW5hbABvcmlnaW5hbABEaXNwb3NlSW50ZXJuYWwAUmVhZFNo
b3J0SW50ZXJuYWwAbGl0ZXJhbABvcF9HcmVhdGVyVGhhbk9yRXF1YWwAb3BfTGVzc1RoYW5PckVx
dWFsAHVwZGF0ZUludGVydmFsAGdldF9Qcm9ncmVzc0ludGVydmFsAHNldF9Qcm9ncmVzc0ludGVy
dmFsAFNjcmlwdE9iamVjdE1vZGVsAFN5c3RlbS5Db21wb25lbnRNb2RlbABkZWZhdWx0Q29tcHJl
c3Npb25MZXZlbABHZXRMZXZlbABTZXRMZXZlbABsZXZlbABTVF9kYjljOTE0Nzk0OTY0ZDI4YmY2
ZjFkNzExNmRkMjIyZi5kbGwARmlsbABJc0Z1bGwAV3JpdGVTeW1ib2wAcmVwU3ltYm9sAEdldFN5
bWJvbABaaXBBRVNTdHJlYW0AVW5jb21wcmVzc2VkU3RyZWFtAEZpbGVTdHJlYW0AYmFzZVN0cmVh
bQBnZXRfRmluYWxTdHJlYW0AQ3JlYXRlQW5kSW5pdERlY3J5cHRpb25TdHJlYW0AQ3JlYXRlQW5k
SW5pdEVuY3J5cHRpb25TdHJlYW0AY2xhc3NpY0NyeXB0b1N0cmVhbQBaaXBIZWxwZXJTdHJlYW0A
b3V0U3RyZWFtAGJhc2VJbnB1dFN0cmVhbQBQYXJ0aWFsSW5wdXRTdHJlYW0AWmlwSW5wdXRTdHJl
YW0ASW5mbGF0ZXJJbnB1dFN0cmVhbQBHZXRJbnB1dFN0cmVhbQBpbnB1dFN0cmVhbQBiYXNlT3V0
cHV0U3RyZWFtAFppcE91dHB1dFN0cmVhbQBEZWZsYXRlck91dHB1dFN0cmVhbQBHZXRPdXRwdXRT
dHJlYW0Ab3V0cHV0U3RyZWFtAE1lbW9yeVN0cmVhbQBfc3RyZWFtAFRhbmRlbQBnZXRfSXRlbQBz
ZXRfSXRlbQBaU3lzdGVtAHVzZUZpbGVTeXN0ZW0AZ2V0X0hvc3RTeXN0ZW0Ac2V0X0hvc3RTeXN0
ZW0AU3ltbWV0cmljQWxnb3JpdGhtAEhhc2hBbGdvcml0aG0ARW5jcnlwdGlvbkFsZ29yaXRobQBS
YW5kb20AQ3BtAFppcEFFU1RyYW5zZm9ybQBJTmFtZVRyYW5zZm9ybQBnZXRfTmFtZVRyYW5zZm9y
bQBzZXRfTmFtZVRyYW5zZm9ybQBaaXBOYW1lVHJhbnNmb3JtAFdpbmRvd3NOYW1lVHJhbnNmb3Jt
AGdldF9DYW5SZXVzZVRyYW5zZm9ybQBJQ3J5cHRvVHJhbnNmb3JtAHNldF9DcnlwdG9UcmFuc2Zv
cm0AUGt6aXBDbGFzc2ljRGVjcnlwdENyeXB0b1RyYW5zZm9ybQBQa3ppcENsYXNzaWNFbmNyeXB0
Q3J5cHRvVHJhbnNmb3JtAGNyeXB0b1RyYW5zZm9ybQBfdHJhbnNmb3JtAEVudW0AZG51bQBibG51
bQBJQ2hlY2tzdW0AY2hlY2tzdW0ARGVjb2RlQ2hrc3VtAGdldF9Ub3RhbEluAHRvdGFsSW4AT24A
cmVzb3VyY2VNYW4AU2NhbgBvcF9HcmVhdGVyVGhhbgBEZWNvZGVIdWZmbWFuAERlZmxhdGVySHVm
Zm1hbgBodWZmbWFuAFRpbWVTcGFuAG1hdGNoTGVuAHVuY29tcHJMZW4AZ2V0X0FFU1NhbHRMZW4A
bGFzdExlbgBsZW4AT3BlbgBSZW9wZW4AcmVwTWluAFNjcmlwdE1haW4AbWF4X2NoYWluAFNlZWtP
cmlnaW4Ab3JpZ2luAGdldF9WZXJzaW9uAElDU2hhcnBDb2RlLlNoYXJwWmlwTGliLlppcC5Db21w
cmVzc2lvbgBJc1ZhbGlkRXhwcmVzc2lvbgBJc1ZhbGlkRmlsdGVyRXhwcmVzc2lvbgBleHByZXNz
aW9uAGVuZExvY2F0aW9uAGRlc3RpbmF0aW9uAGdldF9PcGVyYXRpb24AU2V0T3BlcmF0aW9uAFRl
c3RPcGVyYXRpb24Ab3BlcmF0aW9uAFN5c3RlbS5Db25maWd1cmF0aW9uAFN5c3RlbS5HbG9iYWxp
emF0aW9uAFN5c3RlbS5SdW50aW1lLlNlcmlhbGl6YXRpb24Ab3BfU3VidHJhY3Rpb24AU3lzdGVt
LlJlZmxlY3Rpb24AY29tcHJlc3Npb25GdW5jdGlvbgBvcF9BZGRpdGlvbgBnZXRfUG9zaXRpb24A
c2V0X1Bvc2l0aW9uAHNvdXJjZVBvc2l0aW9uAGRlc3RpbmF0aW9uUG9zaXRpb24ASU9FeGNlcHRp
b24AZ2V0X0V4Y2VwdGlvbgBDcnlwdG9ncmFwaGljRXhjZXB0aW9uAE9iamVjdERpc3Bvc2VkRXhj
ZXB0aW9uAE5vdEltcGxlbWVudGVkRXhjZXB0aW9uAE5vdFN1cHBvcnRlZEV4Y2VwdGlvbgBBcmd1
bWVudE91dE9mUmFuZ2VFeGNlcHRpb24AU2hhcnBaaXBCYXNlRXhjZXB0aW9uAFBhdGhUb29Mb25n
RXhjZXB0aW9uAEFyZ3VtZW50TnVsbEV4Y2VwdGlvbgBFbmRPZlN0cmVhbUV4Y2VwdGlvbgBBcHBs
aWNhdGlvbkV4Y2VwdGlvbgBJbnZhbGlkT3BlcmF0aW9uRXhjZXB0aW9uAFppcEV4Y2VwdGlvbgBp
bm5lckV4Y2VwdGlvbgBBcmd1bWVudEV4Y2VwdGlvbgBleGNlcHRpb24ASUNTaGFycENvZGUuU2hh
cnBaaXBMaWIuRW5jcnlwdGlvbgBWZXJzaW9uU3Ryb25nRW5jcnlwdGlvbgBLbm93bgBVbmtub3du
AENvcHlUbwBGaWxlSW5mbwBDdWx0dXJlSW5mbwBGaWxlU3lzdGVtSW5mbwBTZXJpYWxpemF0aW9u
SW5mbwBnZXRfVGV4dEluZm8AbWFkZUJ5SW5mbwBEaXJlY3RvcnlJbmZvAGluZm8ASUNTaGFycENv
ZGUuU2hhcnBaaXBMaWIuWmlwAENyZWF0ZVppcABFeHRyYWN0WmlwAHRhcmdldFppcABGYXN0Wmlw
AFNraXAAUG9zdFVwZGF0ZUNsZWFudXAAQ2FsY0JMRnJlcQBUb29GYXIAZ2V0X1llYXIAQ2xlYXIA
X3JlcGxhY2VtZW50Q2hhcgBfYWVzVmVyAFdyaXRlQUVTSGVhZGVyAERlY29kZUhlYWRlcgBXcml0
ZUxvY2FsSGVhZGVyAFRlc3RMb2NhbEhlYWRlcgBsb2NhbEhlYWRlcgBXcml0ZUVuY3J5cHRpb25I
ZWFkZXIASW5mbGF0ZXJEeW5IZWFkZXIAZHluSGVhZGVyAG5vSGVhZGVyAGdldF9Db21wcmVzc2lv
bk1ldGhvZEZvckhlYWRlcgBXcml0ZUNlbnRyYWxEaXJlY3RvcnlIZWFkZXIAcGF0Y2hFbnRyeUhl
YWRlcgBXcml0ZUxvY2FsRW50cnlIZWFkZXIAaW50ZXJuYWxSZWFkZXIAUk5HQ3J5cHRvU2Vydmlj
ZVByb3ZpZGVyAFN0cmluZ0J1aWxkZXIAc291cmNlRm9sZGVyAHNlbmRlcgBfc2xpZGVCdWZmZXIA
UGVuZGluZ0J1ZmZlcgBHZXRCdWZmZXIAX2VuY3J5cHRCdWZmZXIAb3V0QnVmZmVyAEluZmxhdGVy
SW5wdXRCdWZmZXIAaW5wdXRCdWZmZXIAb3V0cHV0QnVmZmVyAFJlYWRDbGVhclRleHRCdWZmZXIA
UmVhZFJhd0J1ZmZlcgBidWZmZXIAZ2V0X1Jlc291cmNlTWFuYWdlcgBnZXRfUHdkVmVyaWZpZXIA
X3B3ZFZlcmlmaWVyAGdldF9BZGxlcgByZWFkQWRsZXIAUmVzZXRBZGxlcgBhZGxlcgBSZWFkRGF0
YUhhbmRsZXIAQ29tcGxldGVkRmlsZUhhbmRsZXIAUHJvY2Vzc0ZpbGVIYW5kbGVyAEZpbGVGYWls
dXJlSGFuZGxlcgBEaXJlY3RvcnlGYWlsdXJlSGFuZGxlcgBQcm9ncmVzc0hhbmRsZXIAcHJvZ3Jl
c3NIYW5kbGVyAFppcFRlc3RSZXN1bHRIYW5kbGVyAHJlc3VsdEhhbmRsZXIAS2V5c1JlcXVpcmVk
RXZlbnRIYW5kbGVyAFByb2Nlc3NEaXJlY3RvcnlIYW5kbGVyAEZpbGVTeXN0ZW1TY2FubmVyAGdl
dF9Jc1N0cmVhbU93bmVyAHNldF9Jc1N0cmVhbU93bmVyAGlzU3RyZWFtT3duZXIASUNvbXBhcmVy
AFVwZGF0ZUNvbXBhcmVyAERlZmxhdGVyAGRlZmxhdGVyAEluZmxhdGVyAGluZmxhdGVyAGZpbGVG
aWx0ZXIATmFtZUZpbHRlcgBOYW1lQW5kU2l6ZUZpbHRlcgBFeHRlbmRlZFBhdGhGaWx0ZXIASVNj
YW5GaWx0ZXIAZGlyZWN0b3J5RmlsdGVyAGZpbHRlcgBFbnRlcgBub1psaWJIZWFkZXJPckZvb3Rl
cgBOZXZlcgBUb0xvd2VyAFNjYW5EaXIAQWRkRXJyb3IARmluZEZpcnN0RXJyb3IAU3RyZWFtTWFu
aXB1bGF0b3IASUVudW1lcmF0b3IAR2V0RW51bWVyYXRvcgBaaXBFbnRyeUVudW1lcmF0b3IAUmFu
ZG9tTnVtYmVyR2VuZXJhdG9yAC5jdG9yAC5jY3RvcgBNb25pdG9yAFJlYWREYXRhRGVzY3JpcHRv
cgBXcml0ZURhdGFEZXNjcmlwdG9yAENyZWF0ZURlY3J5cHRvcgBDcmVhdGVFbmNyeXB0b3IAX2Vu
Y3J5cHRvcgBwdHIAc3RyAGdldF9Ib3VyAFN5c3RlbS5EaWFnbm9zdGljcwBjaGlsZHMAZ2V0X1Rv
dGFsU2Vjb25kcwBGcm9tU2Vjb25kcwBEZXMAU3lzdGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNl
cwBTeXN0ZW0uUmVzb3VyY2VzAFNUX2RiOWM5MTQ3OTQ5NjRkMjhiZjZmMWQ3MTE2ZGQyMjJmLlBy
b3BlcnRpZXMuUmVzb3VyY2VzLnJlc291cmNlcwBzdGF0aWNEQ29kZXMAc3RhdGljTENvZGVzAFNl
dFN0YXRpY0NvZGVzAHN0YXRpY0NvZGVzAEJ1aWxkQ29kZXMAYmxUcmVlQ29kZXMAbWluTnVtQ29k
ZXMAbnVtQ29kZXMAbWluQ29kZXMARGVidWdnaW5nTW9kZXMAY29kZXMAU2VuZEFsbFRyZWVzAEdl
dERpcmVjdG9yaWVzAGdldF9DcmVhdGVFbXB0eURpcmVjdG9yaWVzAHNldF9DcmVhdGVFbXB0eURp
cmVjdG9yaWVzAFJlYWRFbnRyaWVzAHNpemVFbnRyaWVzAG5vT2ZFbnRyaWVzAGdldF9DYW5QYXRj
aEVudHJpZXMAZW50cmllcwBTVF9kYjljOTE0Nzk0OTY0ZDI4YmY2ZjFkNzExNmRkMjIyZi5Qcm9w
ZXJ0aWVzAGdldF9WYXJpYWJsZXMAZ2V0X0hhc01hdGNoaW5nRmlsZXMAaGFzTWF0Y2hpbmdGaWxl
cwBHZXRGaWxlcwBSdW5VcGRhdGVzAGdldF9BdHRyaWJ1dGVzAGdldF9FeHRlcm5hbEZpbGVBdHRy
aWJ1dGVzAHNldF9FeHRlcm5hbEZpbGVBdHRyaWJ1dGVzAGV4dGVybmFsRmlsZUF0dHJpYnV0ZXMA
TWFrZUV4dGVybmFsQXR0cmlidXRlcwBIYXNEb3NBdHRyaWJ1dGVzAGdldF9HZXRBdHRyaWJ1dGVz
AHNldF9HZXRBdHRyaWJ1dGVzAGdldF9TZXRBdHRyaWJ1dGVzAHNldF9TZXRBdHRyaWJ1dGVzAGF0
dHJpYnV0ZXMAZ2V0X0F2YWlsYWJsZUJ5dGVzAFJmYzI4OThEZXJpdmVCeXRlcwBDb3B5RGVzY3Jp
cHRvckJ5dGVzAEdldEJ5dGVzAHNhbHRCeXRlcwBOZXh0Qnl0ZXMAQ29weUJ5dGVzAGdldF9MZWdh
bEJsb2NrU2l6ZXMAZ2V0X0xlZ2FsS2V5U2l6ZXMAZ2V0X0ZsYWdzAHNldF9GbGFncwBHZW5lcmFs
Qml0RmxhZ3MAX2ZsYWdzAFNldHRpbmdzAEtleXNSZXF1aXJlZEV2ZW50QXJncwBTY2FuRmFpbHVy
ZUV2ZW50QXJncwBTY2FuRXZlbnRBcmdzAFByb2dyZXNzRXZlbnRBcmdzAERpcmVjdG9yeUV2ZW50
QXJncwBnZXRfVHJpbUluY29taW5nUGF0aHMAc2V0X1RyaW1JbmNvbWluZ1BhdGhzAF90cmltSW5j
b21pbmdQYXRocwBzdGF0aWNMZW5ndGhzAGNvZGVMZW5ndGhzAGdldF9DYW5UcmFuc2Zvcm1NdWx0
aXBsZUJsb2NrcwBXaW5kb3dzUGF0aFV0aWxzAFN0cmVhbVV0aWxzAFZNQ21zAE9wZW5WbXMASUNT
aGFycENvZGUuU2hhcnBaaXBMaWIuWmlwLkNvbXByZXNzaW9uLlN0cmVhbXMAZWxlbXMASUNTaGFy
cENvZGUuU2hhcnBaaXBMaWIuQ2hlY2tzdW1zAGJsTGVucwBsaXRkaXN0TGVucwBTeXN0ZW0uVGV4
dC5SZWd1bGFyRXhwcmVzc2lvbnMAU3lzdGVtLkNvbGxlY3Rpb25zAFJlZ2V4T3B0aW9ucwBfc2xp
ZGVCdWZGcmVlUG9zAGNyY1BhdGNoUG9zAHNpemVQYXRjaFBvcwBfZW5jclBvcwBfc2xpZGVCdWZT
dGFydFBvcwBNc2RvcwBmcmVxcwBnZXRfQ2hhcnMAc2V0X0NoYXJzAEdldEludmFsaWRQYXRoQ2hh
cnMASW52YWxpZEVudHJ5Q2hhcnMAUnVudGltZUhlbHBlcnMARmluZEFsbEVycm9ycwBGaWxlQWNj
ZXNzAFN1Y2Nlc3MAUHJvZ3Jlc3MARW5oYW5jZWRDb21wcmVzcwBnZXRfQ2FuRGVjb21wcmVzcwBn
ZXRfRHRzAG5lZWRlZEJpdHMAZ2V0X0F2YWlsYWJsZUJpdHMAV3JpdGVCaXRzAFBlZWtCaXRzAHJl
cEJpdHMARHJvcEJpdHMAR2V0Qml0cwBleHRyYV9iaXRzAFNjcmlwdFJlc3VsdHMAWmlwQ29uc3Rh
bnRzAERlZmxhdGVyQ29uc3RhbnRzAEFkZEZpbGVDb250ZW50cwBGYXN0WmlwRXZlbnRzAGV2ZW50
cwBibF9jb3VudHMATWlzY2VsbGFuZW91c1Rlc3RzAHRlc3RzAGdldF9FeGlzdHMAVGVzdFN0YXR1
cwBzdGF0dXMAQWx0ZXJuYXRlTXZzAEFsd2F5cwBVcGRhdGVLZXlzAEdlbmVyYXRlS2V5cwBnZXRf
SGF2ZUtleXMAU2V0S2V5cwBrZXlzAENvbmNhdABTbG93UmVwZWF0AFZmYXQARm9ybWF0AGdldF9S
ZXN0b3JlRGF0ZVRpbWVPbkV4dHJhY3QAc2V0X1Jlc3RvcmVEYXRlVGltZU9uRXh0cmFjdABnZXRf
UmVzdG9yZUF0dHJpYnV0ZXNPbkV4dHJhY3QAc2V0X1Jlc3RvcmVBdHRyaWJ1dGVzT25FeHRyYWN0
AHZlcnNpb25SZXF1aXJlZFRvRXh0cmFjdAB2ZXJzaW9uVG9FeHRyYWN0AE9iamVjdABvYmplY3QA
Q29weUVudHJ5RGF0YURpcmVjdABDb3B5RGVzY3JpcHRvckJ5dGVzRGlyZWN0AENvcHlFbnRyeURp
cmVjdABEZWNvZGVEaWN0AENvcHlEaWN0AGdldF9UYXJnZXQAZml4ZWRUYXJnZXQAdGFyZ2V0AFJl
c2V0AGdldF9PZmZzZXQAc2V0X09mZnNldABzdG9yZWRPZmZzZXQAZ2V0X0NyY1BhdGNoT2Zmc2V0
AHNldF9DcmNQYXRjaE9mZnNldABnZXRfU2l6ZVBhdGNoT2Zmc2V0AHNldF9TaXplUGF0Y2hPZmZz
ZXQAY2VudHJhbERpck9mZnNldABpbnB1dE9mZnNldABvdXRwdXRPZmZzZXQAb2Zmc2V0AFRhbGx5
TGl0AG9wX0ltcGxpY2l0AGxhc3RfbGl0AEV4aXQAc2FsdABnZXRfRGVmYXVsdABJQXN5bmNSZXN1
bHQAc2V0X1Rhc2tSZXN1bHQAcmVzdWx0AFJlYWRMRUludABXcml0ZUxFSW50AFJlYWRJbnQAUmVh
ZExlSW50AEFkZExlSW50AFdyaXRlTGVJbnQAV3JpdGVJbnQAZ2V0X1JlcGxhY2VtZW50AHNldF9S
ZXBsYWNlbWVudAByZXBsYWNlbWVudABnZXRfQ29tbWVudABzZXRfQ29tbWVudABnZXRfWmlwRmls
ZUNvbW1lbnQAemlwQ29tbWVudABTZXRDb21tZW50AGdldF9SYXdDb21tZW50AGNvbW1lbnQAZ2V0
X0N1cnJlbnQAUmVhZExFVWludABXcml0ZUxFVWludABnZXRfQ291bnQAZ2V0X1VucmVhZENvdW50
AGdldF9FcnJvckNvdW50AGdldF9CaXRDb3VudABiaXRDb3VudABpbnB1dENvdW50AGNvdW50AGFt
b3VudABEcm9wUGF0aFJvb3QAR2V0UGF0aFJvb3QAUHJvbXB0AENvcHlBbmRFbmNyeXB0AF9yZWFk
VmFsdWVTdGFydABtYXRjaFN0YXJ0AGJsb2NrU3RhcnQAcmVwU3RhcnQAc3Ryc3RhcnQAU29ydABS
ZWFkTEVTaG9ydABXcml0ZUxFU2hvcnQAUmVhZFNob3J0AFJlYWRMZVNob3J0AEFkZExlU2hvcnQA
V3JpdGVMZVNob3J0AFdyaXRlU2hvcnQAU2V0U2hvcnQAUmVhZExFVXNob3J0AFdyaXRlTEVVc2hv
cnQARGVmbGF0ZUZhc3QAdG9UZXN0AEhlYWRlclRlc3QAZGVzdAByZXBEaXN0AFRhbGx5RGlzdABB
cnJheUxpc3QAZ2V0X1RvdGFsT3V0AHRvdGFsT3V0AGdldF9DYW5UaW1lb3V0AGdldF9Jc05lZWRp
bmdJbnB1dABnZXRfUmVtYWluaW5nSW5wdXQAU2V0SW5mbGF0ZXJJbnB1dABOZWVkc0lucHV0AFNl
dElucHV0AGlucHV0AENvcHlPdXRwdXQAR2V0VGVtcG9yYXJ5T3V0cHV0AG91dHB1dABDb252ZXJ0
VG9TdHJpbmdFeHQATW92ZU5leHQAU3lzdGVtLlRleHQAdXNlVW5pY29kZVRleHQAZ2V0X0lzVW5p
Y29kZVRleHQAc2V0X0lzVW5pY29kZVRleHQAZ2V0X0NsZWFyVGV4dABpbnRlcm5hbENsZWFyVGV4
dABjbGVhclRleHQAU3RyZWFtaW5nQ29udGV4dABjb250ZXh0AHByZXYAZ2V0X05vdwBTbGlkZVdp
bmRvdwBGaWxsV2luZG93AE91dHB1dFdpbmRvdwBvdXRwdXRXaW5kb3cAd2luZG93AERlZmxhdGVT
bG93AE1heABnZXRfQ3VycmVudFJlYWRJbmRleABnZXRfWmlwRmlsZUluZGV4AHNldF9aaXBGaWxl
SW5kZXgAemlwRmlsZUluZGV4AGdldF9FbnRyeUJ5SW5kZXgAZW50cnlJbmRleABfaW5kZXgAUmVn
ZXgAZ2V0X1RyaW1QcmVmaXgAc2V0X1RyaW1QcmVmaXgAdHJpbVByZWZpeABVbml4AGdldF9WZXJz
aW9uTWFkZUJ5AHZlcnNpb25NYWRlQnkAZ2V0X0RheQBUb0J5dGVBcnJheQBJbml0aWFsaXplQXJy
YXkAQ29udmVydFRvQXJyYXkAYXJyYXkAZ2V0X0tleQBzZXRfS2V5AHJnYktleQBHZW5lcmF0ZUtl
eQBDb250YWluc0tleQBrZXkATW9kaWZ5AGdldF9TdHJhdGVneQBzZXRfU3RyYXRlZ3kARGVmbGF0
ZVN0cmF0ZWd5AFNldFN0cmF0ZWd5AFRlc3RTdHJhdGVneQBzdHJhdGVneQBTeXN0ZW0uU2VjdXJp
dHkuQ3J5cHRvZ3JhcGh5AGdldF9Bc3NlbWJseQBSZWFkRnVsbHkASHVmZm1hbk9ubHkAVXBkYXRl
Q29tbWVudE9ubHkASW5kZXhPZkFueQBieXRlc1RvQ29weQBNYWtlVGVtcG9yYXJ5Q29weQBTa2lw
VG9CeXRlQm91bmRhcnkAZ2V0X0lzTmVlZGluZ0RpY3Rpb25hcnkAU2V0RGljdGlvbmFyeQBkaWN0
aW9uYXJ5AElUYWdnZWREYXRhRmFjdG9yeQBJRW50cnlGYWN0b3J5AGdldF9FbnRyeUZhY3RvcnkA
c2V0X0VudHJ5RmFjdG9yeQBaaXBFbnRyeUZhY3RvcnkAQWRkRGlyZWN0b3J5AHNvdXJjZURpcmVj
dG9yeQBnZXRfQmFzZURpcmVjdG9yeQBzZXRfQmFzZURpcmVjdG9yeQBfYmFzZURpcmVjdG9yeQBD
cmVhdGVEaXJlY3RvcnkAV3JpdGVaaXA2NEVuZE9mQ2VudHJhbERpcmVjdG9yeQBXcml0ZUVuZE9m
Q2VudHJhbERpcmVjdG9yeQBzdGFydE9mQ2VudHJhbERpcmVjdG9yeQBUcmFuc2Zvcm1EaXJlY3Rv
cnkAZ2V0X0lzRGlyZWN0b3J5AE9uUHJvY2Vzc0RpcmVjdG9yeQB0YXJnZXREaXJlY3RvcnkAZGly
ZWN0b3J5AGdldF9Jc0RPU0VudHJ5AGdldF9FbnRyeQBBZGRFbnRyeQBGaW5kRW50cnkATWFrZUZp
bGVFbnRyeQBFeHRyYWN0RmlsZUVudHJ5AENvbXBsZXRlQ2xvc2VFbnRyeQBMb2NhdGVFbnRyeQBa
aXBFbnRyeQBjdXJFbnRyeQBnZXRfQ2FuRGVjb21wcmVzc0VudHJ5AEV4dHJhY3RFbnRyeQBHZXRF
bnRyeQBTZXRFbnRyeQBvZmZzZXRPZkZpcnN0RW50cnkAZ2V0X091dEVudHJ5AEdldE5leHRFbnRy
eQBQdXROZXh0RW50cnkAQWRkTmV3RW50cnkAU3RhcnROZXdFbnRyeQBfbmV3RW50cnkATW9kaWZ5
RW50cnkAQ29weUVudHJ5AE1ha2VEaXJlY3RvcnlFbnRyeQBlbnRyeQBvcF9JbmVxdWFsaXR5AENo
ZWNrRW1wdHkAbWF4X2xhenkAACVJAG4AdgBhAGwAaQBkACAAYgBsAG8AYwBrAHMAaQB6AGUAIAAA
Jy4AIABNAHUAcwB0ACAAYgBlACAAMQA2ACAAbwByACAAMwAyAC4AADVJAG4AdgBhAGwAaQBkACAA
cwBhAGwAdAAgAGwAZQBuAC4AIABNAHUAcwB0ACAAYgBlACAAAB8gAGYAbwByACAAYgBsAG8AYwBr
AHMAaQB6AGUAIAAAR1oAaQBwAEEARQBTAFQAcgBhAG4AcwBmAG8AcgBtAC4AVAByAGEAbgBzAGYA
bwByAG0ARgBpAG4AYQBsAEIAbABvAGMAawAANVoAaQBwAEEARQBTAFMAdAByAGUAYQBtACAAbwBu
AGwAeQAgAGYAbwByACAAcgBlAGEAZAAAP0kAbgB0AGUAcgBuAGEAbAAgAGUAcgByAG8AcgAgAG0A
aQBzAHMAZQBkACAAYQB1AHQAaAAgAGMAbwBkAGUAAIEtQQBFAFMAIABBAHUAdABoAGUAbgB0AGkA
YwBhAHQAaQBvAG4AIABDAG8AZABlACAAZABvAGUAcwAgAG4AbwB0ACAAbQBhAHQAYwBoAC4AIABU
AGgAaQBzACAAaQBzACAAYQAgAHMAdQBwAGUAcgAtAEMAUgBDACAAYwBoAGUAYwBrACAAbwBuACAA
dABoAGUAIABkAGEAdABhACAAaQBuACAAdABoAGUAIABmAGkAbABlACAAYQBmAHQAZQByACAAYwBv
AG0AcAByAGUAcwBzAGkAbwBuACAAYQBuAGQAIABlAG4AYwByAHkAcAB0AGkAbwBuAC4AIAANAAoA
VABoAGUAIABmAGkAbABlACAAbQBhAHkAIABiAGUAIABkAGEAbQBhAGcAZQBkAC4AAQlzAGUAZQBk
AAAdTABlAG4AZwB0AGgAIABpAHMAIAB6AGUAcgBvAAAPawBlAHkARABhAHQAYQAAL0sAZQB5ACAA
bABlAG4AZwB0AGgAIABpAHMAIABuAG8AdAAgAHYAYQBsAGkAZAAAK0IAbABvAGMAawAgAHMAaQB6
AGUAIABpAHMAIABpAG4AdgBhAGwAaQBkAAALdgBhAGwAdQBlAAAnSwBlAHkAIABzAGkAegBlACAA
aQBzACAAaQBsAGwAZQBnAGEAbAAADXQAbwBUAGUAcwB0AABJTQBpAHMAcwBpAG4AZwAgAHQAZQBy
AG0AaQBuAGEAdABpAG4AZwAgAGUAcwBjAGEAcABlACAAYwBoAGEAcgBhAGMAdABlAHIAABFvAHIA
aQBnAGkAbgBhAGwAAAEAH0UAeABjAGUAZQBkAHMAIABNAGEAeABEAGEAdABlAAAfRQB4AGMAZQBl
AGQAcwAgAE0AaQBuAEQAYQB0AGUAAA1zAHQAcgBlAGEAbQAADWIAdQBmAGYAZQByAAANbwBmAGYA
cwBlAHQAAAtjAG8AdQBuAHQAAA1zAG8AdQByAGMAZQAAF2QAZQBzAHQAaQBuAGEAdABpAG8AbgAA
J0IAdQBmAGYAZQByACAAaQBzACAAdABvAG8AIABzAG0AYQBsAGwAAB9wAHIAbwBnAHIAZQBzAHMA
SABhAG4AZABsAGUAcgAAH2MAbwBuAGYAaQByAG0ARABlAGwAZQBnAGEAdABlAAAbYgBhAHMAZQBE
AGkAcgBlAGMAdABvAHIAeQAAM0QAaQByAGUAYwB0AG8AcgB5ACAAbgBhAG0AZQAgAGkAcwAgAGkA
bgB2AGEAbABpAGQAAANcAABHQwBhAG4AbgBvAHQAIABoAGEAdgBlACAAYQBuACAAZQBtAHAAdAB5
ACAAZABpAHIAZQBjAHQAbwByAHkAIABuAGEAbQBlAAAJbgBhAG0AZQAAAy8AAAVcAFwAAC1pAG4A
dgBhAGwAaQBkACAAcABhAHQAaAAgAGMAaABhAHIAYQBjAHQAZQByAAA7aQBuAHYAYQBsAGkAZAAg
AHIAZQBwAGwAYQBjAGUAbQBlAG4AdAAgAGMAaABhAHIAYQBjAHQAZQByAAAhTgBhAG0AZQAgAGkA
cwAgAHQAbwBvACAAbABvAG4AZwAAMXYAZQByAHMAaQBvAG4AUgBlAHEAdQBpAHIAZQBkAFQAbwBF
AHgAdAByAGEAYwB0AAALZQBuAHQAcgB5AABBQwBvAG0AcAByAGUAcwBzAGkAbwBuACAAbQBlAHQA
aABvAGQAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAAA9SQBuAHYAYQBsAGkAZAAgAEEARQBT
AEUAbgBjAHIAeQBwAHQAaQBvAG4AUwB0AHIAZQBuAGcAdABoACAAAEVBAEUAUwBLAGUAeQBTAGkA
egBlACAAbQB1AHMAdAAgAGIAZQAgADAALAAgADEAMgA4ACAAbwByACAAMgA1ADYAOgAgAABvRQB4
AHQAcgBhACAAZABhAHQAYQAgAGUAeAB0AGUAbgBkAGUAZAAgAFoAaQBwADYANAAgAGkAbgBmAG8A
cgBtAGEAdABpAG8AbgAgAGwAZQBuAGcAdABoACAAaQBzACAAaQBuAHYAYQBsAGkAZAAAZ1oAaQBw
ADYANAAgAEUAeAB0AGUAbgBkAGUAZAAgAGkAbgBmAG8AcgBtAGEAdABpAG8AbgAgAHIAZQBxAHUA
aQByAGUAZAAgAGIAdQB0ACAAaQBzACAAbQBpAHMAcwBpAG4AZwAuAAAvTgBUAEYAUwAgAEUAeAB0
AHIAYQAgAGQAYQB0AGEAIABpAG4AdgBhAGwAaQBkAAAtQQBFAFMAIABFAHgAdAByAGEAIABEAGEA
dABhACAATABlAG4AZwB0AGgAIAAAEyAAaQBuAHYAYQBsAGkAZAAuAAAtQQBFAFMAIABFAHgAdABy
AGEAIABEAGEAdABhACAAbQBpAHMAcwBpAG4AZwAAJ2MAYQBuAG4AbwB0ACAAZQB4AGMAZQBlAGQA
IAA2ADUANQAzADUAADlWAGEAbAB1AGUAIABpAHMAIAB0AG8AbwAgAG8AbABkACAAdABvACAAYgBl
ACAAdgBhAGwAaQBkAABPVQBuAGgAYQBuAGQAbABlAGQAIAB0AGkAbQBlACAAcwBlAHQAdABpAG4A
ZwAgAGkAbgAgAE0AYQBrAGUARgBpAGwAZQBFAG4AdAByAHkAAFlVAG4AaABhAG4AZABsAGUAZAAg
AHQAaQBtAGUAIABzAGUAdAB0AGkAbgBnACAAaQBuACAATQBhAGsAZQBEAGkAcgBlAGMAdABvAHIA
eQBFAG4AdAByAHkAAAlkAGEAdABhAAA3RABhAHQAYQAgAGUAeABjAGUAZQBkAHMAIABtAGEAeABp
AG0AdQBtACAAbABlAG4AZwB0AGgAAGFGAGkAbgBkACAAbQB1AHMAdAAgAGIAZQAgAGMAYQBsAGwA
ZQBkACAAYgBlAGYAbwByAGUAIABjAGEAbABsAGkAbgBnACAAYQAgAFIAZQBhAGQAIABtAGUAdABo
AG8AZAAAFXQAYQBnAGcAZQBkAEQAYQB0AGEAABFoAGUAYQBkAGUAcgBJAEQAABNmAGkAZQBsAGQA
RABhAHQAYQAALWUAeABjAGUAZQBkAHMAIABtAGEAeABpAG0AdQBtACAAbABlAG4AZwB0AGgAACNF
AG4AZAAgAG8AZgAgAGUAeAB0AHIAYQAgAGQAYQB0AGEAAD9DAGEAbgBuAG8AdAAgAHIAZQBhAGQA
IABiAGUAZgBvAHIAZQAgAHMAdABhAHIAdAAgAG8AZgAgAHQAYQBnAAAJZgBpAGwAZQAALVMAdABy
AGUAYQBtACAAaQBzACAAbgBvAHQAIABzAGUAZQBrAGEAYgBsAGUAABFmAGkAbABlAE4AYQBtAGUA
ABNvAHUAdABTAHQAcgBlAGEAbQAAL1MAdAByAGUAYQBtACAAaQBzACAAbgBvAHQAIAB3AHIAaQB0
AGUAYQBiAGwAZQAAD1oAaQBwAEYAaQBsAGUAACtFAG4AdAByAHkAIABjAGEAbgBuAG8AdAAgAGIA
ZQAgAGYAbwB1AG4AZAAAOVUAbgBhAGIAbABlACAAdABvACAAZABlAGMAcgB5AHAAdAAgAHQAaABp
AHMAIABlAG4AdAByAHkAAD9VAG4AcwB1AHAAcABvAHIAdABlAGQAIABjAG8AbQBwAHIAZQBzAHMA
aQBvAG4AIABtAGUAdABoAG8AZAAgAAA7RQB4AGMAZQBwAHQAaQBvAG4AIABkAHUAcgBpAG4AZwAg
AHQAZQBzAHQAIAAtACAAJwB7ADAAfQAnAAEZQwBSAEMAIABtAGkAcwBtAGEAdABjAGgAAEdXAHIA
bwBuAGcAIABsAG8AYwBhAGwAIABoAGUAYQBkAGUAcgAgAHMAaQBnAG4AYQB0AHUAcgBlACAAQAB7
ADAAOgBYAH0AADdTAGkAegBlACAAaQBuAHYAYQBsAGkAZAAgAGYAbwByACAAZABlAHMAYwByAGkA
cAB0AG8AcgAATUMAbwBtAHAAcgBlAHMAcwBlAGQAIABzAGkAegBlACAAaQBuAHYAYQBsAGkAZAAg
AGYAbwByACAAZABlAHMAYwByAGkAcAB0AG8AcgAAV1IAZQBxAHUAaQByAGUAZAAgAFoAaQBwADYA
NAAgAGUAeAB0AGUAbgBkAGUAZAAgAGkAbgBmAG8AcgBtAGEAdABpAG8AbgAgAG0AaQBzAHMAaQBu
AGcAAHVWAGUAcgBzAGkAbwBuACAAcgBlAHEAdQBpAHIAZQBkACAAdABvACAAZQB4AHQAcgBhAGMA
dAAgAHQAaABpAHMAIABlAG4AdAByAHkAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkACAAKAB7
ADAAfQApAACAl1QAaABlACAAbABpAGIAcgBhAHIAeQAgAGQAbwBlAHMAIABuAG8AdAAgAHMAdQBw
AHAAbwByAHQAIAB0AGgAZQAgAHoAaQBwACAAdgBlAHIAcwBpAG8AbgAgAHIAZQBxAHUAaQByAGUA
ZAAgAHQAbwAgAGUAeAB0AHIAYQBjAHQAIAB0AGgAaQBzACAAZQBuAHQAcgB5AABvVgBlAHIAcwBp
AG8AbgAgAHIAZQBxAHUAaQByAGUAZAAgAHQAbwAgAGUAeAB0AHIAYQBjAHQAIAB0AGgAaQBzACAA
ZQBuAHQAcgB5ACAAaQBzACAAaQBuAHYAYQBsAGkAZAAgACgAewAwAH0AKQAAQ1IAZQBzAGUAcgB2
AGUAZAAgAGIAaQB0ACAAZgBsAGEAZwBzACAAYwBhAG4AbgBvAHQAIABiAGUAIABzAGUAdAAuAACA
jVYAZQByAHMAaQBvAG4AIAByAGUAcQB1AGkAcgBlAGQAIAB0AG8AIABlAHgAdAByAGEAYwB0ACAA
dABoAGkAcwAgAGUAbgB0AHIAeQAgAGkAcwAgAHQAbwBvACAAbABvAHcAIABmAG8AcgAgAGUAbgBj
AHIAeQBwAHQAaQBvAG4AIAAoAHsAMAB9ACkAAHNTAHQAcgBvAG4AZwAgAGUAbgBjAHIAeQBwAHQA
aQBvAG4AIABmAGwAYQBnACAAcwBlAHQAIABiAHUAdAAgAGUAbgBjAHIAeQBwAHQAaQBvAG4AIABm
AGwAYQBnACAAaQBzACAAbgBvAHQAIABzAGUAdAAAX1AAYQB0AGMAaABlAGQAIABkAGEAdABhACAA
cgBlAHEAdQBpAHIAZQBzACAAaABpAGcAaABlAHIAIAB2AGUAcgBzAGkAbwBuACAAdABoAGEAbgAg
ACgAewAwAH0AKQAAVUMAZQBuAHQAcgBhAGwAIABoAGUAYQBkAGUAcgAvAGwAbwBjAGEAbAAgAGgA
ZQBhAGQAZQByACAAZgBsAGEAZwBzACAAbQBpAHMAbQBhAHQAYwBoAABvQwBlAG4AdAByAGEAbAAg
AGgAZQBhAGQAZQByAC8AbABvAGMAYQBsACAAaABlAGEAZABlAHIAIABjAG8AbQBwAHIAZQBzAHMA
aQBvAG4AIABtAGUAdABoAG8AZAAgAG0AaQBzAG0AYQB0AGMAaAAAMUUAeAB0AHIAYQBjAHQAIAB2
AGUAcgBzAGkAbwBuACAAbQBpAHMAbQBhAHQAYwBoAABtUwB0AHIAbwBuAGcAIABlAG4AYwByAHkA
cAB0AGkAbwBuACAAZgBsAGEAZwAgAHMAZQB0ACAAYgB1AHQAIAB2AGUAcgBzAGkAbwBuACAAbgBv
AHQAIABoAGkAZwBoACAAZQBuAG8AdQBnAGgAAF9IAGUAYQBkAGUAcgAgAG0AYQBzAGsAZQBkACAA
cwBlAHQAIABiAHUAdAAgAGQAYQB0AGUALwB0AGkAbQBlACAAdgBhAGwAdQBlAHMAIABuAG8AbgAt
AHoAZQByAG8AAVFDAGUAbgB0AHIAYQBsACAAaABlAGEAZABlAHIALwBsAG8AYwBhAGwAIABoAGUA
YQBkAGUAcgAgAGMAcgBjACAAbQBpAHMAbQBhAHQAYwBoAAA3SQBuAHYAYQBsAGkAZAAgAEMAUgBD
ACAAZgBvAHIAIABlAG0AcAB0AHkAIABlAG4AdAByAHkAADNGAGkAbABlACAAbgBhAG0AZQAgAGwA
ZQBuAGcAdABoACAAbQBpAHMAbQBhAHQAYwBoAABlQwBlAG4AdAByAGEAbAAgAGgAZQBhAGQAZQBy
ACAAYQBuAGQAIABsAG8AYwBhAGwAIABoAGUAYQBkAGUAcgAgAGYAaQBsAGUAIABuAGEAbQBlACAA
bQBpAHMAbQBhAHQAYwBoAAA1RABpAHIAZQBjAHQAbwByAHkAIABjAGEAbgBuAG8AdAAgAGgAYQB2
AGUAIABzAGkAegBlAABDRABpAHIAZQBjAHQAbwByAHkAIABjAG8AbQBwAHIAZQBzAHMAZQBkACAA
cwBpAHoAZQAgAGkAbgB2AGEAbABpAGQAAB9OAGEAbQBlACAAaQBzACAAaQBuAHYAYQBsAGkAZAAA
f1MAaQB6AGUAIABtAGkAcwBtAGEAdABjAGgAIABiAGUAdAB3AGUAZQBuACAAYwBlAG4AdAByAGEA
bAAgAGgAZQBhAGQAZQByACgAewAwAH0AKQAgAGEAbgBkACAAbABvAGMAYQBsACAAaABlAGEAZABl
AHIAKAB7ADEAfQApAACAlUMAbwBtAHAAcgBlAHMAcwBlAGQAIABzAGkAegBlACAAbQBpAHMAbQBh
AHQAYwBoACAAYgBlAHQAdwBlAGUAbgAgAGMAZQBuAHQAcgBhAGwAIABoAGUAYQBkAGUAcgAoAHsA
MAB9ACkAIABhAG4AZAAgAGwAbwBjAGEAbAAgAGgAZQBhAGQAZQByACgAewAxAH0AKQAAKWMAYQBu
AG4AbwB0ACAAYgBlACAAYgBlAGwAbwB3ACAAMQAwADIANAAAHWEAcgBjAGgAaQB2AGUAUwB0AG8A
cgBhAGcAZQAAFWQAYQB0AGEAUwBvAHUAcgBjAGUAAEdDAGEAbgBuAG8AdAAgAHUAcABkAGEAdABl
ACAAZQBtAGIAZQBkAGQAZQBkAC8AUwBGAFgAIABhAHIAYwBoAGkAdgBlAHMAAE1DAG8AbQBtAGUA
bgB0ACAAbABlAG4AZwB0AGgAIABlAHgAYwBlAGUAZABzACAAbQBhAHgAaQBtAHUAbQAgAC0AIAA2
ADUANQAzADUAASNjAG8AbQBwAHIAZQBzAHMAaQBvAG4ATQBlAHQAaABvAGQAABNlAG4AdAByAHkA
TgBhAG0AZQAANUUAbgB0AHIAeQAgAGMAYQBuAG4AbwB0ACAAaABhAHYAZQAgAGEAbgB5ACAAZABh
AHQAYQAAG2QAaQByAGUAYwB0AG8AcgB5AE4AYQBtAGUAADdDAGEAbgBuAG8AdAAgAGYAaQBuAGQA
IABlAG4AdAByAHkAIAB0AG8AIABkAGUAbABlAHQAZQAAKUUAbgB0AHIAeQAgAG4AYQBtAGUAIAB0
AG8AbwAgAGwAbwBuAGcALgAAS0kAbgB0AGUAcgBuAGEAbAAgAGUAcgByAG8AcgAgAGMAYQBuAG4A
bwB0ACAAZgBpAG4AZAAgAGUAeAB0AHIAYQAgAGQAYQB0AGEAAHdBAHQAdABlAG0AcAB0ACAAdABv
ACAAdwByAGkAdABlACAAYwBlAG4AdAByAGEAbAAgAGQAaQByAGUAYwB0AG8AcgB5ACAAZQBuAHQA
cgB5ACAAdwBpAHQAaAAgAHUAbgBrAG4AbwB3AG4AIABjAHMAaQB6AGUAAHVBAHQAdABlAG0AcAB0
ACAAdABvACAAdwByAGkAdABlACAAYwBlAG4AdAByAGEAbAAgAGQAaQByAGUAYwB0AG8AcgB5ACAA
ZQBuAHQAcgB5ACAAdwBpAHQAaAAgAHUAbgBrAG4AbwB3AG4AIABzAGkAegBlAABzQQB0AHQAZQBt
AHAAdAAgAHQAbwAgAHcAcgBpAHQAZQAgAGMAZQBuAHQAcgBhAGwAIABkAGkAcgBlAGMAdABvAHIA
eQAgAGUAbgB0AHIAeQAgAHcAaQB0AGgAIAB1AG4AawBuAG8AdwBuACAAYwByAGMAAC9FAG4AdABy
AHkAIABuAGEAbQBlACAAaQBzACAAdABvAG8AIABsAG8AbgBnAC4AAC9VAG4AeABwAGUAYwB0AGUA
ZAAgAGUAbgBkACAAbwBmACAAcwB0AHIAZQBhAG0AAEdEAGUAcwB0AGkAbgBhAHQAaQBvAG4AIABh
AG4AZAAgAHMAbwB1AHIAYwBlACAAYQByAGUAIAB0AGgAZQAgAHMAYQBtAGUAAFVGAGEAaQBsAGUA
ZAAgAHQAbwAgAGMAbwBwAHkAIABiAHkAdABlAHMAIABlAHgAcABlAGMAdABlAGQAIAB7ADAAfQAg
AHIAZQBhAGQAIAB7ADEAfQAAN1UAbgBrAG4AbwB3AG4AIABjAG8AbQBwAHIAZQBzAHMAaQBvAG4A
IABtAGUAdABoAG8AZAAgAAA/RQBuAHQAcgB5ACAAcwBpAHoAZQAvAHMAdAByAGUAYQBtACAAcwBp
AHoAZQAgAG0AaQBzAG0AYQB0AGMAaAAASUYAYQBpAGwAZQBkACAAdABvACAAcgBlAG8AcABlAG4A
IABhAHIAYwBoAGkAdgBlACAALQAgAG4AbwAgAHMAbwB1AHIAYwBlAAE/TgBhAG0AZQAgAGkAcwAg
AG4AbwB0ACAAawBuAG8AdwBuACAAYwBhAG4AbgBvAHQAIABSAGUAbwBwAGUAbgAAO0MAYQBuAG4A
bwB0ACAAZgBpAG4AZAAgAGMAZQBuAHQAcgBhAGwAIABkAGkAcgBlAGMAdABvAHIAeQAAP0IAZQBn
AGkAbgBVAHAAZABhAHQAZQAgAGgAYQBzACAAbgBvAHQAIABiAGUAZQBuACAAYwBhAGwAbABlAGQA
ABtFAG4AZAAgAG8AZgAgAHMAdAByAGUAYQBtAAA/WgBpAHAARgBpAGwAZQAgAHMAdAByAGUAYQBt
ACAAbQB1AHMAdAAgAGIAZQAgAHMAZQBlAGsAYQBiAGwAZQAAM0MAYQBuAG4AbwB0ACAAZgBpAG4A
ZAAgAFoAaQBwADYANAAgAGwAbwBjAGEAdABvAHIAAGVJAG4AdgBhAGwAaQBkACAAWgBpAHAANgA0
ACAAQwBlAG4AdAByAGEAbAAgAGQAaQByAGUAYwB0AG8AcgB5ACAAcwBpAGcAbgBhAHQAdQByAGUA
IABhAHQAIAB7ADAAOgBYAH0AADlJAG4AdgBhAGwAaQBkACAAZQBtAGIAZQBkAGQAZQBkACAAegBp
AHAAIABhAHIAYwBoAGkAdgBlAABDVwByAG8AbgBnACAAQwBlAG4AdAByAGEAbAAgAEQAaQByAGUA
YwB0AG8AcgB5ACAAcwBpAGcAbgBhAHQAdQByAGUAAFVOAG8AIABwAGEAcwBzAHcAbwByAGQAIABh
AHYAYQBpAGwAYQBiAGwAZQAgAGYAbwByACAAZQBuAGMAcgB5AHAAdABlAGQAIABzAHQAcgBlAGEA
bQAAXU4AbwAgAHAAYQBzAHMAdwBvAHIAZAAgAGEAdgBhAGkAbABhAGIAbABlACAAZgBvAHIAIABB
AEUAUwAgAGUAbgBjAHIAeQBwAHQAZQBkACAAcwB0AHIAZQBhAG0AACVBAEUAUwAgAFMAYQBsAHQA
IABlAHgAcABlAGMAdABlAGQAIAAACyAAZwBvAHQAIAAAMUkAbgB2AGEAbABpAGQAIABwAGEAcwBz
AHcAbwByAGQAIABmAG8AcgAgAEEARQBTAAA/RABlAGMAcgB5AHAAdABpAG8AbgAgAG0AZQB0AGgA
bwBkACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAIUkAbgB2AGEAbABpAGQAIABwAGEAcwBz
AHcAbwByAGQAADtDAGEAbgB0ACAAaABhAG4AZABsAGUAIABuAG8AbgAgAGYAaQBsAGUAIABhAHIA
YwBoAGkAdgBlAHMAAElOAG8AIAB0AGUAbQBwAG8AcgBhAHIAeQAgAHMAdAByAGUAYQBtACAAaABh
AHMAIABiAGUAZQBuACAAYwByAGUAYQB0AGUAZAAAHXsAMAB9AC4AewAxAH0AewAyAH0ALgB0AG0A
cAAAR0kAbgB0AGUAcgBuAGEAbAAgAGUAcgByAG8AcgAgAGMAYQBuAHQAIABmAGkAbgBkACAAZQB4
AHQAcgBhACAAZABhAHQAYQAAX0MAbwBtAG0AZQBuAHQAIABsAGUAbgBnAHQAaAAoAHsAMAB9ACkA
IABpAHMAIAB0AG8AbwAgAGwAbwBuAGcAIABjAGEAbgAgAG8AbgBsAHkAIABiAGUAIAA2ADQASwAA
R0QAYQB0AGEAIABkAGUAcwBjAHIAaQBwAHQAbwByACAAcwBpAGcAbgBhAHQAdQByAGUAIABuAG8A
dAAgAGYAbwB1AG4AZAAAD0MAbABvAHMAZQBkAC4AAEFXAHIAbwBuAGcAIABMAG8AYwBhAGwAIABo
AGUAYQBkAGUAcgAgAHMAaQBnAG4AYQB0AHUAcgBlADoAIAAwAHgAAAt7ADAAOgBYAH0AAE1TAHQA
bwByAGUAZAAsACAAYgB1AHQAIABjAG8AbQBwAHIAZQBzAHMAZQBkACAAIQA9ACAAdQBuAGMAbwBt
AHAAcgBlAHMAcwBlAGQAAA1DAGwAbwBzAGUAZAAAL1oAaQBwACAAYQByAGMAaABpAHYAZQAgAGUA
bgBkAHMAIABlAGEAcgBsAHkALgAAVUwAZQBuAGcAdABoACAAbgBvAHQAIABhAHYAYQBpAGwAYQBi
AGwAZQAgAGYAbwByACAAdABoAGUAIABjAHUAcgByAGUAbgB0ACAAZQBuAHQAcgB5AAAhTgBvACAA
YwB1AHIAcgBlAG4AdAAgAGUAbgB0AHIAeQAAP1UAbgBhAGIAbABlACAAdABvACAAcgBlAGEAZAAg
AGYAcgBvAG0AIAB0AGgAaQBzACAAcwB0AHIAZQBhAG0AAG1UAGgAZQAgAGMAbwBtAHAAcgBlAHMA
cwBpAG8AbgAgAG0AZQB0AGgAbwBkACAAZgBvAHIAIAB0AGgAaQBzACAAZQBuAHQAcgB5ACAAaQBz
ACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAcUwAaQBiAHIAYQByAHkAIABjAGEAbgBuAG8A
dAAgAGUAeAB0AHIAYQBjAHQAIAB0AGgAaQBzACAAZQBuAHQAcgB5AC4AIABWAGUAcgBzAGkAbwBu
ACAAcgBlAHEAdQBpAHIAZQBkACAAaQBzACAAKAAAAykAACFOAG8AIABwAGEAcwBzAHcAbwByAGQA
IABzAGUAdAAuAABlRQBuAHQAcgB5ACAAYwBvAG0AcAByAGUAcwBzAGUAZAAgAHMAaQB6AGUAIAB7
ADAAfQAgAHQAbwBvACAAcwBtAGEAbABsACAAZgBvAHIAIABlAG4AYwByAHkAcAB0AGkAbwBuAAAl
QwBhAG4AbgBvAHQAIABiAGUAIABuAGUAZwBhAHQAaQB2AGUAAEFJAG4AdgBhAGwAaQBkACAAbwBm
AGYAcwBlAHQALwBjAG8AdQBuAHQAIABjAG8AbQBiAGkAbgBhAHQAaQBvAG4AAEVPAGYAZgBzAGUA
dAAgACsAIABjAG8AdQBuAHQAIABlAHgAYwBlAGUAZABzACAAYgB1AGYAZgBlAHIAIABzAGkAegBl
AAAtSQBuAGYAbABhAHQAZQByACAAbgBvAHQAIABmAGkAbgBpAHMAaABlAGQAIQAAH1MAaQB6AGUA
IABtAGkAcwBtAGEAdABjAGgAOgAgAAADOwAACyAAPAAtAD4AIAABJ0UATwBGACAAaQBuACAAcwB0
AG8AcgBlAGQAIABiAGwAbwBjAGsAAAUvAC8AAA9jAG8AbQBtAGUAbgB0AAA5WgBpAHAATwB1AHQA
cAB1AHQAUwB0AHIAZQBhAG0AIAB3AGEAcwAgAGYAaQBuAGkAcwBoAGUAZAAAO1QAbwBvACAAbQBh
AG4AeQAgAGUAbgB0AHIAaQBlAHMAIABmAG8AcgAgAFoAaQBwACAAZgBpAGwAZQAAG04AbwAgAG8A
cABlAG4AIABlAG4AdAByAHkAABNzAGkAegBlACAAdwBhAHMAIAAAIywAIABiAHUAdAAgAEkAIABl
AHgAcABlAGMAdABlAGQAIAAAKWMAbwBtAHAAcgBlAHMAcwBlAGQAIABzAGkAegBlACAAdwBhAHMA
IAAAEWMAcgBjACAAdwBhAHMAIAAAY0UAbgB0AHIAeQAgAHIAZQBxAHUAaQByAGUAcwAgAHoAaQBw
ADYANAAgAGIAdQB0ACAAdABoAGkAcwAgAGgAYQBzACAAYgBlAGUAbgAgAHQAdQByAG4AZQBkACAA
bwBmAGYAAB1OAG8AIABvAHAAZQBuACAAZQBuAHQAcgB5AC4AAB1OAGEAbQBlACAAdABvAG8AIABs
AG8AbgBnAC4AACNDAG8AbQBtAGUAbgB0ACAAdABvAG8AIABsAG8AbgBnAC4AAAtsAGUAdgBlAGwA
AC9GAGkAbgBpAHMAaAAoACkAIABhAGwAcgBlAGEAZAB5ACAAYwBhAGwAbABlAGQAAB9EAGUAZgBs
AGEAdABlAHIAIABjAGwAbwBzAGUAZAAAN3UAbgBrAG4AbwB3AG4AIABjAG8AbQBwAHIAZQBzAHMA
aQBvAG4ARgB1AG4AYwB0AGkAbwBuAABNTwBsAGQAIABpAG4AcAB1AHQAIAB3AGEAcwAgAG4AbwB0
ACAAYwBvAG0AcABsAGUAdABlAGwAeQAgAHAAcgBvAGMAZQBzAHMAZQBkAAAvSABlAGEAZABlAHIA
IABjAGgAZQBjAGsAcwB1AG0AIABpAGwAbABlAGcAYQBsAAA1QwBvAG0AcAByAGUAcwBzAGkAbwBu
ACAATQBlAHQAaABvAGQAIAB1AG4AawBuAG8AdwBuAAAvSQBsAGwAZQBnAGEAbAAgAHIAZQBwACAA
bABlAG4AZwB0AGgAIABjAG8AZABlAAArSQBsAGwAZQBnAGEAbAAgAHIAZQBwACAAZABpAHMAdAAg
AGMAbwBkAGUAACtJAG4AZgBsAGEAdABlAHIAIAB1AG4AawBuAG8AdwBuACAAbQBvAGQAZQAAOUEA
ZABsAGUAcgAgAGMAaABrAHMAdQBtACAAZABvAGUAcwBuACcAdAAgAG0AYQB0AGMAaAA6ACAAAQsg
AHYAcwAuACAAACdVAG4AawBuAG8AdwBuACAAYgBsAG8AYwBrACAAdAB5AHAAZQAgAAAzYgByAG8A
awBlAG4AIAB1AG4AYwBvAG0AcAByAGUAcwBzAGUAZAAgAGIAbABvAGMAawAAOUkAbgBmAGwAYQB0
AGUAcgAuAEQAZQBjAG8AZABlACAAdQBuAGsAbgBvAHcAbgAgAG0AbwBkAGUAAAtpAG4AZABlAHgA
ADFEAGkAYwB0AGkAbwBuAGEAcgB5ACAAaQBzACAAbgBvAHQAIABuAGUAZQBkAGUAZAAAKVcAcgBv
AG4AZwAgAGEAZABsAGUAcgAgAGMAaABlAGMAawBzAHUAbQAAMWMAbwB1AG4AdAAgAGMAYQBuAG4A
bwB0ACAAYgBlACAAbgBlAGcAYQB0AGkAdgBlAAAzbwBmAGYAcwBlAHQAIABjAGEAbgBuAG8AdAAg
AGIAZQAgAG4AZQBnAGEAdABpAHYAZQAAN2MAbwB1AG4AdAAgAGUAeABjAGUAZQBkAHMAIABiAHUA
ZgBmAGUAcgAgAGIAbwB1AG4AZABzAABfSQBuAGYAbABhAHQAZQByAEgAdQBmAGYAbQBhAG4AVABy
AGUAZQA6ACAAcwB0AGEAdABpAGMAIAB0AHIAZQBlACAAbABlAG4AZwB0AGgAIABpAGwAbABlAGcA
YQBsAAAhYgBhAHMAZQBPAHUAdABwAHUAdABTAHQAcgBlAGEAbQAAKU0AdQBzAHQAIABzAHUAcABw
AG8AcgB0ACAAdwByAGkAdABpAG4AZwAAEWQAZQBmAGwAYQB0AGUAcgAAFWIAdQBmAGYAZQByAFMA
aQB6AGUAADFDAGEAbgAnAHQAIABkAGUAZgBsAGEAdABlACAAYQBsAGwAIABpAG4AcAB1AHQAPwAB
W0QAZQBmAGwAYQB0AGUAcgBPAHUAdABwAHUAdABTAHQAcgBlAGEAbQAgAGMAYQBuACcAdAAgAGQA
ZQBmAGwAYQB0AGUAIABhAGwAbAAgAGkAbgBwAHUAdAA/AAE/UABvAHMAaQB0AGkAbwBuACAAcABy
AG8AcABlAHIAdAB5ACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAT0QAZQBmAGwAYQB0AGUA
cgBPAHUAdABwAHUAdABTAHQAcgBlAGEAbQAgAFMAZQBlAGsAIABuAG8AdAAgAHMAdQBwAHAAbwBy
AHQAZQBkAABZRABlAGYAbABhAHQAZQByAE8AdQB0AHAAdQB0AFMAdAByAGUAYQBtACAAUwBlAHQA
TABlAG4AZwB0AGgAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABXRABlAGYAbABhAHQAZQBy
AE8AdQB0AHAAdQB0AFMAdAByAGUAYQBtACAAUgBlAGEAZABCAHkAdABlACAAbgBvAHQAIABzAHUA
cABwAG8AcgB0AGUAZAAAT0QAZQBmAGwAYQB0AGUAcgBPAHUAdABwAHUAdABTAHQAcgBlAGEAbQAg
AFIAZQBhAGQAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABtRABlAGYAbABhAHQAZQByAE8A
dQB0AHAAdQB0AFMAdAByAGUAYQBtACAAQgBlAGcAaQBuAFIAZQBhAGQAIABuAG8AdAAgAGMAdQBy
AHIAZQBuAHQAbAB5ACAAcwB1AHAAcABvAHIAdABlAGQAADdCAGUAZwBpAG4AVwByAGkAdABlACAA
aQBzACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAADWwAZQBuAGcAdABoAAAbRQBPAEYAIABp
AG4AIABoAGUAYQBkAGUAcgAAH2IAYQBzAGUASQBuAHAAdQB0AFMAdAByAGUAYQBtAAARaQBuAGYA
bABhAHQAZQByAAAdVQBuAGUAeABwAGUAYwB0AGUAZAAgAEUATwBGAABVSQBuAGYAbABhAHQAZQBy
AEkAbgBwAHUAdABTAHQAcgBlAGEAbQAgAFAAbwBzAGkAdABpAG8AbgAgAG4AbwB0ACAAcwB1AHAA
cABvAHIAdABlAGQAACVTAGUAZQBrACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAV0kAbgBm
AGwAYQB0AGUAcgBJAG4AcAB1AHQAUwB0AHIAZQBhAG0AIABTAGUAdABMAGUAbgBnAHQAaAAgAG4A
bwB0ACAAcwB1AHAAcABvAHIAdABlAGQAAE9JAG4AZgBsAGEAdABlAHIASQBuAHAAdQB0AFMAdABy
AGUAYQBtACAAVwByAGkAdABlACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAV0kAbgBmAGwA
YQB0AGUAcgBJAG4AcAB1AHQAUwB0AHIAZQBhAG0AIABXAHIAaQB0AGUAQgB5AHQAZQAgAG4AbwB0
ACAAcwB1AHAAcABvAHIAdABlAGQAAFlJAG4AZgBsAGEAdABlAHIASQBuAHAAdQB0AFMAdAByAGUA
YQBtACAAQgBlAGcAaQBuAFcAcgBpAHQAZQAgAG4AbwB0ACAAcwB1AHAAcABvAHIAdABlAGQAACNO
AGUAZQBkACAAYQAgAGQAaQBjAHQAaQBvAG4AYQByAHkAAClEAG8AbgB0ACAAawBuAG8AdwAgAHcA
aABhAHQAIAB0AG8AIABkAG8AABdXAGkAbgBkAG8AdwAgAGYAdQBsAGwAABVkAGkAYwB0AGkAbwBu
AGEAcgB5AAA/QgBpAHQAIABiAHUAZgBmAGUAcgAgAGkAcwAgAG4AbwB0ACAAYgB5AHQAZQAgAGEA
bABpAGcAbgBlAGQAIQAAJWMAYQBuAG4AbwB0ACAAYgBlACAAbgBlAGcAYQB0AGkAdgBlAAA7bgBv
AHQAIABhACAAdgBhAGwAaQBkACAAaQBuAGQAZQB4ACAAaQBuAHQAbwAgAGIAdQBmAGYAZQByAAAn
ZQB4AGMAZQBlAGQAcwAgAGIAdQBmAGYAZQByACAAcwBpAHoAZQAAPUMAbwB1AG4AdAAgAGMAYQBu
AG4AbwB0ACAAYgBlACAAbABlAHMAcwAgAHQAaABhAG4AIAB6AGUAcgBvAAAxYwBhAG4AbgBvAHQA
IABiAGUAIABsAGUAcwBzACAAdABoAGEAbgAgAHoAZQByAG8AABtTAGEAdgBlAEQAaQByAGUAYwB0
AG8AcgB5AAAZXABQAHIAaQBjAGUAVQBwAGQAYQB0AGUAABF5AHkAeQB5AE0ATQBkAGQAAAkuAHoA
aQBwAAAhRQBtAGEAaQBsAEEAdAB0AGEAYwBoAG0AZQBuAHQAcwAACyoALgB4AG0AbAAAcVMAVABf
AGQAYgA5AGMAOQAxADQANwA5ADQAOQA2ADQAZAAyADgAYgBmADYAZgAxAGQANwAxADEANgBkAGQA
MgAyADIAZgAuAFAAcgBvAHAAZQByAHQAaQBlAHMALgBSAGUAcwBvAHUAcgBjAGUAcwAAPU0AbwBk
AGkAZgB5ACAAbgBvAHQAIABjAHUAcgByAGUAbgB0AGwAeQAgAHMAdQBwAHAAbwByAHQAZQBkAAA5
TgBlAGcAYQB0AGkAdgBlACAAcABvAHMAaQB0AGkAbwBuACAAaQBzACAAaQBuAHYAYQBsAGkAZAAA
KUMAYQBuAG4AbwB0ACAAcwBlAGUAawAgAHAAYQBzAHQAIABlAG4AZAAADSEARQBtAHAAdAB5AAAv
SABlAGEAcAAgAGkAbgB2AGEAcgBpAGEAbgB0ACAAdgBpAG8AbABhAHQAZQBkAAAAOC5zrzC5tUeE
DL9cPlMNjwAEIAEBCAMgAAEFIAEBEREEIAEBDgYgAQERgOkHIAIBEjkRPQYgAgEOEkEKBwQSVRJZ
HQUdBQYAAw4cHBwFAAEOHRwHIAMBDh0FCAYgAQERgQkFIAEdBQgIIAISSR0FHQUFIAEBHQUGBwQI
CAUICiAFCB0FCAgdBQgEBwEdBQggAx0FHQUICAQgAB0FCSADARJhEkkRZQwHCQgICAgICB0FCAgH
IAMIHQUICAUHAh0JCAUgAgEODgkAAgESgSURgSkEBwIIBQYgAwEICAgDIAAcAh0FAwcBDAYHAhJI
EjQEBwESNAYHAhI8EigGBwISRBIoBgcCEjgSMBEHCh0OAggdDggOEkESQQ4SQQUAAR0ODgMHAQIH
IAIBDhGBQQcHBAIdDggOAyAACAQgAQMIBSACDggIDAcFAx0DEoCBCBKAiQMgAA4EIAEIHAkQAQII
HR4AHgADCgEDBiABEoCJAwgAARKBSRGBTQggARKBJRKBSQIdDggHAwISgI0STQUgABKAjQQgAQIO
AyAAAgYHAx0OCA4EBwICDgQAAQ4OBAYRgJEGBwICEoCVAyAACgUgABGAkQkAAgIRgJERgJEEBwIC
CgMHAQgEBwICCAcgAwEdBQgIDAcHAhGAkQoKEiwCCAUAABGAkQsAAhGAnRGAkRGAkQkAAgIRgJ0R
gJ0GBwQOCAgIBCABDggHBwMCEkgSNAcHAxJMAhI0BwcDAhI8EigHBwMCEkQSKAcHAwISOBIwBgAB
EYCdDQYAARKAoQ4KBwMSgRASgRASUAsAAhKBZRKBZRKBZQQHARJhDwAEEoChDhGBaRGBbRGBcQ4H
BBKA2BKA2BKAjRKAnAUHARKAnAUAAgIODgoHAxKAoRKAnBJBCwcEAhKAoRGApRJBBAABAg4HAAIB
DhGAkQcAAgEOEYClBwcEAg4OEkEGAAESgLUOBSAAEYClBAAAHQMFIAEIHQMFAAIODg4CBg4FAAII
Dg4FBwIdAwgMAAUBEoElCBKBJQgIBgcCCBKAiQUgAg4ODgQgAQgOBSACAQgDBiACCB0DCAYAARKB
eQgHIAMOHQUICAUAABKBeQUgAR0FDgUAABKBfQUgABKA5QUgABKBgQQHAgILCAcGCQkJCQkIBQAC
CQkJBQACCAgICSAGAQgICAgICAgHBgkJCQkJCQUAAg4cHAwHBhKAvAgKCAgRgJEGAAERgJEKCCAF
AQgICAgICwACEYCREYCREYCdBgcECAgICA0HBRKAnAgCEoCVEYF8DAcEEoCcCBKAtRGBfA4HBhKA
uRKBBAgRgJEICAggBAEdBQgIAhkHChKAuRKBBBGAnQgRgJERgJ0IEYCdCB0FBCABAQUDIAANDAcG
EoC5EoEECAoKCgcgAgoKEYDNCgcDEoC5EoEEHQUFBwESgKgEBwIICAcHBAgIHQUIByACARKBJQgH
BwQCCB0FCAUHARKAwAQAAQEcBQcBEoChBQAAEoDlCQAECA4OAhKA5QMHAQoIBwMKEYCIEmEbBwwS
gMwRgYgCCBKApBKBVBJhHQUKCBKA/BJBBQACDg4cGAcREmECBgYGBgYJCgoICB0FHQUSgLwICgYA
AgEcEAIGAAMODhwcFAcICB0SgJwIEoCcCBKAjRKBlBJNBSACARwcBiABARKAyQQgARwIBwcCHQUS
gQQFIAIBCBwNBwQSgJwdBRKAvBGAhAsHBB0FEoC8HQUdBQQHARJUBwcECB0FCAgLBwYSgVQdBQoK
CAgEIAEBCgwHBwoSgVQdBQoKCAgEBwIIDgQgAQIcBCABHBwHBwISYRGAiAsHBhJhEmEKCgoSYQgH
BAoKEmESYQcHBQIKCgkJBQcDCgkJCwcEChKBBBKBBB0FIAcOCgoCChKA2AodBRKAjRKBlBGBjBJN
EoGUEoEEEoGUBAABAQ4FBwISYQIGBwISgQQKIgcbCgcLCwsKCQIdBQsLCAgICAkJCgoICAgJCh0F
EoCcHQURBwkSXRIkCB0FCB0FCBIMHQUGBwISXRIkAwAADgYHAxJhDgIFAAIBDg4GAAMBDg4CCiAD
AQ4RgWkRgW0MBwYOCAgRgJEOEoChBwAEDg4cHBwOBwYRgIgCAh0FEoC8HQUEBwIKCgUAAgoKCg0H
CQgGCQgIAh0FDh0FBQcCHQUKCQcECBIkHQUdBQYAAw4ODg4EBwIOCAQgAQgDDgcGEYCICAIdBRKA
vB0FBgcCHQUdBQUHARGAiAUHAh0FCBgHCgoKEoCNEoCcHQUSgLwdBR0FEk0SgQQJBwcICAgICAgI
BQcDAgIIBQcDCAgIBAcCBggOBwsICB0GCAgICAgIBQUEBwIIAgYHBAgCCAIHBwUICAgIAggHBggI
CAgICAcHBQgICAgICAcGCAgIBQgIFgcSHQgdCAgICAgICAgICAgICAgICAgGBwISJB0FBwcECB0F
CAoEBwIJCQUHAwkJCAcHAw4OEYCRBSAAEoGpBSAAEoGtBiABEoGxHAQgAQ4OBwAEDg4ODg4EIAEB
HBYHCwgODh0OEoEQHQUdDggSgJwSgKEIBgACHQ4ODgUgABKBtQcgAgEOEoG1CwcFEoGUEoGUCAgK
BwcEEmECCggHBwQSYQIICAgHBR0ICAgICBoHFQgdCAgIHQgdCAgICAgICAgICAgICAgICBEHDggI
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
IAESYRJhBiABARGA1AkgAgESgNgRgNQFAAIODgIFIAASgLkJIAIBEoCcEoEABiADAQoKCgggBAEK
CgodBQcgAgECEoD8BiACARJhCAUAAgIOAgkAAgESgJwSgLwFIAIBCAIGIAEBEYEcBSABCB0FBiAB
ARKBKAUgAgICAgUgABGBHAUgAgIICAQAAQYIBAABCAgGIAECEoFMBSAAEoE0BiABCBKBTAUgAgEI
CAggAgESYRKBFAkgAwESYRKBFAgNIAQBEoCcDhAdBRAdBQsgBRJ5HQUICBJ9HAYgAQESgSwFIAEB
EkkIIAIBEmESgSwJIAMBEmESgSwIBCABCgoHIAIIEoFMCAQgAQgIBQACCQkFBQAAEoDhBgABARKA
5QUAABKBaAggAxJ5DhJ9HAUgAQISeQcgAgEcEoDACyAEEnkcEoDAEn0cBSACCBwcByACAQ4SgJwI
IAMBDg4RgIgJIAIBEoDcEoCcCSACARKAnBKAnAkgAgERgYwSgJwFIAARgYwGAAEOEoGYByABAR0S
gJwIIAMBEoDYCgoFIAEIEnkJIAQBEoEkCAgIByACAR0GHQUGIAEBEoGsBSABAR0IBCgAHQUDKAAI
AygAAgUoAB0SbQMoAA4DKAAMAygACgQoABJBBSgAEYCRBSgAEYCdBCgAElQEKAASfAUoABGAhAMo
AAMDCAAIAygABQUoABGAiAUoABGBfAMoAAYFKAARgYAFKAARgMgFKAASgNgFKAASgJwGKAESgJwI
BSgAEYDUBSgAEoC5BSgAEYEcBCgAEkkFCAASgOEFCAASgOUFCAASgWgFKAARgYwDKAAcCAEACAAA
AAAAHgEAAQBUAhZXcmFwTm9uRXhjZXB0aW9uVGhyb3dzAQgBAAIAAAAAACgBACNTVF9kYjljOTE0
Nzk0OTY0ZDI4YmY2ZjFkNzExNmRkMjIyZgAABQEAAAAAFgEAEUNvcHlyaWdodCBAICAyMDE4AABJ
AQAaLk5FVEZyYW1ld29yayxWZXJzaW9uPXY0LjUBAFQOFEZyYW1ld29ya0Rpc3BsYXlOYW1lEi5O
RVQgRnJhbWV3b3JrIDQuNRYBABFVc2UgQ2xvbmUgaW5zdGVhZAAAHgEAGVVzZSBWZXJzaW9uTWFk
ZUJ5IGluc3RlYWQAACgBACNVc2UgVmVyc2lvblN0cm9uZ0VuY3J5cHRpb24gaW5zdGVhZAAAJAEA
H1VzZSBMb2NhbEhlYWRlckJhc2VTaXplIGluc3RlYWQAACMBAB5Vc2UgRGF0YURlc2NyaXB0b3JT
aXplIGluc3RlYWQAACYBACFVc2UgQ2VudHJhbEhlYWRlckJhc2VTaXplIGluc3RlYWQAACsBACZV
c2UgRW5kT2ZDZW50cmFsUmVjb3JkQmFzZVNpemUgaW5zdGVhZAAAIQEAHFVzZSBDcnlwdG9IZWFk
ZXJTaXplIGluc3RlYWQAACUBACBVc2UgTG9jYWxIZWFkZXJTaWduYXR1cmUgaW5zdGVhZAAAIgEA
HVVzZSBTcGFubmluZ1NpZ25hdHVyZSBpbnN0ZWFkAAAmAQAhVXNlIFNwYW5uaW5nVGVtcFNpZ25h
dHVyZSBpbnN0ZWFkAAAoAQAjVXNlIERhdGFEZXNjcmlwdG9yU2lnbmF0dXJlIGluc3RlYWQAACcB
ACJVc2UgQ2VudHJhbEhlYWRlclNpZ25hdHVyZSBpbnN0ZWFkAAAwAQArVXNlIFppcDY0Q2VudHJh
bEZpbGVIZWFkZXJTaWduYXR1cmUgaW5zdGVhZAAALQEAKFVzZSBDZW50cmFsSGVhZGVyRGlnaXRh
bFNpZ25hdXJlIGluc3RlYWQAAC8BACpVc2UgRW5kT2ZDZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJl
IGluc3RlYWQAACMBAB5Vc2UgRXh0ZW5kZWRQYXRoRmlsdGVyIGluc3RlYWQAABEBAAxFbnRyeUJ5
SW5kZXgAACMBAB5Vc2UgdGhlIENvdW50IHByb3BlcnR5IGluc3RlYWQAAAAAALQAAADOyu++AQAA
AJEAAABsU3lzdGVtLlJlc291cmNlcy5SZXNvdXJjZVJlYWRlciwgbXNjb3JsaWIsIFZlcnNpb249
NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5
I1N5c3RlbS5SZXNvdXJjZXMuUnVudGltZVJlc291cmNlU2V0AgAAAAAAAAAAAAAAUEFEUEFEULQA
AACYFwIAAAAAAAAAAACyFwIAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApBcCAAAAAAAAAAAAAABf
Q29yRGxsTWFpbgBtc2NvcmVlLmRsbAAAAAAA/yUAIAAQAAAAAAQAAAAEAAAABAAAAAQAAAAIAAAA
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
YG2t+NdwbPzSICviZT3q5rwbqesLBmjvtrsn1wGm5tPYgKXeb51k2mrNI8Td0OLABPahzbPrYMl+
jT69yZD/uRC2vLSnq32wovs6rhXm+6rMwLine915o8ZgNptxffefqFu0kh9GdZYaFjKIrQvzjHQt
sIHDMHGFmZCKXS6NS1n3qwhUQLbJUEXmjk7y+09KK90MR5zAzUMhfYJ7lmBDf09GAHL4W8F2/QuG
aEoWR2yTMARhJC3FZelLmxFeVloVh3AZGDBt2Bw1PZ8CgiBeBlsGHQvsG9wPUaaTN+a7UjM/nRE+
iIDQOo3QlyQ6zVYg4+sVLVT21Cl5JqnFzjtowRcdK8ygAOrIpVCt1hJNbNLLay/ffHbu28HLoeN2
1mDnr/Aj6hjt4u4dvaXwqqBk9HOGJ/nEm+b9Cf24ib7geY1nxjqA0Nv7hNWLvJpiln2eu7A+kwyt
/5exELCvBg1xq98rMqZoNvOibWa0vNp7dbgDXTa1tED3sQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAADAAAAAwAAAAMAAAADAAAA
BAAAAAQAAAAEAAAABAAAAAUAAAAFAAAABQAAAAUAAAAAAAAAAAAAAAAAAAAEAAAABQAAAAYAAAAE
AAAAEAAAABAAAAAgAAAAgAAAAAIBAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAACAAAAAgAAAAMA
AAADAAAABAAAAAQAAAAFAAAABQAAAAYAAAAGAAAABwAAAAcAAAAIAAAACAAAAAkAAAAJAAAACgAA
AAoAAAALAAAACwAAAAwAAAAMAAAADQAAAA0AAAAACAQMAgoGDgEJBQ0DCwcPAgAAAAMAAAAHAAAA
AAAAAAMAAAADAAAACwAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAcAAAAJAAAADQAAABEAAAAZ
AAAAIQAAADEAAABBAAAAYQAAAIEAAADBAAAAAQEAAIEBAAABAgAAAQMAAAEEAAABBgAAAQgAAAEM
AAABEAAAARgAAAEgAAABMAAAAUAAAAFgAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAA
AAsAAAANAAAADwAAABEAAAATAAAAFwAAABsAAAAfAAAAIwAAACsAAAAzAAAAOwAAAEMAAABTAAAA
YwAAAHMAAACDAAAAowAAAMMAAADjAAAAAgEAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAIAAAAC
AAAAAgAAAAIAAAACAAAAAAAAAAQAAAAIAAAAIAAAABAAAAAgAAAAgAAAAAABAAAABAAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAEAAAABgAAIAAAAAAAAAA
AAAAAAAAAAEAAQAAADAAAIAAAAAAAAAAAAAAAAAAAAEAAAAAAEgAAABYQAIAGgQAAAAAAAAAAAAA
GgQ0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAAAL0E7/4AAAEAAAABAHCGtBoA
AAEAcIa0Gj8AAAAAAAAABAAAAAIAAAAAAAAAAAAAAAAAAABEAAAAAQBWAGEAcgBGAGkAbABlAEkA
bgBmAG8AAAAAACQABAAAAFQAcgBhAG4AcwBsAGEAdABpAG8AbgAAAAAAAACwBHoDAAABAFMAdABy
AGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAAFYDAAABADAAMAAwADAAMAA0AGIAMAAAABoAAQABAEMA
bwBtAG0AZQBuAHQAcwAAAAAAAAAiAAEAAQBDAG8AbQBwAGEAbgB5AE4AYQBtAGUAAAAAAAAAAABw
ACQAAQBGAGkAbABlAEQAZQBzAGMAcgBpAHAAdABpAG8AbgAAAAAAUwBUAF8AZABiADkAYwA5ADEA
NAA3ADkANAA5ADYANABkADIAOABiAGYANgBmADEAZAA3ADEAMQA2AGQAZAAyADIAMgBmAAAAPgAP
AAEARgBpAGwAZQBWAGUAcgBzAGkAbwBuAAAAAAAxAC4AMAAuADYAOAAzADYALgAzADQANAAxADYA
AAAAAHAAKAABAEkAbgB0AGUAcgBuAGEAbABOAGEAbQBlAAAAUwBUAF8AZABiADkAYwA5ADEANAA3
ADkANAA5ADYANABkADIAOABiAGYANgBmADEAZAA3ADEAMQA2AGQAZAAyADIAMgBmAC4AZABsAGwA
AABIABIAAQBMAGUAZwBhAGwAQwBvAHAAeQByAGkAZwBoAHQAAABDAG8AcAB5AHIAaQBnAGgAdAAg
AEAAIAAgADIAMAAxADgAAAAqAAEAAQBMAGUAZwBhAGwAVAByAGEAZABlAG0AYQByAGsAcwAAAAAA
AAAAAHgAKAABAE8AcgBpAGcAaQBuAGEAbABGAGkAbABlAG4AYQBtAGUAAABTAFQAXwBkAGIAOQBj
ADkAMQA0ADcAOQA0ADkANgA0AGQAMgA4AGIAZgA2AGYAMQBkADcAMQAxADYAZABkADIAMgAyAGYA
LgBkAGwAbAAAAGgAJAABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAUwBUAF8AZABiADkAYwA5
ADEANAA3ADkANAA5ADYANABkADIAOABiAGYANgBmADEAZAA3ADEAMQA2AGQAZAAyADIAMgBmAAAA
QgAPAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgA2ADgAMwA2AC4AMwA0
ADQAMQA2AAAAAABGAA8AAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAA
LgA2ADgAMwA2AC4AMwA0ADQAMQA2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAIADAAAAMQ3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</BinaryItem>
        </ScriptProject>
      </DTS:ObjectData>
    </DTS:Executable>
    <DTS:Executable
      DTS:refId="Package\Send Mail Task"
      DTS:CreationName="Microsoft.SendMailTask"
      DTS:Description="Send Mail Task"
      DTS:DTSID="{A08B54E7-5906-40C0-A8AF-A2D321314E59}"
      DTS:ExecutableType="Microsoft.SendMailTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="Send Mail Task"
      DTS:TaskContact="Send Mail Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:PropertyExpression
        DTS:Name="BCCLine">@[$Package::BCCLine]</DTS:PropertyExpression>
      <DTS:PropertyExpression
        DTS:Name="CCLine">@[$Package::CCLine]</DTS:PropertyExpression>
      <DTS:PropertyExpression
        DTS:Name="FileAttachments">@[User::EmailAttachments]</DTS:PropertyExpression>
      <DTS:PropertyExpression
        DTS:Name="FromLine">@[$Package::FromLine]</DTS:PropertyExpression>
      <DTS:PropertyExpression
        DTS:Name="Subject">@[$Package::Subject]</DTS:PropertyExpression>
      <DTS:PropertyExpression
        DTS:Name="ToLine">@[$Package::ToLine]</DTS:PropertyExpression>
      <DTS:ObjectData>
        <SendMailTask:SendMailTaskData
          SendMailTask:SMTPServer="{44746D80-BC52-4CE6-8DCE-21F9A9AE6791}"
          SendMailTask:From="aptak@hcfm.com"
          SendMailTask:To="aptak@hcfm.com"
          SendMailTask:Subject="Factory Price Update"
          SendMailTask:MessageSource="Attached are Contract Price updates for orders that have been Allocated and are still in production by Factories. Please use the Factory App Maintenance to update the Pricing with the Factory specific Price Update file." xmlns:SendMailTask="www.microsoft.com/sqlserver/dts/tasks/sendmailtask" />
      </DTS:ObjectData>
    </DTS:Executable>
  </DTS:Executables>
  <DTS:PrecedenceConstraints>
    <DTS:PrecedenceConstraint
      DTS:refId="Package.PrecedenceConstraints[Constraint]"
      DTS:CreationName=""
      DTS:DTSID="{F9198C99-78C6-44C1-B436-B670FC097845}"
      DTS:From="Package\New Zip Task"
      DTS:LogicalAnd="True"
      DTS:ObjectName="Constraint"
      DTS:To="Package\Send Mail Task" />
    <DTS:PrecedenceConstraint
      DTS:refId="Package.PrecedenceConstraints[Constraint 1]"
      DTS:CreationName=""
      DTS:DTSID="{FC1986AC-CB78-4457-A69A-A63461A0D367}"
      DTS:From="Package\Foreach Hair Factory"
      DTS:LogicalAnd="True"
      DTS:ObjectName="Constraint 1"
      DTS:To="Package\New Zip Task" />
    <DTS:PrecedenceConstraint
      DTS:refId="Package.PrecedenceConstraints[Constraint 2]"
      DTS:CreationName=""
      DTS:DTSID="{5C406C6F-959D-472C-AA23-A50A3B8C3E83}"
      DTS:From="Package\Get Hair Factories"
      DTS:LogicalAnd="True"
      DTS:ObjectName="Constraint 2"
      DTS:To="Package\Foreach Hair Factory" />
    <DTS:PrecedenceConstraint
      DTS:refId="Package.PrecedenceConstraints[Constraint 4]"
      DTS:CreationName=""
      DTS:DTSID="{1F6AFFA3-6C54-4FD4-B501-8BC4A77D0E20}"
      DTS:From="Package\Send Mail Task"
      DTS:LogicalAnd="True"
      DTS:ObjectName="Constraint 4"
      DTS:To="Package\Cleanup Task" />
  </DTS:PrecedenceConstraints>
  <DTS:DesignTimeProperties><![CDATA[<?xml version="1.0"?>
<!--This CDATA section contains the layout information of the package. The section includes information such as (x,y) coordinates, width, and height.-->
<!--If you manually edit this section and make a mistake, you can delete it. -->
<!--The package will still be able to load normally but the previous layout information will be lost and the designer will automatically re-arrange the elements on the design surface.-->
<Objects
  Version="8">
  <!--Each node below will contain properties that do not affect runtime behavior.-->
  <Package
    design-time-name="Package">
    <LayoutInfo>
      <GraphLayout
        Capacity="16" xmlns="clr-namespace:Microsoft.SqlServer.IntegrationServices.Designer.Model.Serialization;assembly=Microsoft.SqlServer.IntegrationServices.Graph" xmlns:mssgle="clr-namespace:Microsoft.SqlServer.Graph.LayoutEngine;assembly=Microsoft.SqlServer.Graph" xmlns:assembly="http://schemas.microsoft.com/winfx/2006/xaml">
        <NodeLayout
          Size="142,42"
          Id="Package\Cleanup Task"
          TopLeft="790.2857277442,147.435296185371" />
        <NodeLayout
          Size="132,42"
          Id="Package\Foreach Hair Factory\Create XML"
          TopLeft="202.400003542219,19.0588256142957" />
        <NodeLayout
          Size="138,42"
          Id="Package\Foreach Hair Factory\Query Prices"
          TopLeft="26.7924528301887,17.8679245283019" />
        <EdgeLayout
          Id="Package\Foreach Hair Factory.PrecedenceConstraints[Constraint 1]"
          TopLeft="164.392452830189,39.2633750712988">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="38.0075507120304,0"
              Start="0,0"
              End="30.5075507120304,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="30.5075507120304,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <ContainerLayout
          HeaderHeight="43.924528301886795"
          IsExpanded="True"
          PanelSize="390,129"
          Size="390,173"
          Id="Package\Foreach Hair Factory"
          TopLeft="5.5,85.5377358490566" />
        <NodeLayout
          Size="162,42"
          Id="Package\Get Hair Factories"
          TopLeft="120.206199577693,6.72352942892421" />
        <NodeLayout
          Size="142,42"
          Id="Package\New Zip Task"
          TopLeft="436.000007425036,153.552943329993" />
        <NodeLayout
          Size="149,42"
          Id="Package\Send Mail Task"
          TopLeft="613.376011102806,149.843618570928" />
        <EdgeLayout
          Id="Package.PrecedenceConstraints[Constraint]"
          TopLeft="577.600007425036,172.49828095046">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="35.7760036777702,0"
              Start="0,0"
              End="28.2760036777702,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="28.2760036777702,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package.PrecedenceConstraints[Constraint 1]"
          TopLeft="395.1,173.145339589525">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="40.9000074250355,0"
              Start="0,0"
              End="33.4000074250355,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="33.4000074250355,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package.PrecedenceConstraints[Constraint 2]"
          TopLeft="200.853099788847,48.3235294289242">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="0,37.2142064201324"
              Start="0,0"
              End="0,29.7142064201324">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="0,29.7142064201324" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package.PrecedenceConstraints[Constraint 4]"
          TopLeft="762.176011102806,169.43945737815">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="28.1097166413941,0"
              Start="0,0"
              End="20.6097166413941,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="20.6097166413941,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
      </GraphLayout>
    </LayoutInfo>
  </Package>
</Objects>]]></DTS:DesignTimeProperties>
</DTS:Executable>