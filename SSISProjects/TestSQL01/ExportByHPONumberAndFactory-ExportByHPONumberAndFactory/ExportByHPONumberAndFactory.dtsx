<?xml version="1.0"?>
<DTS:Executable xmlns:DTS="www.microsoft.com/SqlServer/Dts"
  DTS:refId="Package"
  DTS:CreationDate="1/22/2008 4:09:19 PM"
  DTS:CreationName="Microsoft.Package"
  DTS:CreatorComputerName="ITDWS01"
  DTS:CreatorName="HCFM\mburrell"
  DTS:DelayValidation="True"
  DTS:DTSID="{F237A3EA-4C77-4A65-A2C7-31F9959054F3}"
  DTS:ExecutableType="Microsoft.Package"
  DTS:LastModifiedProductVersion="14.0.3192.2"
  DTS:LocaleID="1033"
  DTS:ObjectName="ExportByHPONumberAndFactory"
  DTS:PackageType="5"
  DTS:ProtectionLevel="5"
  DTS:VersionBuild="612"
  DTS:VersionGUID="{B496804F-E071-40E7-ADBA-DAF8799F4E1D}"
  DTS:VersionMajor="2">
  <DTS:Property
    DTS:Name="PackageFormatVersion">8</DTS:Property>
  <DTS:ConnectionManagers>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[ADO.NET.HairClubCMS]"
      DTS:CreationName="ADO.NET:System.Data.SqlClient.SqlConnection, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
      DTS:DTSID="{9FEC6523-BFEE-491B-8350-50107CA5666F}"
      DTS:ObjectName="ADO.NET.HairClubCMS">
      <DTS:ObjectData>
        <DTS:ConnectionManager
          DTS:ConnectionString="Data Source=HCTestSQL011;User ID=skyline;Initial Catalog=HairClubCMSDevSky;Persist Security Info=True;Application Name=SSIS-ExportByHPONumberAndFactory-{9FEC6523-BFEE-491B-8350-50107CA5666F}ADO.NET.Production;" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[FTP Connection Manager]"
      DTS:CreationName="FTP"
      DTS:DTSID="{1B09DEEF-122C-4A14-90A0-C89849E9E161}"
      DTS:ObjectName="FTP Connection Manager">
      <DTS:ObjectData>
        <DTS:ConnectionManager
          DTS:ConnectionString="ftp.hcfm.com:21">
          <DTS:FtpConnection
            DTS:ServerName="ftp.hcfm.com"
            DTS:ServerUserName="factoryapp"
            DTS:UsePassiveMode="True">
            <DTS:Property
              DTS:Name="ServerPassword"
              Sensitive="1"></DTS:Property>
          </DTS:FtpConnection>
        </DTS:ConnectionManager>
      </DTS:ObjectData>
    </DTS:ConnectionManager>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[HCSQL2.HairClubCMS]"
      DTS:CreationName="OLEDB"
      DTS:DTSID="{A7AC90A7-740D-4852-A755-D24917CEBB39}"
      DTS:ObjectName="HCSQL2.HairClubCMS">
      <DTS:ObjectData>
        <DTS:ConnectionManager
          DTS:ConnectionString="Data Source=HCTestSQL011;User ID=skyline;Initial Catalog=HairClubCMSDevSky;Provider=SQLNCLI11.1;Persist Security Info=True;Auto Translate=False;Application Name=SSIS-ExportByHPONumberAndFactory-{A7AC90A7-740D-4852-A755-D24917CEBB39}HCSQL2.Production;" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[SMTP Connection Manager]"
      DTS:CreationName="SMTP"
      DTS:DTSID="{98039C3A-502D-4E16-9BBB-AAB576E11DDB}"
      DTS:ObjectName="SMTP Connection Manager">
      <DTS:ObjectData>
        <SmtpConnectionManager
          ConnectionString="SmtpServer=HCSMTP.hcfm.com;UseWindowsAuthentication=False;EnableSsl=False;" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
    <DTS:ConnectionManager
      DTS:refId="Package.ConnectionManagers[XML File Generator]"
      DTS:CreationName="FILE"
      DTS:DTSID="{7997E7CF-E6D0-4B1D-9260-483BC58394DA}"
      DTS:ObjectName="XML File Generator">
      <DTS:ObjectData>
        <DTS:ConnectionManager
          DTS:FileUsageType="1" />
      </DTS:ObjectData>
    </DTS:ConnectionManager>
  </DTS:ConnectionManagers>
  <DTS:PackageParameters>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{03EDFB2E-6C3E-443B-8447-DBB9A6644A3B}"
      DTS:ObjectName="EmailFrom">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">aptak@hcfm.com</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{37080989-EC3D-4960-8894-BA974F5ACD95}"
      DTS:ObjectName="LocalXMLFileDirectory">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">c:\temp\HCFilesXML\</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{2B7B3EC4-BE8A-4E6F-8148-8C490930F5FE}"
      DTS:ObjectName="RemoteXMLFTPDirectory">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">/factory app/FactoryData/</DTS:Property>
    </DTS:PackageParameter>
    <DTS:PackageParameter
      DTS:CreationName=""
      DTS:DataType="8"
      DTS:DTSID="{A89D0DED-03DA-4FBA-9387-92688ADA62E7}"
      DTS:ObjectName="XMLNameSpace">
      <DTS:Property
        DTS:DataType="8"
        DTS:Name="ParameterValue">http://www.hcfm.com/CMSFactoryService/</DTS:Property>
    </DTS:PackageParameter>
  </DTS:PackageParameters>
  <DTS:Variables>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{D7402577-8E5B-408F-A9A7-AAB167C49529}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="CurrentHPOGuid">
      <DTS:VariableValue
        DTS:DataType="8">0E2EF224-744B-4013-92A9-0F3147C82F0F</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{8DDA57D6-B7B1-410B-942E-56B865344CC7}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="CurrentHPONumber">
      <DTS:VariableValue
        DTS:DataType="8">222</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{C78F41E1-F62E-40FD-8C7D-24F1A13875F2}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="DestinationZip">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{D846495B-AA60-4EFF-96DC-A39458928A01}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="DestinationZipSource">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{1B49D0B8-B367-4BB8-8F2F-A29246BFD47C}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="EmailCC">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{E6531EB7-E864-4630-8324-F58FAAFFEA14}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="EmailFrom">
      <DTS:VariableValue
        DTS:DataType="8">aptak@hcfm.com</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{F8EBA665-A0D7-4EFB-A306-07B0A9A91308}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="EmailSubject">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{7FE64CD1-4344-404D-AE30-7949CD586FFA}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="EmailTo">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{5D9F2062-0DF9-4739-BDA3-2C08B7F51565}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="ExportFileType">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{02397503-DF0F-4129-AD76-6414DD629E0B}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="Factory">
      <DTS:VariableValue
        DTS:DataType="8">5A</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{69754CF9-5221-414B-8C2E-B3044145830C}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="LocalXMLFilePath">
      <DTS:VariableValue
        DTS:DataType="8">c:\temp\HCFilesXML\</DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{18A6791F-3130-4B5F-A5EA-0CBEBBEBBD96}"
      DTS:IncludeInDebugDump="6789"
      DTS:Namespace="User"
      DTS:ObjectName="PONumbers">
      <DTS:VariableValue
        DTS:DataSubType="ManagedSerializable"
        DTS:DataType="13">
        <SOAP-ENV:Envelope xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
          <SOAP-ENV:Body>
            <xsd:anyType
              id="ref-1"></xsd:anyType>
          </SOAP-ENV:Body>
        </SOAP-ENV:Envelope>
      </DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{BB9DDE32-7B07-4D58-9758-8C08A511BD96}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="PurchaseOrderType">
      <DTS:VariableValue
        DTS:DataType="8"
        xml:space="preserve"></DTS:VariableValue>
    </DTS:Variable>
    <DTS:Variable
      DTS:CreationName=""
      DTS:DTSID="{ED1348F6-4E8E-490F-89FA-E1237D98E12E}"
      DTS:IncludeInDebugDump="2345"
      DTS:Namespace="User"
      DTS:ObjectName="RemoteXMLFTPPath">
      <DTS:VariableValue
        DTS:DataType="8">/factory app/FactoryData/</DTS:VariableValue>
    </DTS:Variable>
  </DTS:Variables>
  <DTS:Executables>
    <DTS:Executable
      DTS:refId="Package\Get PO Numbers"
      DTS:CreationName="Microsoft.ExecuteSQLTask"
      DTS:Description="Execute SQL Task"
      DTS:DTSID="{EBE80716-EAD2-4EFE-9864-F1F3AC0F8EA9}"
      DTS:ExecutableType="Microsoft.ExecuteSQLTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="Get PO Numbers"
      DTS:TaskContact="Execute SQL Task; Microsoft Corporation; Microsoft SQL Server v9; Â© 2004 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:ObjectData>
        <SQLTask:SqlTaskData
          SQLTask:Connection="{9FEC6523-BFEE-491B-8350-50107CA5666F}"
          SQLTask:IsStoredProc="True"
          SQLTask:SqlStatementSource="[dbo].[selGetPONumbers]"
          SQLTask:ResultType="ResultSetType_Rowset" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask">
          <SQLTask:ResultBinding
            SQLTask:ResultName="0"
            SQLTask:DtsVariableName="User::PONumbers" />
          <SQLTask:ParameterBinding
            SQLTask:ParameterName="@MailFrom"
            SQLTask:DtsVariableName="$Package::EmailFrom"
            SQLTask:ParameterDirection="Input"
            SQLTask:DataType="16"
            SQLTask:ParameterSize="-1" />
        </SQLTask:SqlTaskData>
      </DTS:ObjectData>
    </DTS:Executable>
    <DTS:Executable
      DTS:refId="Package\SET PO Number Variables"
      DTS:CreationName="STOCK:FOREACHLOOP"
      DTS:Description="Foreach Loop Container"
      DTS:DTSID="{35CC683A-04B0-4E74-9390-163F8151C88E}"
      DTS:ExecutableType="STOCK:FOREACHLOOP"
      DTS:LocaleID="-1"
      DTS:ObjectName="SET PO Number Variables">
      <DTS:ForEachEnumerator
        DTS:CreationName="Microsoft.ForEachADOEnumerator"
        DTS:DTSID="{2D74873B-600A-47F4-95DA-F328C5A1F739}"
        DTS:ObjectName="{83BD357A-CCFA-4223-BB12-31A069EC87B5}">
        <DTS:ObjectData>
          <FEEADO
            EnumType="EnumerateRowsInFirstTable"
            VarName="User::PONumbers" />
        </DTS:ObjectData>
      </DTS:ForEachEnumerator>
      <DTS:Variables />
      <DTS:Executables>
        <DTS:Executable
          DTS:refId="Package\SET PO Number Variables\Clean Up"
          DTS:CreationName="STOCK:SEQUENCE"
          DTS:Description="Sequence Container"
          DTS:DTSID="{D002E475-6ACF-4C87-8781-3CC7372B897C}"
          DTS:ExecutableType="STOCK:SEQUENCE"
          DTS:LocaleID="-1"
          DTS:ObjectName="Clean Up">
          <DTS:Variables />
          <DTS:Executables>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\Clean Up\Clean Up Local Files"
              DTS:CreationName="Microsoft.ScriptTask"
              DTS:Description="Script Task"
              DTS:DTSID="{907948E6-79FE-426A-9EC0-4A53F8C21269}"
              DTS:ExecutableType="Microsoft.ScriptTask"
              DTS:LocaleID="-1"
              DTS:ObjectName="Clean Up Local Files"
              DTS:ThreadHint="0">
              <DTS:Variables />
              <DTS:ObjectData>
                <ScriptProject
                  Name="ST_1fe10381b30b4832bd24584cd02968f0"
                  VSTAMajorVersion="15"
                  VSTAMinorVersion="0"
                  Language="CSharp"
                  ReadOnlyVariables="User::Factory,$Package::LocalXMLFileDirectory">
                  <ProjectItem
                    Name="Properties\Resources.resx"
                    Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Settings.Designer.cs"
                    Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Settings.get_Default():ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Sett" +
    "ings")]

namespace ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties
{


    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem>
                  <ProjectItem
                    Name="ScriptMain.cs"
                    Encoding="UTF8"><![CDATA[/*
   Microsoft SQL Server Integration Services Script Task
   Write scripts using Microsoft Visual C# 2008.
   The ScriptMain is the entry point class of the script.
*/

using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using System.IO;

namespace ST_1fe10381b30b4832bd24584cd02968f0.csproj
{
    [Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
    public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
    {

        #region VSTA generated code
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

        /*
		The execution engine calls this method when the task executes.
		To access the object model, use the Dts property. Connections, variables, events,
		and logging features are available as members of the Dts property as shown in the following examples.

		To reference a variable, call Dts.Variables["MyCaseSensitiveVariableName"].Value;
		To post a log entry, call Dts.Log("This is my log text", 999, null);
		To fire an event, call Dts.Events.FireInformation(99, "test", "hit the help message", "", 0, true);

		To use the connections collection use something like the following:
		ConnectionManager cm = Dts.Connections.Add("OLEDB");
		cm.ConnectionString = "Data Source=localhost;Initial Catalog=AdventureWorks;Provider=SQLNCLI10;Integrated Security=SSPI;Auto Translate=False;";

		Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
		
		To open Help, press F1.
	*/

        public void Main()
        {

            string dir = (Dts.Variables["LocalXMLFileDirectory"].Value == null ? "" : Dts.Variables["LocalXMLFileDirectory"].Value.ToString()) +
                                (Dts.Variables["Factory"].Value == null ? "" : Dts.Variables["Factory"].Value.ToString());
               
            string dirZip = dir + "\\Zip";

            ClearDirectory(dir);
            ClearDirectory(dirZip);        

            // TODO: Add your code here
            Dts.TaskResult = (int)ScriptResults.Success;
        }

        private void ClearDirectory(string dir)
        {
            if (Directory.Exists(dir))
            {
                var files = Directory.GetFiles(dir);

                foreach (string file in files)
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch (Exception)
                    {
                        //Do Nothing
                    }
                }
            }
        }
    }
}]]></ProjectItem>
                  <ProjectItem
                    Name="st_1fe10381b30b4832bd24584cd02968f0.csproj"
                    Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This section defines project-level properties.

       Configuration - Specifies whether the default configuration is Release or Debug.
       Platform - Specifies what CPU the output of this project can run on.
       OutputType - Must be "Library" for VSTA.
       NoStandardLibraries - Set to "false" for VSTA.
       RootNamespace - In C#, this specifies the namespace given to new files.
                       In Visual Basic, all objects are wrapped in this namespace at runtime.
       AssemblyName - Name of the output assembly.
  -->
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <OutputType>Library</OutputType>
    <NoStandardLibraries>false</NoStandardLibraries>
    <RootNamespace>ST_1fe10381b30b4832bd24584cd02968f0.csproj</RootNamespace>
    <AssemblyName>ST_1fe10381b30b4832bd24584cd02968f0.csproj</AssemblyName>
    <ProjectGuid>{8FE14B59-5E81-498D-9CFA-C891B87AE89E}</ProjectGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <TargetFrameworkProfile></TargetFrameworkProfile>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Debug" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Release" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section enables pre- and post-build steps. However,
       it is recommended that MSBuild tasks be used instead of these properties.
  -->
  <PropertyGroup>
    <PreBuildEvent></PreBuildEvent>
    <PostBuildEvent></PostBuildEvent>
  </PropertyGroup>
  <!-- This sections specifies references for the project. -->
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=14.0.0.0, Culture=Neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=14.0.0.0, Culture=Neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>
  <!-- This section defines the user source files that are part of the
       project.

       Compile - Specifies a source file to compile.
       EmbeddedResource - Specifies a .resx file for embedded resources.
       None - Specifies a file that is not to be passed to the compiler (for instance,
              a text file or XML file).
       AppDesigner - Specifies the directory where the application properties files can
                     be found.
  -->
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
      <SubType>Code</SubType>
    </Compile>
    <!-- Include the default configuration information and metadata files for the add-in.
         These files are copied to the build output directory when the project is
         built, and the path to the configuration file is passed to add-in on the command
         line when debugging.
    -->
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- This section defines VSTA properties that describe the host-changable project properties. -->
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="VSTAHostName" HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}" ApplicationType="usd" Language="cs" TemplatesPath="" DebugInfoExeName="" />
        <Host Name="SSIS_ScriptTask" />
        <ProjectClient>
          <HostIdentifier>SSIS_ST140</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem>
                  <ProjectItem
                    Name="Project"
                    Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="4.0" schemaVersion="1.0">
	<msb:PropertyGroup>
		<msb:CodeName>st_1fe10381b30b4832bd24584cd02968f0</msb:CodeName>
		<msb:Language>msBuild</msb:Language>
		<msb:DisplayName>st_1fe10381b30b4832bd24584cd02968f0</msb:DisplayName>
		<msb:ProjectId>{66205756-2DB1-41EA-BE47-304467BCF96A}</msb:ProjectId>
	</msb:PropertyGroup>
	<msb:ItemGroup>
		<msb:Project Include="st_1fe10381b30b4832bd24584cd02968f0.csproj"/>
		<msb:File Include="Properties\Settings.settings"/>
		<msb:File Include="Properties\AssemblyInfo.cs"/>
		<msb:File Include="Properties\Resources.resx"/>
		<msb:File Include="Properties\Resources.Designer.cs"/>
		<msb:File Include="Properties\Settings.Designer.cs"/>
		<msb:File Include="ScriptMain.cs"/>
	</msb:ItemGroup>
</c:Project>]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\AssemblyInfo.cs"
                    Encoding="UTF8"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_1fe10381b30b4832bd24584cd02968f0.csproj")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ST_1fe10381b30b4832bd24584cd02968f0.csproj")]
[assembly: AssemblyCopyright("Copyright @ Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Settings.settings"
                    Encoding="UTF8"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Resources.Designer.cs"
                    Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_1fe10381b30b4832bd24584cd02968f0.csproj.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem>
                  <BinaryItem
                    Name="ST_1fe10381b30b4832bd24584cd02968f0.csproj.dll">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
GACCACkAcwDqAC4ACwDCAC4AEwDLAC4AGwDqAC4AIwDzAC4AKwAjAS4AMwAjAS4AOwApAS4AQwDz
AC4ASwA4AS4AUwAjAS4AWwBYAUMAYwCCAEkAcwDqAGEAewCCAGMAawCCABsAPgADAAEABAADAAAA
QwSzAAAA0wC4AAAAjgW9AAIABQADAAIABgAFAAEABwAFAAIACAAHAASAAAABAAAAlhqDYAAAAAAA
APcCAAAEAAAAAAAAAAAAAABrADsAAAAAAA4AAAAAAAAAAAAAAHQAIgMAAAAABAAAAAAAAAAAAAAA
awDKAwAAAAAOAAAAAAAAAAAAAAB0ABQAAAAAAAAAAAABAAAAqAQAAAUAAgAAAAAAADxNb2R1bGU+
AFN5c3RlbS5JTwBNaWNyb3NvZnQuU3FsU2VydmVyLk1hbmFnZWREVFMAdmFsdWVfXwBtc2Nvcmxp
YgBkZWZhdWx0SW5zdGFuY2UAVmFyaWFibGUAUnVudGltZVR5cGVIYW5kbGUAR2V0VHlwZUZyb21I
YW5kbGUARmlsZQBNaWNyb3NvZnQuU3FsU2VydmVyLkR0cy5SdW50aW1lAFR5cGUARmFpbHVyZQBn
ZXRfQ3VsdHVyZQBzZXRfQ3VsdHVyZQByZXNvdXJjZUN1bHR1cmUAVlNUQVJUU2NyaXB0T2JqZWN0
TW9kZWxCYXNlAEFwcGxpY2F0aW9uU2V0dGluZ3NCYXNlAEVkaXRvckJyb3dzYWJsZVN0YXRlAERl
bGV0ZQBDb21waWxlckdlbmVyYXRlZEF0dHJpYnV0ZQBEZWJ1Z2dlck5vblVzZXJDb2RlQXR0cmli
dXRlAERlYnVnZ2FibGVBdHRyaWJ1dGUARWRpdG9yQnJvd3NhYmxlQXR0cmlidXRlAEFzc2VtYmx5
VGl0bGVBdHRyaWJ1dGUAQXNzZW1ibHlUcmFkZW1hcmtBdHRyaWJ1dGUAVGFyZ2V0RnJhbWV3b3Jr
QXR0cmlidXRlAEFzc2VtYmx5Q29uZmlndXJhdGlvbkF0dHJpYnV0ZQBBc3NlbWJseURlc2NyaXB0
aW9uQXR0cmlidXRlAENvbXBpbGF0aW9uUmVsYXhhdGlvbnNBdHRyaWJ1dGUAQXNzZW1ibHlQcm9k
dWN0QXR0cmlidXRlAEFzc2VtYmx5Q29weXJpZ2h0QXR0cmlidXRlAFNTSVNTY3JpcHRUYXNrRW50
cnlQb2ludEF0dHJpYnV0ZQBBc3NlbWJseUNvbXBhbnlBdHRyaWJ1dGUAUnVudGltZUNvbXBhdGli
aWxpdHlBdHRyaWJ1dGUAZ2V0X1ZhbHVlAHZhbHVlAFN5c3RlbS5SdW50aW1lLlZlcnNpb25pbmcA
VG9TdHJpbmcAU1RfMWZlMTAzODFiMzBiNDgzMmJkMjQ1ODRjZDAyOTY4ZjAuY3Nwcm9qAE1pY3Jv
c29mdC5TcWxTZXJ2ZXIuU2NyaXB0VGFzawBNaWNyb3NvZnQuU3FsU2VydmVyLkR0cy5UYXNrcy5T
Y3JpcHRUYXNrAFNjcmlwdE9iamVjdE1vZGVsAFN5c3RlbS5Db21wb25lbnRNb2RlbABTVF8xZmUx
MDM4MWIzMGI0ODMyYmQyNDU4NGNkMDI5NjhmMC5jc3Byb2ouZGxsAGdldF9JdGVtAFN5c3RlbQBF
bnVtAHJlc291cmNlTWFuAFNjcmlwdE1haW4AU3lzdGVtLkNvbmZpZ3VyYXRpb24AU3lzdGVtLkds
b2JhbGl6YXRpb24AU3lzdGVtLlJlZmxlY3Rpb24ARXhjZXB0aW9uAEN1bHR1cmVJbmZvAGdldF9S
ZXNvdXJjZU1hbmFnZXIAZGlyAC5jdG9yAC5jY3RvcgBTeXN0ZW0uRGlhZ25vc3RpY3MAU3lzdGVt
LlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcwBTeXN0ZW0uUmVzb3VyY2VzAFNUXzFmZTEwMzgxYjMw
YjQ4MzJiZDI0NTg0Y2QwMjk2OGYwLmNzcHJvai5Qcm9wZXJ0aWVzLlJlc291cmNlcy5yZXNvdXJj
ZXMARGVidWdnaW5nTW9kZXMAU1RfMWZlMTAzODFiMzBiNDgzMmJkMjQ1ODRjZDAyOTY4ZjAuY3Nw
cm9qLlByb3BlcnRpZXMAZ2V0X1ZhcmlhYmxlcwBHZXRGaWxlcwBTZXR0aW5ncwBTdWNjZXNzAGdl
dF9EdHMAU2NyaXB0UmVzdWx0cwBFeGlzdHMAQ29uY2F0AE9iamVjdABnZXRfRGVmYXVsdABzZXRf
VGFza1Jlc3VsdABnZXRfQXNzZW1ibHkAQ2xlYXJEaXJlY3RvcnkAAAAAACtMAG8AYwBhAGwAWABN
AEwARgBpAGwAZQBEAGkAcgBlAGMAdABvAHIAeQAAAQAPRgBhAGMAdABvAHIAeQAACVwAWgBpAHAA
AH9TAFQAXwAxAGYAZQAxADAAMwA4ADEAYgAzADAAYgA0ADgAMwAyAGIAZAAyADQANQA4ADQAYwBk
ADAAMgA5ADYAOABmADAALgBjAHMAcAByAG8AagAuAFAAcgBvAHAAZQByAHQAaQBlAHMALgBSAGUA
cwBvAHUAcgBjAGUAcwAAAAAAhBitxc6uQEWMuV0Lz/OHvAAEIAEBCAMgAAEFIAEBEREEIAEBDgUg
AQERVQQHAg4OBCAAEmUEIAASaQUgARJtHAMgABwDIAAOBQACDg4OBgcDHQ4IDgQAAQIOBQABHQ4O
BAABAQ4HAAESfRGAgQUgABKAhQcgAgEOEoCFCLd6XFYZNOCJCImEXc2AgMyRBAAAAAAEAQAAAAMG
Ek0DBhJRAwYSEAIGCAMGERQEAAASTQQAABJRBQABARJRBAAAEhADAAABBAgAEk0ECAASUQQIABIQ
CAEACAAAAAAAHgEAAQBUAhZXcmFwTm9uRXhjZXB0aW9uVGhyb3dzAQgBAAIAAAAAAC8BACpTVF8x
ZmUxMDM4MWIzMGI0ODMyYmQyNDU4NGNkMDI5NjhmMC5jc3Byb2oAAAUBAAAAAA4BAAlNaWNyb3Nv
ZnQAAB8BABpDb3B5cmlnaHQgQCBNaWNyb3NvZnQgMjAxMQAASQEAGi5ORVRGcmFtZXdvcmssVmVy
c2lvbj12NC41AQBUDhRGcmFtZXdvcmtEaXNwbGF5TmFtZRIuTkVUIEZyYW1ld29yayA0LjUAALQA
AADOyu++AQAAAJEAAABsU3lzdGVtLlJlc291cmNlcy5SZXNvdXJjZVJlYWRlciwgbXNjb3JsaWIs
IFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1
NjE5MzRlMDg5I1N5c3RlbS5SZXNvdXJjZXMuUnVudGltZVJlc291cmNlU2V0AgAAAAAAAAAAAAAA
UEFEUEFEULQAAABYLwAAAAAAAAAAAAByLwAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZC8AAAAA
AAAAAAAAAABfQ29yRGxsTWFpbgBtc2NvcmVlLmRsbAAAAAAA/yUAIAAQAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAABABAAAAAYAACAAAAAAAAAAAAAAAAAAAABAAEAAAAwAACAAAAAAAAAAAAAAAAAAAABAAAA
AABIAAAAWEAAAH4EAAAAAAAAAAAAAH4ENAAAAFYAUwBfAFYARQBSAFMASQBPAE4AXwBJAE4ARgBP
AAAAAAC9BO/+AAABAAAAAQCDYJYaAAABAINglho/AAAAAAAAAAQAAAACAAAAAAAAAAAAAAAAAAAA
RAAAAAEAVgBhAHIARgBpAGwAZQBJAG4AZgBvAAAAAAAkAAQAAABUAHIAYQBuAHMAbABhAHQAaQBv
AG4AAAAAAAAAsATeAwAAAQBTAHQAcgBpAG4AZwBGAGkAbABlAEkAbgBmAG8AAAC6AwAAAQAwADAA
MAAwADAANABiADAAAAAaAAEAAQBDAG8AbQBtAGUAbgB0AHMAAAAAAAAANAAKAAEAQwBvAG0AcABh
AG4AeQBOAGEAbQBlAAAAAABNAGkAYwByAG8AcwBvAGYAdAAAAH4AKwABAEYAaQBsAGUARABlAHMA
YwByAGkAcAB0AGkAbwBuAAAAAABTAFQAXwAxAGYAZQAxADAAMwA4ADEAYgAzADAAYgA0ADgAMwAy
AGIAZAAyADQANQA4ADQAYwBkADAAMgA5ADYAOABmADAALgBjAHMAcAByAG8AagAAAAAAPgAPAAEA
RgBpAGwAZQBWAGUAcgBzAGkAbwBuAAAAAAAxAC4AMAAuADYAOAAwADYALgAyADQANwAwADcAAAAA
AH4ALwABAEkAbgB0AGUAcgBuAGEAbABOAGEAbQBlAAAAUwBUAF8AMQBmAGUAMQAwADMAOAAxAGIA
MwAwAGIANAA4ADMAMgBiAGQAMgA0ADUAOAA0AGMAZAAwADIAOQA2ADgAZgAwAC4AYwBzAHAAcgBv
AGoALgBkAGwAbAAAAAAAWgAbAAEATABlAGcAYQBsAEMAbwBwAHkAcgBpAGcAaAB0AAAAQwBvAHAA
eQByAGkAZwBoAHQAIABAACAATQBpAGMAcgBvAHMAbwBmAHQAIAAyADAAMQAxAAAAAAAqAAEAAQBM
AGUAZwBhAGwAVAByAGEAZABlAG0AYQByAGsAcwAAAAAAAAAAAIYALwABAE8AcgBpAGcAaQBuAGEA
bABGAGkAbABlAG4AYQBtAGUAAABTAFQAXwAxAGYAZQAxADAAMwA4ADEAYgAzADAAYgA0ADgAMwAy
AGIAZAAyADQANQA4ADQAYwBkADAAMgA5ADYAOABmADAALgBjAHMAcAByAG8AagAuAGQAbABsAAAA
AAB2ACsAAQBQAHIAbwBkAHUAYwB0AE4AYQBtAGUAAAAAAFMAVABfADEAZgBlADEAMAAzADgAMQBi
ADMAMABiADQAOAAzADIAYgBkADIANAA1ADgANABjAGQAMAAyADkANgA4AGYAMAAuAGMAcwBwAHIA
bwBqAAAAAABCAA8AAQBQAHIAbwBkAHUAYwB0AFYAZQByAHMAaQBvAG4AAAAxAC4AMAAuADYAOAAw
ADYALgAyADQANwAwADcAAAAAAEYADwABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4A
AAAxAC4AMAAuADYAOAAwADYALgAyADQANwAwADcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAwAAACEPwAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</BinaryItem>
                </ScriptProject>
              </DTS:ObjectData>
            </DTS:Executable>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\Clean Up\New Zip Task"
              DTS:CreationName="Microsoft.ScriptTask"
              DTS:Description="Script Task"
              DTS:DTSID="{CB0DD0A9-5F26-4A44-8C42-F61FC85F7224}"
              DTS:ExecutableType="Microsoft.ScriptTask"
              DTS:LocaleID="-1"
              DTS:ObjectName="New Zip Task"
              DTS:ThreadHint="0">
              <DTS:Variables />
              <DTS:ObjectData>
                <ScriptProject
                  Name="ST_7cba1a05836245c19b25f058965b1d94"
                  VSTAMajorVersion="15"
                  VSTAMinorVersion="0"
                  Language="CSharp"
                  ReadOnlyVariables="User::DestinationZip,User::DestinationZipSource">
                  <ProjectItem
                    Name="Properties\AssemblyInfo.cs"
                    Encoding="UTF8"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_7cba1a05836245c19b25f058965b1d94.csproj")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ST_7cba1a05836245c19b25f058965b1d94.csproj")]
[assembly: AssemblyCopyright("Copyright @ Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Resources.resx"
                    Encoding="UTF8"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem>
                  <ProjectItem
                    Name="st_7cba1a05836245c19b25f058965b1d94.csproj"
                    Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This section defines project-level properties.

       Configuration - Specifies whether the default configuration is Release or Debug.
       Platform - Specifies what CPU the output of this project can run on.
       OutputType - Must be "Library" for VSTA.
       NoStandardLibraries - Set to "false" for VSTA.
       RootNamespace - In C#, this specifies the namespace given to new files.
                       In Visual Basic, all objects are wrapped in this namespace at runtime.
       AssemblyName - Name of the output assembly.
  -->
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <OutputType>Library</OutputType>
    <NoStandardLibraries>false</NoStandardLibraries>
    <RootNamespace>ST_7cba1a05836245c19b25f058965b1d94.csproj</RootNamespace>
    <AssemblyName>ST_7cba1a05836245c19b25f058965b1d94.csproj</AssemblyName>
    <ProjectGuid>{A92FB446-12A7-44A0-AFE2-6A3A48B11816}</ProjectGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <TargetFrameworkProfile></TargetFrameworkProfile>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Debug" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Release" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section enables pre- and post-build steps. However,
       it is recommended that MSBuild tasks be used instead of these properties.
  -->
  <PropertyGroup>
    <PreBuildEvent></PreBuildEvent>
    <PostBuildEvent></PostBuildEvent>
  </PropertyGroup>
  <!-- This sections specifies references for the project. -->
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=14.0.0.0, Culture=Neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=14.0.0.0, Culture=Neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>
  <!-- This section defines the user source files that are part of the
       project.

       Compile - Specifies a source file to compile.
       EmbeddedResource - Specifies a .resx file for embedded resources.
       None - Specifies a file that is not to be passed to the compiler (for instance,
              a text file or XML file).
       AppDesigner - Specifies the directory where the application properties files can
                     be found.
  -->
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
      <SubType>Code</SubType>
    </Compile>
    <!-- Include the default configuration information and metadata files for the add-in.
         These files are copied to the build output directory when the project is
         built, and the path to the configuration file is passed to add-in on the command
         line when debugging.
    -->
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- This section defines VSTA properties that describe the host-changable project properties. -->
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="VSTAHostName" HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}" ApplicationType="usd" Language="cs" TemplatesPath="" DebugInfoExeName="" />
        <Host Name="SSIS_ScriptTask" />
        <ProjectClient>
          <HostIdentifier>SSIS_ST140</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem>
                  <ProjectItem
                    Name="ScriptMain.cs"
                    Encoding="UTF8"><![CDATA[namespace ST_7cba1a05836245c19b25f058965b1d94.csproj
{
using System;
using System.IO;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using ICSharpCode.SharpZipLib.Zip;
using ICSharpCode.SharpZipLib.Checksums;
    [Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
    public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
    {

        #region VSTA generated code
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

        public void Main()
        {
            Dts.TaskResult = (int)ScriptResults.Success;
            string sourceFolder = Dts.Variables["DestinationZipSource"].Value.ToString();
            string targetZip = Dts.Variables["DestinationZip"].Value.ToString();
            Compress(sourceFolder, targetZip);
        }

        private void Compress(string sourceFolder, string targetZip)
        {
            try
            {
                if (File.Exists(targetZip)) { File.Delete(targetZip); }

                int index = sourceFolder.LastIndexOf('\\');
                if (index < 0)
                    return;

                string sourceDir = sourceFolder.Substring(0, index);
                string searchPattern = sourceFolder.Substring(index + 1);

                if (!Directory.Exists(sourceDir))
                    return;

                string[] files = Directory.GetFiles(sourceDir, searchPattern);

                using (ZipOutputStream s = new ZipOutputStream(File.Create(targetZip)))
                {

                    s.SetLevel(9); // 0 - store only to 9 - means best compression

                    byte[] buffer = new byte[4096];

                    foreach (string file in files)
                    {

                        // Using GetFileName makes the result compatible with XP
                        // as the resulting path is not absolute.
                        ZipEntry entry = new ZipEntry(Path.GetFileName(file));

                        // Setup the entry data as required.

                        // Crc and size are handled by the library for seakable streams
                        // so no need to do them here.

                        // Could also use the last write time or similar for the file.
                        entry.DateTime = DateTime.Now;
                        s.PutNextEntry(entry);

                        using (FileStream fs = File.OpenRead(file))
                        {

                            // Using a fixed size buffer here makes no noticeable difference for output
                            // but keeps a lid on memory usage.
                            int sourceBytes;
                            do
                            {
                                sourceBytes = fs.Read(buffer, 0, buffer.Length);
                                s.Write(buffer, 0, sourceBytes);
                            } while (sourceBytes > 0);
                        }
                    }
                    s.Finish();
                    s.Close();
                }
            }
            catch (Exception)
            {
                Dts.TaskResult = (int)ScriptResults.Failure;
            }




        }

    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Computes Adler32 checksum for a stream of data. An Adler32
    /// checksum is not as reliable as a CRC32 checksum, but a lot faster to
    /// compute.
    /// 
    /// The specification for Adler32 may be found in RFC 1950.
    /// ZLIB Compressed Data Format Specification version 3.3)
    /// 
    /// 
    /// From that document:
    /// 
    ///      "ADLER32 (Adler-32 checksum)
    ///       This contains a checksum value of the uncompressed data
    ///       (excluding any dictionary data) computed according to Adler-32
    ///       algorithm. This algorithm is a 32-bit extension and improvement
    ///       of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
    ///       standard.
    /// 
    ///       Adler-32 is composed of two sums accumulated per byte: s1 is
    ///       the sum of all bytes, s2 is the sum of all s1 values. Both sums
    ///       are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
    ///       Adler-32 checksum is stored as s2*65536 + s1 in most-
    ///       significant-byte first (network) order."
    /// 
    ///  "8.2. The Adler-32 algorithm
    /// 
    ///    The Adler-32 algorithm is much faster than the CRC32 algorithm yet
    ///    still provides an extremely low probability of undetected errors.
    /// 
    ///    The modulo on unsigned long accumulators can be delayed for 5552
    ///    bytes, so the modulo operation time is negligible.  If the bytes
    ///    are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
    ///    and order sensitive, unlike the first sum, which is just a
    ///    checksum.  That 65521 is prime is important to avoid a possible
    ///    large class of two-byte errors that leave the check unchanged.
    ///    (The Fletcher checksum uses 255, which is not prime and which also
    ///    makes the Fletcher check insensitive to single byte changes 0 -
    ///    255.)
    /// 
    ///    The sum s1 is initialized to 1 instead of zero to make the length
    ///    of the sequence part of s2, so that the length does not have to be
    ///    checked separately. (Any sequence of zeroes has a Fletcher
    ///    checksum of zero.)"
    /// </summary>
    /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
    /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
    public sealed class Adler32 : IChecksum
    {
        /// <summary>
        /// largest prime smaller than 65536
        /// </summary>
        const uint BASE = 65521;

        /// <summary>
        /// Returns the Adler32 data checksum computed so far.
        /// </summary>
        public long Value
        {
            get
            {
                return checksum;
            }
        }

        /// <summary>
        /// Creates a new instance of the Adler32 class.
        /// The checksum starts off with a value of 1.
        /// </summary>
        public Adler32()
        {
            Reset();
        }

        /// <summary>
        /// Resets the Adler32 checksum to the initial value.
        /// </summary>
        public void Reset()
        {
            checksum = 1;
        }

        /// <summary>
        /// Updates the checksum with a byte value.
        /// </summary>
        /// <param name="value">
        /// The data value to add. The high byte of the int is ignored.
        /// </param>
        public void Update(int value)
        {
            // We could make a length 1 byte array and call update again, but I
            // would rather not have that overhead
            uint s1 = checksum & 0xFFFF;
            uint s2 = checksum >> 16;

            s1 = (s1 + ((uint)value & 0xFF)) % BASE;
            s2 = (s1 + s2) % BASE;

            checksum = (s2 << 16) + s1;
        }

        /// <summary>
        /// Updates the checksum with an array of bytes.
        /// </summary>
        /// <param name="buffer">
        /// The source of the data to update with.
        /// </param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Updates the checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// an array of bytes
        /// </param>
        /// <param name="offset">
        /// the start of the data used for this update
        /// </param>
        /// <param name="count">
        /// the number of bytes to use for this update
        /// </param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "cannot be negative");
#endif
            }

            if (offset >= buffer.Length)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "not a valid index into buffer");
#endif
            }

            if (offset + count > buffer.Length)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "exceeds buffer size");
#endif
            }

            //(By Per Bothner)
            uint s1 = checksum & 0xFFFF;
            uint s2 = checksum >> 16;

            while (count > 0)
            {
                // We can defer the modulo operation:
                // s1 maximally grows from 65521 to 65521 + 255 * 3800
                // s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31
                int n = 3800;
                if (n > count)
                {
                    n = count;
                }
                count -= n;
                while (--n >= 0)
                {
                    s1 = s1 + (uint)(buffer[offset++] & 0xff);
                    s2 = s2 + s1;
                }
                s1 %= BASE;
                s2 %= BASE;
            }

            checksum = (s2 << 16) | s1;
        }

        #region Instance Fields
        uint checksum;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
    /// x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
    ///
    /// Polynomials over GF(2) are represented in binary, one bit per coefficient,
    /// with the lowest powers in the most significant bit.  Then adding polynomials
    /// is just exclusive-or, and multiplying a polynomial by x is a right shift by
    /// one.  If we call the above polynomial p, and represent a byte as the
    /// polynomial q, also with the lowest power in the most significant bit (so the
    /// byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
    /// where a mod b means the remainder after dividing a by b.
    ///
    /// This calculation is done using the shift-register method of multiplying and
    /// taking the remainder.  The register is initialized to zero, and for each
    /// incoming bit, x^32 is added mod p to the register if the bit is a one (where
    /// x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
    /// x (which is shifting right by one and adding x^32 mod p if the bit shifted
    /// out is a one).  We start with the highest power (least significant bit) of
    /// q and repeat for all eight bits of q.
    ///
    /// The table is simply the CRC of all possible eight bit values.  This is all
    /// the information needed to generate CRC's on data a byte at a time for all
    /// combinations of CRC register values and incoming bytes.
    /// </summary>
    public sealed class Crc32 : IChecksum
    {
        const uint CrcSeed = 0xFFFFFFFF;

        readonly static uint[] CrcTable = new uint[] {
			0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
			0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
			0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
			0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
			0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
			0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
			0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
			0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
			0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
			0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
			0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
			0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
			0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
			0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
			0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
			0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
			0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
			0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
			0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
			0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
			0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
			0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
			0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
			0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
			0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
			0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
			0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
			0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
			0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
			0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
			0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
			0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
			0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
			0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
			0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
			0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
			0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
			0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
			0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
			0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
			0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
			0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
			0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
			0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
			0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
			0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
			0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
			0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
			0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
			0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
			0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
			0x2D02EF8D
		};

        internal static uint ComputeCrc32(uint oldCrc, byte value)
        {
            return (uint)(Crc32.CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
        }

        /// <summary>
        /// The crc data checksum so far.
        /// </summary>
        uint crc;

        /// <summary>
        /// Returns the CRC32 data checksum computed so far.
        /// </summary>
        public long Value
        {
            get
            {
                return (long)crc;
            }
            set
            {
                crc = (uint)value;
            }
        }

        /// <summary>
        /// Resets the CRC32 data checksum as if no update was ever called.
        /// </summary>
        public void Reset()
        {
            crc = 0;
        }

        /// <summary>
        /// Updates the checksum with the int bval.
        /// </summary>
        /// <param name = "value">
        /// the byte is taken as the lower 8 bits of value
        /// </param>
        public void Update(int value)
        {
            crc ^= CrcSeed;
            crc = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
            crc ^= CrcSeed;
        }

        /// <summary>
        /// Updates the checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// buffer an array of bytes
        /// </param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Adds the byte array to the data checksum.
        /// </summary>
        /// <param name = "buffer">
        /// The buffer which contains the data
        /// </param>
        /// <param name = "offset">
        /// The offset in the buffer where the data starts
        /// </param>
        /// <param name = "count">
        /// The number of data bytes to update the CRC with.
        /// </param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Count cannot be less than zero");
#endif
            }

            if (offset < 0 || offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            crc ^= CrcSeed;

            while (--count >= 0)
            {
                crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);
            }

            crc ^= CrcSeed;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This is the Deflater class.  The deflater class compresses input
    /// with the deflate algorithm described in RFC 1951.  It has several
    /// compression levels and three different strategies described below.
    ///
    /// This class is <i>not</i> thread safe.  This is inherent in the API, due
    /// to the split of deflate and setInput.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class Deflater
    {
        #region Deflater Documentation
        /*
		* The Deflater can do the following state transitions:
		*
		* (1) -> INIT_STATE   ----> INIT_FINISHING_STATE ---.
		*        /  | (2)      (5)                          |
		*       /   v          (5)                          |
		*   (3)| SETDICT_STATE ---> SETDICT_FINISHING_STATE |(3)
		*       \   | (3)                 |        ,--------'
		*        |  |                     | (3)   /
		*        v  v          (5)        v      v
		* (1) -> BUSY_STATE   ----> FINISHING_STATE
		*                                | (6)
		*                                v
		*                           FINISHED_STATE
		*    \_____________________________________/
		*                    | (7)
		*                    v
		*               CLOSED_STATE
		*
		* (1) If we should produce a header we start in INIT_STATE, otherwise
		*     we start in BUSY_STATE.
		* (2) A dictionary may be set only when we are in INIT_STATE, then
		*     we change the state as indicated.
		* (3) Whether a dictionary is set or not, on the first call of deflate
		*     we change to BUSY_STATE.
		* (4) -- intentionally left blank -- :)
		* (5) FINISHING_STATE is entered, when flush() is called to indicate that
		*     there is no more INPUT.  There are also states indicating, that
		*     the header wasn't written yet.
		* (6) FINISHED_STATE is entered, when everything has been flushed to the
		*     internal pending output buffer.
		* (7) At any time (7)
		*
		*/
        #endregion
        #region Public Constants
        /// <summary>
        /// The best and slowest compression level.  This tries to find very
        /// long and distant string repetitions.
        /// </summary>
        public const int BEST_COMPRESSION = 9;

        /// <summary>
        /// The worst but fastest compression level.
        /// </summary>
        public const int BEST_SPEED = 1;

        /// <summary>
        /// The default compression level.
        /// </summary>
        public const int DEFAULT_COMPRESSION = -1;

        /// <summary>
        /// This level won't compress at all but output uncompressed blocks.
        /// </summary>
        public const int NO_COMPRESSION = 0;

        /// <summary>
        /// The compression method.  This is the only method supported so far.
        /// There is no need to use this constant at all.
        /// </summary>
        public const int DEFLATED = 8;
        #endregion
        #region Local Constants
        private const int IS_SETDICT = 0x01;
        private const int IS_FLUSHING = 0x04;
        private const int IS_FINISHING = 0x08;

        private const int INIT_STATE = 0x00;
        private const int SETDICT_STATE = 0x01;
        //		private static  int INIT_FINISHING_STATE    = 0x08;
        //		private static  int SETDICT_FINISHING_STATE = 0x09;
        private const int BUSY_STATE = 0x10;
        private const int FLUSHING_STATE = 0x14;
        private const int FINISHING_STATE = 0x1c;
        private const int FINISHED_STATE = 0x1e;
        private const int CLOSED_STATE = 0x7f;
        #endregion
        #region Constructors
        /// <summary>
        /// Creates a new deflater with default compression level.
        /// </summary>
        public Deflater()
            : this(DEFAULT_COMPRESSION, false)
        {

        }

        /// <summary>
        /// Creates a new deflater with given compression level.
        /// </summary>
        /// <param name="level">
        /// the compression level, a value between NO_COMPRESSION
        /// and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
        /// </param>
        /// <exception cref="System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        public Deflater(int level)
            : this(level, false)
        {

        }

        /// <summary>
        /// Creates a new deflater with given compression level.
        /// </summary>
        /// <param name="level">
        /// the compression level, a value between NO_COMPRESSION
        /// and BEST_COMPRESSION.
        /// </param>
        /// <param name="noZlibHeaderOrFooter">
        /// true, if we should suppress the Zlib/RFC1950 header at the
        /// beginning and the adler checksum at the end of the output.  This is
        /// useful for the GZIP/PKZIP formats.
        /// </param>
        /// <exception cref="System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        public Deflater(int level, bool noZlibHeaderOrFooter)
        {
            if (level == DEFAULT_COMPRESSION)
            {
                level = 6;
            }
            else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)
            {
                throw new ArgumentOutOfRangeException("level");
            }

            pending = new DeflaterPending();
            engine = new DeflaterEngine(pending);
            this.noZlibHeaderOrFooter = noZlibHeaderOrFooter;
            SetStrategy(DeflateStrategy.Default);
            SetLevel(level);
            Reset();
        }
        #endregion

        /// <summary>
        /// Resets the deflater.  The deflater acts afterwards as if it was
        /// just created with the same compression level and strategy as it
        /// had before.
        /// </summary>
        public void Reset()
        {
            state = (noZlibHeaderOrFooter ? BUSY_STATE : INIT_STATE);
            totalOut = 0;
            pending.Reset();
            engine.Reset();
        }

        /// <summary>
        /// Gets the current adler checksum of the data that was processed so far.
        /// </summary>
        public int Adler
        {
            get
            {
                return engine.Adler;
            }
        }

        /// <summary>
        /// Gets the number of input bytes processed so far.
        /// </summary>
        public long TotalIn
        {
            get
            {
                return engine.TotalIn;
            }
        }

        /// <summary>
        /// Gets the number of output bytes so far.
        /// </summary>
        public long TotalOut
        {
            get
            {
                return totalOut;
            }
        }

        /// <summary>
        /// Flushes the current input block.  Further calls to deflate() will
        /// produce enough output to inflate everything in the current input
        /// block.  This is not part of Sun's JDK so I have made it package
        /// private.  It is used by DeflaterOutputStream to implement
        /// flush().
        /// </summary>
        public void Flush()
        {
            state |= IS_FLUSHING;
        }

        /// <summary>
        /// Finishes the deflater with the current input block.  It is an error
        /// to give more input after this method was called.  This method must
        /// be called to force all bytes to be flushed.
        /// </summary>
        public void Finish()
        {
            state |= (IS_FLUSHING | IS_FINISHING);
        }

        /// <summary>
        /// Returns true if the stream was finished and no more output bytes
        /// are available.
        /// </summary>
        public bool IsFinished
        {
            get
            {
                return (state == FINISHED_STATE) && pending.IsFlushed;
            }
        }

        /// <summary>
        /// Returns true, if the input buffer is empty.
        /// You should then call setInput(). 
        /// NOTE: This method can also return true when the stream
        /// was finished.
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return engine.NeedsInput();
            }
        }

        /// <summary>
        /// Sets the data which should be compressed next.  This should be only
        /// called when needsInput indicates that more input is needed.
        /// If you call setInput when needsInput() returns false, the
        /// previous input that is still pending will be thrown away.
        /// The given byte array should not be changed, before needsInput() returns
        /// true again.
        /// This call is equivalent to <code>setInput(input, 0, input.length)</code>.
        /// </summary>
        /// <param name="input">
        /// the buffer containing the input data.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if the buffer was finished() or ended().
        /// </exception>
        public void SetInput(byte[] input)
        {
            SetInput(input, 0, input.Length);
        }

        /// <summary>
        /// Sets the data which should be compressed next.  This should be
        /// only called when needsInput indicates that more input is needed.
        /// The given byte array should not be changed, before needsInput() returns
        /// true again.
        /// </summary>
        /// <param name="input">
        /// the buffer containing the input data.
        /// </param>
        /// <param name="offset">
        /// the start of the data.
        /// </param>
        /// <param name="count">
        /// the number of data bytes of input.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if the buffer was Finish()ed or if previous input is still pending.
        /// </exception>
        public void SetInput(byte[] input, int offset, int count)
        {
            if ((state & IS_FINISHING) != 0)
            {
                throw new InvalidOperationException("Finish() already called");
            }
            engine.SetInput(input, offset, count);
        }

        /// <summary>
        /// Sets the compression level.  There is no guarantee of the exact
        /// position of the change, but if you call this when needsInput is
        /// true the change of compression level will occur somewhere near
        /// before the end of the so far given input.
        /// </summary>
        /// <param name="level">
        /// the new compression level.
        /// </param>
        public void SetLevel(int level)
        {
            if (level == DEFAULT_COMPRESSION)
            {
                level = 6;
            }
            else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)
            {
                throw new ArgumentOutOfRangeException("level");
            }

            if (this.level != level)
            {
                this.level = level;
                engine.SetLevel(level);
            }
        }

        /// <summary>
        /// Get current compression level
        /// </summary>
        /// <returns>Returns the current compression level</returns>
        public int GetLevel()
        {
            return level;
        }

        /// <summary>
        /// Sets the compression strategy. Strategy is one of
        /// DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
        /// position where the strategy is changed, the same as for
        /// SetLevel() applies.
        /// </summary>
        /// <param name="strategy">
        /// The new compression strategy.
        /// </param>
        public void SetStrategy(DeflateStrategy strategy)
        {
            engine.Strategy = strategy;
        }

        /// <summary>
        /// Deflates the current input block with to the given array.
        /// </summary>
        /// <param name="output">
        /// The buffer where compressed data is stored
        /// </param>
        /// <returns>
        /// The number of compressed bytes added to the output, or 0 if either
        /// IsNeedingInput() or IsFinished returns true or length is zero.
        /// </returns>
        public int Deflate(byte[] output)
        {
            return Deflate(output, 0, output.Length);
        }

        /// <summary>
        /// Deflates the current input block to the given array.
        /// </summary>
        /// <param name="output">
        /// Buffer to store the compressed data.
        /// </param>
        /// <param name="offset">
        /// Offset into the output array.
        /// </param>
        /// <param name="length">
        /// The maximum number of bytes that may be stored.
        /// </param>
        /// <returns>
        /// The number of compressed bytes added to the output, or 0 if either
        /// needsInput() or finished() returns true or length is zero.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">
        /// If Finish() was previously called.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// If offset or length don't match the array length.
        /// </exception>
        public int Deflate(byte[] output, int offset, int length)
        {
            int origLength = length;

            if (state == CLOSED_STATE)
            {
                throw new InvalidOperationException("Deflater closed");
            }

            if (state < BUSY_STATE)
            {
                // output header
                int header = (DEFLATED +
                    ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;
                int level_flags = (level - 1) >> 1;
                if (level_flags < 0 || level_flags > 3)
                {
                    level_flags = 3;
                }
                header |= level_flags << 6;
                if ((state & IS_SETDICT) != 0)
                {
                    // Dictionary was set
                    header |= DeflaterConstants.PRESET_DICT;
                }
                header += 31 - (header % 31);

                pending.WriteShortMSB(header);
                if ((state & IS_SETDICT) != 0)
                {
                    int chksum = engine.Adler;
                    engine.ResetAdler();
                    pending.WriteShortMSB(chksum >> 16);
                    pending.WriteShortMSB(chksum & 0xffff);
                }

                state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));
            }

            for (; ; )
            {
                int count = pending.Flush(output, offset, length);
                offset += count;
                totalOut += count;
                length -= count;

                if (length == 0 || state == FINISHED_STATE)
                {
                    break;
                }

                if (!engine.Deflate((state & IS_FLUSHING) != 0, (state & IS_FINISHING) != 0))
                {
                    if (state == BUSY_STATE)
                    {
                        // We need more input now
                        return origLength - length;
                    }
                    else if (state == FLUSHING_STATE)
                    {
                        if (level != NO_COMPRESSION)
                        {
                            /* We have to supply some lookahead.  8 bit lookahead
                             * is needed by the zlib inflater, and we must fill
                             * the next byte, so that all bits are flushed.
                             */
                            int neededbits = 8 + ((-pending.BitCount) & 7);
                            while (neededbits > 0)
                            {
                                /* write a static tree block consisting solely of
                                 * an EOF:
                                 */
                                pending.WriteBits(2, 10);
                                neededbits -= 10;
                            }
                        }
                        state = BUSY_STATE;
                    }
                    else if (state == FINISHING_STATE)
                    {
                        pending.AlignToByte();

                        // Compressed data is complete.  Write footer information if required.
                        if (!noZlibHeaderOrFooter)
                        {
                            int adler = engine.Adler;
                            pending.WriteShortMSB(adler >> 16);
                            pending.WriteShortMSB(adler & 0xffff);
                        }
                        state = FINISHED_STATE;
                    }
                }
            }
            return origLength - length;
        }

        /// <summary>
        /// Sets the dictionary which should be used in the deflate process.
        /// This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
        /// </summary>
        /// <param name="dictionary">
        /// the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// if SetInput () or Deflate () were already called or another dictionary was already set.
        /// </exception>
        public void SetDictionary(byte[] dictionary)
        {
            SetDictionary(dictionary, 0, dictionary.Length);
        }

        /// <summary>
        /// Sets the dictionary which should be used in the deflate process.
        /// The dictionary is a byte array containing strings that are
        /// likely to occur in the data which should be compressed.  The
        /// dictionary is not stored in the compressed output, only a
        /// checksum.  To decompress the output you need to supply the same
        /// dictionary again.
        /// </summary>
        /// <param name="dictionary">
        /// The dictionary data
        /// </param>
        /// <param name="index">
        /// The index where dictionary information commences.
        /// </param>
        /// <param name="count">
        /// The number of bytes in the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// If SetInput () or Deflate() were already called or another dictionary was already set.
        /// </exception>
        public void SetDictionary(byte[] dictionary, int index, int count)
        {
            if (state != INIT_STATE)
            {
                throw new InvalidOperationException();
            }

            state = SETDICT_STATE;
            engine.SetDictionary(dictionary, index, count);
        }

        #region Instance Fields
        /// <summary>
        /// Compression level.
        /// </summary>
        int level;

        /// <summary>
        /// If true no Zlib/RFC1950 headers or footers are generated
        /// </summary>
        bool noZlibHeaderOrFooter;

        /// <summary>
        /// The current state.
        /// </summary>
        int state;

        /// <summary>
        /// The total bytes of output written.
        /// </summary>
        long totalOut;

        /// <summary>
        /// The pending output.
        /// </summary>
        DeflaterPending pending;

        /// <summary>
        /// The deflater engine.
        /// </summary>
        DeflaterEngine engine;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This class contains constants used for deflation.
    /// </summary>
    public class DeflaterConstants
    {
        /// <summary>
        /// Set to true to enable debugging
        /// </summary>
        public const bool DEBUGGING = false;

        /// <summary>
        /// Written to Zip file to identify a stored block
        /// </summary>
        public const int STORED_BLOCK = 0;

        /// <summary>
        /// Identifies static tree in Zip file
        /// </summary>
        public const int STATIC_TREES = 1;

        /// <summary>
        /// Identifies dynamic tree in Zip file
        /// </summary>
        public const int DYN_TREES = 2;

        /// <summary>
        /// Header flag indicating a preset dictionary for deflation
        /// </summary>
        public const int PRESET_DICT = 0x20;

        /// <summary>
        /// Sets internal buffer sizes for Huffman encoding
        /// </summary>
        public const int DEFAULT_MEM_LEVEL = 8;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_MATCH = 258;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MIN_MATCH = 3;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_WBITS = 15;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int WSIZE = 1 << MAX_WBITS;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int WMASK = WSIZE - 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_BITS = DEFAULT_MEM_LEVEL + 7;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_SIZE = 1 << HASH_BITS;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_MASK = HASH_SIZE - 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int HASH_SHIFT = (HASH_BITS + MIN_MATCH - 1) / MIN_MATCH;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int MAX_DIST = WSIZE - MIN_LOOKAHEAD;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int PENDING_BUF_SIZE = 1 << (DEFAULT_MEM_LEVEL + 8);

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int MAX_BLOCK_SIZE = Math.Min(65535, PENDING_BUF_SIZE - 5);

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_STORED = 0;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_FAST = 1;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public const int DEFLATE_SLOW = 2;

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] GOOD_LENGTH = { 0, 4, 4, 4, 4, 8, 8, 8, 32, 32 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] MAX_LAZY = { 0, 4, 5, 6, 4, 16, 16, 32, 128, 258 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] NICE_LENGTH = { 0, 8, 16, 32, 16, 32, 128, 128, 258, 258 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] MAX_CHAIN = { 0, 4, 8, 32, 16, 32, 128, 256, 1024, 4096 };

        /// <summary>
        /// Internal compression engine constant
        /// </summary>		
        public static int[] COMPR_FUNC = { 0, 1, 1, 1, 1, 2, 2, 2, 2, 2 };

    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Checksums;
    /// <summary>
    /// Strategies for deflater
    /// </summary>
    public enum DeflateStrategy
    {
        /// <summary>
        /// The default strategy
        /// </summary>
        Default = 0,

        /// <summary>
        /// This strategy will only allow longer string repetitions.  It is
        /// useful for random data with a small character set.
        /// </summary>
        Filtered = 1,


        /// <summary>
        /// This strategy will not look for string repetitions at all.  It
        /// only encodes with Huffman trees (which means, that more common
        /// characters get a smaller encoding.
        /// </summary>
        HuffmanOnly = 2
    }

    // DEFLATE ALGORITHM:
    // 
    // The uncompressed stream is inserted into the window array.  When
    // the window array is full the first half is thrown away and the
    // second half is copied to the beginning.
    //
    // The head array is a hash table.  Three characters build a hash value
    // and they the value points to the corresponding index in window of 
    // the last string with this hash.  The prev array implements a
    // linked list of matches with the same hash: prev[index & WMASK] points
    // to the previous index with the same hash.
    // 


    /// <summary>
    /// Low level compression engine for deflate algorithm which uses a 32K sliding window
    /// with secondary compression from Huffman/Shannon-Fano codes.
    /// </summary>
    public class DeflaterEngine : DeflaterConstants
    {
        #region Constants
        const int TooFar = 4096;
        #endregion

        #region Constructors
        /// <summary>
        /// Construct instance with pending buffer
        /// </summary>
        /// <param name="pending">
        /// Pending buffer to use
        /// </param>>
        public DeflaterEngine(DeflaterPending pending)
        {
            this.pending = pending;
            huffman = new DeflaterHuffman(pending);
            adler = new Adler32();

            window = new byte[2 * WSIZE];
            head = new short[HASH_SIZE];
            prev = new short[WSIZE];

            // We start at index 1, to avoid an implementation deficiency, that
            // we cannot build a repeat pattern at index 0.
            blockStart = strstart = 1;
        }

        #endregion

        /// <summary>
        /// Deflate drives actual compression of data
        /// </summary>
        /// <param name="flush">True to flush input buffers</param>
        /// <param name="finish">Finish deflation with the current input.</param>
        /// <returns>Returns true if progress has been made.</returns>
        public bool Deflate(bool flush, bool finish)
        {
            bool progress;
            do
            {
                FillWindow();
                bool canFlush = flush && (inputOff == inputEnd);

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) {
					Console.WriteLine("window: [" + blockStart + "," + strstart + ","
								+ lookahead + "], " + compressionFunction + "," + canFlush);
				}
#endif
                switch (compressionFunction)
                {
                    case DEFLATE_STORED:
                        progress = DeflateStored(canFlush, finish);
                        break;
                    case DEFLATE_FAST:
                        progress = DeflateFast(canFlush, finish);
                        break;
                    case DEFLATE_SLOW:
                        progress = DeflateSlow(canFlush, finish);
                        break;
                    default:
                        throw new InvalidOperationException("unknown compressionFunction");
                }
            } while (pending.IsFlushed && progress); // repeat while we have no pending output and progress was made
            return progress;
        }

        /// <summary>
        /// Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
        /// returns true
        /// </summary>
        /// <param name="buffer">The buffer containing input data.</param>
        /// <param name="offset">The offset of the first byte of data.</param>
        /// <param name="count">The number of bytes of data to use as input.</param>
        public void SetInput(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if (inputOff < inputEnd)
            {
                throw new InvalidOperationException("Old input was not completely processed");
            }

            int end = offset + count;

            /* We want to throw an ArrayIndexOutOfBoundsException early.  The
            * check is very tricky: it also handles integer wrap around.
            */
            if ((offset > end) || (end > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            inputBuf = buffer;
            inputOff = offset;
            inputEnd = end;
        }

        /// <summary>
        /// Determines if more <see cref="SetInput">input</see> is needed.
        /// </summary>		
        /// <returns>Return true if input is needed via <see cref="SetInput">SetInput</see></returns>
        public bool NeedsInput()
        {
            return (inputEnd == inputOff);
        }

        /// <summary>
        /// Set compression dictionary
        /// </summary>
        /// <param name="buffer">The buffer containing the dictionary data</param>
        /// <param name="offset">The offset in the buffer for the first byte of data</param>
        /// <param name="length">The length of the dictionary data.</param>
        public void SetDictionary(byte[] buffer, int offset, int length)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (strstart != 1) ) 
			{
				throw new InvalidOperationException("strstart not 1");
			}
#endif
            adler.Update(buffer, offset, length);
            if (length < MIN_MATCH)
            {
                return;
            }

            if (length > MAX_DIST)
            {
                offset += length - MAX_DIST;
                length = MAX_DIST;
            }

            System.Array.Copy(buffer, offset, window, strstart, length);

            UpdateHash();
            --length;
            while (--length > 0)
            {
                InsertString();
                strstart++;
            }
            strstart += 2;
            blockStart = strstart;
        }

        /// <summary>
        /// Reset internal state
        /// </summary>		
        public void Reset()
        {
            huffman.Reset();
            adler.Reset();
            blockStart = strstart = 1;
            lookahead = 0;
            totalIn = 0;
            prevAvailable = false;
            matchLen = MIN_MATCH - 1;

            for (int i = 0; i < HASH_SIZE; i++)
            {
                head[i] = 0;
            }

            for (int i = 0; i < WSIZE; i++)
            {
                prev[i] = 0;
            }
        }

        /// <summary>
        /// Reset Adler checksum
        /// </summary>		
        public void ResetAdler()
        {
            adler.Reset();
        }

        /// <summary>
        /// Get current value of Adler checksum
        /// </summary>		
        public int Adler
        {
            get
            {
                return unchecked((int)adler.Value);
            }
        }

        /// <summary>
        /// Total data processed
        /// </summary>		
        public long TotalIn
        {
            get
            {
                return totalIn;
            }
        }

        /// <summary>
        /// Get/set the <see cref="DeflateStrategy">deflate strategy</see>
        /// </summary>		
        public DeflateStrategy Strategy
        {
            get
            {
                return strategy;
            }
            set
            {
                strategy = value;
            }
        }

        /// <summary>
        /// Set the deflate level (0-9)
        /// </summary>
        /// <param name="level">The value to set the level to.</param>
        public void SetLevel(int level)
        {
            if ((level < 0) || (level > 9))
            {
                throw new ArgumentOutOfRangeException("level");
            }

            goodLength = DeflaterConstants.GOOD_LENGTH[level];
            max_lazy = DeflaterConstants.MAX_LAZY[level];
            niceLength = DeflaterConstants.NICE_LENGTH[level];
            max_chain = DeflaterConstants.MAX_CHAIN[level];

            if (DeflaterConstants.COMPR_FUNC[level] != compressionFunction)
            {

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) {
				   Console.WriteLine("Change from " + compressionFunction + " to "
										  + DeflaterConstants.COMPR_FUNC[level]);
				}
#endif
                switch (compressionFunction)
                {
                    case DEFLATE_STORED:
                        if (strstart > blockStart)
                        {
                            huffman.FlushStoredBlock(window, blockStart,
                                strstart - blockStart, false);
                            blockStart = strstart;
                        }
                        UpdateHash();
                        break;

                    case DEFLATE_FAST:
                        if (strstart > blockStart)
                        {
                            huffman.FlushBlock(window, blockStart, strstart - blockStart,
                                false);
                            blockStart = strstart;
                        }
                        break;

                    case DEFLATE_SLOW:
                        if (prevAvailable)
                        {
                            huffman.TallyLit(window[strstart - 1] & 0xff);
                        }
                        if (strstart > blockStart)
                        {
                            huffman.FlushBlock(window, blockStart, strstart - blockStart, false);
                            blockStart = strstart;
                        }
                        prevAvailable = false;
                        matchLen = MIN_MATCH - 1;
                        break;
                }
                compressionFunction = COMPR_FUNC[level];
            }
        }

        /// <summary>
        /// Fill the window
        /// </summary>
        public void FillWindow()
        {
            /* If the window is almost full and there is insufficient lookahead,
             * move the upper half to the lower one to make room in the upper half.
             */
            if (strstart >= WSIZE + MAX_DIST)
            {
                SlideWindow();
            }

            /* If there is not enough lookahead, but still some input left,
             * read in the input
             */
            while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd)
            {
                int more = 2 * WSIZE - lookahead - strstart;

                if (more > inputEnd - inputOff)
                {
                    more = inputEnd - inputOff;
                }

                System.Array.Copy(inputBuf, inputOff, window, strstart + lookahead, more);
                adler.Update(inputBuf, inputOff, more);

                inputOff += more;
                totalIn += more;
                lookahead += more;
            }

            if (lookahead >= MIN_MATCH)
            {
                UpdateHash();
            }
        }

        void UpdateHash()
        {
            /*
                        if (DEBUGGING) {
                            Console.WriteLine("updateHash: "+strstart);
                        }
            */
            ins_h = (window[strstart] << HASH_SHIFT) ^ window[strstart + 1];
        }

        /// <summary>
        /// Inserts the current string in the head hash and returns the previous
        /// value for this hash.
        /// </summary>
        /// <returns>The previous hash value</returns>
        int InsertString()
        {
            short match;
            int hash = ((ins_h << HASH_SHIFT) ^ window[strstart + (MIN_MATCH - 1)]) & HASH_MASK;

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) 
			{
				if (hash != (((window[strstart] << (2*HASH_SHIFT)) ^ 
								  (window[strstart + 1] << HASH_SHIFT) ^ 
								  (window[strstart + 2])) & HASH_MASK)) {
						throw new SharpZipBaseException("hash inconsistent: " + hash + "/"
												+window[strstart] + ","
												+window[strstart + 1] + ","
												+window[strstart + 2] + "," + HASH_SHIFT);
					}
			}
#endif
            prev[strstart & WMASK] = match = head[hash];
            head[hash] = unchecked((short)strstart);
            ins_h = hash;
            return match & 0xffff;
        }

        void SlideWindow()
        {
            Array.Copy(window, WSIZE, window, 0, WSIZE);
            matchStart -= WSIZE;
            strstart -= WSIZE;
            blockStart -= WSIZE;

            // Slide the hash table (could be avoided with 32 bit values
            // at the expense of memory usage).
            for (int i = 0; i < HASH_SIZE; ++i)
            {
                int m = head[i] & 0xffff;
                head[i] = (short)(m >= WSIZE ? (m - WSIZE) : 0);
            }

            // Slide the prev table.
            for (int i = 0; i < WSIZE; i++)
            {
                int m = prev[i] & 0xffff;
                prev[i] = (short)(m >= WSIZE ? (m - WSIZE) : 0);
            }
        }

        /// <summary>
        /// Find the best (longest) string in the window matching the 
        /// string starting at strstart.
        ///
        /// Preconditions:
        /// <code>
        /// strstart + MAX_MATCH &lt;= window.length.</code>
        /// </summary>
        /// <param name="curMatch"></param>
        /// <returns>True if a match greater than the minimum length is found</returns>
        bool FindLongestMatch(int curMatch)
        {
            int chainLength = this.max_chain;
            int niceLength = this.niceLength;
            short[] prev = this.prev;
            int scan = this.strstart;
            int match;
            int best_end = this.strstart + matchLen;
            int best_len = Math.Max(matchLen, MIN_MATCH - 1);

            int limit = Math.Max(strstart - MAX_DIST, 0);

            int strend = strstart + MAX_MATCH - 1;
            byte scan_end1 = window[best_end - 1];
            byte scan_end = window[best_end];

            // Do not waste too much time if we already have a good match:
            if (best_len >= this.goodLength)
            {
                chainLength >>= 2;
            }

            /* Do not look for matches beyond the end of the input. This is necessary
            * to make deflate deterministic.
            */
            if (niceLength > lookahead)
            {
                niceLength = lookahead;
            }

#if DebugDeflation

			if (DeflaterConstants.DEBUGGING && (strstart > 2 * WSIZE - MIN_LOOKAHEAD))
			{
				throw new InvalidOperationException("need lookahead");
			}
#endif

            do
            {

#if DebugDeflation

				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )
				{
					throw new InvalidOperationException("no future");
				}
#endif
                if (window[curMatch + best_len] != scan_end ||
                    window[curMatch + best_len - 1] != scan_end1 ||
                    window[curMatch] != window[scan] ||
                    window[curMatch + 1] != window[scan + 1])
                {
                    continue;
                }

                match = curMatch + 2;
                scan += 2;

                /* We check for insufficient lookahead only every 8th comparison;
                * the 256th check will be made at strstart + 258.
                */
                while (
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    window[++scan] == window[++match] &&
                    (scan < strend))
                {
                    // Do nothing
                }

                if (scan > best_end)
                {
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )
						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));
#endif
                    matchStart = curMatch;
                    best_end = scan;
                    best_len = scan - strstart;

                    if (best_len >= niceLength)
                    {
                        break;
                    }

                    scan_end1 = window[best_end - 1];
                    scan_end = window[best_end];
                }
                scan = strstart;
            } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);

            matchLen = Math.Min(best_len, lookahead);
            return matchLen >= MIN_MATCH;
        }

        bool DeflateStored(bool flush, bool finish)
        {
            if (!flush && (lookahead == 0))
            {
                return false;
            }

            strstart += lookahead;
            lookahead = 0;

            int storedLength = strstart - blockStart;

            if ((storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full
                (blockStart < WSIZE && storedLength >= MAX_DIST) ||   // Block may move out of window
                flush)
            {
                bool lastBlock = finish;
                if (storedLength > DeflaterConstants.MAX_BLOCK_SIZE)
                {
                    storedLength = DeflaterConstants.MAX_BLOCK_SIZE;
                    lastBlock = false;
                }

#if DebugDeflation
				if (DeflaterConstants.DEBUGGING) 
				{
				   Console.WriteLine("storedBlock[" + storedLength + "," + lastBlock + "]");
				}
#endif

                huffman.FlushStoredBlock(window, blockStart, storedLength, lastBlock);
                blockStart += storedLength;
                return !lastBlock;
            }
            return true;
        }

        bool DeflateFast(bool flush, bool finish)
        {
            if (lookahead < MIN_LOOKAHEAD && !flush)
            {
                return false;
            }

            while (lookahead >= MIN_LOOKAHEAD || flush)
            {
                if (lookahead == 0)
                {
                    // We are flushing everything
                    huffman.FlushBlock(window, blockStart, strstart - blockStart, finish);
                    blockStart = strstart;
                    return false;
                }

                if (strstart > 2 * WSIZE - MIN_LOOKAHEAD)
                {
                    /* slide window, as FindLongestMatch needs this.
                     * This should only happen when flushing and the window
                     * is almost full.
                     */
                    SlideWindow();
                }

                int hashHead;
                if (lookahead >= MIN_MATCH &&
                    (hashHead = InsertString()) != 0 &&
                    strategy != DeflateStrategy.HuffmanOnly &&
                    strstart - hashHead <= MAX_DIST &&
                    FindLongestMatch(hashHead))
                {
                    // longestMatch sets matchStart and matchLen
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING) 
					{
						for (int i = 0 ; i < matchLen; i++) {
							if (window[strstart + i] != window[matchStart + i]) {
								throw new SharpZipBaseException("Match failure");
							}
						}
					}
#endif

                    bool full = huffman.TallyDist(strstart - matchStart, matchLen);

                    lookahead -= matchLen;
                    if (matchLen <= max_lazy && lookahead >= MIN_MATCH)
                    {
                        while (--matchLen > 0)
                        {
                            ++strstart;
                            InsertString();
                        }
                        ++strstart;
                    }
                    else
                    {
                        strstart += matchLen;
                        if (lookahead >= MIN_MATCH - 1)
                        {
                            UpdateHash();
                        }
                    }
                    matchLen = MIN_MATCH - 1;
                    if (!full)
                    {
                        continue;
                    }
                }
                else
                {
                    // No match found
                    huffman.TallyLit(window[strstart] & 0xff);
                    ++strstart;
                    --lookahead;
                }

                if (huffman.IsFull())
                {
                    bool lastBlock = finish && (lookahead == 0);
                    huffman.FlushBlock(window, blockStart, strstart - blockStart, lastBlock);
                    blockStart = strstart;
                    return !lastBlock;
                }
            }
            return true;
        }

        bool DeflateSlow(bool flush, bool finish)
        {
            if (lookahead < MIN_LOOKAHEAD && !flush)
            {
                return false;
            }

            while (lookahead >= MIN_LOOKAHEAD || flush)
            {
                if (lookahead == 0)
                {
                    if (prevAvailable)
                    {
                        huffman.TallyLit(window[strstart - 1] & 0xff);
                    }
                    prevAvailable = false;

                    // We are flushing everything
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING && !flush) 
					{
						throw new SharpZipBaseException("Not flushing, but no lookahead");
					}
#endif
                    huffman.FlushBlock(window, blockStart, strstart - blockStart,
                        finish);
                    blockStart = strstart;
                    return false;
                }

                if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD)
                {
                    /* slide window, as FindLongestMatch needs this.
                     * This should only happen when flushing and the window
                     * is almost full.
                     */
                    SlideWindow();
                }

                int prevMatch = matchStart;
                int prevLen = matchLen;
                if (lookahead >= MIN_MATCH)
                {

                    int hashHead = InsertString();

                    if (strategy != DeflateStrategy.HuffmanOnly &&
                        hashHead != 0 &&
                        strstart - hashHead <= MAX_DIST &&
                        FindLongestMatch(hashHead))
                    {

                        // longestMatch sets matchStart and matchLen

                        // Discard match if too small and too far away
                        if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))
                        {
                            matchLen = MIN_MATCH - 1;
                        }
                    }
                }

                // previous match was better
                if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))
                {
#if DebugDeflation
					if (DeflaterConstants.DEBUGGING) 
					{
					   for (int i = 0 ; i < matchLen; i++) {
						  if (window[strstart-1+i] != window[prevMatch + i])
							 throw new SharpZipBaseException();
						}
					}
#endif
                    huffman.TallyDist(strstart - 1 - prevMatch, prevLen);
                    prevLen -= 2;
                    do
                    {
                        strstart++;
                        lookahead--;
                        if (lookahead >= MIN_MATCH)
                        {
                            InsertString();
                        }
                    } while (--prevLen > 0);

                    strstart++;
                    lookahead--;
                    prevAvailable = false;
                    matchLen = MIN_MATCH - 1;
                }
                else
                {
                    if (prevAvailable)
                    {
                        huffman.TallyLit(window[strstart - 1] & 0xff);
                    }
                    prevAvailable = true;
                    strstart++;
                    lookahead--;
                }

                if (huffman.IsFull())
                {
                    int len = strstart - blockStart;
                    if (prevAvailable)
                    {
                        len--;
                    }
                    bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);
                    huffman.FlushBlock(window, blockStart, len, lastBlock);
                    blockStart += len;
                    return !lastBlock;
                }
            }
            return true;
        }

        #region Instance Fields

        // Hash index of string to be inserted
        int ins_h;

        /// <summary>
        /// Hashtable, hashing three characters to an index for window, so
        /// that window[index]..window[index+2] have this hash code.  
        /// Note that the array should really be unsigned short, so you need
        /// to and the values with 0xffff.
        /// </summary>
        short[] head;

        /// <summary>
        /// <code>prev[index &amp; WMASK]</code> points to the previous index that has the
        /// same hash code as the string starting at index.  This way 
        /// entries with the same hash code are in a linked list.
        /// Note that the array should really be unsigned short, so you need
        /// to and the values with 0xffff.
        /// </summary>
        short[] prev;

        int matchStart;
        // Length of best match
        int matchLen;
        // Set if previous match exists
        bool prevAvailable;
        int blockStart;

        /// <summary>
        /// Points to the current character in the window.
        /// </summary>
        int strstart;

        /// <summary>
        /// lookahead is the number of characters starting at strstart in
        /// window that are valid.
        /// So window[strstart] until window[strstart+lookahead-1] are valid
        /// characters.
        /// </summary>
        int lookahead;

        /// <summary>
        /// This array contains the part of the uncompressed stream that 
        /// is of relevance.  The current character is indexed by strstart.
        /// </summary>
        byte[] window;

        DeflateStrategy strategy;
        int max_chain, max_lazy, niceLength, goodLength;

        /// <summary>
        /// The current compression function.
        /// </summary>
        int compressionFunction;

        /// <summary>
        /// The input data for compression.
        /// </summary>
        byte[] inputBuf;

        /// <summary>
        /// The total bytes of input read.
        /// </summary>
        long totalIn;

        /// <summary>
        /// The offset into inputBuf, where input data starts.
        /// </summary>
        int inputOff;

        /// <summary>
        /// The end offset of the input data.
        /// </summary>
        int inputEnd;

        DeflaterPending pending;
        DeflaterHuffman huffman;

        /// <summary>
        /// The adler checksum
        /// </summary>
        Adler32 adler;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This is the DeflaterHuffman class.
    /// 
    /// This class is <i>not</i> thread safe.  This is inherent in the API, due
    /// to the split of Deflate and SetInput.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class DeflaterHuffman
    {
        const int BUFSIZE = 1 << (DeflaterConstants.DEFAULT_MEM_LEVEL + 6);
        const int LITERAL_NUM = 286;

        // Number of distance codes
        const int DIST_NUM = 30;
        // Number of codes used to transfer bit lengths
        const int BITLEN_NUM = 19;

        // repeat previous bit length 3-6 times (2 bits of repeat count)
        const int REP_3_6 = 16;
        // repeat a zero length 3-10 times  (3 bits of repeat count)
        const int REP_3_10 = 17;
        // repeat a zero length 11-138 times  (7 bits of repeat count)
        const int REP_11_138 = 18;

        const int EOF_SYMBOL = 256;

        // The lengths of the bit length codes are sent in order of decreasing
        // probability, to avoid transmitting the lengths for unused bit length codes.
        static readonly int[] BL_ORDER = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

        static readonly byte[] bit4Reverse = {
			0,
			8,
			4,
			12,
			2,
			10,
			6,
			14,
			1,
			9,
			5,
			13,
			3,
			11,
			7,
			15
		};

        static short[] staticLCodes;
        static byte[] staticLLength;
        static short[] staticDCodes;
        static byte[] staticDLength;

        class Tree
        {
            #region Instance Fields
            public short[] freqs;

            public byte[] length;

            public int minNumCodes;

            public int numCodes;

            short[] codes;
            int[] bl_counts;
            int maxLength;
            DeflaterHuffman dh;
            #endregion

            #region Constructors
            public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
            {
                this.dh = dh;
                this.minNumCodes = minCodes;
                this.maxLength = maxLength;
                freqs = new short[elems];
                bl_counts = new int[maxLength];
            }

            #endregion

            /// <summary>
            /// Resets the internal state of the tree
            /// </summary>
            public void Reset()
            {
                for (int i = 0; i < freqs.Length; i++)
                {
                    freqs[i] = 0;
                }
                codes = null;
                length = null;
            }

            public void WriteSymbol(int code)
            {
                //				if (DeflaterConstants.DEBUGGING) {
                //					freqs[code]--;
                //					//  	  Console.Write("writeSymbol("+freqs.length+","+code+"): ");
                //				}
                dh.pending.WriteBits(codes[code] & 0xffff, length[code]);
            }

            /// <summary>
            /// Check that all frequencies are zero
            /// </summary>
            /// <exception cref="SharpZipBaseException">
            /// At least one frequency is non-zero
            /// </exception>
            public void CheckEmpty()
            {
                bool empty = true;
                for (int i = 0; i < freqs.Length; i++)
                {
                    if (freqs[i] != 0)
                    {
                        //Console.WriteLine("freqs[" + i + "] == " + freqs[i]);
                        empty = false;
                    }
                }

                if (!empty)
                {
                    throw new SharpZipBaseException("!Empty");
                }
            }

            /// <summary>
            /// Set static codes and length
            /// </summary>
            /// <param name="staticCodes">new codes</param>
            /// <param name="staticLengths">length for new codes</param>
            public void SetStaticCodes(short[] staticCodes, byte[] staticLengths)
            {
                codes = staticCodes;
                length = staticLengths;
            }

            /// <summary>
            /// Build dynamic codes and lengths
            /// </summary>
            public void BuildCodes()
            {
                int numSymbols = freqs.Length;
                int[] nextCode = new int[maxLength];
                int code = 0;

                codes = new short[freqs.Length];

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("buildCodes: "+freqs.Length);
                //				}

                for (int bits = 0; bits < maxLength; bits++)
                {
                    nextCode[bits] = code;
                    code += bl_counts[bits] << (15 - bits);

                    //					if (DeflaterConstants.DEBUGGING) {
                    //						//Console.WriteLine("bits: " + ( bits + 1) + " count: " + bl_counts[bits]
                    //						                  +" nextCode: "+code);
                    //					}
                }

#if DebugDeflation
				if ( DeflaterConstants.DEBUGGING && (code != 65536) ) 
				{
					throw new SharpZipBaseException("Inconsistent bl_counts!");
				}
#endif
                for (int i = 0; i < numCodes; i++)
                {
                    int bits = length[i];
                    if (bits > 0)
                    {

                        //						if (DeflaterConstants.DEBUGGING) {
                        //								//Console.WriteLine("codes["+i+"] = rev(" + nextCode[bits-1]+"),
                        //								                  +bits);
                        //						}

                        codes[i] = BitReverse(nextCode[bits - 1]);
                        nextCode[bits - 1] += 1 << (16 - bits);
                    }
                }
            }

            public void BuildTree()
            {
                int numSymbols = freqs.Length;

                /* heap is a priority queue, sorted by frequency, least frequent
                * nodes first.  The heap is a binary tree, with the property, that
                * the parent node is smaller than both child nodes.  This assures
                * that the smallest node is the first parent.
                *
                * The binary tree is encoded in an array:  0 is root node and
                * the nodes 2*n+1, 2*n+2 are the child nodes of node n.
                */
                int[] heap = new int[numSymbols];
                int heapLen = 0;
                int maxCode = 0;
                for (int n = 0; n < numSymbols; n++)
                {
                    int freq = freqs[n];
                    if (freq != 0)
                    {
                        // Insert n into heap
                        int pos = heapLen++;
                        int ppos;
                        while (pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq)
                        {
                            heap[pos] = heap[ppos];
                            pos = ppos;
                        }
                        heap[pos] = n;

                        maxCode = n;
                    }
                }

                /* We could encode a single literal with 0 bits but then we
                * don't see the literals.  Therefore we force at least two
                * literals to avoid this case.  We don't care about order in
                * this case, both literals get a 1 bit code.
                */
                while (heapLen < 2)
                {
                    int node = maxCode < 2 ? ++maxCode : 0;
                    heap[heapLen++] = node;
                }

                numCodes = Math.Max(maxCode + 1, minNumCodes);

                int numLeafs = heapLen;
                int[] childs = new int[4 * heapLen - 2];
                int[] values = new int[2 * heapLen - 1];
                int numNodes = numLeafs;
                for (int i = 0; i < heapLen; i++)
                {
                    int node = heap[i];
                    childs[2 * i] = node;
                    childs[2 * i + 1] = -1;
                    values[i] = freqs[node] << 8;
                    heap[i] = i;
                }

                /* Construct the Huffman tree by repeatedly combining the least two
                * frequent nodes.
                */
                do
                {
                    int first = heap[0];
                    int last = heap[--heapLen];

                    // Propagate the hole to the leafs of the heap
                    int ppos = 0;
                    int path = 1;

                    while (path < heapLen)
                    {
                        if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])
                        {
                            path++;
                        }

                        heap[ppos] = heap[path];
                        ppos = path;
                        path = path * 2 + 1;
                    }

                    /* Now propagate the last element down along path.  Normally
                    * it shouldn't go too deep.
                    */
                    int lastVal = values[last];
                    while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)
                    {
                        heap[path] = heap[ppos];
                    }
                    heap[path] = last;


                    int second = heap[0];

                    // Create a new node father of first and second
                    last = numNodes++;
                    childs[2 * last] = first;
                    childs[2 * last + 1] = second;
                    int mindepth = Math.Min(values[first] & 0xff, values[second] & 0xff);
                    values[last] = lastVal = values[first] + values[second] - mindepth + 1;

                    // Again, propagate the hole to the leafs
                    ppos = 0;
                    path = 1;

                    while (path < heapLen)
                    {
                        if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])
                        {
                            path++;
                        }

                        heap[ppos] = heap[path];
                        ppos = path;
                        path = ppos * 2 + 1;
                    }

                    // Now propagate the new element down along path
                    while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)
                    {
                        heap[path] = heap[ppos];
                    }
                    heap[path] = last;
                } while (heapLen > 1);

                if (heap[0] != childs.Length / 2 - 1)
                {
                    throw new SharpZipBaseException("Heap invariant violated");
                }

                BuildLength(childs);
            }

            /// <summary>
            /// Get encoded length
            /// </summary>
            /// <returns>Encoded length, the sum of frequencies * lengths</returns>
            public int GetEncodedLength()
            {
                int len = 0;
                for (int i = 0; i < freqs.Length; i++)
                {
                    len += freqs[i] * length[i];
                }
                return len;
            }

            /// <summary>
            /// Scan a literal or distance tree to determine the frequencies of the codes
            /// in the bit length tree.
            /// </summary>
            public void CalcBLFreq(Tree blTree)
            {
                int max_count;               /* max repeat count */
                int min_count;               /* min repeat count */
                int count;                   /* repeat count of the current code */
                int curlen = -1;             /* length of current code */

                int i = 0;
                while (i < numCodes)
                {
                    count = 1;
                    int nextlen = length[i];
                    if (nextlen == 0)
                    {
                        max_count = 138;
                        min_count = 3;
                    }
                    else
                    {
                        max_count = 6;
                        min_count = 3;
                        if (curlen != nextlen)
                        {
                            blTree.freqs[nextlen]++;
                            count = 0;
                        }
                    }
                    curlen = nextlen;
                    i++;

                    while (i < numCodes && curlen == length[i])
                    {
                        i++;
                        if (++count >= max_count)
                        {
                            break;
                        }
                    }

                    if (count < min_count)
                    {
                        blTree.freqs[curlen] += (short)count;
                    }
                    else if (curlen != 0)
                    {
                        blTree.freqs[REP_3_6]++;
                    }
                    else if (count <= 10)
                    {
                        blTree.freqs[REP_3_10]++;
                    }
                    else
                    {
                        blTree.freqs[REP_11_138]++;
                    }
                }
            }

            /// <summary>
            /// Write tree values
            /// </summary>
            /// <param name="blTree">Tree to write</param>
            public void WriteTree(Tree blTree)
            {
                int max_count;               // max repeat count
                int min_count;               // min repeat count
                int count;                   // repeat count of the current code
                int curlen = -1;             // length of current code

                int i = 0;
                while (i < numCodes)
                {
                    count = 1;
                    int nextlen = length[i];
                    if (nextlen == 0)
                    {
                        max_count = 138;
                        min_count = 3;
                    }
                    else
                    {
                        max_count = 6;
                        min_count = 3;
                        if (curlen != nextlen)
                        {
                            blTree.WriteSymbol(nextlen);
                            count = 0;
                        }
                    }
                    curlen = nextlen;
                    i++;

                    while (i < numCodes && curlen == length[i])
                    {
                        i++;
                        if (++count >= max_count)
                        {
                            break;
                        }
                    }

                    if (count < min_count)
                    {
                        while (count-- > 0)
                        {
                            blTree.WriteSymbol(curlen);
                        }
                    }
                    else if (curlen != 0)
                    {
                        blTree.WriteSymbol(REP_3_6);
                        dh.pending.WriteBits(count - 3, 2);
                    }
                    else if (count <= 10)
                    {
                        blTree.WriteSymbol(REP_3_10);
                        dh.pending.WriteBits(count - 3, 3);
                    }
                    else
                    {
                        blTree.WriteSymbol(REP_11_138);
                        dh.pending.WriteBits(count - 11, 7);
                    }
                }
            }

            void BuildLength(int[] childs)
            {
                this.length = new byte[freqs.Length];
                int numNodes = childs.Length / 2;
                int numLeafs = (numNodes + 1) / 2;
                int overflow = 0;

                for (int i = 0; i < maxLength; i++)
                {
                    bl_counts[i] = 0;
                }

                // First calculate optimal bit lengths
                int[] lengths = new int[numNodes];
                lengths[numNodes - 1] = 0;

                for (int i = numNodes - 1; i >= 0; i--)
                {
                    if (childs[2 * i + 1] != -1)
                    {
                        int bitLength = lengths[i] + 1;
                        if (bitLength > maxLength)
                        {
                            bitLength = maxLength;
                            overflow++;
                        }
                        lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;
                    }
                    else
                    {
                        // A leaf node
                        int bitLength = lengths[i];
                        bl_counts[bitLength - 1]++;
                        this.length[childs[2 * i]] = (byte)lengths[i];
                    }
                }

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("Tree "+freqs.Length+" lengths:");
                //					for (int i=0; i < numLeafs; i++) {
                //						//Console.WriteLine("Node "+childs[2*i]+" freq: "+freqs[childs[2*i]]
                //						                  + " len: "+length[childs[2*i]]);
                //					}
                //				}

                if (overflow == 0)
                {
                    return;
                }

                int incrBitLen = maxLength - 1;
                do
                {
                    // Find the first bit length which could increase:
                    while (bl_counts[--incrBitLen] == 0)
                        ;

                    // Move this node one down and remove a corresponding
                    // number of overflow nodes.
                    do
                    {
                        bl_counts[incrBitLen]--;
                        bl_counts[++incrBitLen]++;
                        overflow -= 1 << (maxLength - 1 - incrBitLen);
                    } while (overflow > 0 && incrBitLen < maxLength - 1);
                } while (overflow > 0);

                /* We may have overshot above.  Move some nodes from maxLength to
                * maxLength-1 in that case.
                */
                bl_counts[maxLength - 1] += overflow;
                bl_counts[maxLength - 2] -= overflow;

                /* Now recompute all bit lengths, scanning in increasing
                * frequency.  It is simpler to reconstruct all lengths instead of
                * fixing only the wrong ones. This idea is taken from 'ar'
                * written by Haruhiko Okumura.
                *
                * The nodes were inserted with decreasing frequency into the childs
                * array.
                */
                int nodePtr = 2 * numLeafs;
                for (int bits = maxLength; bits != 0; bits--)
                {
                    int n = bl_counts[bits - 1];
                    while (n > 0)
                    {
                        int childPtr = 2 * childs[nodePtr++];
                        if (childs[childPtr + 1] == -1)
                        {
                            // We found another leaf
                            length[childs[childPtr]] = (byte)bits;
                            n--;
                        }
                    }
                }
                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("*** After overflow elimination. ***");
                //					for (int i=0; i < numLeafs; i++) {
                //						//Console.WriteLine("Node "+childs[2*i]+" freq: "+freqs[childs[2*i]]
                //						                  + " len: "+length[childs[2*i]]);
                //					}
                //				}
            }

        }

        #region Instance Fields
        /// <summary>
        /// Pending buffer to use
        /// </summary>
        public DeflaterPending pending;

        Tree literalTree;
        Tree distTree;
        Tree blTree;

        // Buffer for distances
        short[] d_buf;
        byte[] l_buf;
        int last_lit;
        int extra_bits;
        #endregion

        static DeflaterHuffman()
        {
            // See RFC 1951 3.2.6
            // Literal codes
            staticLCodes = new short[LITERAL_NUM];
            staticLLength = new byte[LITERAL_NUM];

            int i = 0;
            while (i < 144)
            {
                staticLCodes[i] = BitReverse((0x030 + i) << 8);
                staticLLength[i++] = 8;
            }

            while (i < 256)
            {
                staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);
                staticLLength[i++] = 9;
            }

            while (i < 280)
            {
                staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);
                staticLLength[i++] = 7;
            }

            while (i < LITERAL_NUM)
            {
                staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);
                staticLLength[i++] = 8;
            }

            // Distance codes
            staticDCodes = new short[DIST_NUM];
            staticDLength = new byte[DIST_NUM];
            for (i = 0; i < DIST_NUM; i++)
            {
                staticDCodes[i] = BitReverse(i << 11);
                staticDLength[i] = 5;
            }
        }

        /// <summary>
        /// Construct instance with pending buffer
        /// </summary>
        /// <param name="pending">Pending buffer to use</param>
        public DeflaterHuffman(DeflaterPending pending)
        {
            this.pending = pending;

            literalTree = new Tree(this, LITERAL_NUM, 257, 15);
            distTree = new Tree(this, DIST_NUM, 1, 15);
            blTree = new Tree(this, BITLEN_NUM, 4, 7);

            d_buf = new short[BUFSIZE];
            l_buf = new byte[BUFSIZE];
        }

        /// <summary>
        /// Reset internal state
        /// </summary>		
        public void Reset()
        {
            last_lit = 0;
            extra_bits = 0;
            literalTree.Reset();
            distTree.Reset();
            blTree.Reset();
        }

        /// <summary>
        /// Write all trees to pending buffer
        /// </summary>
        /// <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        public void SendAllTrees(int blTreeCodes)
        {
            blTree.BuildCodes();
            literalTree.BuildCodes();
            distTree.BuildCodes();
            pending.WriteBits(literalTree.numCodes - 257, 5);
            pending.WriteBits(distTree.numCodes - 1, 5);
            pending.WriteBits(blTreeCodes - 4, 4);
            for (int rank = 0; rank < blTreeCodes; rank++)
            {
                pending.WriteBits(blTree.length[BL_ORDER[rank]], 3);
            }
            literalTree.WriteTree(blTree);
            distTree.WriteTree(blTree);

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				blTree.CheckEmpty();
			}
#endif
        }

        /// <summary>
        /// Compress current buffer writing data to pending buffer
        /// </summary>
        public void CompressBlock()
        {
            for (int i = 0; i < last_lit; i++)
            {
                int litlen = l_buf[i] & 0xff;
                int dist = d_buf[i];
                if (dist-- != 0)
                {
                    //					if (DeflaterConstants.DEBUGGING) {
                    //						Console.Write("["+(dist+1)+","+(litlen+3)+"]: ");
                    //					}

                    int lc = Lcode(litlen);
                    literalTree.WriteSymbol(lc);

                    int bits = (lc - 261) / 4;
                    if (bits > 0 && bits <= 5)
                    {
                        pending.WriteBits(litlen & ((1 << bits) - 1), bits);
                    }

                    int dc = Dcode(dist);
                    distTree.WriteSymbol(dc);

                    bits = dc / 2 - 1;
                    if (bits > 0)
                    {
                        pending.WriteBits(dist & ((1 << bits) - 1), bits);
                    }
                }
                else
                {
                    //					if (DeflaterConstants.DEBUGGING) {
                    //						if (litlen > 32 && litlen < 127) {
                    //							Console.Write("("+(char)litlen+"): ");
                    //						} else {
                    //							Console.Write("{"+litlen+"}: ");
                    //						}
                    //					}
                    literalTree.WriteSymbol(litlen);
                }
            }

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				Console.Write("EOF: ");
			}
#endif
            literalTree.WriteSymbol(EOF_SYMBOL);

#if DebugDeflation
			if (DeflaterConstants.DEBUGGING) {
				literalTree.CheckEmpty();
				distTree.CheckEmpty();
			}
#endif
        }

        /// <summary>
        /// Flush block to output with no compression
        /// </summary>
        /// <param name="stored">Data to write</param>
        /// <param name="storedOffset">Index of first byte to write</param>
        /// <param name="storedLength">Count of bytes to write</param>
        /// <param name="lastBlock">True if this is the last block</param>
        public void FlushStoredBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
        {
#if DebugDeflation
			//			if (DeflaterConstants.DEBUGGING) {
			//				//Console.WriteLine("Flushing stored block "+ storedLength);
			//			}
#endif
            pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0), 3);
            pending.AlignToByte();
            pending.WriteShort(storedLength);
            pending.WriteShort(~storedLength);
            pending.WriteBlock(stored, storedOffset, storedLength);
            Reset();
        }

        /// <summary>
        /// Flush block to output with compression
        /// </summary>		
        /// <param name="stored">Data to flush</param>
        /// <param name="storedOffset">Index of first byte to flush</param>
        /// <param name="storedLength">Count of bytes to flush</param>
        /// <param name="lastBlock">True if this is the last block</param>
        public void FlushBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
        {
            literalTree.freqs[EOF_SYMBOL]++;

            // Build trees
            literalTree.BuildTree();
            distTree.BuildTree();

            // Calculate bitlen frequency
            literalTree.CalcBLFreq(blTree);
            distTree.CalcBLFreq(blTree);

            // Build bitlen tree
            blTree.BuildTree();

            int blTreeCodes = 4;
            for (int i = 18; i > blTreeCodes; i--)
            {
                if (blTree.length[BL_ORDER[i]] > 0)
                {
                    blTreeCodes = i + 1;
                }
            }
            int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +
                literalTree.GetEncodedLength() + distTree.GetEncodedLength() +
                extra_bits;

            int static_len = extra_bits;
            for (int i = 0; i < LITERAL_NUM; i++)
            {
                static_len += literalTree.freqs[i] * staticLLength[i];
            }
            for (int i = 0; i < DIST_NUM; i++)
            {
                static_len += distTree.freqs[i] * staticDLength[i];
            }
            if (opt_len >= static_len)
            {
                // Force static trees
                opt_len = static_len;
            }

            if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)
            {
                // Store Block

                //				if (DeflaterConstants.DEBUGGING) {
                //					//Console.WriteLine("Storing, since " + storedLength + " < " + opt_len
                //					                  + " <= " + static_len);
                //				}
                FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
            }
            else if (opt_len == static_len)
            {
                // Encode with static tree
                pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0), 3);
                literalTree.SetStaticCodes(staticLCodes, staticLLength);
                distTree.SetStaticCodes(staticDCodes, staticDLength);
                CompressBlock();
                Reset();
            }
            else
            {
                // Encode with dynamic tree
                pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0), 3);
                SendAllTrees(blTreeCodes);
                CompressBlock();
                Reset();
            }
        }

        /// <summary>
        /// Get value indicating if internal buffer is full
        /// </summary>
        /// <returns>true if buffer is full</returns>
        public bool IsFull()
        {
            return last_lit >= BUFSIZE;
        }

        /// <summary>
        /// Add literal to buffer
        /// </summary>
        /// <param name="literal">Literal value to add to buffer.</param>
        /// <returns>Value indicating internal buffer is full</returns>
        public bool TallyLit(int literal)
        {
            //			if (DeflaterConstants.DEBUGGING) {
            //				if (lit > 32 && lit < 127) {
            //					//Console.WriteLine("("+(char)lit+")");
            //				} else {
            //					//Console.WriteLine("{"+lit+"}");
            //				}
            //			}
            d_buf[last_lit] = 0;
            l_buf[last_lit++] = (byte)literal;
            literalTree.freqs[literal]++;
            return IsFull();
        }

        /// <summary>
        /// Add distance code and length to literal and distance trees
        /// </summary>
        /// <param name="distance">Distance code</param>
        /// <param name="length">Length</param>
        /// <returns>Value indicating if internal buffer is full</returns>
        public bool TallyDist(int distance, int length)
        {
            //			if (DeflaterConstants.DEBUGGING) {
            //				//Console.WriteLine("[" + distance + "," + length + "]");
            //			}

            d_buf[last_lit] = (short)distance;
            l_buf[last_lit++] = (byte)(length - 3);

            int lc = Lcode(length - 3);
            literalTree.freqs[lc]++;
            if (lc >= 265 && lc < 285)
            {
                extra_bits += (lc - 261) / 4;
            }

            int dc = Dcode(distance - 1);
            distTree.freqs[dc]++;
            if (dc >= 4)
            {
                extra_bits += dc / 2 - 1;
            }
            return IsFull();
        }


        /// <summary>
        /// Reverse the bits of a 16 bit value.
        /// </summary>
        /// <param name="toReverse">Value to reverse bits</param>
        /// <returns>Value with bits reversed</returns>
        public static short BitReverse(int toReverse)
        {
            return (short)(bit4Reverse[toReverse & 0xF] << 12 |
                            bit4Reverse[(toReverse >> 4) & 0xF] << 8 |
                            bit4Reverse[(toReverse >> 8) & 0xF] << 4 |
                            bit4Reverse[toReverse >> 12]);
        }

        static int Lcode(int length)
        {
            if (length == 255)
            {
                return 285;
            }

            int code = 257;
            while (length >= 8)
            {
                code += 4;
                length >>= 1;
            }
            return code + length;
        }

        static int Dcode(int distance)
        {
            int code = 0;
            while (distance >= 4)
            {
                code += 2;
                distance >>= 1;
            }
            return code + distance;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    using System.IO;

#if !NETCF_1_0
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    /// <summary>
    /// A special stream deflating or compressing the bytes that are
    /// written to it.  It uses a Deflater to perform actual deflating.<br/>
    /// Authors of the original java version : Tom Tromey, Jochen Hoenicke 
    /// </summary>
    public class DeflaterOutputStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// the output stream where deflated output should be written.
        /// </param>
        public DeflaterOutputStream(Stream baseOutputStream)
            : this(baseOutputStream, new Deflater(), 512)
        {
        }

        /// <summary>
        /// Creates a new DeflaterOutputStream with the given Deflater and
        /// default buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// the output stream where deflated output should be written.
        /// </param>
        /// <param name="deflater">
        /// the underlying deflater.
        /// </param>
        public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater)
            : this(baseOutputStream, deflater, 512)
        {
        }

        /// <summary>
        /// Creates a new DeflaterOutputStream with the given Deflater and
        /// buffer size.
        /// </summary>
        /// <param name="baseOutputStream">
        /// The output stream where deflated output is written.
        /// </param>
        /// <param name="deflater">
        /// The underlying deflater to use
        /// </param>
        /// <param name="bufferSize">
        /// The buffer size in bytes to use when deflating (minimum value 512)
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// bufsize is less than or equal to zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// baseOutputStream does not support writing
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// deflater instance is null
        /// </exception>
        public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater, int bufferSize)
        {
            if (baseOutputStream == null)
            {
                throw new ArgumentNullException("baseOutputStream");
            }

            if (baseOutputStream.CanWrite == false)
            {
                throw new ArgumentException("Must support writing", "baseOutputStream");
            }

            if (deflater == null)
            {
                throw new ArgumentNullException("deflater");
            }

            if (bufferSize < 512)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }

            baseOutputStream_ = baseOutputStream;
            buffer_ = new byte[bufferSize];
            deflater_ = deflater;
        }
        #endregion

        #region Public API
        /// <summary>
        /// Finishes the stream by calling finish() on the deflater. 
        /// </summary>
        /// <exception cref="SharpZipBaseException">
        /// Not all input is deflated
        /// </exception>
        public virtual void Finish()
        {
            deflater_.Finish();
            while (!deflater_.IsFinished)
            {
                int len = deflater_.Deflate(buffer_, 0, buffer_.Length);
                if (len <= 0)
                {
                    break;
                }

#if NETCF_1_0
				if ( keys != null ) {
#else
                if (cryptoTransform_ != null)
                {
#endif
                    EncryptBlock(buffer_, 0, len);
                }

                baseOutputStream_.Write(buffer_, 0, len);
            }

            if (!deflater_.IsFinished)
            {
                throw new SharpZipBaseException("Can't deflate all input?");
            }

            baseOutputStream_.Flush();

#if NETCF_1_0
			if ( keys != null ) {
				keys = null;
			}
#else
            if (cryptoTransform_ != null)
            {
#if !NET_1_1 && !NETCF_2_0
                if (cryptoTransform_ is ZipAESTransform)
                {
                    AESAuthCode = ((ZipAESTransform)cryptoTransform_).GetAuthCode();
                }
#endif
                cryptoTransform_.Dispose();
                cryptoTransform_ = null;
            }
#endif
        }

        /// <summary>
        /// Get/set flag indicating ownership of the underlying stream.
        /// When the flag is true <see cref="Close"></see> will close the underlying stream also.
        /// </summary>
        public bool IsStreamOwner
        {
            get { return isStreamOwner_; }
            set { isStreamOwner_ = value; }
        }

        ///	<summary>
        /// Allows client to determine if an entry can be patched after its added
        /// </summary>
        public bool CanPatchEntries
        {
            get
            {
                return baseOutputStream_.CanSeek;
            }
        }

        #endregion

        #region Encryption

        string password;

#if NETCF_1_0
		uint[] keys;
#else
        ICryptoTransform cryptoTransform_;

        /// <summary>
        /// Returns the 10 byte AUTH CODE to be appended immediately following the AES data stream.
        /// </summary>
        protected byte[] AESAuthCode;
#endif

        /// <summary>
        /// Get/set the password used for encryption.
        /// </summary>
        /// <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        public string Password
        {
            get
            {
                return password;
            }
            set
            {
                if ((value != null) && (value.Length == 0))
                {
                    password = null;
                }
                else
                {
                    password = value;
                }
            }
        }

        /// <summary>
        /// Encrypt a block of data
        /// </summary>
        /// <param name="buffer">
        /// Data to encrypt.  NOTE the original contents of the buffer are lost
        /// </param>
        /// <param name="offset">
        /// Offset of first byte in buffer to encrypt
        /// </param>
        /// <param name="length">
        /// Number of bytes in buffer to encrypt
        /// </param>
        protected void EncryptBlock(byte[] buffer, int offset, int length)
        {
#if NETCF_1_0
			for (int i = offset; i < offset + length; ++i) {
				byte oldbyte = buffer[i];
				buffer[i] ^= EncryptByte();
				UpdateKeys(oldbyte);
			}
#else
            cryptoTransform_.TransformBlock(buffer, 0, length, buffer, 0);
#endif
        }

        /// <summary>
        /// Initializes encryption keys based on given <paramref name="password"/>.
        /// </summary>
        /// <param name="password">The password.</param>
        protected void InitializePassword(string password)
        {
#if NETCF_1_0
			keys = new uint[] {
				0x12345678,
				0x23456789,
				0x34567890
			};
			
			byte[] rawPassword = ZipConstants.ConvertToArray(password);
			
			for (int i = 0; i < rawPassword.Length; ++i) {
				UpdateKeys((byte)rawPassword[i]);
			}
			
#else
            PkzipClassicManaged pkManaged = new PkzipClassicManaged();
            byte[] key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(password));
            cryptoTransform_ = pkManaged.CreateEncryptor(key, null);
#endif
        }

#if !NET_1_1 && !NETCF_2_0
        /// <summary>
        /// Initializes encryption keys based on given password.
        /// </summary>
        protected void InitializeAESPassword(ZipEntry entry, string rawPassword,
                                            out byte[] salt, out byte[] pwdVerifier)
        {
            salt = new byte[entry.AESSaltLen];
            // Salt needs to be cryptographically random, and unique per file
            if (_aesRnd == null)
                _aesRnd = new RNGCryptoServiceProvider();
            _aesRnd.GetBytes(salt);
            int blockSize = entry.AESKeySize / 8;	// bits to bytes

            cryptoTransform_ = new ZipAESTransform(rawPassword, salt, blockSize, true);
            pwdVerifier = ((ZipAESTransform)cryptoTransform_).PwdVerifier;
        }
#endif

#if NETCF_1_0
		
		/// <summary>
		/// Encrypt a single byte 
		/// </summary>
		/// <returns>
		/// The encrypted value
		/// </returns>
		protected byte EncryptByte()
		{
			uint temp = ((keys[2] & 0xFFFF) | 2);
			return (byte)((temp * (temp ^ 1)) >> 8);
		}

		/// <summary>
		/// Update encryption keys 
		/// </summary>		
		protected void UpdateKeys(byte ch)
		{
			keys[0] = Crc32.ComputeCrc32(keys[0], ch);
			keys[1] = keys[1] + (byte)keys[0];
			keys[1] = keys[1] * 134775813 + 1;
			keys[2] = Crc32.ComputeCrc32(keys[2], (byte)(keys[1] >> 24));
		}
#endif

        #endregion

        #region Deflation Support
        /// <summary>
        /// Deflates everything in the input buffers.  This will call
        /// <code>def.deflate()</code> until all bytes from the input buffers
        /// are processed.
        /// </summary>
        protected void Deflate()
        {
            while (!deflater_.IsNeedingInput)
            {
                int deflateCount = deflater_.Deflate(buffer_, 0, buffer_.Length);

                if (deflateCount <= 0)
                {
                    break;
                }
#if NETCF_1_0
				if (keys != null) 
#else
                if (cryptoTransform_ != null)
#endif
                {
                    EncryptBlock(buffer_, 0, deflateCount);
                }

                baseOutputStream_.Write(buffer_, 0, deflateCount);
            }

            if (!deflater_.IsNeedingInput)
            {
                throw new SharpZipBaseException("DeflaterOutputStream can't deflate all input?");
            }
        }
        #endregion

        #region Stream Overrides
        /// <summary>
        /// Gets value indicating stream can be read from
        /// </summary>
        public override bool CanRead
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a value indicating if seeking is supported for this stream
        /// This property always returns false
        /// </summary>
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Get value indicating if this stream supports writing
        /// </summary>
        public override bool CanWrite
        {
            get
            {
                return baseOutputStream_.CanWrite;
            }
        }

        /// <summary>
        /// Get current length of stream
        /// </summary>
        public override long Length
        {
            get
            {
                return baseOutputStream_.Length;
            }
        }

        /// <summary>
        /// Gets the current position within the stream.
        /// </summary>
        /// <exception cref="NotSupportedException">Any attempt to set position</exception>
        public override long Position
        {
            get
            {
                return baseOutputStream_.Position;
            }
            set
            {
                throw new NotSupportedException("Position property not supported");
            }
        }

        /// <summary>
        /// Sets the current position of this stream to the given value. Not supported by this class!
        /// </summary>
        /// <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
        /// <param name="origin">The <see cref="SeekOrigin"/> to seek from.</param>
        /// <returns>The new position in the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("DeflaterOutputStream Seek not supported");
        }

        /// <summary>
        /// Sets the length of this stream to the given value. Not supported by this class!
        /// </summary>
        /// <param name="value">The new stream length.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("DeflaterOutputStream SetLength not supported");
        }

        /// <summary>
        /// Read a byte from stream advancing position by one
        /// </summary>
        /// <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override int ReadByte()
        {
            throw new NotSupportedException("DeflaterOutputStream ReadByte not supported");
        }

        /// <summary>
        /// Read a block of bytes from stream
        /// </summary>
        /// <param name="buffer">The buffer to store read data in.</param>
        /// <param name="offset">The offset to start storing at.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("DeflaterOutputStream Read not supported");
        }

        /// <summary>
        /// Asynchronous reads are not supported a NotSupportedException is always thrown
        /// </summary>
        /// <param name="buffer">The buffer to read into.</param>
        /// <param name="offset">The offset to start storing data at.</param>
        /// <param name="count">The number of bytes to read</param>
        /// <param name="callback">The async callback to use.</param>
        /// <param name="state">The state to use.</param>
        /// <returns>Returns an <see cref="IAsyncResult"/></returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("DeflaterOutputStream BeginRead not currently supported");
        }

        /// <summary>
        /// Asynchronous writes arent supported, a NotSupportedException is always thrown
        /// </summary>
        /// <param name="buffer">The buffer to write.</param>
        /// <param name="offset">The offset to begin writing at.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <param name="callback">The <see cref="AsyncCallback"/> to use.</param>
        /// <param name="state">The state object.</param>
        /// <returns>Returns an IAsyncResult.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("BeginWrite is not supported");
        }

        /// <summary>
        /// Flushes the stream by calling <see cref="DeflaterOutputStream.Flush">Flush</see> on the deflater and then
        /// on the underlying stream.  This ensures that all bytes are flushed.
        /// </summary>
        public override void Flush()
        {
            deflater_.Flush();
            Deflate();
            baseOutputStream_.Flush();
        }

        /// <summary>
        /// Calls <see cref="Finish"/> and closes the underlying
        /// stream when <see cref="IsStreamOwner"></see> is true.
        /// </summary>
        public override void Close()
        {
            if (!isClosed_)
            {
                isClosed_ = true;

                try
                {
                    Finish();
#if NETCF_1_0
					keys=null;
#else
                    if (cryptoTransform_ != null)
                    {
                        GetAuthCodeIfAES();
                        cryptoTransform_.Dispose();
                        cryptoTransform_ = null;
                    }
#endif
                }
                finally
                {
                    if (isStreamOwner_)
                    {
                        baseOutputStream_.Close();
                    }
                }
            }
        }

        private void GetAuthCodeIfAES()
        {
#if !NET_1_1 && !NETCF_2_0
            if (cryptoTransform_ is ZipAESTransform)
            {
                AESAuthCode = ((ZipAESTransform)cryptoTransform_).GetAuthCode();
            }
#endif
        }

        /// <summary>
        /// Writes a single byte to the compressed output stream.
        /// </summary>
        /// <param name="value">
        /// The byte value.
        /// </param>
        public override void WriteByte(byte value)
        {
            byte[] b = new byte[1];
            b[0] = value;
            Write(b, 0, 1);
        }

        /// <summary>
        /// Writes bytes from an array to the compressed stream.
        /// </summary>
        /// <param name="buffer">
        /// The byte array
        /// </param>
        /// <param name="offset">
        /// The offset into the byte array where to start.
        /// </param>
        /// <param name="count">
        /// The number of bytes to write.
        /// </param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            deflater_.SetInput(buffer, offset, count);
            Deflate();
        }
        #endregion

        #region Instance Fields
        /// <summary>
        /// This buffer is used temporarily to retrieve the bytes from the
        /// deflater and write them to the underlying output stream.
        /// </summary>
        byte[] buffer_;

        /// <summary>
        /// The deflater which is used to deflate the stream.
        /// </summary>
        protected Deflater deflater_;

        /// <summary>
        /// Base stream the deflater depends on.
        /// </summary>
        protected Stream baseOutputStream_;

        bool isClosed_;

        bool isStreamOwner_ = true;
        #endregion

        #region Static Fields

#if !NET_1_1 && !NETCF_2_0
        // Static to help ensure that multiple files within a zip will get different random salt
        private static RNGCryptoServiceProvider _aesRnd;
#endif
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{

    /// <summary>
    /// This class stores the pending output of the Deflater.
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class DeflaterPending : PendingBuffer
    {
        /// <summary>
        /// Construct instance with default buffer size
        /// </summary>
        public DeflaterPending()
            : base(DeflaterConstants.PENDING_BUF_SIZE)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// FastZipEvents supports all events applicable to <see cref="FastZip">FastZip</see> operations.
    /// </summary>
    public class FastZipEvents
    {
        /// <summary>
        /// Delegate to invoke when processing directories.
        /// </summary>
        public ProcessDirectoryHandler ProcessDirectory;

        /// <summary>
        /// Delegate to invoke when processing files.
        /// </summary>
        public ProcessFileHandler ProcessFile;

        /// <summary>
        /// Delegate to invoke during processing of files.
        /// </summary>
        public ProgressHandler Progress;

        /// <summary>
        /// Delegate to invoke when processing for a file has been completed.
        /// </summary>
        public CompletedFileHandler CompletedFile;

        /// <summary>
        /// Delegate to invoke when processing directory failures.
        /// </summary>
        public DirectoryFailureHandler DirectoryFailure;

        /// <summary>
        /// Delegate to invoke when processing file failures.
        /// </summary>
        public FileFailureHandler FileFailure;

        /// <summary>
        /// Raise the <see cref="DirectoryFailure">directory failure</see> event.
        /// </summary>
        /// <param name="directory">The directory causing the failure.</param>
        /// <param name="e">The exception for this event.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnDirectoryFailure(string directory, Exception e)
        {
            bool result = false;
            DirectoryFailureHandler handler = DirectoryFailure;

            if (handler != null)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(directory, e);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="FileFailure"> file failure handler delegate</see>.
        /// </summary>
        /// <param name="file">The file causing the failure.</param>
        /// <param name="e">The exception for this failure.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnFileFailure(string file, Exception e)
        {
            FileFailureHandler handler = FileFailure;
            bool result = (handler != null);

            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(file, e);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="ProcessFile">ProcessFile delegate</see>.
        /// </summary>
        /// <param name="file">The file being processed.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnProcessFile(string file)
        {
            bool result = true;
            ProcessFileHandler handler = ProcessFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="CompletedFile"/> delegate
        /// </summary>
        /// <param name="file">The file whose processing has been completed.</param>
        /// <returns>A boolean indicating if execution should continue or not.</returns>
        public bool OnCompletedFile(string file)
        {
            bool result = true;
            CompletedFileHandler handler = CompletedFile;
            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Fires the <see cref="ProcessDirectory">process directory</see> delegate.
        /// </summary>
        /// <param name="directory">The directory being processed.</param>
        /// <param name="hasMatchingFiles">Flag indicating if the directory has matching files as determined by the current filter.</param>
        /// <returns>A <see cref="bool"/> of true if the operation should continue; false otherwise.</returns>
        public bool OnProcessDirectory(string directory, bool hasMatchingFiles)
        {
            bool result = true;
            ProcessDirectoryHandler handler = ProcessDirectory;
            if (handler != null)
            {
                DirectoryEventArgs args = new DirectoryEventArgs(directory, hasMatchingFiles);
                handler(this, args);
                result = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// The minimum timespan between <see cref="Progress"/> events.
        /// </summary>
        /// <value>The minimum period of time between <see cref="Progress"/> events.</value>
        /// <seealso cref="Progress"/>
        /// <remarks>The default interval is three seconds.</remarks>
        public TimeSpan ProgressInterval
        {
            get { return progressInterval_; }
            set { progressInterval_ = value; }
        }

        #region Instance Fields
        TimeSpan progressInterval_ = TimeSpan.FromSeconds(3);
        #endregion
    }

    /// <summary>
    /// FastZip provides facilities for creating and extracting zip files.
    /// </summary>
    public class FastZip
    {
        #region Enumerations
        /// <summary>
        /// Defines the desired handling when overwriting files during extraction.
        /// </summary>
        public enum Overwrite
        {
            /// <summary>
            /// Prompt the user to confirm overwriting
            /// </summary>
            Prompt,
            /// <summary>
            /// Never overwrite files.
            /// </summary>
            Never,
            /// <summary>
            /// Always overwrite files.
            /// </summary>
            Always
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initialise a default instance of <see cref="FastZip"/>.
        /// </summary>
        public FastZip()
        {
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FastZip"/>
        /// </summary>
        /// <param name="events">The <see cref="FastZipEvents">events</see> to use during operations.</param>
        public FastZip(FastZipEvents events)
        {
            events_ = events;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get/set a value indicating wether empty directories should be created.
        /// </summary>
        public bool CreateEmptyDirectories
        {
            get { return createEmptyDirectories_; }
            set { createEmptyDirectories_ = value; }
        }

#if !NETCF_1_0
        /// <summary>
        /// Get / set the password value.
        /// </summary>
        public string Password
        {
            get { return password_; }
            set { password_ = value; }
        }
#endif

        /// <summary>
        /// Get or set the <see cref="INameTransform"></see> active when creating Zip files.
        /// </summary>
        /// <seealso cref="EntryFactory"></seealso>
        public INameTransform NameTransform
        {
            get { return entryFactory_.NameTransform; }
            set
            {
                entryFactory_.NameTransform = value;
            }
        }

        /// <summary>
        /// Get or set the <see cref="IEntryFactory"></see> active when creating Zip files.
        /// </summary>
        public IEntryFactory EntryFactory
        {
            get { return entryFactory_; }
            set
            {
                if (value == null)
                {
                    entryFactory_ = new ZipEntryFactory();
                }
                else
                {
                    entryFactory_ = value;
                }
            }
        }

        /// <summary>
        /// Gets or sets the setting for <see cref="UseZip64">Zip64 handling when writing.</see>
        /// </summary>
        /// <remarks>
        /// The default value is dynamic which is not backwards compatible with old
        /// programs and can cause problems with XP's built in compression which cant
        /// read Zip64 archives. However it does avoid the situation were a large file
        /// is added and cannot be completed correctly.
        /// NOTE: Setting the size for entries before they are added is the best solution!
        /// By default the EntryFactory used by FastZip will set fhe file size.
        /// </remarks>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        /// <summary>
        /// Get/set a value indicating wether file dates and times should 
        /// be restored when extracting files from an archive.
        /// </summary>
        /// <remarks>The default value is false.</remarks>
        public bool RestoreDateTimeOnExtract
        {
            get
            {
                return restoreDateTimeOnExtract_;
            }
            set
            {
                restoreDateTimeOnExtract_ = value;
            }
        }

        /// <summary>
        /// Get/set a value indicating wether file attributes should
        /// be restored during extract operations
        /// </summary>
        public bool RestoreAttributesOnExtract
        {
            get { return restoreAttributesOnExtract_; }
            set { restoreAttributesOnExtract_ = value; }
        }
        #endregion

        #region Delegates
        /// <summary>
        /// Delegate called when confirming overwriting of files.
        /// </summary>
        public delegate bool ConfirmOverwriteDelegate(string fileName);
        #endregion

        #region CreateZip
        /// <summary>
        /// Create a zip file.
        /// </summary>
        /// <param name="zipFileName">The name of the zip file to create.</param>
        /// <param name="sourceDirectory">The directory to source files from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter">directory filter</see> to apply.</param>
        public void CreateZip(string zipFileName, string sourceDirectory,
            bool recurse, string fileFilter, string directoryFilter)
        {
            CreateZip(File.Create(zipFileName), sourceDirectory, recurse, fileFilter, directoryFilter);
        }

        /// <summary>
        /// Create a zip file/archive.
        /// </summary>
        /// <param name="zipFileName">The name of the zip file to create.</param>
        /// <param name="sourceDirectory">The directory to obtain files and directories from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The file filter to apply.</param>
        public void CreateZip(string zipFileName, string sourceDirectory, bool recurse, string fileFilter)
        {
            CreateZip(File.Create(zipFileName), sourceDirectory, recurse, fileFilter, null);
        }

        /// <summary>
        /// Create a zip archive sending output to the <paramref name="outputStream"/> passed.
        /// </summary>
        /// <param name="outputStream">The stream to write archive data to.</param>
        /// <param name="sourceDirectory">The directory to source files from.</param>
        /// <param name="recurse">True to recurse directories, false for no recursion.</param>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter">directory filter</see> to apply.</param>
        /// <remarks>The <paramref name="outputStream"/> is closed after creation.</remarks>
        public void CreateZip(Stream outputStream, string sourceDirectory, bool recurse, string fileFilter, string directoryFilter)
        {
            NameTransform = new ZipNameTransform(sourceDirectory);
            sourceDirectory_ = sourceDirectory;

            using (outputStream_ = new ZipOutputStream(outputStream))
            {

#if !NETCF_1_0
                if (password_ != null)
                {
                    outputStream_.Password = password_;
                }
#endif

                outputStream_.UseZip64 = UseZip64;
                FileSystemScanner scanner = new FileSystemScanner(fileFilter, directoryFilter);
                scanner.ProcessFile += new ProcessFileHandler(ProcessFile);
                if (this.CreateEmptyDirectories)
                {
                    scanner.ProcessDirectory += new ProcessDirectoryHandler(ProcessDirectory);
                }

                if (events_ != null)
                {
                    if (events_.FileFailure != null)
                    {
                        scanner.FileFailure += events_.FileFailure;
                    }

                    if (events_.DirectoryFailure != null)
                    {
                        scanner.DirectoryFailure += events_.DirectoryFailure;
                    }
                }

                scanner.Scan(sourceDirectory, recurse);
            }
        }

        #endregion

        #region ExtractZip
        /// <summary>
        /// Extract the contents of a zip file.
        /// </summary>
        /// <param name="zipFileName">The zip file to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter)
        {
            ExtractZip(zipFileName, targetDirectory, Overwrite.Always, null, fileFilter, null, restoreDateTimeOnExtract_);
        }

        /// <summary>
        /// Extract the contents of a zip file.
        /// </summary>
        /// <param name="zipFileName">The zip file to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="overwrite">The style of <see cref="Overwrite">overwriting</see> to apply.</param>
        /// <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        /// <param name="directoryFilter">A filter to apply to directories.</param>
        /// <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
        public void ExtractZip(string zipFileName, string targetDirectory,
                               Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate,
                               string fileFilter, string directoryFilter, bool restoreDateTime)
        {
            Stream inputStream = File.Open(zipFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            ExtractZip(inputStream, targetDirectory, overwrite, confirmDelegate, fileFilter, directoryFilter, restoreDateTime, true);
        }

        /// <summary>
        /// Extract the contents of a zip file held in a stream.
        /// </summary>
        /// <param name="inputStream">The seekable input stream containing the zip to extract from.</param>
        /// <param name="targetDirectory">The directory to save extracted information in.</param>
        /// <param name="overwrite">The style of <see cref="Overwrite">overwriting</see> to apply.</param>
        /// <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
        /// <param name="fileFilter">A filter to apply to files.</param>
        /// <param name="directoryFilter">A filter to apply to directories.</param>
        /// <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
        /// <param name="isStreamOwner">Flag indicating whether the inputStream will be closed by this method.</param>
        public void ExtractZip(Stream inputStream, string targetDirectory,
                       Overwrite overwrite, ConfirmOverwriteDelegate confirmDelegate,
                       string fileFilter, string directoryFilter, bool restoreDateTime,
                       bool isStreamOwner)
        {
            if ((overwrite == Overwrite.Prompt) && (confirmDelegate == null))
            {
                throw new ArgumentNullException("confirmDelegate");
            }

            continueRunning_ = true;
            overwrite_ = overwrite;
            confirmDelegate_ = confirmDelegate;
            extractNameTransform_ = new WindowsNameTransform(targetDirectory);

            fileFilter_ = new NameFilter(fileFilter);
            directoryFilter_ = new NameFilter(directoryFilter);
            restoreDateTimeOnExtract_ = restoreDateTime;

            using (zipFile_ = new ZipFile(inputStream))
            {

#if !NETCF_1_0
                if (password_ != null)
                {
                    zipFile_.Password = password_;
                }
#endif
                zipFile_.IsStreamOwner = isStreamOwner;
                System.Collections.IEnumerator enumerator = zipFile_.GetEnumerator();
                while (continueRunning_ && enumerator.MoveNext())
                {
                    ZipEntry entry = (ZipEntry)enumerator.Current;
                    if (entry.IsFile)
                    {
                        // TODO Path.GetDirectory can fail here on invalid characters.
                        if (directoryFilter_.IsMatch(Path.GetDirectoryName(entry.Name)) && fileFilter_.IsMatch(entry.Name))
                        {
                            ExtractEntry(entry);
                        }
                    }
                    else if (entry.IsDirectory)
                    {
                        if (directoryFilter_.IsMatch(entry.Name) && CreateEmptyDirectories)
                        {
                            ExtractEntry(entry);
                        }
                    }
                    else
                    {
                        // Do nothing for volume labels etc...
                    }
                }
            }
        }
        #endregion

        #region Internal Processing
        void ProcessDirectory(object sender, DirectoryEventArgs e)
        {
            if (!e.HasMatchingFiles && CreateEmptyDirectories)
            {
                if (events_ != null)
                {
                    events_.OnProcessDirectory(e.Name, e.HasMatchingFiles);
                }

                if (e.ContinueRunning)
                {
                    if (e.Name != sourceDirectory_)
                    {
                        ZipEntry entry = entryFactory_.MakeDirectoryEntry(e.Name);
                        outputStream_.PutNextEntry(entry);
                    }
                }
            }
        }

        void ProcessFile(object sender, ScanEventArgs e)
        {
            if ((events_ != null) && (events_.ProcessFile != null))
            {
                events_.ProcessFile(sender, e);
            }

            if (e.ContinueRunning)
            {
                try
                {
                    // The open below is equivalent to OpenRead which gaurantees that if opened the 
                    // file will not be changed by subsequent openers, but precludes opening in some cases
                    // were it could succeed.
                    using (FileStream stream = File.Open(e.Name, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        ZipEntry entry = entryFactory_.MakeFileEntry(e.Name);
                        outputStream_.PutNextEntry(entry);
                        AddFileContents(e.Name, stream);
                    }
                }
                catch (Exception ex)
                {
                    if (events_ != null)
                    {
                        continueRunning_ = events_.OnFileFailure(e.Name, ex);
                    }
                    else
                    {
                        continueRunning_ = false;
                        throw;
                    }
                }
            }
        }

        void AddFileContents(string name, Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (buffer_ == null)
            {
                buffer_ = new byte[4096];
            }

            if ((events_ != null) && (events_.Progress != null))
            {
                StreamUtils.Copy(stream, outputStream_, buffer_,
                    events_.Progress, events_.ProgressInterval, this, name);
            }
            else
            {
                StreamUtils.Copy(stream, outputStream_, buffer_);
            }

            if (events_ != null)
            {
                continueRunning_ = events_.OnCompletedFile(name);
            }
        }

        void ExtractFileEntry(ZipEntry entry, string targetName)
        {
            bool proceed = true;
            if (overwrite_ != Overwrite.Always)
            {
                if (File.Exists(targetName))
                {
                    if ((overwrite_ == Overwrite.Prompt) && (confirmDelegate_ != null))
                    {
                        proceed = confirmDelegate_(targetName);
                    }
                    else
                    {
                        proceed = false;
                    }
                }
            }

            if (proceed)
            {
                if (events_ != null)
                {
                    continueRunning_ = events_.OnProcessFile(entry.Name);
                }

                if (continueRunning_)
                {
                    try
                    {
                        using (FileStream outputStream = File.Create(targetName))
                        {
                            if (buffer_ == null)
                            {
                                buffer_ = new byte[4096];
                            }
                            if ((events_ != null) && (events_.Progress != null))
                            {
                                StreamUtils.Copy(zipFile_.GetInputStream(entry), outputStream, buffer_,
                                    events_.Progress, events_.ProgressInterval, this, entry.Name, entry.Size);
                            }
                            else
                            {
                                StreamUtils.Copy(zipFile_.GetInputStream(entry), outputStream, buffer_);
                            }

                            if (events_ != null)
                            {
                                continueRunning_ = events_.OnCompletedFile(entry.Name);
                            }
                        }

#if !NETCF_1_0 && !NETCF_2_0
                        if (restoreDateTimeOnExtract_)
                        {
                            File.SetLastWriteTime(targetName, entry.DateTime);
                        }

                        if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1))
                        {
                            FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;
                            // TODO: FastZip - Setting of other file attributes on extraction is a little trickier.
                            fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);
                            File.SetAttributes(targetName, fileAttributes);
                        }
#endif
                    }
                    catch (Exception ex)
                    {
                        if (events_ != null)
                        {
                            continueRunning_ = events_.OnFileFailure(targetName, ex);
                        }
                        else
                        {
                            continueRunning_ = false;
                            throw;
                        }
                    }
                }
            }
        }

        void ExtractEntry(ZipEntry entry)
        {
            bool doExtraction = entry.IsCompressionMethodSupported();
            string targetName = entry.Name;

            if (doExtraction)
            {
                if (entry.IsFile)
                {
                    targetName = extractNameTransform_.TransformFile(targetName);
                }
                else if (entry.IsDirectory)
                {
                    targetName = extractNameTransform_.TransformDirectory(targetName);
                }

                doExtraction = !((targetName == null) || (targetName.Length == 0));
            }

            // TODO: Fire delegate/throw exception were compression method not supported, or name is invalid?

            string dirName = null;

            if (doExtraction)
            {
                if (entry.IsDirectory)
                {
                    dirName = targetName;
                }
                else
                {
                    dirName = Path.GetDirectoryName(Path.GetFullPath(targetName));
                }
            }

            if (doExtraction && !Directory.Exists(dirName))
            {
                if (!entry.IsDirectory || CreateEmptyDirectories)
                {
                    try
                    {
                        Directory.CreateDirectory(dirName);
                    }
                    catch (Exception ex)
                    {
                        doExtraction = false;
                        if (events_ != null)
                        {
                            if (entry.IsDirectory)
                            {
                                continueRunning_ = events_.OnDirectoryFailure(targetName, ex);
                            }
                            else
                            {
                                continueRunning_ = events_.OnFileFailure(targetName, ex);
                            }
                        }
                        else
                        {
                            continueRunning_ = false;
                            throw;
                        }
                    }
                }
            }

            if (doExtraction && entry.IsFile)
            {
                ExtractFileEntry(entry, targetName);
            }
        }

        static int MakeExternalAttributes(FileInfo info)
        {
            return (int)info.Attributes;
        }

#if NET_1_0 || NET_1_1 || NETCF_1_0
		static bool NameIsValid(string name)
		{
			return (name != null) &&
				(name.Length > 0) &&
				(name.IndexOfAny(Path.InvalidPathChars) < 0);
		}
#else
        static bool NameIsValid(string name)
        {
            return (name != null) &&
                (name.Length > 0) &&
                (name.IndexOfAny(Path.GetInvalidPathChars()) < 0);
        }
#endif
        #endregion

        #region Instance Fields
        bool continueRunning_;
        byte[] buffer_;
        ZipOutputStream outputStream_;
        ZipFile zipFile_;
        string sourceDirectory_;
        NameFilter fileFilter_;
        NameFilter directoryFilter_;
        Overwrite overwrite_;
        ConfirmOverwriteDelegate confirmDelegate_;

        bool restoreDateTimeOnExtract_;
        bool restoreAttributesOnExtract_;
        bool createEmptyDirectories_;
        FastZipEvents events_;
        IEntryFactory entryFactory_ = new ZipEntryFactory();
        INameTransform extractNameTransform_;
        UseZip64 useZip64_ = UseZip64.Dynamic;

#if !NETCF_1_0
        string password_;
#endif

        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    #region EventArgs
    /// <summary>
    /// Event arguments for scanning.
    /// </summary>
    public class ScanEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanEventArgs"/>
        /// </summary>
        /// <param name="name">The file or directory name.</param>
        public ScanEventArgs(string name)
        {
            name_ = name;
        }
        #endregion

        /// <summary>
        /// The file or directory name for this event.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Get set a value indicating if scanning should continue or not.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        #region Instance Fields
        string name_;
        bool continueRunning_ = true;
        #endregion
    }

    /// <summary>
    /// Event arguments during processing of a single file or directory.
    /// </summary>
    public class ProgressEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanEventArgs"/>
        /// </summary>
        /// <param name="name">The file or directory name if known.</param>
        /// <param name="processed">The number of bytes processed so far</param>
        /// <param name="target">The total number of bytes to process, 0 if not known</param>
        public ProgressEventArgs(string name, long processed, long target)
        {
            name_ = name;
            processed_ = processed;
            target_ = target;
        }
        #endregion

        /// <summary>
        /// The name for this event if known.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Get set a value indicating wether scanning should continue or not.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        /// <summary>
        /// Get a percentage representing how much of the <see cref="Target"></see> has been processed
        /// </summary>
        /// <value>0.0 to 100.0 percent; 0 if target is not known.</value>
        public float PercentComplete
        {
            get
            {
                float result;
                if (target_ <= 0)
                {
                    result = 0;
                }
                else
                {
                    result = ((float)processed_ / (float)target_) * 100.0f;
                }
                return result;
            }
        }

        /// <summary>
        /// The number of bytes processed so far
        /// </summary>
        public long Processed
        {
            get { return processed_; }
        }

        /// <summary>
        /// The number of bytes to process.
        /// </summary>
        /// <remarks>Target may be 0 or negative if the value isnt known.</remarks>
        public long Target
        {
            get { return target_; }
        }

        #region Instance Fields
        string name_;
        long processed_;
        long target_;
        bool continueRunning_ = true;
        #endregion
    }

    /// <summary>
    /// Event arguments for directories.
    /// </summary>
    public class DirectoryEventArgs : ScanEventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialize an instance of <see cref="DirectoryEventArgs"></see>.
        /// </summary>
        /// <param name="name">The name for this directory.</param>
        /// <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
        public DirectoryEventArgs(string name, bool hasMatchingFiles)
            : base(name)
        {
            hasMatchingFiles_ = hasMatchingFiles;
        }
        #endregion

        /// <summary>
        /// Get a value indicating if the directory contains any matching files or not.
        /// </summary>
        public bool HasMatchingFiles
        {
            get { return hasMatchingFiles_; }
        }

        #region Instance Fields
        bool hasMatchingFiles_;
        #endregion
    }

    /// <summary>
    /// Arguments passed when scan failures are detected.
    /// </summary>
    public class ScanFailureEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="ScanFailureEventArgs"></see>
        /// </summary>
        /// <param name="name">The name to apply.</param>
        /// <param name="e">The exception to use.</param>
        public ScanFailureEventArgs(string name, Exception e)
        {
            name_ = name;
            exception_ = e;
            continueRunning_ = true;
        }
        #endregion

        /// <summary>
        /// The applicable name.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// The applicable exception.
        /// </summary>
        public Exception Exception
        {
            get { return exception_; }
        }

        /// <summary>
        /// Get / set a value indicating wether scanning should continue.
        /// </summary>
        public bool ContinueRunning
        {
            get { return continueRunning_; }
            set { continueRunning_ = value; }
        }

        #region Instance Fields
        string name_;
        Exception exception_;
        bool continueRunning_;
        #endregion
    }

    #endregion

    #region Delegates
    /// <summary>
    /// Delegate invoked before starting to process a directory.
    /// </summary>
    public delegate void ProcessDirectoryHandler(object sender, DirectoryEventArgs e);

    /// <summary>
    /// Delegate invoked before starting to process a file.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void ProcessFileHandler(object sender, ScanEventArgs e);

    /// <summary>
    /// Delegate invoked during processing of a file or directory
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void ProgressHandler(object sender, ProgressEventArgs e);

    /// <summary>
    /// Delegate invoked when a file has been completely processed.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void CompletedFileHandler(object sender, ScanEventArgs e);

    /// <summary>
    /// Delegate invoked when a directory failure is detected.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void DirectoryFailureHandler(object sender, ScanFailureEventArgs e);

    /// <summary>
    /// Delegate invoked when a file failure is detected.
    /// </summary>
    /// <param name="sender">The source of the event</param>
    /// <param name="e">The event arguments.</param>
    public delegate void FileFailureHandler(object sender, ScanFailureEventArgs e);
    #endregion

    /// <summary>
    /// FileSystemScanner provides facilities scanning of files and directories.
    /// </summary>
    public class FileSystemScanner
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="filter">The <see cref="PathFilter">file filter</see> to apply when scanning.</param>
        public FileSystemScanner(string filter)
        {
            fileFilter_ = new PathFilter(filter);
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The <see cref="PathFilter">file filter</see> to apply.</param>
        /// <param name="directoryFilter">The <see cref="PathFilter"> directory filter</see> to apply.</param>
        public FileSystemScanner(string fileFilter, string directoryFilter)
        {
            fileFilter_ = new PathFilter(fileFilter);
            directoryFilter_ = new PathFilter(directoryFilter);
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The file <see cref="IScanFilter">filter</see> to apply.</param>
        public FileSystemScanner(IScanFilter fileFilter)
        {
            fileFilter_ = fileFilter;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="FileSystemScanner"></see>
        /// </summary>
        /// <param name="fileFilter">The file <see cref="IScanFilter">filter</see>  to apply.</param>
        /// <param name="directoryFilter">The directory <see cref="IScanFilter">filter</see>  to apply.</param>
        public FileSystemScanner(IScanFilter fileFilter, IScanFilter directoryFilter)
        {
            fileFilter_ = fileFilter;
            directoryFilter_ = directoryFilter;
        }
        #endregion

        #region Delegates
        /// <summary>
        /// Delegate to invoke when a directory is processed.
        /// </summary>
        public ProcessDirectoryHandler ProcessDirectory;

        /// <summary>
        /// Delegate to invoke when a file is processed.
        /// </summary>
        public ProcessFileHandler ProcessFile;

        /// <summary>
        /// Delegate to invoke when processing for a file has finished.
        /// </summary>
        public CompletedFileHandler CompletedFile;

        /// <summary>
        /// Delegate to invoke when a directory failure is detected.
        /// </summary>
        public DirectoryFailureHandler DirectoryFailure;

        /// <summary>
        /// Delegate to invoke when a file failure is detected.
        /// </summary>
        public FileFailureHandler FileFailure;
        #endregion

        /// <summary>
        /// Raise the DirectoryFailure event.
        /// </summary>
        /// <param name="directory">The directory name.</param>
        /// <param name="e">The exception detected.</param>
        bool OnDirectoryFailure(string directory, Exception e)
        {
            DirectoryFailureHandler handler = DirectoryFailure;
            bool result = (handler != null);
            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(directory, e);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Raise the FileFailure event.
        /// </summary>
        /// <param name="file">The file name.</param>
        /// <param name="e">The exception detected.</param>
        bool OnFileFailure(string file, Exception e)
        {
            FileFailureHandler handler = FileFailure;

            bool result = (handler != null);

            if (result)
            {
                ScanFailureEventArgs args = new ScanFailureEventArgs(file, e);
                FileFailure(this, args);
                alive_ = args.ContinueRunning;
            }
            return result;
        }

        /// <summary>
        /// Raise the ProcessFile event.
        /// </summary>
        /// <param name="file">The file name.</param>
        void OnProcessFile(string file)
        {
            ProcessFileHandler handler = ProcessFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Raise the complete file event
        /// </summary>
        /// <param name="file">The file name</param>
        void OnCompleteFile(string file)
        {
            CompletedFileHandler handler = CompletedFile;

            if (handler != null)
            {
                ScanEventArgs args = new ScanEventArgs(file);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Raise the ProcessDirectory event.
        /// </summary>
        /// <param name="directory">The directory name.</param>
        /// <param name="hasMatchingFiles">Flag indicating if the directory has matching files.</param>
        void OnProcessDirectory(string directory, bool hasMatchingFiles)
        {
            ProcessDirectoryHandler handler = ProcessDirectory;

            if (handler != null)
            {
                DirectoryEventArgs args = new DirectoryEventArgs(directory, hasMatchingFiles);
                handler(this, args);
                alive_ = args.ContinueRunning;
            }
        }

        /// <summary>
        /// Scan a directory.
        /// </summary>
        /// <param name="directory">The base directory to scan.</param>
        /// <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
        public void Scan(string directory, bool recurse)
        {
            alive_ = true;
            ScanDir(directory, recurse);
        }

        void ScanDir(string directory, bool recurse)
        {

            try
            {
                string[] names = System.IO.Directory.GetFiles(directory);
                bool hasMatch = false;
                for (int fileIndex = 0; fileIndex < names.Length; ++fileIndex)
                {
                    if (!fileFilter_.IsMatch(names[fileIndex]))
                    {
                        names[fileIndex] = null;
                    }
                    else
                    {
                        hasMatch = true;
                    }
                }

                OnProcessDirectory(directory, hasMatch);

                if (alive_ && hasMatch)
                {
                    foreach (string fileName in names)
                    {
                        try
                        {
                            if (fileName != null)
                            {
                                OnProcessFile(fileName);
                                if (!alive_)
                                {
                                    break;
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            if (!OnFileFailure(fileName, e))
                            {
                                throw;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (!OnDirectoryFailure(directory, e))
                {
                    throw;
                }
            }

            if (alive_ && recurse)
            {
                try
                {
                    string[] names = System.IO.Directory.GetDirectories(directory);
                    foreach (string fulldir in names)
                    {
                        if ((directoryFilter_ == null) || (directoryFilter_.IsMatch(fulldir)))
                        {
                            ScanDir(fulldir, true);
                            if (!alive_)
                            {
                                break;
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    if (!OnDirectoryFailure(directory, e))
                    {
                        throw;
                    }
                }
            }
        }

        #region Instance Fields
        /// <summary>
        /// The file filter currently in use.
        /// </summary>
        IScanFilter fileFilter_;
        /// <summary>
        /// The directory filter currently in use.
        /// </summary>
        IScanFilter directoryFilter_;
        /// <summary>
        /// Flag indicating if scanning should continue running.
        /// </summary>
        bool alive_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{

    /// <summary>
    /// Interface to compute a data checksum used by checked input/output streams.
    /// A data checksum can be updated by one byte or with a byte array. After each
    /// update the value of the current checksum can be returned by calling
    /// <code>getValue</code>. The complete checksum object can also be reset
    /// so it can be used again with new data.
    /// </summary>
    public interface IChecksum
    {
        /// <summary>
        /// Returns the data checksum computed so far.
        /// </summary>
        long Value
        {
            get;
        }

        /// <summary>
        /// Resets the data checksum as if no update was ever called.
        /// </summary>
        void Reset();

        /// <summary>
        /// Adds one byte to the data checksum.
        /// </summary>
        /// <param name = "value">
        /// the data value to add. The high byte of the int is ignored.
        /// </param>
        void Update(int value);

        /// <summary>
        /// Updates the data checksum with the bytes taken from the array.
        /// </summary>
        /// <param name="buffer">
        /// buffer an array of bytes
        /// </param>
        void Update(byte[] buffer);

        /// <summary>
        /// Adds the byte array to the data checksum.
        /// </summary>
        /// <param name = "buffer">
        /// The buffer which contains the data
        /// </param>
        /// <param name = "offset">
        /// The offset in the buffer where the data starts
        /// </param>
        /// <param name = "count">
        /// the number of data bytes to add.
        /// </param>
        void Update(byte[] buffer, int offset, int count);
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using ICSharpCode.SharpZipLib.Core;
    /// <summary>
    /// Defines factory methods for creating new <see cref="ZipEntry"></see> values.
    /// </summary>
    public interface IEntryFactory
    {
        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a file given its name
        /// </summary>
        /// <param name="fileName">The name of the file to create an entry for.</param>
        /// <returns>Returns a <see cref="ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        ZipEntry MakeFileEntry(string fileName);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a file given its name
        /// </summary>
        /// <param name="fileName">The name of the file to create an entry for.</param>
        /// <param name="useFileSystem">If true get details from the file system if the file exists.</param>
        /// <returns>Returns a <see cref="ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        ZipEntry MakeFileEntry(string fileName, bool useFileSystem);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a directory given its name
        /// </summary>
        /// <param name="directoryName">The name of the directory to create an entry for.</param>
        /// <returns>Returns a <see cref="ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        ZipEntry MakeDirectoryEntry(string directoryName);

        /// <summary>
        /// Create a <see cref="ZipEntry"/> for a directory given its name
        /// </summary>
        /// <param name="directoryName">The name of the directory to create an entry for.</param>
        /// <param name="useFileSystem">If true get details from the file system for this directory if it exists.</param>
        /// <returns>Returns a <see cref="ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem);

        /// <summary>
        /// Get/set the <see cref="INameTransform"></see> applicable.
        /// </summary>
        INameTransform NameTransform { get; set; }
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// INameTransform defines how file system names are transformed for use with archives, or vice versa.
    /// </summary>
    public interface INameTransform
    {
        /// <summary>
        /// Given a file name determine the transformed value.
        /// </summary>
        /// <param name="name">The name to transform.</param>
        /// <returns>The transformed file name.</returns>
        string TransformFile(string name);

        /// <summary>
        /// Given a directory name determine the transformed value.
        /// </summary>
        /// <param name="name">The name to transform.</param>
        /// <returns>The transformed directory name</returns>
        string TransformDirectory(string name);
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// Inflater is used to decompress data that has been compressed according
    /// to the "deflate" standard described in rfc1951.
    /// 
    /// By default Zlib (rfc1950) headers and footers are expected in the input.
    /// You can use constructor <code> public Inflater(bool noHeader)</code> passing true
    /// if there is no Zlib header information
    ///
    /// The usage is as following.  First you have to set some input with
    /// <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
    /// inflate any bytes there may be three reasons:
    /// <ul>
    /// <li>IsNeedingInput() returns true because the input buffer is empty.
    /// You have to provide more input with <code>SetInput()</code>.
    /// NOTE: IsNeedingInput() also returns true when, the stream is finished.
    /// </li>
    /// <li>IsNeedingDictionary() returns true, you have to provide a preset
    ///    dictionary with <code>SetDictionary()</code>.</li>
    /// <li>IsFinished returns true, the inflater has finished.</li>
    /// </ul>
    /// Once the first output byte is produced, a dictionary will not be
    /// needed at a later stage.
    ///
    /// author of the original java version : John Leuner, Jochen Hoenicke
    /// </summary>
    public class Inflater
    {
        #region Constants/Readonly
        /// <summary>
        /// Copy lengths for literal codes 257..285
        /// </summary>
        static readonly int[] CPLENS = {
								  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
								  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258
							  };

        /// <summary>
        /// Extra bits for literal codes 257..285
        /// </summary>
        static readonly int[] CPLEXT = {
								  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
								  3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
							  };

        /// <summary>
        /// Copy offsets for distance codes 0..29
        /// </summary>
        static readonly int[] CPDIST = {
								1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
								257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
								8193, 12289, 16385, 24577
							  };

        /// <summary>
        /// Extra bits for distance codes
        /// </summary>
        static readonly int[] CPDEXT = {
								0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
								7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
								12, 12, 13, 13
							  };

        /// <summary>
        /// These are the possible states for an inflater
        /// </summary>
        const int DECODE_HEADER = 0;
        const int DECODE_DICT = 1;
        const int DECODE_BLOCKS = 2;
        const int DECODE_STORED_LEN1 = 3;
        const int DECODE_STORED_LEN2 = 4;
        const int DECODE_STORED = 5;
        const int DECODE_DYN_HEADER = 6;
        const int DECODE_HUFFMAN = 7;
        const int DECODE_HUFFMAN_LENBITS = 8;
        const int DECODE_HUFFMAN_DIST = 9;
        const int DECODE_HUFFMAN_DISTBITS = 10;
        const int DECODE_CHKSUM = 11;
        const int FINISHED = 12;
        #endregion

        #region Instance Fields
        /// <summary>
        /// This variable contains the current state.
        /// </summary>
        int mode;

        /// <summary>
        /// The adler checksum of the dictionary or of the decompressed
        /// stream, as it is written in the header resp. footer of the
        /// compressed stream. 
        /// Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
        /// </summary>
        int readAdler;

        /// <summary>
        /// The number of bits needed to complete the current state.  This
        /// is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
        /// DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
        /// </summary>
        int neededBits;
        int repLength;
        int repDist;
        int uncomprLen;

        /// <summary>
        /// True, if the last block flag was set in the last block of the
        /// inflated stream.  This means that the stream ends after the
        /// current block.
        /// </summary>
        bool isLastBlock;

        /// <summary>
        /// The total number of inflated bytes.
        /// </summary>
        long totalOut;

        /// <summary>
        /// The total number of bytes set with setInput().  This is not the
        /// value returned by the TotalIn property, since this also includes the
        /// unprocessed input.
        /// </summary>
        long totalIn;

        /// <summary>
        /// This variable stores the noHeader flag that was given to the constructor.
        /// True means, that the inflated stream doesn't contain a Zlib header or 
        /// footer.
        /// </summary>
        bool noHeader;

        StreamManipulator input;
        OutputWindow outputWindow;
        InflaterDynHeader dynHeader;
        InflaterHuffmanTree litlenTree, distTree;
        Adler32 adler;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new inflater or RFC1951 decompressor
        /// RFC1950/Zlib headers and footers will be expected in the input data
        /// </summary>
        public Inflater()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new inflater.
        /// </summary>
        /// <param name="noHeader">
        /// True if no RFC1950/Zlib header and footer fields are expected in the input data
        /// 
        /// This is used for GZIPed/Zipped input.
        /// 
        /// For compatibility with
        /// Sun JDK you should provide one byte of input more than needed in
        /// this case.
        /// </param>
        public Inflater(bool noHeader)
        {
            this.noHeader = noHeader;
            this.adler = new Adler32();
            input = new StreamManipulator();
            outputWindow = new OutputWindow();
            mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
        }
        #endregion

        /// <summary>
        /// Resets the inflater so that a new stream can be decompressed.  All
        /// pending input and output will be discarded.
        /// </summary>
        public void Reset()
        {
            mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
            totalIn = 0;
            totalOut = 0;
            input.Reset();
            outputWindow.Reset();
            dynHeader = null;
            litlenTree = null;
            distTree = null;
            isLastBlock = false;
            adler.Reset();
        }

        /// <summary>
        /// Decodes a zlib/RFC1950 header.
        /// </summary>
        /// <returns>
        /// False if more input is needed.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// The header is invalid.
        /// </exception>
        private bool DecodeHeader()
        {
            int header = input.PeekBits(16);
            if (header < 0)
            {
                return false;
            }
            input.DropBits(16);

            // The header is written in "wrong" byte order
            header = ((header << 8) | (header >> 8)) & 0xffff;
            if (header % 31 != 0)
            {
                throw new SharpZipBaseException("Header checksum illegal");
            }

            if ((header & 0x0f00) != (Deflater.DEFLATED << 8))
            {
                throw new SharpZipBaseException("Compression Method unknown");
            }

            /* Maximum size of the backwards window in bits.
            * We currently ignore this, but we could use it to make the
            * inflater window more space efficient. On the other hand the
            * full window (15 bits) is needed most times, anyway.
            int max_wbits = ((header & 0x7000) >> 12) + 8;
            */

            if ((header & 0x0020) == 0)
            { // Dictionary flag?
                mode = DECODE_BLOCKS;
            }
            else
            {
                mode = DECODE_DICT;
                neededBits = 32;
            }
            return true;
        }

        /// <summary>
        /// Decodes the dictionary checksum after the deflate header.
        /// </summary>
        /// <returns>
        /// False if more input is needed.
        /// </returns>
        private bool DecodeDict()
        {
            while (neededBits > 0)
            {
                int dictByte = input.PeekBits(8);
                if (dictByte < 0)
                {
                    return false;
                }
                input.DropBits(8);
                readAdler = (readAdler << 8) | dictByte;
                neededBits -= 8;
            }
            return false;
        }

        /// <summary>
        /// Decodes the huffman encoded symbols in the input stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed, true if output window is
        /// full or the current block ends.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// if deflated stream is invalid.
        /// </exception>
        private bool DecodeHuffman()
        {
            int free = outputWindow.GetFreeSpace();
            while (free >= 258)
            {
                int symbol;
                switch (mode)
                {
                    case DECODE_HUFFMAN:
                        // This is the inner loop so it is optimized a bit
                        while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)
                        {
                            outputWindow.Write(symbol);
                            if (--free < 258)
                            {
                                return true;
                            }
                        }

                        if (symbol < 257)
                        {
                            if (symbol < 0)
                            {
                                return false;
                            }
                            else
                            {
                                // symbol == 256: end of block
                                distTree = null;
                                litlenTree = null;
                                mode = DECODE_BLOCKS;
                                return true;
                            }
                        }

                        try
                        {
                            repLength = CPLENS[symbol - 257];
                            neededBits = CPLEXT[symbol - 257];
                        }
                        catch (Exception)
                        {
                            throw new SharpZipBaseException("Illegal rep length code");
                        }
                        goto case DECODE_HUFFMAN_LENBITS; // fall through

                    case DECODE_HUFFMAN_LENBITS:
                        if (neededBits > 0)
                        {
                            mode = DECODE_HUFFMAN_LENBITS;
                            int i = input.PeekBits(neededBits);
                            if (i < 0)
                            {
                                return false;
                            }
                            input.DropBits(neededBits);
                            repLength += i;
                        }
                        mode = DECODE_HUFFMAN_DIST;
                        goto case DECODE_HUFFMAN_DIST; // fall through

                    case DECODE_HUFFMAN_DIST:
                        symbol = distTree.GetSymbol(input);
                        if (symbol < 0)
                        {
                            return false;
                        }

                        try
                        {
                            repDist = CPDIST[symbol];
                            neededBits = CPDEXT[symbol];
                        }
                        catch (Exception)
                        {
                            throw new SharpZipBaseException("Illegal rep dist code");
                        }

                        goto case DECODE_HUFFMAN_DISTBITS; // fall through

                    case DECODE_HUFFMAN_DISTBITS:
                        if (neededBits > 0)
                        {
                            mode = DECODE_HUFFMAN_DISTBITS;
                            int i = input.PeekBits(neededBits);
                            if (i < 0)
                            {
                                return false;
                            }
                            input.DropBits(neededBits);
                            repDist += i;
                        }

                        outputWindow.Repeat(repLength, repDist);
                        free -= repLength;
                        mode = DECODE_HUFFMAN;
                        break;

                    default:
                        throw new SharpZipBaseException("Inflater unknown mode");
                }
            }
            return true;
        }

        /// <summary>
        /// Decodes the adler checksum after the deflate stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// If checksum doesn't match.
        /// </exception>
        private bool DecodeChksum()
        {
            while (neededBits > 0)
            {
                int chkByte = input.PeekBits(8);
                if (chkByte < 0)
                {
                    return false;
                }
                input.DropBits(8);
                readAdler = (readAdler << 8) | chkByte;
                neededBits -= 8;
            }

            if ((int)adler.Value != readAdler)
            {
                throw new SharpZipBaseException("Adler chksum doesn't match: " + (int)adler.Value + " vs. " + readAdler);
            }

            mode = FINISHED;
            return false;
        }

        /// <summary>
        /// Decodes the deflated stream.
        /// </summary>
        /// <returns>
        /// false if more input is needed, or if finished.
        /// </returns>
        /// <exception cref="SharpZipBaseException">
        /// if deflated stream is invalid.
        /// </exception>
        private bool Decode()
        {
            switch (mode)
            {
                case DECODE_HEADER:
                    return DecodeHeader();

                case DECODE_DICT:
                    return DecodeDict();

                case DECODE_CHKSUM:
                    return DecodeChksum();

                case DECODE_BLOCKS:
                    if (isLastBlock)
                    {
                        if (noHeader)
                        {
                            mode = FINISHED;
                            return false;
                        }
                        else
                        {
                            input.SkipToByteBoundary();
                            neededBits = 32;
                            mode = DECODE_CHKSUM;
                            return true;
                        }
                    }

                    int type = input.PeekBits(3);
                    if (type < 0)
                    {
                        return false;
                    }
                    input.DropBits(3);

                    if ((type & 1) != 0)
                    {
                        isLastBlock = true;
                    }
                    switch (type >> 1)
                    {
                        case DeflaterConstants.STORED_BLOCK:
                            input.SkipToByteBoundary();
                            mode = DECODE_STORED_LEN1;
                            break;
                        case DeflaterConstants.STATIC_TREES:
                            litlenTree = InflaterHuffmanTree.defLitLenTree;
                            distTree = InflaterHuffmanTree.defDistTree;
                            mode = DECODE_HUFFMAN;
                            break;
                        case DeflaterConstants.DYN_TREES:
                            dynHeader = new InflaterDynHeader();
                            mode = DECODE_DYN_HEADER;
                            break;
                        default:
                            throw new SharpZipBaseException("Unknown block type " + type);
                    }
                    return true;

                case DECODE_STORED_LEN1:
                    {
                        if ((uncomprLen = input.PeekBits(16)) < 0)
                        {
                            return false;
                        }
                        input.DropBits(16);
                        mode = DECODE_STORED_LEN2;
                    }
                    goto case DECODE_STORED_LEN2; // fall through

                case DECODE_STORED_LEN2:
                    {
                        int nlen = input.PeekBits(16);
                        if (nlen < 0)
                        {
                            return false;
                        }
                        input.DropBits(16);
                        if (nlen != (uncomprLen ^ 0xffff))
                        {
                            throw new SharpZipBaseException("broken uncompressed block");
                        }
                        mode = DECODE_STORED;
                    }
                    goto case DECODE_STORED; // fall through

                case DECODE_STORED:
                    {
                        int more = outputWindow.CopyStored(input, uncomprLen);
                        uncomprLen -= more;
                        if (uncomprLen == 0)
                        {
                            mode = DECODE_BLOCKS;
                            return true;
                        }
                        return !input.IsNeedingInput;
                    }

                case DECODE_DYN_HEADER:
                    if (!dynHeader.Decode(input))
                    {
                        return false;
                    }

                    litlenTree = dynHeader.BuildLitLenTree();
                    distTree = dynHeader.BuildDistTree();
                    mode = DECODE_HUFFMAN;
                    goto case DECODE_HUFFMAN; // fall through

                case DECODE_HUFFMAN:
                case DECODE_HUFFMAN_LENBITS:
                case DECODE_HUFFMAN_DIST:
                case DECODE_HUFFMAN_DISTBITS:
                    return DecodeHuffman();

                case FINISHED:
                    return false;

                default:
                    throw new SharpZipBaseException("Inflater.Decode unknown mode");
            }
        }

        /// <summary>
        /// Sets the preset dictionary.  This should only be called, if
        /// needsDictionary() returns true and it should set the same
        /// dictionary, that was used for deflating.  The getAdler()
        /// function returns the checksum of the dictionary needed.
        /// </summary>
        /// <param name="buffer">
        /// The dictionary.
        /// </param>
        public void SetDictionary(byte[] buffer)
        {
            SetDictionary(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Sets the preset dictionary.  This should only be called, if
        /// needsDictionary() returns true and it should set the same
        /// dictionary, that was used for deflating.  The getAdler()
        /// function returns the checksum of the dictionary needed.
        /// </summary>
        /// <param name="buffer">
        /// The dictionary.
        /// </param>
        /// <param name="index">
        /// The index into buffer where the dictionary starts.
        /// </param>
        /// <param name="count">
        /// The number of bytes in the dictionary.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// No dictionary is needed.
        /// </exception>
        /// <exception cref="SharpZipBaseException">
        /// The adler checksum for the buffer is invalid
        /// </exception>
        public void SetDictionary(byte[] buffer, int index, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (index < 0)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if (!IsNeedingDictionary)
            {
                throw new InvalidOperationException("Dictionary is not needed");
            }

            adler.Update(buffer, index, count);

            if ((int)adler.Value != readAdler)
            {
                throw new SharpZipBaseException("Wrong adler checksum");
            }
            adler.Reset();
            outputWindow.CopyDict(buffer, index, count);
            mode = DECODE_BLOCKS;
        }

        /// <summary>
        /// Sets the input.  This should only be called, if needsInput()
        /// returns true.
        /// </summary>
        /// <param name="buffer">
        /// the input.
        /// </param>
        public void SetInput(byte[] buffer)
        {
            SetInput(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Sets the input.  This should only be called, if needsInput()
        /// returns true.
        /// </summary>
        /// <param name="buffer">
        /// The source of input data
        /// </param>
        /// <param name="index">
        /// The index into buffer where the input starts.
        /// </param>
        /// <param name="count">
        /// The number of bytes of input to use.
        /// </param>
        /// <exception cref="System.InvalidOperationException">
        /// No input is needed.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// The index and/or count are wrong.
        /// </exception>
        public void SetInput(byte[] buffer, int index, int count)
        {
            input.SetInput(buffer, index, count);
            totalIn += (long)count;
        }

        /// <summary>
        /// Inflates the compressed stream to the output buffer.  If this
        /// returns 0, you should check, whether IsNeedingDictionary(),
        /// IsNeedingInput() or IsFinished() returns true, to determine why no
        /// further output is produced.
        /// </summary>
        /// <param name="buffer">
        /// the output buffer.
        /// </param>
        /// <returns>
        /// The number of bytes written to the buffer, 0 if no further
        /// output can be produced.
        /// </returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if buffer has length 0.
        /// </exception>
        /// <exception cref="System.FormatException">
        /// if deflated stream is invalid.
        /// </exception>
        public int Inflate(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            return Inflate(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Inflates the compressed stream to the output buffer.  If this
        /// returns 0, you should check, whether needsDictionary(),
        /// needsInput() or finished() returns true, to determine why no
        /// further output is produced.
        /// </summary>
        /// <param name="buffer">
        /// the output buffer.
        /// </param>
        /// <param name="offset">
        /// the offset in buffer where storing starts.
        /// </param>
        /// <param name="count">
        /// the maximum number of bytes to output.
        /// </param>
        /// <returns>
        /// the number of bytes written to the buffer, 0 if no further output can be produced.
        /// </returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if count is less than 0.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// if the index and / or count are wrong.
        /// </exception>
        /// <exception cref="System.FormatException">
        /// if deflated stream is invalid.
        /// </exception>
        public int Inflate(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "count cannot be negative");
#endif
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "offset cannot be negative");
#endif
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException("count exceeds buffer bounds");
            }

            // Special case: count may be zero
            if (count == 0)
            {
                if (!IsFinished)
                { // -jr- 08-Nov-2003 INFLATE_BUG fix..
                    Decode();
                }
                return 0;
            }

            int bytesCopied = 0;

            do
            {
                if (mode != DECODE_CHKSUM)
                {
                    /* Don't give away any output, if we are waiting for the
                    * checksum in the input stream.
                    *
                    * With this trick we have always:
                    *   IsNeedingInput() and not IsFinished()
                    *   implies more output can be produced.
                    */
                    int more = outputWindow.CopyOutput(buffer, offset, count);
                    if (more > 0)
                    {
                        adler.Update(buffer, offset, more);
                        offset += more;
                        bytesCopied += more;
                        totalOut += (long)more;
                        count -= more;
                        if (count == 0)
                        {
                            return bytesCopied;
                        }
                    }
                }
            } while (Decode() || ((outputWindow.GetAvailable() > 0) && (mode != DECODE_CHKSUM)));
            return bytesCopied;
        }

        /// <summary>
        /// Returns true, if the input buffer is empty.
        /// You should then call setInput(). 
        /// NOTE: This method also returns true when the stream is finished.
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return input.IsNeedingInput;
            }
        }

        /// <summary>
        /// Returns true, if a preset dictionary is needed to inflate the input.
        /// </summary>
        public bool IsNeedingDictionary
        {
            get
            {
                return mode == DECODE_DICT && neededBits == 0;
            }
        }

        /// <summary>
        /// Returns true, if the inflater has finished.  This means, that no
        /// input is needed and no output can be produced.
        /// </summary>
        public bool IsFinished
        {
            get
            {
                return mode == FINISHED && outputWindow.GetAvailable() == 0;
            }
        }

        /// <summary>
        /// Gets the adler checksum.  This is either the checksum of all
        /// uncompressed bytes returned by inflate(), or if needsDictionary()
        /// returns true (and thus no output was yet produced) this is the
        /// adler checksum of the expected dictionary.
        /// </summary>
        /// <returns>
        /// the adler checksum.
        /// </returns>
        public int Adler
        {
            get
            {
                return IsNeedingDictionary ? readAdler : (int)adler.Value;
            }
        }

        /// <summary>
        /// Gets the total number of output bytes returned by Inflate().
        /// </summary>
        /// <returns>
        /// the total number of output bytes.
        /// </returns>
        public long TotalOut
        {
            get
            {
                return totalOut;
            }
        }

        /// <summary>
        /// Gets the total number of processed compressed input bytes.
        /// </summary>
        /// <returns>
        /// The total number of bytes of processed input bytes.
        /// </returns>
        public long TotalIn
        {
            get
            {
                return totalIn - (long)RemainingInput;
            }
        }

        /// <summary>
        /// Gets the number of unprocessed input bytes.  Useful, if the end of the
        /// stream is reached and you want to further process the bytes after
        /// the deflate stream.
        /// </summary>
        /// <returns>
        /// The number of bytes of the input which have not been processed.
        /// </returns>
        public int RemainingInput
        {
            // TODO: This should be a long?
            get
            {
                return input.AvailableBytes;
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    class InflaterDynHeader
    {
        #region Constants
        const int LNUM = 0;
        const int DNUM = 1;
        const int BLNUM = 2;
        const int BLLENS = 3;
        const int LENS = 4;
        const int REPS = 5;

        static readonly int[] repMin = { 3, 3, 11 };
        static readonly int[] repBits = { 2, 3, 7 };

        static readonly int[] BL_ORDER = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

        #endregion

        #region Constructors
        public InflaterDynHeader()
        {
        }
        #endregion

        public bool Decode(StreamManipulator input)
        {
        decode_loop:
            for (; ; )
            {
                switch (mode)
                {
                    case LNUM:
                        lnum = input.PeekBits(5);
                        if (lnum < 0)
                        {
                            return false;
                        }
                        lnum += 257;
                        input.DropBits(5);
                        //  	    System.err.println("LNUM: "+lnum);
                        mode = DNUM;
                        goto case DNUM; // fall through
                    case DNUM:
                        dnum = input.PeekBits(5);
                        if (dnum < 0)
                        {
                            return false;
                        }
                        dnum++;
                        input.DropBits(5);
                        //  	    System.err.println("DNUM: "+dnum);
                        num = lnum + dnum;
                        litdistLens = new byte[num];
                        mode = BLNUM;
                        goto case BLNUM; // fall through
                    case BLNUM:
                        blnum = input.PeekBits(4);
                        if (blnum < 0)
                        {
                            return false;
                        }
                        blnum += 4;
                        input.DropBits(4);
                        blLens = new byte[19];
                        ptr = 0;
                        //  	    System.err.println("BLNUM: "+blnum);
                        mode = BLLENS;
                        goto case BLLENS; // fall through
                    case BLLENS:
                        while (ptr < blnum)
                        {
                            int len = input.PeekBits(3);
                            if (len < 0)
                            {
                                return false;
                            }
                            input.DropBits(3);
                            //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);
                            blLens[BL_ORDER[ptr]] = (byte)len;
                            ptr++;
                        }
                        blTree = new InflaterHuffmanTree(blLens);
                        blLens = null;
                        ptr = 0;
                        mode = LENS;
                        goto case LENS; // fall through
                    case LENS:
                        {
                            int symbol;
                            while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)
                            {
                                /* Normal case: symbol in [0..15] */

                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);
                                litdistLens[ptr++] = lastLen = (byte)symbol;

                                if (ptr == num)
                                {
                                    /* Finished */
                                    return true;
                                }
                            }

                            /* need more input ? */
                            if (symbol < 0)
                            {
                                return false;
                            }

                            /* otherwise repeat code */
                            if (symbol >= 17)
                            {
                                /* repeat zero */
                                //  		  System.err.println("repeating zero");
                                lastLen = 0;
                            }
                            else
                            {
                                if (ptr == 0)
                                {
                                    throw new SharpZipBaseException();
                                }
                            }
                            repSymbol = symbol - 16;
                        }
                        mode = REPS;
                        goto case REPS; // fall through
                    case REPS:
                        {
                            int bits = repBits[repSymbol];
                            int count = input.PeekBits(bits);
                            if (count < 0)
                            {
                                return false;
                            }
                            input.DropBits(bits);
                            count += repMin[repSymbol];
                            //  	      System.err.println("litdistLens repeated: "+count);

                            if (ptr + count > num)
                            {
                                throw new SharpZipBaseException();
                            }
                            while (count-- > 0)
                            {
                                litdistLens[ptr++] = lastLen;
                            }

                            if (ptr == num)
                            {
                                /* Finished */
                                return true;
                            }
                        }
                        mode = LENS;
                        goto decode_loop;
                }
            }
        }

        public InflaterHuffmanTree BuildLitLenTree()
        {
            byte[] litlenLens = new byte[lnum];
            Array.Copy(litdistLens, 0, litlenLens, 0, lnum);
            return new InflaterHuffmanTree(litlenLens);
        }

        public InflaterHuffmanTree BuildDistTree()
        {
            byte[] distLens = new byte[dnum];
            Array.Copy(litdistLens, lnum, distLens, 0, dnum);
            return new InflaterHuffmanTree(distLens);
        }

        #region Instance Fields
        byte[] blLens;
        byte[] litdistLens;

        InflaterHuffmanTree blTree;

        /// <summary>
        /// The current decode mode
        /// </summary>
        int mode;
        int lnum, dnum, blnum, num;
        int repSymbol;
        byte lastLen;
        int ptr;
        #endregion

    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;

    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// Huffman tree used for inflation
    /// </summary>
    public class InflaterHuffmanTree
    {
        #region Constants
        const int MAX_BITLEN = 15;
        #endregion

        #region Instance Fields
        short[] tree;
        #endregion

        /// <summary>
        /// Literal length tree
        /// </summary>
        public static InflaterHuffmanTree defLitLenTree;

        /// <summary>
        /// Distance tree
        /// </summary>
        public static InflaterHuffmanTree defDistTree;

        static InflaterHuffmanTree()
        {
            try
            {
                byte[] codeLengths = new byte[288];
                int i = 0;
                while (i < 144)
                {
                    codeLengths[i++] = 8;
                }
                while (i < 256)
                {
                    codeLengths[i++] = 9;
                }
                while (i < 280)
                {
                    codeLengths[i++] = 7;
                }
                while (i < 288)
                {
                    codeLengths[i++] = 8;
                }
                defLitLenTree = new InflaterHuffmanTree(codeLengths);

                codeLengths = new byte[32];
                i = 0;
                while (i < 32)
                {
                    codeLengths[i++] = 5;
                }
                defDistTree = new InflaterHuffmanTree(codeLengths);
            }
            catch (Exception)
            {
                throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");
            }
        }

        #region Constructors
        /// <summary>
        /// Constructs a Huffman tree from the array of code lengths.
        /// </summary>
        /// <param name = "codeLengths">
        /// the array of code lengths
        /// </param>
        public InflaterHuffmanTree(byte[] codeLengths)
        {
            BuildTree(codeLengths);
        }
        #endregion

        void BuildTree(byte[] codeLengths)
        {
            int[] blCount = new int[MAX_BITLEN + 1];
            int[] nextCode = new int[MAX_BITLEN + 1];

            for (int i = 0; i < codeLengths.Length; i++)
            {
                int bits = codeLengths[i];
                if (bits > 0)
                {
                    blCount[bits]++;
                }
            }

            int code = 0;
            int treeSize = 512;
            for (int bits = 1; bits <= MAX_BITLEN; bits++)
            {
                nextCode[bits] = code;
                code += blCount[bits] << (16 - bits);
                if (bits >= 10)
                {
                    /* We need an extra table for bit lengths >= 10. */
                    int start = nextCode[bits] & 0x1ff80;
                    int end = code & 0x1ff80;
                    treeSize += (end - start) >> (16 - bits);
                }
            }

            /* -jr comment this out! doesnt work for dynamic trees and pkzip 2.04g
                        if (code != 65536) 
                        {
                            throw new SharpZipBaseException("Code lengths don't add up properly.");
                        }
            */
            /* Now create and fill the extra tables from longest to shortest
            * bit len.  This way the sub trees will be aligned.
            */
            tree = new short[treeSize];
            int treePtr = 512;
            for (int bits = MAX_BITLEN; bits >= 10; bits--)
            {
                int end = code & 0x1ff80;
                code -= blCount[bits] << (16 - bits);
                int start = code & 0x1ff80;
                for (int i = start; i < end; i += 1 << 7)
                {
                    tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);
                    treePtr += 1 << (bits - 9);
                }
            }

            for (int i = 0; i < codeLengths.Length; i++)
            {
                int bits = codeLengths[i];
                if (bits == 0)
                {
                    continue;
                }
                code = nextCode[bits];
                int revcode = DeflaterHuffman.BitReverse(code);
                if (bits <= 9)
                {
                    do
                    {
                        tree[revcode] = (short)((i << 4) | bits);
                        revcode += 1 << bits;
                    } while (revcode < 512);
                }
                else
                {
                    int subTree = tree[revcode & 511];
                    int treeLen = 1 << (subTree & 15);
                    subTree = -(subTree >> 4);
                    do
                    {
                        tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);
                        revcode += 1 << bits;
                    } while (revcode < treeLen);
                }
                nextCode[bits] = code + (1 << (16 - bits));
            }

        }

        /// <summary>
        /// Reads the next symbol from input.  The symbol is encoded using the
        /// huffman tree.
        /// </summary>
        /// <param name="input">
        /// input the input source.
        /// </param>
        /// <returns>
        /// the next symbol, or -1 if not enough input is available.
        /// </returns>
        public int GetSymbol(StreamManipulator input)
        {
            int lookahead, symbol;
            if ((lookahead = input.PeekBits(9)) >= 0)
            {
                if ((symbol = tree[lookahead]) >= 0)
                {
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                int subtree = -(symbol >> 4);
                int bitlen = symbol & 15;
                if ((lookahead = input.PeekBits(bitlen)) >= 0)
                {
                    symbol = tree[subtree | (lookahead >> 9)];
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                else
                {
                    int bits = input.AvailableBits;
                    lookahead = input.PeekBits(bits);
                    symbol = tree[subtree | (lookahead >> 9)];
                    if ((symbol & 15) <= bits)
                    {
                        input.DropBits(symbol & 15);
                        return symbol >> 4;
                    }
                    else
                    {
                        return -1;
                    }
                }
            }
            else
            {
                int bits = input.AvailableBits;
                lookahead = input.PeekBits(bits);
                symbol = tree[lookahead];
                if (symbol >= 0 && (symbol & 15) <= bits)
                {
                    input.DropBits(symbol & 15);
                    return symbol >> 4;
                }
                else
                {
                    return -1;
                }
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    using System.IO;

#if !NETCF_1_0
    using System.Security.Cryptography;
#endif
    /// <summary>
    /// An input buffer customised for use by <see cref="InflaterInputStream"/>
    /// </summary>
    /// <remarks>
    /// The buffer supports decryption of incoming data.
    /// </remarks>
    public class InflaterInputBuffer
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="InflaterInputBuffer"/> with a default buffer size
        /// </summary>
        /// <param name="stream">The stream to buffer.</param>
        public InflaterInputBuffer(Stream stream)
            : this(stream, 4096)
        {
        }

        /// <summary>
        /// Initialise a new instance of <see cref="InflaterInputBuffer"/>
        /// </summary>
        /// <param name="stream">The stream to buffer.</param>
        /// <param name="bufferSize">The size to use for the buffer</param>
        /// <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        public InflaterInputBuffer(Stream stream, int bufferSize)
        {
            inputStream = stream;
            if (bufferSize < 1024)
            {
                bufferSize = 1024;
            }
            rawData = new byte[bufferSize];
            clearText = rawData;
        }
        #endregion

        /// <summary>
        /// Get the length of bytes bytes in the <see cref="RawData"/>
        /// </summary>
        public int RawLength
        {
            get
            {
                return rawLength;
            }
        }

        /// <summary>
        /// Get the contents of the raw data buffer.
        /// </summary>
        /// <remarks>This may contain encrypted data.</remarks>
        public byte[] RawData
        {
            get
            {
                return rawData;
            }
        }

        /// <summary>
        /// Get the number of useable bytes in <see cref="ClearText"/>
        /// </summary>
        public int ClearTextLength
        {
            get
            {
                return clearTextLength;
            }
        }

        /// <summary>
        /// Get the contents of the clear text buffer.
        /// </summary>
        public byte[] ClearText
        {
            get
            {
                return clearText;
            }
        }

        /// <summary>
        /// Get/set the number of bytes available
        /// </summary>
        public int Available
        {
            get { return available; }
            set { available = value; }
        }

        /// <summary>
        /// Call <see cref="Inflater.SetInput(byte[], int, int)"/> passing the current clear text buffer contents.
        /// </summary>
        /// <param name="inflater">The inflater to set input for.</param>
        public void SetInflaterInput(Inflater inflater)
        {
            if (available > 0)
            {
                inflater.SetInput(clearText, clearTextLength - available, available);
                available = 0;
            }
        }

        /// <summary>
        /// Fill the buffer from the underlying input stream.
        /// </summary>
        public void Fill()
        {
            rawLength = 0;
            int toRead = rawData.Length;

            while (toRead > 0)
            {
                int count = inputStream.Read(rawData, rawLength, toRead);
                if (count <= 0)
                {
                    break;
                }
                rawLength += count;
                toRead -= count;
            }

#if !NETCF_1_0
            if (cryptoTransform != null)
            {
                clearTextLength = cryptoTransform.TransformBlock(rawData, 0, rawLength, clearText, 0);
            }
            else
#endif
            {
                clearTextLength = rawLength;
            }

            available = clearTextLength;
        }

        /// <summary>
        /// Read a buffer directly from the input stream
        /// </summary>
        /// <param name="buffer">The buffer to fill</param>
        /// <returns>Returns the number of bytes read.</returns>
        public int ReadRawBuffer(byte[] buffer)
        {
            return ReadRawBuffer(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Read a buffer directly from the input stream
        /// </summary>
        /// <param name="outBuffer">The buffer to read into</param>
        /// <param name="offset">The offset to start reading data into.</param>
        /// <param name="length">The number of bytes to read.</param>
        /// <returns>Returns the number of bytes read.</returns>
        public int ReadRawBuffer(byte[] outBuffer, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            int currentOffset = offset;
            int currentLength = length;

            while (currentLength > 0)
            {
                if (available <= 0)
                {
                    Fill();
                    if (available <= 0)
                    {
                        return 0;
                    }
                }
                int toCopy = Math.Min(currentLength, available);
                System.Array.Copy(rawData, rawLength - (int)available, outBuffer, currentOffset, toCopy);
                currentOffset += toCopy;
                currentLength -= toCopy;
                available -= toCopy;
            }
            return length;
        }

        /// <summary>
        /// Read clear text data from the input stream.
        /// </summary>
        /// <param name="outBuffer">The buffer to add data to.</param>
        /// <param name="offset">The offset to start adding data at.</param>
        /// <param name="length">The number of bytes to read.</param>
        /// <returns>Returns the number of bytes actually read.</returns>
        public int ReadClearTextBuffer(byte[] outBuffer, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            int currentOffset = offset;
            int currentLength = length;

            while (currentLength > 0)
            {
                if (available <= 0)
                {
                    Fill();
                    if (available <= 0)
                    {
                        return 0;
                    }
                }

                int toCopy = Math.Min(currentLength, available);
                Array.Copy(clearText, clearTextLength - (int)available, outBuffer, currentOffset, toCopy);
                currentOffset += toCopy;
                currentLength -= toCopy;
                available -= toCopy;
            }
            return length;
        }

        /// <summary>
        /// Read a <see cref="byte"/> from the input stream.
        /// </summary>
        /// <returns>Returns the byte read.</returns>
        public int ReadLeByte()
        {
            if (available <= 0)
            {
                Fill();
                if (available <= 0)
                {
                    throw new ZipException("EOF in header");
                }
            }
            byte result = rawData[rawLength - available];
            available -= 1;
            return result;
        }

        /// <summary>
        /// Read an <see cref="short"/> in little endian byte order.
        /// </summary>
        /// <returns>The short value read case to an int.</returns>
        public int ReadLeShort()
        {
            return ReadLeByte() | (ReadLeByte() << 8);
        }

        /// <summary>
        /// Read an <see cref="int"/> in little endian byte order.
        /// </summary>
        /// <returns>The int value read.</returns>
        public int ReadLeInt()
        {
            return ReadLeShort() | (ReadLeShort() << 16);
        }

        /// <summary>
        /// Read a <see cref="long"/> in little endian byte order.
        /// </summary>
        /// <returns>The long value read.</returns>
        public long ReadLeLong()
        {
            return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
        }

#if !NETCF_1_0
        /// <summary>
        /// Get/set the <see cref="ICryptoTransform"/> to apply to any data.
        /// </summary>
        /// <remarks>Set this value to null to have no transform applied.</remarks>
        public ICryptoTransform CryptoTransform
        {
            set
            {
                cryptoTransform = value;
                if (cryptoTransform != null)
                {
                    if (rawData == clearText)
                    {
                        if (internalClearText == null)
                        {
                            internalClearText = new byte[rawData.Length];
                        }
                        clearText = internalClearText;
                    }
                    clearTextLength = rawLength;
                    if (available > 0)
                    {
                        cryptoTransform.TransformBlock(rawData, rawLength - available, available, clearText, rawLength - available);
                    }
                }
                else
                {
                    clearText = rawData;
                    clearTextLength = rawLength;
                }
            }
        }
#endif

        #region Instance Fields
        int rawLength;
        byte[] rawData;

        int clearTextLength;
        byte[] clearText;
#if !NETCF_1_0
        byte[] internalClearText;
#endif

        int available;

#if !NETCF_1_0
        ICryptoTransform cryptoTransform;
#endif
        Stream inputStream;
        #endregion
    }

    /// <summary>
    /// This filter stream is used to decompress data compressed using the "deflate"
    /// format. The "deflate" format is described in RFC 1951.
    ///
    /// This stream may form the basis for other decompression filters, such
    /// as the <see cref="ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
    ///
    /// Author of the original java version : John Leuner.
    /// </summary>
    public class InflaterInputStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Create an InflaterInputStream with the default decompressor
        /// and a default buffer size of 4KB.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The InputStream to read bytes from
        /// </param>
        public InflaterInputStream(Stream baseInputStream)
            : this(baseInputStream, new Inflater(), 4096)
        {
        }

        /// <summary>
        /// Create an InflaterInputStream with the specified decompressor
        /// and a default buffer size of 4KB.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The source of input data
        /// </param>
        /// <param name = "inf">
        /// The decompressor used to decompress data read from baseInputStream
        /// </param>
        public InflaterInputStream(Stream baseInputStream, Inflater inf)
            : this(baseInputStream, inf, 4096)
        {
        }

        /// <summary>
        /// Create an InflaterInputStream with the specified decompressor
        /// and the specified buffer size.
        /// </summary>
        /// <param name = "baseInputStream">
        /// The InputStream to read bytes from
        /// </param>
        /// <param name = "inflater">
        /// The decompressor to use
        /// </param>
        /// <param name = "bufferSize">
        /// Size of the buffer to use
        /// </param>
        public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize)
        {
            if (baseInputStream == null)
            {
                throw new ArgumentNullException("baseInputStream");
            }

            if (inflater == null)
            {
                throw new ArgumentNullException("inflater");
            }

            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }

            this.baseInputStream = baseInputStream;
            this.inf = inflater;

            inputBuffer = new InflaterInputBuffer(baseInputStream, bufferSize);
        }

        #endregion

        /// <summary>
        /// Get/set flag indicating ownership of underlying stream.
        /// When the flag is true <see cref="Close"/> will close the underlying stream also.
        /// </summary>
        /// <remarks>
        /// The default value is true.
        /// </remarks>
        public bool IsStreamOwner
        {
            get { return isStreamOwner; }
            set { isStreamOwner = value; }
        }

        /// <summary>
        /// Skip specified number of bytes of uncompressed data
        /// </summary>
        /// <param name ="count">
        /// Number of bytes to skip
        /// </param>
        /// <returns>
        /// The number of bytes skipped, zero if the end of 
        /// stream has been reached
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
        /// </exception>
        public long Skip(long count)
        {
            if (count <= 0)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            // v0.80 Skip by seeking if underlying stream supports it...
            if (baseInputStream.CanSeek)
            {
                baseInputStream.Seek(count, SeekOrigin.Current);
                return count;
            }
            else
            {
                int length = 2048;
                if (count < length)
                {
                    length = (int)count;
                }

                byte[] tmp = new byte[length];
                int readCount = 1;
                long toSkip = count;

                while ((toSkip > 0) && (readCount > 0))
                {
                    if (toSkip < length)
                    {
                        length = (int)toSkip;
                    }

                    readCount = baseInputStream.Read(tmp, 0, length);
                    toSkip -= readCount;
                }

                return count - toSkip;
            }
        }

        /// <summary>
        /// Clear any cryptographic state.
        /// </summary>		
        protected void StopDecrypting()
        {
#if !NETCF_1_0
            inputBuffer.CryptoTransform = null;
#endif
        }

        /// <summary>
        /// Returns 0 once the end of the stream (EOF) has been reached.
        /// Otherwise returns 1.
        /// </summary>
        public virtual int Available
        {
            get
            {
                return inf.IsFinished ? 0 : 1;
            }
        }

        /// <summary>
        /// Fills the buffer with more data to decompress.
        /// </summary>
        /// <exception cref="SharpZipBaseException">
        /// Stream ends early
        /// </exception>
        protected void Fill()
        {
            // Protect against redundant calls
            if (inputBuffer.Available <= 0)
            {
                inputBuffer.Fill();
                if (inputBuffer.Available <= 0)
                {
                    throw new SharpZipBaseException("Unexpected EOF");
                }
            }
            inputBuffer.SetInflaterInput(inf);
        }

        #region Stream Overrides
        /// <summary>
        /// Gets a value indicating whether the current stream supports reading
        /// </summary>
        public override bool CanRead
        {
            get
            {
                return baseInputStream.CanRead;
            }
        }

        /// <summary>
        /// Gets a value of false indicating seeking is not supported for this stream.
        /// </summary>
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a value of false indicating that this stream is not writeable.
        /// </summary>
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// A value representing the length of the stream in bytes.
        /// </summary>
        public override long Length
        {
            get
            {
                return inputBuffer.RawLength;
            }
        }

        /// <summary>
        /// The current position within the stream.
        /// Throws a NotSupportedException when attempting to set the position
        /// </summary>
        /// <exception cref="NotSupportedException">Attempting to set the position</exception>
        public override long Position
        {
            get
            {
                return baseInputStream.Position;
            }
            set
            {
                throw new NotSupportedException("InflaterInputStream Position not supported");
            }
        }

        /// <summary>
        /// Flushes the baseInputStream
        /// </summary>
        public override void Flush()
        {
            baseInputStream.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="offset">The relative offset to seek to.</param>
        /// <param name="origin">The <see cref="SeekOrigin"/> defining where to seek from.</param>
        /// <returns>The new position in the stream.</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Seek not supported");
        }

        /// <summary>
        /// Set the length of the current stream
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="value">The new length value for the stream.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("InflaterInputStream SetLength not supported");
        }

        /// <summary>
        /// Writes a sequence of bytes to stream and advances the current position
        /// This method always throws a NotSupportedException
        /// </summary>
        /// <param name="buffer">Thew buffer containing data to write.</param>
        /// <param name="offset">The offset of the first byte to write.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("InflaterInputStream Write not supported");
        }

        /// <summary>
        /// Writes one byte to the current stream and advances the current position
        /// Always throws a NotSupportedException
        /// </summary>
        /// <param name="value">The byte to write.</param>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override void WriteByte(byte value)
        {
            throw new NotSupportedException("InflaterInputStream WriteByte not supported");
        }

        /// <summary>
        /// Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
        /// </summary>
        /// <param name="buffer">The buffer to write data from</param>
        /// <param name="offset">Offset of first byte to write</param>
        /// <param name="count">The maximum number of bytes to write</param>
        /// <param name="callback">The method to be called when the asynchronous write operation is completed</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
        /// <returns>An <see cref="System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
        /// <exception cref="NotSupportedException">Any access</exception>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException("InflaterInputStream BeginWrite not supported");
        }

        /// <summary>
        /// Closes the input stream.  When <see cref="IsStreamOwner"></see>
        /// is true the underlying stream is also closed.
        /// </summary>
        public override void Close()
        {
            if (!isClosed)
            {
                isClosed = true;
                if (isStreamOwner)
                {
                    baseInputStream.Close();
                }
            }
        }

        /// <summary>
        /// Reads decompressed data into the provided buffer byte array
        /// </summary>
        /// <param name ="buffer">
        /// The array to read and decompress data into
        /// </param>
        /// <param name ="offset">
        /// The offset indicating where the data should be placed
        /// </param>
        /// <param name ="count">
        /// The number of bytes to decompress
        /// </param>
        /// <returns>The number of bytes read.  Zero signals the end of stream</returns>
        /// <exception cref="SharpZipBaseException">
        /// Inflater needs a dictionary
        /// </exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (inf.IsNeedingDictionary)
            {
                throw new SharpZipBaseException("Need a dictionary");
            }

            int remainingBytes = count;
            while (true)
            {
                int bytesRead = inf.Inflate(buffer, offset, remainingBytes);
                offset += bytesRead;
                remainingBytes -= bytesRead;

                if (remainingBytes == 0 || inf.IsFinished)
                {
                    break;
                }

                if (inf.IsNeedingInput)
                {
                    Fill();
                }
                else if (bytesRead == 0)
                {
                    throw new ZipException("Dont know what to do");
                }
            }
            return count - remainingBytes;
        }
        #endregion

        #region Instance Fields
        /// <summary>
        /// Decompressor for this stream
        /// </summary>
        protected Inflater inf;

        /// <summary>
        /// <see cref="InflaterInputBuffer">Input buffer</see> for this stream.
        /// </summary>
        protected InflaterInputBuffer inputBuffer;

        /// <summary>
        /// Base stream the inflater reads from.
        /// </summary>
        private Stream baseInputStream;

        /// <summary>
        /// The compressed size
        /// </summary>
        protected long csize;

        /// <summary>
        /// Flag indicating wether this instance has been closed or not.
        /// </summary>
        bool isClosed;

        /// <summary>
        /// Flag indicating wether this instance is designated the stream owner.
        /// When closing if this flag is true the underlying stream is closed.
        /// </summary>
        bool isStreamOwner = true;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// Scanning filters support filtering of names.
    /// </summary>
    public interface IScanFilter
    {
        /// <summary>
        /// Test a name to see if it 'matches' the filter.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name matches the filter, false if it does not match.</returns>
        bool IsMatch(string name);
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.Collections;
    using System.Text;
    using System.Text.RegularExpressions;
    /// <summary>
    /// NameFilter is a string matching class which allows for both positive and negative
    /// matching.
    /// A filter is a sequence of independant <see cref="Regex">regular expressions</see> separated by semi-colons ';'.
    /// To include a semi-colon it may be quoted as in \;. Each expression can be prefixed by a plus '+' sign or
    /// a minus '-' sign to denote the expression is intended to include or exclude names.
    /// If neither a plus or minus sign is found include is the default.
    /// A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
    /// and not matching an exclude spec are deemed to match the filter.
    /// An empty filter matches any name.
    /// </summary>
    /// <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
    /// "+\.dat$;-^dummy\.dat$"
    /// </example>
    public class NameFilter : IScanFilter
    {
        #region Constructors
        /// <summary>
        /// Construct an instance based on the filter expression passed
        /// </summary>
        /// <param name="filter">The filter expression.</param>
        public NameFilter(string filter)
        {
            filter_ = filter;
            inclusions_ = new ArrayList();
            exclusions_ = new ArrayList();
            Compile();
        }
        #endregion

        /// <summary>
        /// Test a string to see if it is a valid regular expression.
        /// </summary>
        /// <param name="expression">The expression to test.</param>
        /// <returns>True if expression is a valid <see cref="System.Text.RegularExpressions.Regex"/> false otherwise.</returns>
        public static bool IsValidExpression(string expression)
        {
            bool result = true;
            try
            {
                Regex exp = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }
            catch (ArgumentException)
            {
                result = false;
            }
            return result;
        }

        /// <summary>
        /// Test an expression to see if it is valid as a filter.
        /// </summary>
        /// <param name="toTest">The filter expression to test.</param>
        /// <returns>True if the expression is valid, false otherwise.</returns>
        public static bool IsValidFilterExpression(string toTest)
        {
            if (toTest == null)
            {
                throw new ArgumentNullException("toTest");
            }

            bool result = true;

            try
            {
                string[] items = SplitQuoted(toTest);
                for (int i = 0; i < items.Length; ++i)
                {
                    if ((items[i] != null) && (items[i].Length > 0))
                    {
                        string toCompile;

                        if (items[i][0] == '+')
                        {
                            toCompile = items[i].Substring(1, items[i].Length - 1);
                        }
                        else if (items[i][0] == '-')
                        {
                            toCompile = items[i].Substring(1, items[i].Length - 1);
                        }
                        else
                        {
                            toCompile = items[i];
                        }

                        Regex testRegex = new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Singleline);
                    }
                }
            }
            catch (ArgumentException)
            {
                result = false;
            }

            return result;
        }

        /// <summary>
        /// Split a string into its component pieces
        /// </summary>
        /// <param name="original">The original string</param>
        /// <returns>Returns an array of <see cref="T:System.String"/> values containing the individual filter elements.</returns>
        public static string[] SplitQuoted(string original)
        {
            char escape = '\\';
            char[] separators = { ';' };

            ArrayList result = new ArrayList();

            if ((original != null) && (original.Length > 0))
            {
                int endIndex = -1;
                StringBuilder b = new StringBuilder();

                while (endIndex < original.Length)
                {
                    endIndex += 1;
                    if (endIndex >= original.Length)
                    {
                        result.Add(b.ToString());
                    }
                    else if (original[endIndex] == escape)
                    {
                        endIndex += 1;
                        if (endIndex >= original.Length)
                        {
#if NETCF_1_0
							throw new ArgumentException("Missing terminating escape character");
#else
                            throw new ArgumentException("Missing terminating escape character", "original");
#endif
                        }
                        // include escape if this is not an escaped separator
                        if (Array.IndexOf(separators, original[endIndex]) < 0)
                            b.Append(escape);

                        b.Append(original[endIndex]);
                    }
                    else
                    {
                        if (Array.IndexOf(separators, original[endIndex]) >= 0)
                        {
                            result.Add(b.ToString());
                            b.Length = 0;
                        }
                        else
                        {
                            b.Append(original[endIndex]);
                        }
                    }
                }
            }

            return (string[])result.ToArray(typeof(string));
        }

        /// <summary>
        /// Convert this filter to its string equivalent.
        /// </summary>
        /// <returns>The string equivalent for this filter.</returns>
        public override string ToString()
        {
            return filter_;
        }

        /// <summary>
        /// Test a value to see if it is included by the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value is included, false otherwise.</returns>
        public bool IsIncluded(string name)
        {
            bool result = false;
            if (inclusions_.Count == 0)
            {
                result = true;
            }
            else
            {
                foreach (Regex r in inclusions_)
                {
                    if (r.IsMatch(name))
                    {
                        result = true;
                        break;
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Test a value to see if it is excluded by the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value is excluded, false otherwise.</returns>
        public bool IsExcluded(string name)
        {
            bool result = false;
            foreach (Regex r in exclusions_)
            {
                if (r.IsMatch(name))
                {
                    result = true;
                    break;
                }
            }
            return result;
        }

        #region IScanFilter Members
        /// <summary>
        /// Test a value to see if it matches the filter.
        /// </summary>
        /// <param name="name">The value to test.</param>
        /// <returns>True if the value matches, false otherwise.</returns>
        public bool IsMatch(string name)
        {
            return (IsIncluded(name) && !IsExcluded(name));
        }
        #endregion

        /// <summary>
        /// Compile this filter.
        /// </summary>
        void Compile()
        {
            // TODO: Check to see if combining RE's makes it faster/smaller.
            // simple scheme would be to have one RE for inclusion and one for exclusion.
            if (filter_ == null)
            {
                return;
            }

            string[] items = SplitQuoted(filter_);
            for (int i = 0; i < items.Length; ++i)
            {
                if ((items[i] != null) && (items[i].Length > 0))
                {
                    bool include = (items[i][0] != '-');
                    string toCompile;

                    if (items[i][0] == '+')
                    {
                        toCompile = items[i].Substring(1, items[i].Length - 1);
                    }
                    else if (items[i][0] == '-')
                    {
                        toCompile = items[i].Substring(1, items[i].Length - 1);
                    }
                    else
                    {
                        toCompile = items[i];
                    }

                    // NOTE: Regular expressions can fail to compile here for a number of reasons that cause an exception
                    // these are left unhandled here as the caller is responsible for ensuring all is valid.
                    // several functions IsValidFilterExpression and IsValidExpression are provided for such checking
                    if (include)
                    {
                        inclusions_.Add(new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
                    }
                    else
                    {
                        exclusions_.Add(new Regex(toCompile, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
                    }
                }
            }
        }

        #region Instance Fields
        string filter_;
        ArrayList inclusions_;
        ArrayList exclusions_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    /// <summary>
    /// Contains the output from the Inflation process.
    /// We need to have a window so that we can refer backwards into the output stream
    /// to repeat stuff.<br/>
    /// Author of the original java version : John Leuner
    /// </summary>
    public class OutputWindow
    {
        #region Constants
        const int WindowSize = 1 << 15;
        const int WindowMask = WindowSize - 1;
        #endregion

        #region Instance Fields
        byte[] window = new byte[WindowSize]; //The window is 2^15 bytes
        int windowEnd;
        int windowFilled;
        #endregion

        /// <summary>
        /// Write a byte to this output window
        /// </summary>
        /// <param name="value">value to write</param>
        /// <exception cref="InvalidOperationException">
        /// if window is full
        /// </exception>
        public void Write(int value)
        {
            if (windowFilled++ == WindowSize)
            {
                throw new InvalidOperationException("Window full");
            }
            window[windowEnd++] = (byte)value;
            windowEnd &= WindowMask;
        }


        private void SlowRepeat(int repStart, int length, int distance)
        {
            while (length-- > 0)
            {
                window[windowEnd++] = window[repStart++];
                windowEnd &= WindowMask;
                repStart &= WindowMask;
            }
        }

        /// <summary>
        /// Append a byte pattern already in the window itself
        /// </summary>
        /// <param name="length">length of pattern to copy</param>
        /// <param name="distance">distance from end of window pattern occurs</param>
        /// <exception cref="InvalidOperationException">
        /// If the repeated data overflows the window
        /// </exception>
        public void Repeat(int length, int distance)
        {
            if ((windowFilled += length) > WindowSize)
            {
                throw new InvalidOperationException("Window full");
            }

            int repStart = (windowEnd - distance) & WindowMask;
            int border = WindowSize - length;
            if ((repStart <= border) && (windowEnd < border))
            {
                if (length <= distance)
                {
                    System.Array.Copy(window, repStart, window, windowEnd, length);
                    windowEnd += length;
                }
                else
                {
                    // We have to copy manually, since the repeat pattern overlaps.
                    while (length-- > 0)
                    {
                        window[windowEnd++] = window[repStart++];
                    }
                }
            }
            else
            {
                SlowRepeat(repStart, length, distance);
            }
        }

        /// <summary>
        /// Copy from input manipulator to internal window
        /// </summary>
        /// <param name="input">source of data</param>
        /// <param name="length">length of data to copy</param>
        /// <returns>the number of bytes copied</returns>
        public int CopyStored(StreamManipulator input, int length)
        {
            length = Math.Min(Math.Min(length, WindowSize - windowFilled), input.AvailableBytes);
            int copied;

            int tailLen = WindowSize - windowEnd;
            if (length > tailLen)
            {
                copied = input.CopyBytes(window, windowEnd, tailLen);
                if (copied == tailLen)
                {
                    copied += input.CopyBytes(window, 0, length - tailLen);
                }
            }
            else
            {
                copied = input.CopyBytes(window, windowEnd, length);
            }

            windowEnd = (windowEnd + copied) & WindowMask;
            windowFilled += copied;
            return copied;
        }

        /// <summary>
        /// Copy dictionary to window
        /// </summary>
        /// <param name="dictionary">source dictionary</param>
        /// <param name="offset">offset of start in source dictionary</param>
        /// <param name="length">length of dictionary</param>
        /// <exception cref="InvalidOperationException">
        /// If window isnt empty
        /// </exception>
        public void CopyDict(byte[] dictionary, int offset, int length)
        {
            if (dictionary == null)
            {
                throw new ArgumentNullException("dictionary");
            }

            if (windowFilled > 0)
            {
                throw new InvalidOperationException();
            }

            if (length > WindowSize)
            {
                offset += length - WindowSize;
                length = WindowSize;
            }
            System.Array.Copy(dictionary, offset, window, 0, length);
            windowEnd = length & WindowMask;
        }

        /// <summary>
        /// Get remaining unfilled space in window
        /// </summary>
        /// <returns>Number of bytes left in window</returns>
        public int GetFreeSpace()
        {
            return WindowSize - windowFilled;
        }

        /// <summary>
        /// Get bytes available for output in window
        /// </summary>
        /// <returns>Number of bytes filled</returns>
        public int GetAvailable()
        {
            return windowFilled;
        }

        /// <summary>
        /// Copy contents of window to output
        /// </summary>
        /// <param name="output">buffer to copy to</param>
        /// <param name="offset">offset to start at</param>
        /// <param name="len">number of bytes to count</param>
        /// <returns>The number of bytes copied</returns>
        /// <exception cref="InvalidOperationException">
        /// If a window underflow occurs
        /// </exception>
        public int CopyOutput(byte[] output, int offset, int len)
        {
            int copyEnd = windowEnd;
            if (len > windowFilled)
            {
                len = windowFilled;
            }
            else
            {
                copyEnd = (windowEnd - windowFilled + len) & WindowMask;
            }

            int copied = len;
            int tailLen = len - copyEnd;

            if (tailLen > 0)
            {
                System.Array.Copy(window, WindowSize - tailLen, output, offset, tailLen);
                offset += tailLen;
                len = copyEnd;
            }
            System.Array.Copy(window, copyEnd - len, output, offset, len);
            windowFilled -= copied;
            if (windowFilled < 0)
            {
                throw new InvalidOperationException();
            }
            return copied;
        }

        /// <summary>
        /// Reset by clearing window so <see cref="GetAvailable">GetAvailable</see> returns 0
        /// </summary>
        public void Reset()
        {
            windowFilled = windowEnd = 0;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.IO;
    /// <summary>
    /// PathFilter filters directories and files using a form of <see cref="System.Text.RegularExpressions.Regex">regular expressions</see>
    /// by full path name.
    /// See <see cref="NameFilter">NameFilter</see> for more detail on filtering.
    /// </summary>
    public class PathFilter : IScanFilter
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="PathFilter"></see>.
        /// </summary>
        /// <param name="filter">The <see cref="NameFilter">filter</see> expression to apply.</param>
        public PathFilter(string filter)
        {
            nameFilter_ = new NameFilter(filter);
        }
        #endregion

        #region IScanFilter Members
        /// <summary>
        /// Test a name to see if it matches the filter.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>True if the name matches, false otherwise.</returns>
        /// <remarks><see cref="Path.GetFullPath(string)"/> is used to get the full path before matching.</remarks>
        public virtual bool IsMatch(string name)
        {
            bool result = false;

            if (name != null)
            {
                string cooked = (name.Length > 0) ? Path.GetFullPath(name) : "";
                result = nameFilter_.IsMatch(cooked);
            }
            return result;
        }
        #endregion

        #region Instance Fields
        NameFilter nameFilter_;
        #endregion
    }

    /// <summary>
    /// ExtendedPathFilter filters based on name, file size, and the last write time of the file.
    /// </summary>
    /// <remarks>Provides an example of how to customise filtering.</remarks>
    public class ExtendedPathFilter : PathFilter
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        public ExtendedPathFilter(string filter,
            long minSize, long maxSize)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
        }

        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minDate">The minimum <see cref="DateTime"/> to include.</param>
        /// <param name="maxDate">The maximum <see cref="DateTime"/> to include.</param>
        public ExtendedPathFilter(string filter,
            DateTime minDate, DateTime maxDate)
            : base(filter)
        {
            MinDate = minDate;
            MaxDate = maxDate;
        }

        /// <summary>
        /// Initialise a new instance of ExtendedPathFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        /// <param name="minDate">The minimum <see cref="DateTime"/> to include.</param>
        /// <param name="maxDate">The maximum <see cref="DateTime"/> to include.</param>
        public ExtendedPathFilter(string filter,
            long minSize, long maxSize,
            DateTime minDate, DateTime maxDate)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
            MinDate = minDate;
            MaxDate = maxDate;
        }
        #endregion

        #region IScanFilter Members
        /// <summary>
        /// Test a filename to see if it matches the filter.
        /// </summary>
        /// <param name="name">The filename to test.</param>
        /// <returns>True if the filter matches, false otherwise.</returns>
        /// <exception cref="System.IO.FileNotFoundException">The <see paramref="fileName"/> doesnt exist</exception>
        public override bool IsMatch(string name)
        {
            bool result = base.IsMatch(name);

            if (result)
            {
                FileInfo fileInfo = new FileInfo(name);
                result =
                    (MinSize <= fileInfo.Length) &&
                    (MaxSize >= fileInfo.Length) &&
                    (MinDate <= fileInfo.LastWriteTime) &&
                    (MaxDate >= fileInfo.LastWriteTime)
                    ;
            }
            return result;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get/set the minimum size/length for a file that will match this filter.
        /// </summary>
        /// <remarks>The default value is zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException">value is less than zero; greater than <see cref="MaxSize"/></exception>
        public long MinSize
        {
            get { return minSize_; }
            set
            {
                if ((value < 0) || (maxSize_ < value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                minSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum size/length for a file that will match this filter.
        /// </summary>
        /// <remarks>The default value is <see cref="System.Int64.MaxValue"/></remarks>
        /// <exception cref="ArgumentOutOfRangeException">value is less than zero or less than <see cref="MinSize"/></exception>
        public long MaxSize
        {
            get { return maxSize_; }
            set
            {
                if ((value < 0) || (minSize_ > value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                maxSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the minimum <see cref="DateTime"/> value that will match for this filter.
        /// </summary>
        /// <remarks>Files with a LastWrite time less than this value are excluded by the filter.</remarks>
        public DateTime MinDate
        {
            get
            {
                return minDate_;
            }

            set
            {
                if (value > maxDate_)
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "Exceeds MaxDate");
#endif
                }

                minDate_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum <see cref="DateTime"/> value that will match for this filter.
        /// </summary>
        /// <remarks>Files with a LastWrite time greater than this value are excluded by the filter.</remarks>
        public DateTime MaxDate
        {
            get
            {
                return maxDate_;
            }

            set
            {
                if (minDate_ > value)
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "Exceeds MinDate");
#endif
                }

                maxDate_ = value;
            }
        }
        #endregion

        #region Instance Fields
        long minSize_;
        long maxSize_ = long.MaxValue;
        DateTime minDate_ = DateTime.MinValue;
        DateTime maxDate_ = DateTime.MaxValue;
        #endregion
    }

    /// <summary>
    /// NameAndSizeFilter filters based on name and file size.
    /// </summary>
    /// <remarks>A sample showing how filters might be extended.</remarks>
    [Obsolete("Use ExtendedPathFilter instead")]
    public class NameAndSizeFilter : PathFilter
    {

        /// <summary>
        /// Initialise a new instance of NameAndSizeFilter.
        /// </summary>
        /// <param name="filter">The filter to apply.</param>
        /// <param name="minSize">The minimum file size to include.</param>
        /// <param name="maxSize">The maximum file size to include.</param>
        public NameAndSizeFilter(string filter, long minSize, long maxSize)
            : base(filter)
        {
            MinSize = minSize;
            MaxSize = maxSize;
        }

        /// <summary>
        /// Test a filename to see if it matches the filter.
        /// </summary>
        /// <param name="name">The filename to test.</param>
        /// <returns>True if the filter matches, false otherwise.</returns>
        public override bool IsMatch(string name)
        {
            bool result = base.IsMatch(name);

            if (result)
            {
                FileInfo fileInfo = new FileInfo(name);
                long length = fileInfo.Length;
                result =
                    (MinSize <= length) &&
                    (MaxSize >= length);
            }
            return result;
        }

        /// <summary>
        /// Get/set the minimum size for a file that will match this filter.
        /// </summary>
        public long MinSize
        {
            get { return minSize_; }
            set
            {
                if ((value < 0) || (maxSize_ < value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                minSize_ = value;
            }
        }

        /// <summary>
        /// Get/set the maximum size for a file that will match this filter.
        /// </summary>
        public long MaxSize
        {
            get { return maxSize_; }
            set
            {
                if ((value < 0) || (minSize_ > value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                maxSize_ = value;
            }
        }

        #region Instance Fields
        long minSize_;
        long maxSize_ = long.MaxValue;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
    using System;
    /// <summary>
    /// This class is general purpose class for writing data to a buffer.
    /// 
    /// It allows you to write bits as well as bytes
    /// Based on DeflaterPending.java
    /// 
    /// author of the original java version : Jochen Hoenicke
    /// </summary>
    public class PendingBuffer
    {
        #region Instance Fields
        /// <summary>
        /// Internal work buffer
        /// </summary>
        byte[] buffer_;

        int start;
        int end;

        uint bits;
        int bitCount;
        #endregion

        #region Constructors
        /// <summary>
        /// construct instance using default buffer size of 4096
        /// </summary>
        public PendingBuffer()
            : this(4096)
        {
        }

        /// <summary>
        /// construct instance using specified buffer size
        /// </summary>
        /// <param name="bufferSize">
        /// size to use for internal buffer
        /// </param>
        public PendingBuffer(int bufferSize)
        {
            buffer_ = new byte[bufferSize];
        }

        #endregion

        /// <summary>
        /// Clear internal state/buffers
        /// </summary>
        public void Reset()
        {
            start = end = bitCount = 0;
        }

        /// <summary>
        /// Write a byte to buffer
        /// </summary>
        /// <param name="value">
        /// The value to write
        /// </param>
        public void WriteByte(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
        }

        /// <summary>
        /// Write a short value to buffer LSB first
        /// </summary>
        /// <param name="value">
        /// The value to write.
        /// </param>
        public void WriteShort(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
            buffer_[end++] = unchecked((byte)(value >> 8));
        }

        /// <summary>
        /// write an integer LSB first
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteInt(int value)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) )
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)value);
            buffer_[end++] = unchecked((byte)(value >> 8));
            buffer_[end++] = unchecked((byte)(value >> 16));
            buffer_[end++] = unchecked((byte)(value >> 24));
        }

        /// <summary>
        /// Write a block of data to buffer
        /// </summary>
        /// <param name="block">data to write</param>
        /// <param name="offset">offset of first byte to write</param>
        /// <param name="length">number of bytes to write</param>
        public void WriteBlock(byte[] block, int offset, int length)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            System.Array.Copy(block, offset, buffer_, end, length);
            end += length;
        }

        /// <summary>
        /// The number of bits written to the buffer
        /// </summary>
        public int BitCount
        {
            get
            {
                return bitCount;
            }
        }

        /// <summary>
        /// Align internal buffer on a byte boundary
        /// </summary>
        public void AlignToByte()
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            if (bitCount > 0)
            {
                buffer_[end++] = unchecked((byte)bits);
                if (bitCount > 8)
                {
                    buffer_[end++] = unchecked((byte)(bits >> 8));
                }
            }
            bits = 0;
            bitCount = 0;
        }

        /// <summary>
        /// Write bits to internal buffer
        /// </summary>
        /// <param name="b">source of bits</param>
        /// <param name="count">number of bits to write</param>
        public void WriteBits(int b, int count)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}

			//			if (DeflaterConstants.DEBUGGING) {
			//				//Console.WriteLine("writeBits("+b+","+count+")");
			//			}
#endif
            bits |= (uint)(b << bitCount);
            bitCount += count;
            if (bitCount >= 16)
            {
                buffer_[end++] = unchecked((byte)bits);
                buffer_[end++] = unchecked((byte)(bits >> 8));
                bits >>= 16;
                bitCount -= 16;
            }
        }

        /// <summary>
        /// Write a short value to internal buffer most significant byte first
        /// </summary>
        /// <param name="s">value to write</param>
        public void WriteShortMSB(int s)
        {
#if DebugDeflation
			if (DeflaterConstants.DEBUGGING && (start != 0) ) 
			{
				throw new SharpZipBaseException("Debug check: start != 0");
			}
#endif
            buffer_[end++] = unchecked((byte)(s >> 8));
            buffer_[end++] = unchecked((byte)s);
        }

        /// <summary>
        /// Indicates if buffer has been flushed
        /// </summary>
        public bool IsFlushed
        {
            get
            {
                return end == 0;
            }
        }

        /// <summary>
        /// Flushes the pending buffer into the given output array.  If the
        /// output array is to small, only a partial flush is done.
        /// </summary>
        /// <param name="output">The output array.</param>
        /// <param name="offset">The offset into output array.</param>
        /// <param name="length">The maximum number of bytes to store.</param>
        /// <returns>The number of bytes flushed.</returns>
        public int Flush(byte[] output, int offset, int length)
        {
            if (bitCount >= 8)
            {
                buffer_[end++] = unchecked((byte)bits);
                bits >>= 8;
                bitCount -= 8;
            }

            if (length > end - start)
            {
                length = end - start;
                System.Array.Copy(buffer_, start, output, offset, length);
                start = 0;
                end = 0;
            }
            else
            {
                System.Array.Copy(buffer_, start, output, offset, length);
                start += length;
            }
            return length;
        }

        /// <summary>
        /// Convert internal buffer to byte array.
        /// Buffer is empty on completion
        /// </summary>
        /// <returns>
        /// The internal buffer contents converted to a byte array.
        /// </returns>
        public byte[] ToByteArray()
        {
            byte[] result = new byte[end - start];
            System.Array.Copy(buffer_, start, result, 0, result.Length);
            start = 0;
            end = 0;
            return result;
        }
    }
}

namespace ICSharpCode.SharpZipLib
{
    using System;

#if !NETCF_1_0 && !NETCF_2_0
    using System.Runtime.Serialization;
#endif

    /// <summary>
    /// SharpZipBaseException is the base exception class for the SharpZipLibrary.
    /// All library exceptions are derived from this.
    /// </summary>
    /// <remarks>NOTE: Not all exceptions thrown will be derived from this class.
    /// A variety of other exceptions are possible for example <see cref="ArgumentNullException"></see></remarks>
#if !NETCF_1_0 && !NETCF_2_0
    [Serializable]
#endif
    public class SharpZipBaseException : ApplicationException
    {
#if !NETCF_1_0 && !NETCF_2_0
        /// <summary>
        /// Deserialization constructor 
        /// </summary>
        /// <param name="info"><see cref="System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
        /// <param name="context"><see cref="StreamingContext"/> for this constructor</param>
        protected SharpZipBaseException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class.
        /// </summary>
        public SharpZipBaseException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class with a specified error message.
        /// </summary>
        /// <param name="message">A message describing the exception.</param>
        public SharpZipBaseException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharpZipBaseException class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">A message describing the exception.</param>
        /// <param name="innerException">The inner exception</param>
        public SharpZipBaseException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Checksums
{
    using System;
    /// <summary>
    /// Bzip2 checksum algorithm
    /// </summary>
    public class StrangeCRC : IChecksum
    {
        readonly static uint[] crc32Table = {
			0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
			0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
			0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
			0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
			0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
			0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
			0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
			0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
			0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
			0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
			0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
			0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
			0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
			0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
			0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
			0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
			0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
			0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
			0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
			0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
			0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
			0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
			0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
			0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
			0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
			0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
			0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
			0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
			0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
			0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
			0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
			0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
			0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
			0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
			0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
			0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
			0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
			0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
			0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
			0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
			0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
			0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
			0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
			0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
			0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
			0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
			0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
			0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
			0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
			0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
			0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
			0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
			0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
			0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
			0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
			0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
			0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
			0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
			0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
			0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
			0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
			0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
			0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
			0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
		};

        int globalCrc;

        /// <summary>
        /// Initialise a default instance of <see cref="StrangeCRC"></see>
        /// </summary>	
        public StrangeCRC()
        {
            Reset();
        }

        /// <summary>
        /// Reset the state of Crc.
        /// </summary>
        public void Reset()
        {
            globalCrc = -1;
        }

        /// <summary>
        /// Get the current Crc value.
        /// </summary>
        public long Value
        {
            get
            {
                return ~globalCrc;
            }
        }

        /// <summary>
        /// Update the Crc value.
        /// </summary>
        /// <param name="value">data update is based on</param>
        public void Update(int value)
        {
            int temp = (globalCrc >> 24) ^ value;
            if (temp < 0)
            {
                temp = 256 + temp;
            }
            globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table[temp]));
        }

        /// <summary>
        /// Update Crc based on a block of data
        /// </summary>
        /// <param name="buffer">The buffer containing data to update the crc with.</param>
        public void Update(byte[] buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            Update(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Update Crc based on a portion of a block of data
        /// </summary>
        /// <param name="buffer">block of data</param>
        /// <param name="offset">index of first byte to use</param>
        /// <param name="count">number of bytes to use</param>
        public void Update(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "cannot be less than zero");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "cannot be less than zero");
#endif
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            for (int i = 0; i < count; ++i)
            {
                Update(buffer[offset++]);
            }
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
    using System;
    /// <summary>
    /// This class allows us to retrieve a specified number of bits from
    /// the input buffer, as well as copy big byte blocks.
    ///
    /// It uses an int buffer to store up to 31 bits for direct
    /// manipulation.  This guarantees that we can get at least 16 bits,
    /// but we only need at most 15, so this is all safe.
    ///
    /// There are some optimizations in this class, for example, you must
    /// never peek more than 8 bits more than needed, and you must first
    /// peek bits before you may drop them.  This is not a general purpose
    /// class but optimized for the behaviour of the Inflater.
    ///
    /// authors of the original java version : John Leuner, Jochen Hoenicke
    /// </summary>
    public class StreamManipulator
    {
        #region Constructors
        /// <summary>
        /// Constructs a default StreamManipulator with all buffers empty
        /// </summary>
        public StreamManipulator()
        {
        }
        #endregion

        /// <summary>
        /// Get the next sequence of bits but don't increase input pointer.  bitCount must be
        /// less or equal 16 and if this call succeeds, you must drop
        /// at least n - 8 bits in the next call.
        /// </summary>
        /// <param name="bitCount">The number of bits to peek.</param>
        /// <returns>
        /// the value of the bits, or -1 if not enough bits available.  */
        /// </returns>
        public int PeekBits(int bitCount)
        {
            if (bitsInBuffer_ < bitCount)
            {
                if (windowStart_ == windowEnd_)
                {
                    return -1; // ok
                }
                buffer_ |= (uint)((window_[windowStart_++] & 0xff |
                                 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);
                bitsInBuffer_ += 16;
            }
            return (int)(buffer_ & ((1 << bitCount) - 1));
        }

        /// <summary>
        /// Drops the next n bits from the input.  You should have called PeekBits
        /// with a bigger or equal n before, to make sure that enough bits are in
        /// the bit buffer.
        /// </summary>
        /// <param name="bitCount">The number of bits to drop.</param>
        public void DropBits(int bitCount)
        {
            buffer_ >>= bitCount;
            bitsInBuffer_ -= bitCount;
        }

        /// <summary>
        /// Gets the next n bits and increases input pointer.  This is equivalent
        /// to <see cref="PeekBits"/> followed by <see cref="DropBits"/>, except for correct error handling.
        /// </summary>
        /// <param name="bitCount">The number of bits to retrieve.</param>
        /// <returns>
        /// the value of the bits, or -1 if not enough bits available.
        /// </returns>
        public int GetBits(int bitCount)
        {
            int bits = PeekBits(bitCount);
            if (bits >= 0)
            {
                DropBits(bitCount);
            }
            return bits;
        }

        /// <summary>
        /// Gets the number of bits available in the bit buffer.  This must be
        /// only called when a previous PeekBits() returned -1.
        /// </summary>
        /// <returns>
        /// the number of bits available.
        /// </returns>
        public int AvailableBits
        {
            get
            {
                return bitsInBuffer_;
            }
        }

        /// <summary>
        /// Gets the number of bytes available.
        /// </summary>
        /// <returns>
        /// The number of bytes available.
        /// </returns>
        public int AvailableBytes
        {
            get
            {
                return windowEnd_ - windowStart_ + (bitsInBuffer_ >> 3);
            }
        }

        /// <summary>
        /// Skips to the next byte boundary.
        /// </summary>
        public void SkipToByteBoundary()
        {
            buffer_ >>= (bitsInBuffer_ & 7);
            bitsInBuffer_ &= ~7;
        }

        /// <summary>
        /// Returns true when SetInput can be called
        /// </summary>
        public bool IsNeedingInput
        {
            get
            {
                return windowStart_ == windowEnd_;
            }
        }

        /// <summary>
        /// Copies bytes from input buffer to output buffer starting
        /// at output[offset].  You have to make sure, that the buffer is
        /// byte aligned.  If not enough bytes are available, copies fewer
        /// bytes.
        /// </summary>
        /// <param name="output">
        /// The buffer to copy bytes to.
        /// </param>
        /// <param name="offset">
        /// The offset in the buffer at which copying starts
        /// </param>
        /// <param name="length">
        /// The length to copy, 0 is allowed.
        /// </param>
        /// <returns>
        /// The number of bytes copied, 0 if no bytes were available.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Length is less than zero
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Bit buffer isnt byte aligned
        /// </exception>
        public int CopyBytes(byte[] output, int offset, int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            if ((bitsInBuffer_ & 7) != 0)
            {
                // bits_in_buffer may only be 0 or a multiple of 8
                throw new InvalidOperationException("Bit buffer is not byte aligned!");
            }

            int count = 0;
            while ((bitsInBuffer_ > 0) && (length > 0))
            {
                output[offset++] = (byte)buffer_;
                buffer_ >>= 8;
                bitsInBuffer_ -= 8;
                length--;
                count++;
            }

            if (length == 0)
            {
                return count;
            }

            int avail = windowEnd_ - windowStart_;
            if (length > avail)
            {
                length = avail;
            }
            System.Array.Copy(window_, windowStart_, output, offset, length);
            windowStart_ += length;

            if (((windowStart_ - windowEnd_) & 1) != 0)
            {
                // We always want an even number of bytes in input, see peekBits
                buffer_ = (uint)(window_[windowStart_++] & 0xff);
                bitsInBuffer_ = 8;
            }
            return count + length;
        }

        /// <summary>
        /// Resets state and empties internal buffers
        /// </summary>
        public void Reset()
        {
            buffer_ = 0;
            windowStart_ = windowEnd_ = bitsInBuffer_ = 0;
        }

        /// <summary>
        /// Add more input for consumption.
        /// Only call when IsNeedingInput returns true
        /// </summary>
        /// <param name="buffer">data to be input</param>
        /// <param name="offset">offset of first byte of input</param>
        /// <param name="count">number of bytes of input to add.</param>
        public void SetInput(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if (windowStart_ < windowEnd_)
            {
                throw new InvalidOperationException("Old input was not completely processed");
            }

            int end = offset + count;

            // We want to throw an ArrayIndexOutOfBoundsException early.
            // Note the check also handles integer wrap around.
            if ((offset > end) || (end > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            if ((count & 1) != 0)
            {
                // We always want an even number of bytes in input, see PeekBits
                buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);
                bitsInBuffer_ += 8;
            }

            window_ = buffer;
            windowStart_ = offset;
            windowEnd_ = end;
        }

        #region Instance Fields
        private byte[] window_;
        private int windowStart_;
        private int windowEnd_;

        private uint buffer_;
        private int bitsInBuffer_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    using System;
    using System.IO;
    /// <summary>
    /// Provides simple <see cref="Stream"/>" utilities.
    /// </summary>
    public sealed class StreamUtils
    {
        /// <summary>
        /// Read from a <see cref="Stream"/> ensuring all the required data is read.
        /// </summary>
        /// <param name="stream">The stream to read.</param>
        /// <param name="buffer">The buffer to fill.</param>
        /// <seealso cref="ReadFully(Stream,byte[],int,int)"/>
        static public void ReadFully(Stream stream, byte[] buffer)
        {
            ReadFully(stream, buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Read from a <see cref="Stream"/>" ensuring all the required data is read.
        /// </summary>
        /// <param name="stream">The stream to read data from.</param>
        /// <param name="buffer">The buffer to store data in.</param>
        /// <param name="offset">The offset at which to begin storing data.</param>
        /// <param name="count">The number of bytes of data to store.</param>
        /// <exception cref="ArgumentNullException">Required parameter is null</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="offset"/> and or <paramref name="count"/> are invalid.</exception>
        /// <exception cref="EndOfStreamException">End of stream is encountered before all the data has been read.</exception>
        static public void ReadFully(Stream stream, byte[] buffer, int offset, int count)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Offset can equal length when buffer and count are 0.
            if ((offset < 0) || (offset > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("offset");
            }

            if ((count < 0) || (offset + count > buffer.Length))
            {
                throw new ArgumentOutOfRangeException("count");
            }

            while (count > 0)
            {
                int readCount = stream.Read(buffer, offset, count);
                if (readCount <= 0)
                {
                    throw new EndOfStreamException();
                }
                offset += readCount;
                count -= readCount;
            }
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        static public void Copy(Stream source, Stream destination, byte[] buffer)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Ensure a reasonable size of buffer is used without being prohibitive.
            if (buffer.Length < 128)
            {
                throw new ArgumentException("Buffer is too small", "buffer");
            }

            bool copying = true;

            while (copying)
            {
                int bytesRead = source.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    destination.Write(buffer, 0, bytesRead);
                }
                else
                {
                    destination.Flush();
                    copying = false;
                }
            }
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        /// <param name="progressHandler">The <see cref="ProgressHandler">progress handler delegate</see> to use.</param>
        /// <param name="updateInterval">The minimum <see cref="TimeSpan"/> between progress updates.</param>
        /// <param name="sender">The source for this event.</param>
        /// <param name="name">The name to use with the event.</param>
        /// <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        static public void Copy(Stream source, Stream destination,
            byte[] buffer, ProgressHandler progressHandler, TimeSpan updateInterval, object sender, string name)
        {
            Copy(source, destination, buffer, progressHandler, updateInterval, sender, name, -1);
        }

        /// <summary>
        /// Copy the contents of one <see cref="Stream"/> to another.
        /// </summary>
        /// <param name="source">The stream to source data from.</param>
        /// <param name="destination">The stream to write data to.</param>
        /// <param name="buffer">The buffer to use during copying.</param>
        /// <param name="progressHandler">The <see cref="ProgressHandler">progress handler delegate</see> to use.</param>
        /// <param name="updateInterval">The minimum <see cref="TimeSpan"/> between progress updates.</param>
        /// <param name="sender">The source for this event.</param>
        /// <param name="name">The name to use with the event.</param>
        /// <param name="fixedTarget">A predetermined fixed target value to use with progress updates.
        /// If the value is negative the target is calculated by looking at the stream.</param>
        /// <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        static public void Copy(Stream source, Stream destination,
            byte[] buffer,
            ProgressHandler progressHandler, TimeSpan updateInterval,
            object sender, string name, long fixedTarget)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (destination == null)
            {
                throw new ArgumentNullException("destination");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            // Ensure a reasonable size of buffer is used without being prohibitive.
            if (buffer.Length < 128)
            {
                throw new ArgumentException("Buffer is too small", "buffer");
            }

            if (progressHandler == null)
            {
                throw new ArgumentNullException("progressHandler");
            }

            bool copying = true;

            DateTime marker = DateTime.Now;
            long processed = 0;
            long target = 0;

            if (fixedTarget >= 0)
            {
                target = fixedTarget;
            }
            else if (source.CanSeek)
            {
                target = source.Length - source.Position;
            }

            // Always fire 0% progress..
            ProgressEventArgs args = new ProgressEventArgs(name, processed, target);
            progressHandler(sender, args);

            bool progressFired = true;

            while (copying)
            {
                int bytesRead = source.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    processed += bytesRead;
                    progressFired = false;
                    destination.Write(buffer, 0, bytesRead);
                }
                else
                {
                    destination.Flush();
                    copying = false;
                }

                if (DateTime.Now - marker > updateInterval)
                {
                    progressFired = true;
                    marker = DateTime.Now;
                    args = new ProgressEventArgs(name, processed, target);
                    progressHandler(sender, args);

                    copying = args.ContinueRunning;
                }
            }

            if (!progressFired)
            {
                args = new ProgressEventArgs(name, processed, target);
                progressHandler(sender, args);
            }
        }

        /// <summary>
        /// Initialise an instance of <see cref="StreamUtils"></see>
        /// </summary>
        private StreamUtils()
        {
            // Do nothing.
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;

    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// WindowsNameTransform transforms <see cref="ZipFile"/> names to windows compatible ones.
    /// </summary>
    public class WindowsNameTransform : INameTransform
    {
        /// <summary>
        /// Initialises a new instance of <see cref="WindowsNameTransform"/>
        /// </summary>
        /// <param name="baseDirectory"></param>
        public WindowsNameTransform(string baseDirectory)
        {
            if (baseDirectory == null)
            {
                throw new ArgumentNullException("baseDirectory", "Directory name is invalid");
            }

            BaseDirectory = baseDirectory;
        }

        /// <summary>
        /// Initialise a default instance of <see cref="WindowsNameTransform"/>
        /// </summary>
        public WindowsNameTransform()
        {
            // Do nothing.
        }

        /// <summary>
        /// Gets or sets a value containing the target directory to prefix values with.
        /// </summary>
        public string BaseDirectory
        {
            get { return _baseDirectory; }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                _baseDirectory = Path.GetFullPath(value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating wether paths on incoming values should be removed.
        /// </summary>
        public bool TrimIncomingPaths
        {
            get { return _trimIncomingPaths; }
            set { _trimIncomingPaths = value; }
        }

        /// <summary>
        /// Transform a Zip directory name to a windows directory name.
        /// </summary>
        /// <param name="name">The directory name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformDirectory(string name)
        {
            name = TransformFile(name);
            if (name.Length > 0)
            {
                while (name.EndsWith(@"\"))
                {
                    name = name.Remove(name.Length - 1, 1);
                }
            }
            else
            {
                throw new ZipException("Cannot have an empty directory name");
            }
            return name;
        }

        /// <summary>
        /// Transform a Zip format file name to a windows style one.
        /// </summary>
        /// <param name="name">The file name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformFile(string name)
        {
            if (name != null)
            {
                name = MakeValidName(name, _replacementChar);

                if (_trimIncomingPaths)
                {
                    name = Path.GetFileName(name);
                }

                // This may exceed windows length restrictions.
                // Combine will throw a PathTooLongException in that case.
                if (_baseDirectory != null)
                {
                    name = Path.Combine(_baseDirectory, name);
                }
            }
            else
            {
                name = string.Empty;
            }
            return name;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a windows filename as extracted from a Zip archive.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>The filename isnt a true windows path in some fundamental ways like no absolute paths, no rooted paths etc.</remarks>
        public static bool IsValidName(string name)
        {
            bool result =
                (name != null) &&
                (name.Length <= MaxPath) &&
                (string.Compare(name, MakeValidName(name, '_')) == 0)
                ;

            return result;
        }

        /// <summary>
        /// Initialise static class information.
        /// </summary>
        static WindowsNameTransform()
        {
            char[] invalidPathChars;

#if NET_1_0 || NET_1_1 || NETCF_1_0
			invalidPathChars = Path.InvalidPathChars;
#else
            invalidPathChars = Path.GetInvalidPathChars();
#endif
            int howMany = invalidPathChars.Length + 3;

            InvalidEntryChars = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryChars, 0, invalidPathChars.Length);
            InvalidEntryChars[howMany - 1] = '*';
            InvalidEntryChars[howMany - 2] = '?';
            InvalidEntryChars[howMany - 3] = ':';
        }

        /// <summary>
        /// Force a name to be valid by replacing invalid characters with a fixed value
        /// </summary>
        /// <param name="name">The name to make valid</param>
        /// <param name="replacement">The replacement character to use for any invalid characters.</param>
        /// <returns>Returns a valid name</returns>
        public static string MakeValidName(string name, char replacement)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            name = WindowsPathUtils.DropPathRoot(name.Replace("/", @"\"));

            // Drop any leading slashes.
            while ((name.Length > 0) && (name[0] == '\\'))
            {
                name = name.Remove(0, 1);
            }

            // Drop any trailing slashes.
            while ((name.Length > 0) && (name[name.Length - 1] == '\\'))
            {
                name = name.Remove(name.Length - 1, 1);
            }

            // Convert consecutive \\ characters to \
            int index = name.IndexOf(@"\\");
            while (index >= 0)
            {
                name = name.Remove(index, 1);
                index = name.IndexOf(@"\\");
            }

            // Convert any invalid characters using the replacement one.
            index = name.IndexOfAny(InvalidEntryChars);
            if (index >= 0)
            {
                StringBuilder builder = new StringBuilder(name);

                while (index >= 0)
                {
                    builder[index] = replacement;

                    if (index >= name.Length)
                    {
                        index = -1;
                    }
                    else
                    {
                        index = name.IndexOfAny(InvalidEntryChars, index + 1);
                    }
                }
                name = builder.ToString();
            }

            // Check for names greater than MaxPath characters.
            // TODO: Were is CLR version of MaxPath defined?  Can't find it in Environment.
            if (name.Length > MaxPath)
            {
                throw new PathTooLongException();
            }

            return name;
        }

        /// <summary>
        /// Gets or set the character to replace invalid characters during transformations.
        /// </summary>
        public char Replacement
        {
            get { return _replacementChar; }
            set
            {
                for (int i = 0; i < InvalidEntryChars.Length; ++i)
                {
                    if (InvalidEntryChars[i] == value)
                    {
                        throw new ArgumentException("invalid path character");
                    }
                }

                if ((value == '\\') || (value == '/'))
                {
                    throw new ArgumentException("invalid replacement character");
                }

                _replacementChar = value;
            }
        }

        /// <summary>
        ///  The maximum windows path name permitted.
        /// </summary>
        /// <remarks>This may not valid for all windows systems - CE?, etc but I cant find the equivalent in the CLR.</remarks>
        const int MaxPath = 260;

        #region Instance Fields
        string _baseDirectory;
        bool _trimIncomingPaths;
        char _replacementChar = '_';
        #endregion

        #region Class Fields
        static readonly char[] InvalidEntryChars;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Core
{
    /// <summary>
    /// WindowsPathUtils provides simple utilities for handling windows paths.
    /// </summary>
    public abstract class WindowsPathUtils
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WindowsPathUtils"/> class.
        /// </summary>
        internal WindowsPathUtils()
        {
        }

        /// <summary>
        /// Remove any path root present in the path
        /// </summary>
        /// <param name="path">A <see cref="string"/> containing path information.</param>
        /// <returns>The path with the root removed if it was present; path otherwise.</returns>
        /// <remarks>Unlike the <see cref="System.IO.Path"/> class the path isnt otherwise checked for validity.</remarks>
        public static string DropPathRoot(string path)
        {
            string result = path;

            if ((path != null) && (path.Length > 0))
            {
                if ((path[0] == '\\') || (path[0] == '/'))
                {
                    // UNC name ?
                    if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))
                    {
                        int index = 2;
                        int elements = 2;

                        // Scan for two separate elements \\machine\share\restofpath
                        while ((index <= path.Length) &&
                            (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))
                        {
                            index++;
                        }

                        index++;

                        if (index < path.Length)
                        {
                            result = path.Substring(index);
                        }
                        else
                        {
                            result = "";
                        }
                    }
                }
                else if ((path.Length > 1) && (path[1] == ':'))
                {
                    int dropCount = 2;
                    if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))
                    {
                        dropCount = 3;
                    }
                    result = result.Remove(0, dropCount);
                }
            }
            return result;
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.Text;
    using System.Threading;

#if NETCF_1_0 || NETCF_2_0
using System.Globalization;
#endif
    #region Enumerations

    /// <summary>
    /// Determines how entries are tested to see if they should use Zip64 extensions or not.
    /// </summary>
    public enum UseZip64
    {
        /// <summary>
        /// Zip64 will not be forced on entries during processing.
        /// </summary>
        /// <remarks>An entry can have this overridden if required <see cref="ZipEntry.ForceZip64"></see></remarks>
        Off,
        /// <summary>
        /// Zip64 should always be used.
        /// </summary>
        On,
        /// <summary>
        /// #ZipLib will determine use based on entry values when added to archive.
        /// </summary>
        Dynamic,
    }

    /// <summary>
    /// The kind of compression used for an entry in an archive
    /// </summary>
    public enum CompressionMethod
    {
        /// <summary>
        /// A direct copy of the file contents is held in the archive
        /// </summary>
        Stored = 0,

        /// <summary>
        /// Common Zip compression method using a sliding dictionary 
        /// of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
        /// </summary>
        Deflated = 8,

        /// <summary>
        /// An extension to deflate with a 64KB window. Not supported by #Zip currently
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// BZip2 compression. Not supported by #Zip.
        /// </summary>
        BZip2 = 11,

        /// <summary>
        /// WinZip special for AES encryption, Now supported by #Zip.
        /// </summary>
        WinZipAES = 99,

    }

    /// <summary>
    /// Identifies the encryption algorithm used for an entry
    /// </summary>
    public enum EncryptionAlgorithm
    {
        /// <summary>
        /// No encryption has been used.
        /// </summary>
        None = 0,
        /// <summary>
        /// Encrypted using PKZIP 2.0 or 'classic' encryption.
        /// </summary>
        PkzipClassic = 1,
        /// <summary>
        /// DES encryption has been used.
        /// </summary>
        Des = 0x6601,
        /// <summary>
        /// RCS encryption has been used for encryption.
        /// </summary>
        RC2 = 0x6602,
        /// <summary>
        /// Triple DES encryption with 168 bit keys has been used for this entry.
        /// </summary>
        TripleDes168 = 0x6603,
        /// <summary>
        /// Triple DES with 112 bit keys has been used for this entry.
        /// </summary>
        TripleDes112 = 0x6609,
        /// <summary>
        /// AES 128 has been used for encryption.
        /// </summary>
        Aes128 = 0x660e,
        /// <summary>
        /// AES 192 has been used for encryption.
        /// </summary>
        Aes192 = 0x660f,
        /// <summary>
        /// AES 256 has been used for encryption.
        /// </summary>
        Aes256 = 0x6610,
        /// <summary>
        /// RC2 corrected has been used for encryption.
        /// </summary>
        RC2Corrected = 0x6702,
        /// <summary>
        /// Blowfish has been used for encryption.
        /// </summary>
        Blowfish = 0x6720,
        /// <summary>
        /// Twofish has been used for encryption.
        /// </summary>
        Twofish = 0x6721,
        /// <summary>
        /// RC4 has been used for encryption.
        /// </summary>
        RC4 = 0x6801,
        /// <summary>
        /// An unknown algorithm has been used for encryption.
        /// </summary>
        Unknown = 0xffff
    }

    /// <summary>
    /// Defines the contents of the general bit flags field for an archive entry.
    /// </summary>
    [Flags]
    public enum GeneralBitFlags : int
    {
        /// <summary>
        /// Bit 0 if set indicates that the file is encrypted
        /// </summary>
        Encrypted = 0x0001,
        /// <summary>
        /// Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
        /// </summary>
        Method = 0x0006,
        /// <summary>
        /// Bit 3 if set indicates a trailing data desciptor is appended to the entry data
        /// </summary>
        Descriptor = 0x0008,
        /// <summary>
        /// Bit 4 is reserved for use with method 8 for enhanced deflation
        /// </summary>
        ReservedPKware4 = 0x0010,
        /// <summary>
        /// Bit 5 if set indicates the file contains Pkzip compressed patched data.
        /// Requires version 2.7 or greater.
        /// </summary>
        Patched = 0x0020,
        /// <summary>
        /// Bit 6 if set indicates strong encryption has been used for this entry.
        /// </summary>
        StrongEncryption = 0x0040,
        /// <summary>
        /// Bit 7 is currently unused
        /// </summary>
        Unused7 = 0x0080,
        /// <summary>
        /// Bit 8 is currently unused
        /// </summary>
        Unused8 = 0x0100,
        /// <summary>
        /// Bit 9 is currently unused
        /// </summary>
        Unused9 = 0x0200,
        /// <summary>
        /// Bit 10 is currently unused
        /// </summary>
        Unused10 = 0x0400,
        /// <summary>
        /// Bit 11 if set indicates the filename and 
        /// comment fields for this file must be encoded using UTF-8.
        /// </summary>
        UnicodeText = 0x0800,
        /// <summary>
        /// Bit 12 is documented as being reserved by PKware for enhanced compression.
        /// </summary>
        EnhancedCompress = 0x1000,
        /// <summary>
        /// Bit 13 if set indicates that values in the local header are masked to hide
        /// their actual values, and the central directory is encrypted.
        /// </summary>
        /// <remarks>
        /// Used when encrypting the central directory contents.
        /// </remarks>
        HeaderMasked = 0x2000,
        /// <summary>
        /// Bit 14 is documented as being reserved for use by PKware
        /// </summary>
        ReservedPkware14 = 0x4000,
        /// <summary>
        /// Bit 15 is documented as being reserved for use by PKware
        /// </summary>
        ReservedPkware15 = 0x8000
    }

    #endregion

    /// <summary>
    /// This class contains constants used for Zip format files
    /// </summary>
    public sealed class ZipConstants
    {
        #region Versions
        /// <summary>
        /// The version made by field for entries in the central header when created by this library
        /// </summary>
        /// <remarks>
        /// This is also the Zip version for the library when comparing against the version required to extract
        /// for an entry.  See <see cref="ZipEntry.CanDecompress"/>.
        /// </remarks>
        public const int VersionMadeBy = 51; // was 45 before AES

        /// <summary>
        /// The version made by field for entries in the central header when created by this library
        /// </summary>
        /// <remarks>
        /// This is also the Zip version for the library when comparing against the version required to extract
        /// for an entry.  See <see cref="ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
        /// </remarks>
        [Obsolete("Use VersionMadeBy instead")]
        public const int VERSION_MADE_BY = 51;

        /// <summary>
        /// The minimum version required to support strong encryption
        /// </summary>
        public const int VersionStrongEncryption = 50;

        /// <summary>
        /// The minimum version required to support strong encryption
        /// </summary>
        [Obsolete("Use VersionStrongEncryption instead")]
        public const int VERSION_STRONG_ENCRYPTION = 50;

        /// <summary>
        /// Version indicating AES encryption
        /// </summary>
        public const int VERSION_AES = 51;

        /// <summary>
        /// The version required for Zip64 extensions (4.5 or higher)
        /// </summary>
        public const int VersionZip64 = 45;
        #endregion

        #region Header Sizes
        /// <summary>
        /// Size of local entry header (excluding variable length fields at end)
        /// </summary>
        public const int LocalHeaderBaseSize = 30;

        /// <summary>
        /// Size of local entry header (excluding variable length fields at end)
        /// </summary>
        [Obsolete("Use LocalHeaderBaseSize instead")]
        public const int LOCHDR = 30;

        /// <summary>
        /// Size of Zip64 data descriptor
        /// </summary>
        public const int Zip64DataDescriptorSize = 24;

        /// <summary>
        /// Size of data descriptor
        /// </summary>
        public const int DataDescriptorSize = 16;

        /// <summary>
        /// Size of data descriptor
        /// </summary>
        [Obsolete("Use DataDescriptorSize instead")]
        public const int EXTHDR = 16;

        /// <summary>
        /// Size of central header entry (excluding variable fields)
        /// </summary>
        public const int CentralHeaderBaseSize = 46;

        /// <summary>
        /// Size of central header entry
        /// </summary>
        [Obsolete("Use CentralHeaderBaseSize instead")]
        public const int CENHDR = 46;

        /// <summary>
        /// Size of end of central record (excluding variable fields)
        /// </summary>
        public const int EndOfCentralRecordBaseSize = 22;

        /// <summary>
        /// Size of end of central record (excluding variable fields)
        /// </summary>
        [Obsolete("Use EndOfCentralRecordBaseSize instead")]
        public const int ENDHDR = 22;

        /// <summary>
        /// Size of 'classic' cryptographic header stored before any entry data
        /// </summary>
        public const int CryptoHeaderSize = 12;

        /// <summary>
        /// Size of cryptographic header stored before entry data
        /// </summary>
        [Obsolete("Use CryptoHeaderSize instead")]
        public const int CRYPTO_HEADER_SIZE = 12;
        #endregion

        #region Header Signatures

        /// <summary>
        /// Signature for local entry header
        /// </summary>
        public const int LocalHeaderSignature = 'P' | ('K' << 8) | (3 << 16) | (4 << 24);

        /// <summary>
        /// Signature for local entry header
        /// </summary>
        [Obsolete("Use LocalHeaderSignature instead")]
        public const int LOCSIG = 'P' | ('K' << 8) | (3 << 16) | (4 << 24);

        /// <summary>
        /// Signature for spanning entry
        /// </summary>
        public const int SpanningSignature = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for spanning entry
        /// </summary>
        [Obsolete("Use SpanningSignature instead")]
        public const int SPANNINGSIG = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for temporary spanning entry
        /// </summary>
        public const int SpanningTempSignature = 'P' | ('K' << 8) | ('0' << 16) | ('0' << 24);

        /// <summary>
        /// Signature for temporary spanning entry
        /// </summary>
        [Obsolete("Use SpanningTempSignature instead")]
        public const int SPANTEMPSIG = 'P' | ('K' << 8) | ('0' << 16) | ('0' << 24);

        /// <summary>
        /// Signature for data descriptor
        /// </summary>
        /// <remarks>
        /// This is only used where the length, Crc, or compressed size isnt known when the
        /// entry is created and the output stream doesnt support seeking.
        /// The local entry cannot be 'patched' with the correct values in this case
        /// so the values are recorded after the data prefixed by this header, as well as in the central directory.
        /// </remarks>
        public const int DataDescriptorSignature = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for data descriptor
        /// </summary>
        /// <remarks>
        /// This is only used where the length, Crc, or compressed size isnt known when the
        /// entry is created and the output stream doesnt support seeking.
        /// The local entry cannot be 'patched' with the correct values in this case
        /// so the values are recorded after the data prefixed by this header, as well as in the central directory.
        /// </remarks>
        [Obsolete("Use DataDescriptorSignature instead")]
        public const int EXTSIG = 'P' | ('K' << 8) | (7 << 16) | (8 << 24);

        /// <summary>
        /// Signature for central header
        /// </summary>
        [Obsolete("Use CentralHeaderSignature instead")]
        public const int CENSIG = 'P' | ('K' << 8) | (1 << 16) | (2 << 24);

        /// <summary>
        /// Signature for central header
        /// </summary>
        public const int CentralHeaderSignature = 'P' | ('K' << 8) | (1 << 16) | (2 << 24);

        /// <summary>
        /// Signature for Zip64 central file header
        /// </summary>
        public const int Zip64CentralFileHeaderSignature = 'P' | ('K' << 8) | (6 << 16) | (6 << 24);

        /// <summary>
        /// Signature for Zip64 central file header
        /// </summary>
        [Obsolete("Use Zip64CentralFileHeaderSignature instead")]
        public const int CENSIG64 = 'P' | ('K' << 8) | (6 << 16) | (6 << 24);

        /// <summary>
        /// Signature for Zip64 central directory locator
        /// </summary>
        public const int Zip64CentralDirLocatorSignature = 'P' | ('K' << 8) | (6 << 16) | (7 << 24);

        /// <summary>
        /// Signature for archive extra data signature (were headers are encrypted).
        /// </summary>
        public const int ArchiveExtraDataSignature = 'P' | ('K' << 8) | (6 << 16) | (7 << 24);

        /// <summary>
        /// Central header digitial signature
        /// </summary>
        public const int CentralHeaderDigitalSignature = 'P' | ('K' << 8) | (5 << 16) | (5 << 24);

        /// <summary>
        /// Central header digitial signature
        /// </summary>
        [Obsolete("Use CentralHeaderDigitalSignaure instead")]
        public const int CENDIGITALSIG = 'P' | ('K' << 8) | (5 << 16) | (5 << 24);

        /// <summary>
        /// End of central directory record signature
        /// </summary>
        public const int EndOfCentralDirectorySignature = 'P' | ('K' << 8) | (5 << 16) | (6 << 24);

        /// <summary>
        /// End of central directory record signature
        /// </summary>
        [Obsolete("Use EndOfCentralDirectorySignature instead")]
        public const int ENDSIG = 'P' | ('K' << 8) | (5 << 16) | (6 << 24);
        #endregion

#if NETCF_1_0 || NETCF_2_0
		// This isnt so great but is better than nothing.
        // Trying to work out an appropriate OEM code page would be good.
        // 850 is a good default for english speakers particularly in Europe.
		static int defaultCodePage = CultureInfo.CurrentCulture.TextInfo.ANSICodePage;
#else
        static int defaultCodePage = Thread.CurrentThread.CurrentCulture.TextInfo.OEMCodePage;
#endif

        /// <summary>
        /// Default encoding used for string conversion.  0 gives the default system OEM code page.
        /// Dont use unicode encodings if you want to be Zip compatible!
        /// Using the default code page isnt the full solution neccessarily
        /// there are many variable factors, codepage 850 is often a good choice for
        /// European users, however be careful about compatability.
        /// </summary>
        public static int DefaultCodePage
        {
            get
            {
                return defaultCodePage;
            }
            set
            {
                defaultCodePage = value;
            }
        }

        /// <summary>
        /// Convert a portion of a byte array to a string.
        /// </summary>		
        /// <param name="data">
        /// Data to convert to string
        /// </param>
        /// <param name="count">
        /// Number of bytes to convert starting from index 0
        /// </param>
        /// <returns>
        /// data[0]..data[length - 1] converted to a string
        /// </returns>
        public static string ConvertToString(byte[] data, int count)
        {
            if (data == null)
            {
                return string.Empty;
            }

            return Encoding.GetEncoding(DefaultCodePage).GetString(data, 0, count);
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToString(byte[] data)
        {
            if (data == null)
            {
                return string.Empty;
            }
            return ConvertToString(data, data.Length);
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="flags">The applicable general purpose bits flags</param>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <param name="count">The number of bytes to convert.</param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToStringExt(int flags, byte[] data, int count)
        {
            if (data == null)
            {
                return string.Empty;
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetString(data, 0, count);
            }
            else
            {
                return ConvertToString(data, count);
            }
        }

        /// <summary>
        /// Convert a byte array to string
        /// </summary>
        /// <param name="data">
        /// Byte array to convert
        /// </param>
        /// <param name="flags">The applicable general purpose bits flags</param>
        /// <returns>
        /// <paramref name="data">data</paramref>converted to a string
        /// </returns>
        public static string ConvertToStringExt(int flags, byte[] data)
        {
            if (data == null)
            {
                return string.Empty;
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetString(data, 0, data.Length);
            }
            else
            {
                return ConvertToString(data, data.Length);
            }
        }

        /// <summary>
        /// Convert a string to a byte array
        /// </summary>
        /// <param name="str">
        /// String to convert to an array
        /// </param>
        /// <returns>Converted array</returns>
        public static byte[] ConvertToArray(string str)
        {
            if (str == null)
            {
                return new byte[0];
            }

            return Encoding.GetEncoding(DefaultCodePage).GetBytes(str);
        }

        /// <summary>
        /// Convert a string to a byte array
        /// </summary>
        /// <param name="flags">The applicable <see cref="GeneralBitFlags">general purpose bits flags</see></param>
        /// <param name="str">
        /// String to convert to an array
        /// </param>
        /// <returns>Converted array</returns>
        public static byte[] ConvertToArray(int flags, string str)
        {
            if (str == null)
            {
                return new byte[0];
            }

            if ((flags & (int)GeneralBitFlags.UnicodeText) != 0)
            {
                return Encoding.UTF8.GetBytes(str);
            }
            else
            {
                return ConvertToArray(str);
            }
        }


        /// <summary>
        /// Initialise default instance of <see cref="ZipConstants">ZipConstants</see>
        /// </summary>
        /// <remarks>
        /// Private to prevent instances being created.
        /// </remarks>
        ZipConstants()
        {
            // Do nothing
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    /// <summary>
    /// Defines known values for the <see cref="HostSystemID"/> property.
    /// </summary>
    public enum HostSystemID
    {
        /// <summary>
        /// Host system = MSDOS
        /// </summary>
        Msdos = 0,
        /// <summary>
        /// Host system = Amiga
        /// </summary>
        Amiga = 1,
        /// <summary>
        /// Host system = Open VMS
        /// </summary>
        OpenVms = 2,
        /// <summary>
        /// Host system = Unix
        /// </summary>
        Unix = 3,
        /// <summary>
        /// Host system = VMCms
        /// </summary>
        VMCms = 4,
        /// <summary>
        /// Host system = Atari ST
        /// </summary>
        AtariST = 5,
        /// <summary>
        /// Host system = OS2
        /// </summary>
        OS2 = 6,
        /// <summary>
        /// Host system = Macintosh
        /// </summary>
        Macintosh = 7,
        /// <summary>
        /// Host system = ZSystem
        /// </summary>
        ZSystem = 8,
        /// <summary>
        /// Host system = Cpm
        /// </summary>
        Cpm = 9,
        /// <summary>
        /// Host system = Windows NT
        /// </summary>
        WindowsNT = 10,
        /// <summary>
        /// Host system = MVS
        /// </summary>
        MVS = 11,
        /// <summary>
        /// Host system = VSE
        /// </summary>
        Vse = 12,
        /// <summary>
        /// Host system = Acorn RISC
        /// </summary>
        AcornRisc = 13,
        /// <summary>
        /// Host system = VFAT
        /// </summary>
        Vfat = 14,
        /// <summary>
        /// Host system = Alternate MVS
        /// </summary>
        AlternateMvs = 15,
        /// <summary>
        /// Host system = BEOS
        /// </summary>
        BeOS = 16,
        /// <summary>
        /// Host system = Tandem
        /// </summary>
        Tandem = 17,
        /// <summary>
        /// Host system = OS400
        /// </summary>
        OS400 = 18,
        /// <summary>
        /// Host system = OSX
        /// </summary>
        OSX = 19,
        /// <summary>
        /// Host system = WinZIP AES
        /// </summary>
        WinZipAES = 99,
    }

    /// <summary>
    /// This class represents an entry in a zip archive.  This can be a file
    /// or a directory
    /// ZipFile and ZipInputStream will give you instances of this class as 
    /// information about the members in an archive.  ZipOutputStream
    /// uses an instance of this class when creating an entry in a Zip file.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    public class ZipEntry : ICloneable
    {
        [Flags]
        enum Known : byte
        {
            None = 0,
            Size = 0x01,
            CompressedSize = 0x02,
            Crc = 0x04,
            Time = 0x08,
            ExternalAttributes = 0x10,
        }

        #region Constructors
        /// <summary>
        /// Creates a zip entry with the given name.
        /// </summary>
        /// <param name="name">
        /// The name for this entry. Can include directory components.
        /// The convention for names is 'unix' style paths with relative names only.
        /// There are with no device names and path elements are separated by '/' characters.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        public ZipEntry(string name)
            : this(name, 0, ZipConstants.VersionMadeBy, CompressionMethod.Deflated)
        {
        }

        /// <summary>
        /// Creates a zip entry with the given name and version required to extract
        /// </summary>
        /// <param name="name">
        /// The name for this entry. Can include directory components.
        /// The convention for names is 'unix'  style paths with no device names and 
        /// path elements separated by '/' characters.  This is not enforced see <see cref="CleanName(string)">CleanName</see>
        /// on how to ensure names are valid if this is desired.
        /// </param>
        /// <param name="versionRequiredToExtract">
        /// The minimum 'feature version' required this entry
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        internal ZipEntry(string name, int versionRequiredToExtract)
            : this(name, versionRequiredToExtract, ZipConstants.VersionMadeBy,
            CompressionMethod.Deflated)
        {
        }

        /// <summary>
        /// Initializes an entry with the given name and made by information
        /// </summary>
        /// <param name="name">Name for this entry</param>
        /// <param name="madeByInfo">Version and HostSystem Information</param>
        /// <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
        /// <param name="method">Compression method for this entry.</param>
        /// <exception cref="ArgumentNullException">
        /// The name passed is null
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// versionRequiredToExtract should be 0 (auto-calculate) or > 10
        /// </exception>
        /// <remarks>
        /// This constructor is used by the ZipFile class when reading from the central header
        /// It is not generally useful, use the constructor specifying the name only.
        /// </remarks>
        internal ZipEntry(string name, int versionRequiredToExtract, int madeByInfo,
            CompressionMethod method)
        {
            if (name == null)
            {
                throw new System.ArgumentNullException("name");
            }

            if (name.Length > 0xffff)
            {
                throw new ArgumentException("Name is too long", "name");
            }

            if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10))
            {
                throw new ArgumentOutOfRangeException("versionRequiredToExtract");
            }

            this.DateTime = System.DateTime.Now;
            this.name = name;
            this.versionMadeBy = (ushort)madeByInfo;
            this.versionToExtract = (ushort)versionRequiredToExtract;
            this.method = method;
        }

        /// <summary>
        /// Creates a deep copy of the given zip entry.
        /// </summary>
        /// <param name="entry">
        /// The entry to copy.
        /// </param>
        [Obsolete("Use Clone instead")]
        public ZipEntry(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            known = entry.known;
            name = entry.name;
            size = entry.size;
            compressedSize = entry.compressedSize;
            crc = entry.crc;
            dosTime = entry.dosTime;
            method = entry.method;
            comment = entry.comment;
            versionToExtract = entry.versionToExtract;
            versionMadeBy = entry.versionMadeBy;
            externalFileAttributes = entry.externalFileAttributes;
            flags = entry.flags;

            zipFileIndex = entry.zipFileIndex;
            offset = entry.offset;

            forceZip64_ = entry.forceZip64_;

            if (entry.extra != null)
            {
                extra = new byte[entry.extra.Length];
                Array.Copy(entry.extra, 0, extra, 0, entry.extra.Length);
            }
        }

        #endregion

        /// <summary>
        /// Get a value indicating wether the entry has a CRC value available.
        /// </summary>
        public bool HasCrc
        {
            get
            {
                return (known & Known.Crc) != 0;
            }
        }

        /// <summary>
        /// Get/Set flag indicating if entry is encrypted.
        /// A simple helper routine to aid interpretation of <see cref="Flags">flags</see>
        /// </summary>
        /// <remarks>This is an assistant that interprets the <see cref="Flags">flags</see> property.</remarks>
        public bool IsCrypted
        {
            get
            {
                return (flags & 1) != 0;
            }
            set
            {
                if (value)
                {
                    flags |= 1;
                }
                else
                {
                    flags &= ~1;
                }
            }
        }

        /// <summary>
        /// Get / set a flag indicating wether entry name and comment text are
        /// encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
        /// </summary>
        /// <remarks>This is an assistant that interprets the <see cref="Flags">flags</see> property.</remarks>
        public bool IsUnicodeText
        {
            get
            {
                return (flags & (int)GeneralBitFlags.UnicodeText) != 0;
            }
            set
            {
                if (value)
                {
                    flags |= (int)GeneralBitFlags.UnicodeText;
                }
                else
                {
                    flags &= ~(int)GeneralBitFlags.UnicodeText;
                }
            }
        }

        /// <summary>
        /// Value used during password checking for PKZIP 2.0 / 'classic' encryption.
        /// </summary>
        internal byte CryptoCheckValue
        {
            get
            {
                return cryptoCheckValue_;
            }

            set
            {
                cryptoCheckValue_ = value;
            }
        }

        /// <summary>
        /// Get/Set general purpose bit flag for entry
        /// </summary>
        /// <remarks>
        /// General purpose bit flag<br/>
        /// <br/>
        /// Bit 0: If set, indicates the file is encrypted<br/>
        /// Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
        /// Imploding:<br/>
        /// Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
        /// Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
        /// <br/>
        /// Deflating:<br/>
        ///   Bit 2    Bit 1<br/>
        ///     0        0       Normal compression was used<br/>
        ///     0        1       Maximum compression was used<br/>
        ///     1        0       Fast compression was used<br/>
        ///     1        1       Super fast compression was used<br/>
        /// <br/>
        /// Bit 3: If set, the fields crc-32, compressed size
        /// and uncompressed size are were not able to be written during zip file creation
        /// The correct values are held in a data descriptor immediately following the compressed data. <br/>
        /// Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
        /// Bit 5: If set indicates the file contains compressed patch data<br/>
        /// Bit 6: If set indicates strong encryption was used.<br/>
        /// Bit 7-10: Unused or reserved<br/>
        /// Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
        /// Bit 12-15: Unused or reserved<br/>
        /// </remarks>
        /// <seealso cref="IsUnicodeText"></seealso>
        /// <seealso cref="IsCrypted"></seealso>
        public int Flags
        {
            get
            {
                return flags;
            }
            set
            {
                flags = value;
            }
        }

        /// <summary>
        /// Get/Set index of this entry in Zip file
        /// </summary>
        /// <remarks>This is only valid when the entry is part of a <see cref="ZipFile"></see></remarks>
        public long ZipFileIndex
        {
            get
            {
                return zipFileIndex;
            }
            set
            {
                zipFileIndex = value;
            }
        }

        /// <summary>
        /// Get/set offset for use in central header
        /// </summary>
        public long Offset
        {
            get
            {
                return offset;
            }
            set
            {
                offset = value;
            }
        }

        /// <summary>
        /// Get/Set external file attributes as an integer.
        /// The values of this are operating system dependant see
        /// <see cref="HostSystem">HostSystem</see> for details
        /// </summary>
        public int ExternalFileAttributes
        {
            get
            {
                if ((known & Known.ExternalAttributes) == 0)
                {
                    return -1;
                }
                else
                {
                    return externalFileAttributes;
                }
            }

            set
            {
                externalFileAttributes = value;
                known |= Known.ExternalAttributes;
            }
        }

        /// <summary>
        /// Get the version made by for this entry or zero if unknown.
        /// The value / 10 indicates the major version number, and 
        /// the value mod 10 is the minor version number
        /// </summary>
        public int VersionMadeBy
        {
            get
            {
                return (versionMadeBy & 0xff);
            }
        }

        /// <summary>
        /// Get a value indicating this entry is for a DOS/Windows system.
        /// </summary>
        public bool IsDOSEntry
        {
            get
            {
                return ((HostSystem == (int)HostSystemID.Msdos) ||
                    (HostSystem == (int)HostSystemID.WindowsNT));
            }
        }

        /// <summary>
        /// Test the external attributes for this <see cref="ZipEntry"/> to
        /// see if the external attributes are Dos based (including WINNT and variants)
        /// and match the values
        /// </summary>
        /// <param name="attributes">The attributes to test.</param>
        /// <returns>Returns true if the external attributes are known to be DOS/Windows 
        /// based and have the same attributes set as the value passed.</returns>
        bool HasDosAttributes(int attributes)
        {
            bool result = false;
            if ((known & Known.ExternalAttributes) != 0)
            {
                if (((HostSystem == (int)HostSystemID.Msdos) ||
                    (HostSystem == (int)HostSystemID.WindowsNT)) &&
                    (ExternalFileAttributes & attributes) == attributes)
                {
                    result = true;
                }
            }
            return result;
        }

        /// <summary>
        /// Gets the compatability information for the <see cref="ExternalFileAttributes">external file attribute</see>
        /// If the external file attributes are compatible with MS-DOS and can be read
        /// by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
        /// will be non-zero and identify the host system on which the attributes are compatible.
        /// </summary>
        /// 		
        /// <remarks>
        /// The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
        /// misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
        /// to obtain up to date and correct information.  The modified appnote by the infozip group is
        /// particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
        /// <list type="table">
        /// <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
        /// <item>1 - Amiga</item>
        /// <item>2 - OpenVMS</item>
        /// <item>3 - Unix</item>
        /// <item>4 - VM/CMS</item>
        /// <item>5 - Atari ST</item>
        /// <item>6 - OS/2 HPFS</item>
        /// <item>7 - Macintosh</item>
        /// <item>8 - Z-System</item>
        /// <item>9 - CP/M</item>
        /// <item>10 - Windows NTFS</item>
        /// <item>11 - MVS (OS/390 - Z/OS)</item>
        /// <item>12 - VSE</item>
        /// <item>13 - Acorn Risc</item>
        /// <item>14 - VFAT</item>
        /// <item>15 - Alternate MVS</item>
        /// <item>16 - BeOS</item>
        /// <item>17 - Tandem</item>
        /// <item>18 - OS/400</item>
        /// <item>19 - OS/X (Darwin)</item>
        /// <item>99 - WinZip AES</item>
        /// <item>remainder - unused</item>
        /// </list>
        /// </remarks>
        public int HostSystem
        {
            get
            {
                return (versionMadeBy >> 8) & 0xff;
            }

            set
            {
                versionMadeBy &= 0xff;
                versionMadeBy |= (ushort)((value & 0xff) << 8);
            }
        }

        /// <summary>
        /// Get minimum Zip feature version required to extract this entry
        /// </summary>		
        /// <remarks>
        /// Minimum features are defined as:<br/>
        /// 1.0 - Default value<br/>
        /// 1.1 - File is a volume label<br/>
        /// 2.0 - File is a folder/directory<br/>
        /// 2.0 - File is compressed using Deflate compression<br/>
        /// 2.0 - File is encrypted using traditional encryption<br/>
        /// 2.1 - File is compressed using Deflate64<br/>
        /// 2.5 - File is compressed using PKWARE DCL Implode<br/>
        /// 2.7 - File is a patch data set<br/>
        /// 4.5 - File uses Zip64 format extensions<br/>
        /// 4.6 - File is compressed using BZIP2 compression<br/>
        /// 5.0 - File is encrypted using DES<br/>
        /// 5.0 - File is encrypted using 3DES<br/>
        /// 5.0 - File is encrypted using original RC2 encryption<br/>
        /// 5.0 - File is encrypted using RC4 encryption<br/>
        /// 5.1 - File is encrypted using AES encryption<br/>
        /// 5.1 - File is encrypted using corrected RC2 encryption<br/>
        /// 5.1 - File is encrypted using corrected RC2-64 encryption<br/>
        /// 6.1 - File is encrypted using non-OAEP key wrapping<br/>
        /// 6.2 - Central directory encryption (not confirmed yet)<br/>
        /// 6.3 - File is compressed using LZMA<br/>
        /// 6.3 - File is compressed using PPMD+<br/>
        /// 6.3 - File is encrypted using Blowfish<br/>
        /// 6.3 - File is encrypted using Twofish<br/>
        /// </remarks>
        /// <seealso cref="CanDecompress"></seealso>
        public int Version
        {
            get
            {
                // Return recorded version if known.
                if (versionToExtract != 0)
                {
                    return versionToExtract;
                }
                else
                {
                    int result = 10;
                    if (AESKeySize > 0)
                    {
                        result = ZipConstants.VERSION_AES;			// Ver 5.1 = AES
                    }
                    else if (CentralHeaderRequiresZip64)
                    {
                        result = ZipConstants.VersionZip64;
                    }
                    else if (CompressionMethod.Deflated == method)
                    {
                        result = 20;
                    }
                    else if (IsDirectory == true)
                    {
                        result = 20;
                    }
                    else if (IsCrypted == true)
                    {
                        result = 20;
                    }
                    else if (HasDosAttributes(0x08))
                    {
                        result = 11;
                    }
                    return result;
                }
            }
        }

        /// <summary>
        /// Get a value indicating whether this entry can be decompressed by the library.
        /// </summary>
        /// <remarks>This is based on the <see cref="Version"></see> and 
        /// wether the <see cref="IsCompressionMethodSupported()">compression method</see> is supported.</remarks>
        public bool CanDecompress
        {
            get
            {
                return (Version <= ZipConstants.VersionMadeBy) &&
                    ((Version == 10) ||
                    (Version == 11) ||
                    (Version == 20) ||
                    (Version == 45) ||
                    (Version == 51)) &&
                    IsCompressionMethodSupported();
            }
        }

        /// <summary>
        /// Force this entry to be recorded using Zip64 extensions.
        /// </summary>
        public void ForceZip64()
        {
            forceZip64_ = true;
        }

        /// <summary>
        /// Get a value indicating wether Zip64 extensions were forced.
        /// </summary>
        /// <returns>A <see cref="bool"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        public bool IsZip64Forced()
        {
            return forceZip64_;
        }

        /// <summary>
        /// Gets a value indicating if the entry requires Zip64 extensions 
        /// to store the full entry values.
        /// </summary>
        /// <value>A <see cref="bool"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        public bool LocalHeaderRequiresZip64
        {
            get
            {
                bool result = forceZip64_;

                if (!result)
                {
                    ulong trueCompressedSize = compressedSize;

                    if ((versionToExtract == 0) && IsCrypted)
                    {
                        trueCompressedSize += ZipConstants.CryptoHeaderSize;
                    }

                    // TODO: A better estimation of the true limit based on compression overhead should be used
                    // to determine when an entry should use Zip64.
                    result =
                        ((this.size >= uint.MaxValue) || (trueCompressedSize >= uint.MaxValue)) &&
                        ((versionToExtract == 0) || (versionToExtract >= ZipConstants.VersionZip64));
                }

                return result;
            }
        }

        /// <summary>
        /// Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
        /// </summary>
        public bool CentralHeaderRequiresZip64
        {
            get
            {
                return LocalHeaderRequiresZip64 || (offset >= uint.MaxValue);
            }
        }

        /// <summary>
        /// Get/Set DosTime value.
        /// </summary>
        /// <remarks>
        /// The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
        /// </remarks>
        public long DosTime
        {
            get
            {
                if ((known & Known.Time) == 0)
                {
                    return 0;
                }
                else
                {
                    return dosTime;
                }
            }

            set
            {
                unchecked
                {
                    dosTime = (uint)value;
                }

                known |= Known.Time;
            }
        }

        /// <summary>
        /// Gets/Sets the time of last modification of the entry.
        /// </summary>
        /// <remarks>
        /// The <see cref="DosTime"></see> property is updated to match this as far as possible.
        /// </remarks>
        public DateTime DateTime
        {
            get
            {
                uint sec = Math.Min(59, 2 * (dosTime & 0x1f));
                uint min = Math.Min(59, (dosTime >> 5) & 0x3f);
                uint hrs = Math.Min(23, (dosTime >> 11) & 0x1f);
                uint mon = Math.Max(1, Math.Min(12, ((dosTime >> 21) & 0xf)));
                uint year = ((dosTime >> 25) & 0x7f) + 1980;
                int day = Math.Max(1, Math.Min(DateTime.DaysInMonth((int)year, (int)mon), (int)((dosTime >> 16) & 0x1f)));
                return new System.DateTime((int)year, (int)mon, day, (int)hrs, (int)min, (int)sec);
            }

            set
            {
                uint year = (uint)value.Year;
                uint month = (uint)value.Month;
                uint day = (uint)value.Day;
                uint hour = (uint)value.Hour;
                uint minute = (uint)value.Minute;
                uint second = (uint)value.Second;

                if (year < 1980)
                {
                    year = 1980;
                    month = 1;
                    day = 1;
                    hour = 0;
                    minute = 0;
                    second = 0;
                }
                else if (year > 2107)
                {
                    year = 2107;
                    month = 12;
                    day = 31;
                    hour = 23;
                    minute = 59;
                    second = 59;
                }

                DosTime = ((year - 1980) & 0x7f) << 25 |
                    (month << 21) |
                    (day << 16) |
                    (hour << 11) |
                    (minute << 5) |
                    (second >> 1);
            }
        }

        /// <summary>
        /// Returns the entry name.
        /// </summary>
        /// <remarks>
        /// The unix naming convention is followed.
        /// Path components in the entry should always separated by forward slashes ('/').
        /// Dos device names like C: should also be removed.
        /// See the <see cref="ZipNameTransform"/> class, or <see cref="CleanName(string)"/>
        ///</remarks>
        public string Name
        {
            get
            {
                return name;
            }
        }

        /// <summary>
        /// Gets/Sets the size of the uncompressed data.
        /// </summary>
        /// <returns>
        /// The size or -1 if unknown.
        /// </returns>
        /// <remarks>Setting the size before adding an entry to an archive can help
        /// avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        public long Size
        {
            get
            {
                return (known & Known.Size) != 0 ? (long)size : -1L;
            }
            set
            {
                this.size = (ulong)value;
                this.known |= Known.Size;
            }
        }

        /// <summary>
        /// Gets/Sets the size of the compressed data.
        /// </summary>
        /// <returns>
        /// The compressed entry size or -1 if unknown.
        /// </returns>
        public long CompressedSize
        {
            get
            {
                return (known & Known.CompressedSize) != 0 ? (long)compressedSize : -1L;
            }
            set
            {
                this.compressedSize = (ulong)value;
                this.known |= Known.CompressedSize;
            }
        }

        /// <summary>
        /// Gets/Sets the crc of the uncompressed data.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Crc is not in the range 0..0xffffffffL
        /// </exception>
        /// <returns>
        /// The crc value or -1 if unknown.
        /// </returns>
        public long Crc
        {
            get
            {
                return (known & Known.Crc) != 0 ? crc & 0xffffffffL : -1L;
            }
            set
            {
                if (((ulong)crc & 0xffffffff00000000L) != 0)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                this.crc = (uint)value;
                this.known |= Known.Crc;
            }
        }

        /// <summary>
        /// Gets/Sets the compression method. Only Deflated and Stored are supported.
        /// </summary>
        /// <returns>
        /// The compression method for this entry
        /// </returns>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated"/>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored"/>
        public CompressionMethod CompressionMethod
        {
            get
            {
                return method;
            }

            set
            {
                if (!IsCompressionMethodSupported(value))
                {
                    throw new NotSupportedException("Compression method not supported");
                }
                this.method = value;
            }
        }

        /// <summary>
        /// Gets the compression method for outputting to the local or central header.
        /// Returns same value as CompressionMethod except when AES encrypting, which
        /// places 99 in the method and places the real method in the extra data.
        /// </summary>
        internal CompressionMethod CompressionMethodForHeader
        {
            get
            {
                return (AESKeySize > 0) ? CompressionMethod.WinZipAES : method;
            }
        }

        /// <summary>
        /// Gets/Sets the extra data.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Extra data is longer than 64KB (0xffff) bytes.
        /// </exception>
        /// <returns>
        /// Extra data or null if not set.
        /// </returns>
        public byte[] ExtraData
        {

            get
            {
                // TODO: This is slightly safer but less efficient.  Think about wether it should change.
                //				return (byte[]) extra.Clone();
                return extra;
            }

            set
            {
                if (value == null)
                {
                    extra = null;
                }
                else
                {
                    if (value.Length > 0xffff)
                    {
                        throw new System.ArgumentOutOfRangeException("value");
                    }

                    extra = new byte[value.Length];
                    Array.Copy(value, 0, extra, 0, value.Length);
                }
            }
        }


#if !NET_1_1 && !NETCF_2_0
        /// <summary>
        /// For AES encrypted files returns or sets the number of bits of encryption (128, 192 or 256).
        /// When setting, only 0 (off), 128 or 256 is supported.
        /// </summary>
        public int AESKeySize
        {
            get
            {
                // the strength (1 or 3) is in the entry header
                switch (_aesEncryptionStrength)
                {
                    case 0: return 0;	// Not AES
                    case 1: return 128;
                    case 2: return 192; // Not used by WinZip
                    case 3: return 256;
                    default: throw new ZipException("Invalid AESEncryptionStrength " + _aesEncryptionStrength);
                }
            }
            set
            {
                switch (value)
                {
                    case 0: _aesEncryptionStrength = 0; break;
                    case 128: _aesEncryptionStrength = 1; break;
                    case 256: _aesEncryptionStrength = 3; break;
                    default: throw new ZipException("AESKeySize must be 0, 128 or 256: " + value);
                }
            }
        }

        /// <summary>
        /// AES Encryption strength for storage in extra data in entry header.
        /// 1 is 128 bit, 2 is 192 bit, 3 is 256 bit.
        /// </summary>
        internal byte AESEncryptionStrength
        {
            get
            {
                return (byte)_aesEncryptionStrength;
            }
        }
#else
		/// <summary>
		/// AES unsupported prior to .NET 2.0
		/// </summary>
		internal int AESKeySize;
#endif

        /// <summary>
        /// Returns the length of the salt, in bytes 
        /// </summary>
        internal int AESSaltLen
        {
            get
            {
                // Key size -> Salt length: 128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.
                return AESKeySize / 16;
            }
        }

        /// <summary>
        /// Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
        /// </summary>
        internal int AESOverheadSize
        {
            get
            {
                // File format:
                //   Bytes		Content
                // Variable		Salt value
                //     2		Password verification value
                // Variable		Encrypted file data
                //    10		Authentication code
                return 12 + AESSaltLen;
            }
        }

        /// <summary>
        /// Process extra data fields updating the entry based on the contents.
        /// </summary>
        /// <param name="localHeader">True if the extra data fields should be handled
        /// for a local header, rather than for a central header.
        /// </param>
        internal void ProcessExtraData(bool localHeader)
        {
            ZipExtraData extraData = new ZipExtraData(this.extra);

            if (extraData.Find(0x0001))
            {
                // Version required to extract is ignored here as some archivers dont set it correctly
                // in theory it should be version 45 or higher

                // The recorded size will change but remember that this is zip64.
                forceZip64_ = true;

                if (extraData.ValueLength < 4)
                {
                    throw new ZipException("Extra data extended Zip64 information length is invalid");
                }

                if (localHeader || (size == uint.MaxValue))
                {
                    size = (ulong)extraData.ReadLong();
                }

                if (localHeader || (compressedSize == uint.MaxValue))
                {
                    compressedSize = (ulong)extraData.ReadLong();
                }

                if (!localHeader && (offset == uint.MaxValue))
                {
                    offset = extraData.ReadLong();
                }

                // Disk number on which file starts is ignored
            }
            else
            {
                if (
                    ((versionToExtract & 0xff) >= ZipConstants.VersionZip64) &&
                    ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))
                )
                {
                    throw new ZipException("Zip64 Extended information required but is missing.");
                }
            }

            if (extraData.Find(10))
            {
                // No room for any tags.
                if (extraData.ValueLength < 4)
                {
                    throw new ZipException("NTFS Extra data invalid");
                }

                extraData.ReadInt(); // Reserved

                while (extraData.UnreadCount >= 4)
                {
                    int ntfsTag = extraData.ReadShort();
                    int ntfsLength = extraData.ReadShort();
                    if (ntfsTag == 1)
                    {
                        if (ntfsLength >= 24)
                        {
                            long lastModification = extraData.ReadLong();
                            long lastAccess = extraData.ReadLong();
                            long createTime = extraData.ReadLong();

                            DateTime = System.DateTime.FromFileTime(lastModification);
                        }
                        break;
                    }
                    else
                    {
                        // An unknown NTFS tag so simply skip it.
                        extraData.Skip(ntfsLength);
                    }
                }
            }
            else if (extraData.Find(0x5455))
            {
                int length = extraData.ValueLength;
                int flags = extraData.ReadByte();

                // Can include other times but these are ignored.  Length of data should
                // actually be 1 + 4 * no of bits in flags.
                if (((flags & 1) != 0) && (length >= 5))
                {
                    int iTime = extraData.ReadInt();

                    DateTime = (new System.DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }
            }
            if (method == CompressionMethod.WinZipAES)
            {
                ProcessAESExtraData(extraData);
            }
        }

        // For AES the method in the entry is 99, and the real compression method is in the extradata
        //
        private void ProcessAESExtraData(ZipExtraData extraData)
        {

#if !NET_1_1 && !NETCF_2_0
            if (extraData.Find(0x9901))
            {
                // Set version and flag for Zipfile.CreateAndInitDecryptionStream
                versionToExtract = ZipConstants.VERSION_AES;			// Ver 5.1 = AES see "Version" getter
                // Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream
                Flags = Flags | (int)GeneralBitFlags.StrongEncryption;
                //
                // Unpack AES extra data field see http://www.winzip.com/aes_info.htm
                int length = extraData.ValueLength;			// Data size currently 7
                if (length < 7)
                    throw new ZipException("AES Extra Data Length " + length + " invalid.");
                int ver = extraData.ReadShort();			// Version number (1=AE-1 2=AE-2)
                int vendorId = extraData.ReadShort();		// 2-character vendor ID 0x4541 = "AE"
                int encrStrength = extraData.ReadByte();	// encryption strength 1 = 128 2 = 192 3 = 256
                int actualCompress = extraData.ReadShort(); // The actual compression method used to compress the file
                _aesVer = ver;
                _aesEncryptionStrength = encrStrength;
                method = (CompressionMethod)actualCompress;
            }
            else
                throw new ZipException("AES Extra Data missing");
#else
				throw new ZipException("AES unsupported");
#endif
        }

        /// <summary>
        /// Gets/Sets the entry comment.
        /// </summary>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// If comment is longer than 0xffff.
        /// </exception>
        /// <returns>
        /// The comment or null if not set.
        /// </returns>
        /// <remarks>
        /// A comment is only available for entries when read via the <see cref="ZipFile"/> class.
        /// The <see cref="ZipInputStream"/> class doesnt have the comment data available.
        /// </remarks>
        public string Comment
        {
            get
            {
                return comment;
            }
            set
            {
                // This test is strictly incorrect as the length is in characters
                // while the storage limit is in bytes.
                // While the test is partially correct in that a comment of this length or greater 
                // is definitely invalid, shorter comments may also have an invalid length
                // where there are multi-byte characters
                // The full test is not possible here however as the code page to apply conversions with
                // isnt available.
                if ((value != null) && (value.Length > 0xffff))
                {
#if NETCF_1_0
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "cannot exceed 65535");
#endif
                }

                comment = value;
            }
        }

        /// <summary>
        /// Gets a value indicating if the entry is a directory.
        /// however.
        /// </summary>
        /// <remarks>
        /// A directory is determined by an entry name with a trailing slash '/'.
        /// The external file attributes can also indicate an entry is for a directory.
        /// Currently only dos/windows attributes are tested in this manner.
        /// The trailing slash convention should always be followed.
        /// </remarks>
        public bool IsDirectory
        {
            get
            {
                int nameLength = name.Length;
                bool result =
                    ((nameLength > 0) &&
                    ((name[nameLength - 1] == '/') || (name[nameLength - 1] == '\\'))) ||
                    HasDosAttributes(16)
                    ;
                return result;
            }
        }

        /// <summary>
        /// Get a value of true if the entry appears to be a file; false otherwise
        /// </summary>
        /// <remarks>
        /// This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
        /// For linux and others the result may be incorrect.
        /// </remarks>
        public bool IsFile
        {
            get
            {
                return !IsDirectory && !HasDosAttributes(8);
            }
        }

        /// <summary>
        /// Test entry to see if data can be extracted.
        /// </summary>
        /// <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        public bool IsCompressionMethodSupported()
        {
            return IsCompressionMethodSupported(CompressionMethod);
        }

        #region ICloneable Members
        /// <summary>
        /// Creates a copy of this zip entry.
        /// </summary>
        /// <returns>An <see cref="Object"/> that is a copy of the current instance.</returns>
        public object Clone()
        {
            ZipEntry result = (ZipEntry)this.MemberwiseClone();

            // Ensure extra data is unique if it exists.
            if (extra != null)
            {
                result.extra = new byte[extra.Length];
                Array.Copy(extra, 0, result.extra, 0, extra.Length);
            }

            return result;
        }

        #endregion

        /// <summary>
        /// Gets a string representation of this ZipEntry.
        /// </summary>
        /// <returns>A readable textual representation of this <see cref="ZipEntry"/></returns>
        public override string ToString()
        {
            return name;
        }

        /// <summary>
        /// Test a <see cref="CompressionMethod">compression method</see> to see if this library
        /// supports extracting data compressed with that method
        /// </summary>
        /// <param name="method">The compression method to test.</param>
        /// <returns>Returns true if the compression method is supported; false otherwise</returns>
        public static bool IsCompressionMethodSupported(CompressionMethod method)
        {
            return
                (method == CompressionMethod.Deflated) ||
                (method == CompressionMethod.Stored);
        }

        /// <summary>
        /// Cleans a name making it conform to Zip file conventions.
        /// Devices names ('c:\') and UNC share names ('\\server\share') are removed
        /// and forward slashes ('\') are converted to back slashes ('/').
        /// Names are made relative by trimming leading slashes which is compatible
        /// with the ZIP naming convention.
        /// </summary>
        /// <param name="name">The name to clean</param>
        /// <returns>The 'cleaned' name.</returns>
        /// <remarks>
        /// The <seealso cref="ZipNameTransform">Zip name transform</seealso> class is more flexible.
        /// </remarks>
        public static string CleanName(string name)
        {
            if (name == null)
            {
                return string.Empty;
            }

            if (Path.IsPathRooted(name) == true)
            {
                // NOTE:
                // for UNC names...  \\machine\share\zoom\beet.txt gives \zoom\beet.txt
                name = name.Substring(Path.GetPathRoot(name).Length);
            }

            name = name.Replace(@"\", "/");

            while ((name.Length > 0) && (name[0] == '/'))
            {
                name = name.Remove(0, 1);
            }
            return name;
        }

        #region Instance Fields
        Known known;
        int externalFileAttributes = -1;     // contains external attributes (O/S dependant)

        ushort versionMadeBy;					// Contains host system and version information
        // only relevant for central header entries

        string name;
        ulong size;
        ulong compressedSize;
        ushort versionToExtract;                // Version required to extract (library handles <= 2.0)
        uint crc;
        uint dosTime;

        CompressionMethod method = CompressionMethod.Deflated;
        byte[] extra;
        string comment;

        int flags;                             // general purpose bit flags

        long zipFileIndex = -1;                // used by ZipFile
        long offset;                           // used by ZipFile and ZipOutputStream

        bool forceZip64_;
        byte cryptoCheckValue_;
#if !NET_1_1 && !NETCF_2_0
        int _aesVer;							// Version number (2 = AE-2 ?). Assigned but not used.
        int _aesEncryptionStrength;				// Encryption strength 1 = 128 2 = 192 3 = 256
#endif
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;

    using ICSharpCode.SharpZipLib.Core;

    /// <summary>
    /// Basic implementation of <see cref="IEntryFactory"></see>
    /// </summary>
    public class ZipEntryFactory : IEntryFactory
    {
        #region Enumerations
        /// <summary>
        /// Defines the possible values to be used for the <see cref="ZipEntry.DateTime"/>.
        /// </summary>
        public enum TimeSetting
        {
            /// <summary>
            /// Use the recorded LastWriteTime value for the file.
            /// </summary>
            LastWriteTime,
            /// <summary>
            /// Use the recorded LastWriteTimeUtc value for the file
            /// </summary>
            LastWriteTimeUtc,
            /// <summary>
            /// Use the recorded CreateTime value for the file.
            /// </summary>
            CreateTime,
            /// <summary>
            /// Use the recorded CreateTimeUtc value for the file.
            /// </summary>
            CreateTimeUtc,
            /// <summary>
            /// Use the recorded LastAccessTime value for the file.
            /// </summary>
            LastAccessTime,
            /// <summary>
            /// Use the recorded LastAccessTimeUtc value for the file.
            /// </summary>
            LastAccessTimeUtc,
            /// <summary>
            /// Use a fixed value.
            /// </summary>
            /// <remarks>The actual <see cref="DateTime"/> value used can be
            /// specified via the <see cref="ZipEntryFactory(DateTime)"/> constructor or 
            /// using the <see cref="ZipEntryFactory(TimeSetting)"/> with the setting set
            /// to <see cref="TimeSetting.Fixed"/> which will use the <see cref="DateTime"/> when this class was constructed.
            /// The <see cref="FixedDateTime"/> property can also be used to set this value.</remarks>
            Fixed,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initialise a new instance of the <see cref="ZipEntryFactory"/> class.
        /// </summary>
        /// <remarks>A default <see cref="INameTransform"/>, and the LastWriteTime for files is used.</remarks>
        public ZipEntryFactory()
        {
            nameTransform_ = new ZipNameTransform();
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipEntryFactory"/> using the specified <see cref="TimeSetting"/>
        /// </summary>
        /// <param name="timeSetting">The <see cref="TimeSetting">time setting</see> to use when creating <see cref="ZipEntry">Zip entries</see>.</param>
        public ZipEntryFactory(TimeSetting timeSetting)
        {
            timeSetting_ = timeSetting;
            nameTransform_ = new ZipNameTransform();
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipEntryFactory"/> using the specified <see cref="DateTime"/>
        /// </summary>
        /// <param name="time">The time to set all <see cref="ZipEntry.DateTime"/> values to.</param>
        public ZipEntryFactory(DateTime time)
        {
            timeSetting_ = TimeSetting.Fixed;
            FixedDateTime = time;
            nameTransform_ = new ZipNameTransform();
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get / set the <see cref="INameTransform"/> to be used when creating new <see cref="ZipEntry"/> values.
        /// </summary>
        /// <remarks>
        /// Setting this property to null will cause a default <see cref="ZipNameTransform">name transform</see> to be used.
        /// </remarks>
        public INameTransform NameTransform
        {
            get { return nameTransform_; }
            set
            {
                if (value == null)
                {
                    nameTransform_ = new ZipNameTransform();
                }
                else
                {
                    nameTransform_ = value;
                }
            }
        }

        /// <summary>
        /// Get / set the <see cref="TimeSetting"/> in use.
        /// </summary>
        public TimeSetting Setting
        {
            get { return timeSetting_; }
            set { timeSetting_ = value; }
        }

        /// <summary>
        /// Get / set the <see cref="DateTime"/> value to use when <see cref="Setting"/> is set to <see cref="TimeSetting.Fixed"/>
        /// </summary>
        public DateTime FixedDateTime
        {
            get { return fixedDateTime_; }
            set
            {
                if (value.Year < 1970)
                {
                    throw new ArgumentException("Value is too old to be valid", "value");
                }
                fixedDateTime_ = value;
            }
        }

        /// <summary>
        /// A bitmask defining the attributes to be retrieved from the actual file.
        /// </summary>
        /// <remarks>The default is to get all possible attributes from the actual file.</remarks>
        public int GetAttributes
        {
            get { return getAttributes_; }
            set { getAttributes_ = value; }
        }

        /// <summary>
        /// A bitmask defining which attributes are to be set on.
        /// </summary>
        /// <remarks>By default no attributes are set on.</remarks>
        public int SetAttributes
        {
            get { return setAttributes_; }
            set { setAttributes_ = value; }
        }

        /// <summary>
        /// Get set a value indicating wether unidoce text should be set on.
        /// </summary>
        public bool IsUnicodeText
        {
            get { return isUnicodeText_; }
            set { isUnicodeText_ = value; }
        }

        #endregion

        #region IEntryFactory Members

        /// <summary>
        /// Make a new <see cref="ZipEntry"/> for a file.
        /// </summary>
        /// <param name="fileName">The name of the file to create a new entry for.</param>
        /// <returns>Returns a new <see cref="ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        public ZipEntry MakeFileEntry(string fileName)
        {
            return MakeFileEntry(fileName, true);
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"/> from a name.
        /// </summary>
        /// <param name="fileName">The name of the file to create a new entry for.</param>
        /// <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
        /// <returns>Returns a new <see cref="ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        public ZipEntry MakeFileEntry(string fileName, bool useFileSystem)
        {
            ZipEntry result = new ZipEntry(nameTransform_.TransformFile(fileName));
            result.IsUnicodeText = isUnicodeText_;

            int externalAttributes = 0;
            bool useAttributes = (setAttributes_ != 0);

            FileInfo fi = null;
            if (useFileSystem)
            {
                fi = new FileInfo(fileName);
            }

            if ((fi != null) && fi.Exists)
            {
                switch (timeSetting_)
                {
                    case TimeSetting.CreateTime:
                        result.DateTime = fi.CreationTime;
                        break;

                    case TimeSetting.CreateTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.CreationTime.ToUniversalTime();
#else
                        result.DateTime = fi.CreationTimeUtc;
#endif
                        break;

                    case TimeSetting.LastAccessTime:
                        result.DateTime = fi.LastAccessTime;
                        break;

                    case TimeSetting.LastAccessTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.LastAccessTime.ToUniversalTime();
#else
                        result.DateTime = fi.LastAccessTimeUtc;
#endif
                        break;

                    case TimeSetting.LastWriteTime:
                        result.DateTime = fi.LastWriteTime;
                        break;

                    case TimeSetting.LastWriteTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = fi.LastWriteTime.ToUniversalTime();
#else
                        result.DateTime = fi.LastWriteTimeUtc;
#endif
                        break;

                    case TimeSetting.Fixed:
                        result.DateTime = fixedDateTime_;
                        break;

                    default:
                        throw new ZipException("Unhandled time setting in MakeFileEntry");
                }

                result.Size = fi.Length;

                useAttributes = true;
                externalAttributes = ((int)fi.Attributes & getAttributes_);
            }
            else
            {
                if (timeSetting_ == TimeSetting.Fixed)
                {
                    result.DateTime = fixedDateTime_;
                }
            }

            if (useAttributes)
            {
                externalAttributes |= setAttributes_;
                result.ExternalFileAttributes = externalAttributes;
            }

            return result;
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"></see> for a directory.
        /// </summary>
        /// <param name="directoryName">The raw untransformed name for the new directory</param>
        /// <returns>Returns a new <see cref="ZipEntry"></see> representing a directory.</returns>
        public ZipEntry MakeDirectoryEntry(string directoryName)
        {
            return MakeDirectoryEntry(directoryName, true);
        }

        /// <summary>
        /// Make a new <see cref="ZipEntry"></see> for a directory.
        /// </summary>
        /// <param name="directoryName">The raw untransformed name for the new directory</param>
        /// <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
        /// <returns>Returns a new <see cref="ZipEntry"></see> representing a directory.</returns>
        public ZipEntry MakeDirectoryEntry(string directoryName, bool useFileSystem)
        {

            ZipEntry result = new ZipEntry(nameTransform_.TransformDirectory(directoryName));
            result.IsUnicodeText = isUnicodeText_;
            result.Size = 0;

            int externalAttributes = 0;

            DirectoryInfo di = null;

            if (useFileSystem)
            {
                di = new DirectoryInfo(directoryName);
            }


            if ((di != null) && di.Exists)
            {
                switch (timeSetting_)
                {
                    case TimeSetting.CreateTime:
                        result.DateTime = di.CreationTime;
                        break;

                    case TimeSetting.CreateTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.CreationTime.ToUniversalTime();
#else
                        result.DateTime = di.CreationTimeUtc;
#endif
                        break;

                    case TimeSetting.LastAccessTime:
                        result.DateTime = di.LastAccessTime;
                        break;

                    case TimeSetting.LastAccessTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.LastAccessTime.ToUniversalTime();
#else
                        result.DateTime = di.LastAccessTimeUtc;
#endif
                        break;

                    case TimeSetting.LastWriteTime:
                        result.DateTime = di.LastWriteTime;
                        break;

                    case TimeSetting.LastWriteTimeUtc:
#if NETCF_1_0 || NETCF_2_0
						result.DateTime = di.LastWriteTime.ToUniversalTime();
#else
                        result.DateTime = di.LastWriteTimeUtc;
#endif
                        break;

                    case TimeSetting.Fixed:
                        result.DateTime = fixedDateTime_;
                        break;

                    default:
                        throw new ZipException("Unhandled time setting in MakeDirectoryEntry");
                }

                externalAttributes = ((int)di.Attributes & getAttributes_);
            }
            else
            {
                if (timeSetting_ == TimeSetting.Fixed)
                {
                    result.DateTime = fixedDateTime_;
                }
            }

            // Always set directory attribute on.
            externalAttributes |= (setAttributes_ | 16);
            result.ExternalFileAttributes = externalAttributes;

            return result;
        }

        #endregion

        #region Instance Fields
        INameTransform nameTransform_;
        DateTime fixedDateTime_ = DateTime.Now;
        TimeSetting timeSetting_;
        bool isUnicodeText_;

        int getAttributes_ = -1;
        int setAttributes_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;

#if !NETCF_1_0 && !NETCF_2_0
    using System.Runtime.Serialization;
#endif
    /// <summary>
    /// Represents exception conditions specific to Zip archive handling
    /// </summary>
#if !NETCF_1_0 && !NETCF_2_0
    [Serializable]
#endif
    public class ZipException : SharpZipBaseException
    {
#if !NETCF_1_0 && !NETCF_2_0
        /// <summary>
        /// Deserialization constructor 
        /// </summary>
        /// <param name="info"><see cref="SerializationInfo"/> for this constructor</param>
        /// <param name="context"><see cref="StreamingContext"/> for this constructor</param>
        protected ZipException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif

        /// <summary>
        /// Initializes a new instance of the ZipException class.
        /// </summary>
        public ZipException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ZipException class with a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public ZipException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initialise a new instance of ZipException.
        /// </summary>
        /// <param name="message">A message describing the error.</param>
        /// <param name="exception">The exception that is the cause of the current exception.</param>
        public ZipException(string message, Exception exception)
            : base(message, exception)
        {
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    // TODO: Sort out wether tagged data is useful and what a good implementation might look like.
    // Its just a sketch of an idea at the moment.

    /// <summary>
    /// ExtraData tagged value interface.
    /// </summary>
    public interface ITaggedData
    {
        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        short TagID { get; }

        /// <summary>
        /// Set the contents of this instance from the data passed.
        /// </summary>
        /// <param name="data">The data to extract contents from.</param>
        /// <param name="offset">The offset to begin extracting data from.</param>
        /// <param name="count">The number of bytes to extract.</param>
        void SetData(byte[] data, int offset, int count);

        /// <summary>
        /// Get the data representing this instance.
        /// </summary>
        /// <returns>Returns the data for this instance.</returns>
        byte[] GetData();
    }

    /// <summary>
    /// A raw binary tagged value
    /// </summary>
    public class RawTaggedData : ITaggedData
    {
        /// <summary>
        /// Initialise a new instance.
        /// </summary>
        /// <param name="tag">The tag ID.</param>
        public RawTaggedData(short tag)
        {
            _tag = tag;
        }

        #region ITaggedData Members

        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        public short TagID
        {
            get { return _tag; }
            set { _tag = value; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="offset">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int offset, int count)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _data = new byte[count];
            Array.Copy(data, offset, _data, 0, count);
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            return _data;
        }

        #endregion

        /// <summary>
        /// Get /set the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] Data
        {
            get { return _data; }
            set { _data = value; }
        }

        #region Instance Fields
        /// <summary>
        /// The tag ID for this instance.
        /// </summary>
        short _tag;

        byte[] _data;
        #endregion
    }

    /// <summary>
    /// Class representing extended unix date time values.
    /// </summary>
    public class ExtendedUnixData : ITaggedData
    {
        /// <summary>
        /// Flags indicate which values are included in this instance.
        /// </summary>
        [Flags]
        public enum Flags : byte
        {
            /// <summary>
            /// The modification time is included
            /// </summary>
            ModificationTime = 0x01,

            /// <summary>
            /// The access time is included
            /// </summary>
            AccessTime = 0x02,

            /// <summary>
            /// The create time is included.
            /// </summary>
            CreateTime = 0x04,
        }

        #region ITaggedData Members

        /// <summary>
        /// Get the ID
        /// </summary>
        public short TagID
        {
            get { return 0x5455; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="index">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int index, int count)
        {
            using (MemoryStream ms = new MemoryStream(data, index, count, false))
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                // bit 0           if set, modification time is present
                // bit 1           if set, access time is present
                // bit 2           if set, creation time is present

                _flags = (Flags)helperStream.ReadByte();
                if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))
                {
                    int iTime = helperStream.ReadLEInt();

                    _modificationTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }

                if ((_flags & Flags.AccessTime) != 0)
                {
                    int iTime = helperStream.ReadLEInt();

                    _lastAccessTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }

                if ((_flags & Flags.CreateTime) != 0)
                {
                    int iTime = helperStream.ReadLEInt();

                    _createTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() +
                        new TimeSpan(0, 0, 0, iTime, 0)).ToLocalTime();
                }
            }
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            using (MemoryStream ms = new MemoryStream())
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.IsStreamOwner = false;
                helperStream.WriteByte((byte)_flags);     // Flags
                if ((_flags & Flags.ModificationTime) != 0)
                {
                    TimeSpan span = _modificationTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                if ((_flags & Flags.AccessTime) != 0)
                {
                    TimeSpan span = _lastAccessTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                if ((_flags & Flags.CreateTime) != 0)
                {
                    TimeSpan span = _createTime.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime();
                    int seconds = (int)span.TotalSeconds;
                    helperStream.WriteLEInt(seconds);
                }
                return ms.ToArray();
            }
        }

        #endregion

        /// <summary>
        /// Test a <see cref="DateTime"> value to see if is valid and can be represented here.</see>
        /// </summary>
        /// <param name="value">The <see cref="DateTime">value</see> to test.</param>
        /// <returns>Returns true if the value is valid and can be represented; false if not.</returns>
        /// <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
        /// which is the number of seconds since 1970-01-01.
        /// Being 32 bits means the values here cover a range of about 136 years.
        /// The minimum representable time is 1901-12-13 20:45:52,
        /// and the maximum representable time is 2038-01-19 03:14:07.
        /// </remarks>
        public static bool IsValidValue(DateTime value)
        {
            return ((value >= new DateTime(1901, 12, 13, 20, 45, 52)) ||
                    (value <= new DateTime(2038, 1, 19, 03, 14, 07)));
        }

        /// <summary>
        /// Get /set the Modification Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime ModificationTime
        {
            get { return _modificationTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.ModificationTime;
                _modificationTime = value;
            }
        }

        /// <summary>
        /// Get / set the Access Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime AccessTime
        {
            get { return _lastAccessTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.AccessTime;
                _lastAccessTime = value;
            }
        }

        /// <summary>
        /// Get / Set the Create Time
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        /// <seealso cref="IsValidValue"></seealso>
        public DateTime CreateTime
        {
            get { return _createTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }

                _flags |= Flags.CreateTime;
                _createTime = value;
            }
        }

        /// <summary>
        /// Get/set the <see cref="Flags">values</see> to include.
        /// </summary>
        Flags Include
        {
            get { return _flags; }
            set { _flags = value; }
        }

        #region Instance Fields
        Flags _flags;
        DateTime _modificationTime = new DateTime(1970, 1, 1);
        DateTime _lastAccessTime = new DateTime(1970, 1, 1);
        DateTime _createTime = new DateTime(1970, 1, 1);
        #endregion
    }

    /// <summary>
    /// Class handling NT date time values.
    /// </summary>
    public class NTTaggedData : ITaggedData
    {
        /// <summary>
        /// Get the ID for this tagged data value.
        /// </summary>
        public short TagID
        {
            get { return 10; }
        }

        /// <summary>
        /// Set the data from the raw values provided.
        /// </summary>
        /// <param name="data">The raw data to extract values from.</param>
        /// <param name="index">The index to start extracting values from.</param>
        /// <param name="count">The number of bytes available.</param>
        public void SetData(byte[] data, int index, int count)
        {
            using (MemoryStream ms = new MemoryStream(data, index, count, false))
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.ReadLEInt(); // Reserved
                while (helperStream.Position < helperStream.Length)
                {
                    int ntfsTag = helperStream.ReadLEShort();
                    int ntfsLength = helperStream.ReadLEShort();
                    if (ntfsTag == 1)
                    {
                        if (ntfsLength >= 24)
                        {
                            long lastModificationTicks = helperStream.ReadLELong();
                            _lastModificationTime = DateTime.FromFileTime(lastModificationTicks);

                            long lastAccessTicks = helperStream.ReadLELong();
                            _lastAccessTime = DateTime.FromFileTime(lastAccessTicks);

                            long createTimeTicks = helperStream.ReadLELong();
                            _createTime = DateTime.FromFileTime(createTimeTicks);
                        }
                        break;
                    }
                    else
                    {
                        // An unknown NTFS tag so simply skip it.
                        helperStream.Seek(ntfsLength, SeekOrigin.Current);
                    }
                }
            }
        }

        /// <summary>
        /// Get the binary data representing this instance.
        /// </summary>
        /// <returns>The raw binary data representing this instance.</returns>
        public byte[] GetData()
        {
            using (MemoryStream ms = new MemoryStream())
            using (ZipHelperStream helperStream = new ZipHelperStream(ms))
            {
                helperStream.IsStreamOwner = false;
                helperStream.WriteLEInt(0);       // Reserved
                helperStream.WriteLEShort(1);     // Tag
                helperStream.WriteLEShort(24);    // Length = 3 x 8.
                helperStream.WriteLELong(_lastModificationTime.ToFileTime());
                helperStream.WriteLELong(_lastAccessTime.ToFileTime());
                helperStream.WriteLELong(_createTime.ToFileTime());
                return ms.ToArray();
            }
        }

        /// <summary>
        /// Test a <see cref="DateTime"> valuie to see if is valid and can be represented here.</see>
        /// </summary>
        /// <param name="value">The <see cref="DateTime">value</see> to test.</param>
        /// <returns>Returns true if the value is valid and can be represented; false if not.</returns>
        /// <remarks>
        /// NTFS filetimes are 64-bit unsigned integers, stored in Intel
        /// (least significant byte first) byte order. They determine the
        /// number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
        /// which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
        /// </remarks>
        public static bool IsValidValue(DateTime value)
        {
            bool result = true;
            try
            {
                value.ToFileTimeUtc();
            }
            catch
            {
                result = false;
            }
            return result;
        }

        /// <summary>
        /// Get/set the <see cref="DateTime">last modification time</see>.
        /// </summary>
        public DateTime LastModificationTime
        {
            get { return _lastModificationTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _lastModificationTime = value;
            }
        }

        /// <summary>
        /// Get /set the <see cref="DateTime">create time</see>
        /// </summary>
        public DateTime CreateTime
        {
            get { return _createTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _createTime = value;
            }
        }

        /// <summary>
        /// Get /set the <see cref="DateTime">last access time</see>.
        /// </summary>
        public DateTime LastAccessTime
        {
            get { return _lastAccessTime; }
            set
            {
                if (!IsValidValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _lastAccessTime = value;
            }
        }

        #region Instance Fields
        DateTime _lastAccessTime = DateTime.FromFileTime(0);
        DateTime _lastModificationTime = DateTime.FromFileTime(0);
        DateTime _createTime = DateTime.FromFileTime(0);
        #endregion
    }

    /// <summary>
    /// A factory that creates <see cref="ITaggedData">tagged data</see> instances.
    /// </summary>
    interface ITaggedDataFactory
    {
        /// <summary>
        /// Get data for a specific tag value.
        /// </summary>
        /// <param name="tag">The tag ID to find.</param>
        /// <param name="data">The data to search.</param>
        /// <param name="offset">The offset to begin extracting data from.</param>
        /// <param name="count">The number of bytes to extract.</param>
        /// <returns>The located <see cref="ITaggedData">value found</see>, or null if not found.</returns>
        ITaggedData Create(short tag, byte[] data, int offset, int count);
    }

    /// 
    /// <summary>
    /// A class to handle the extra data field for Zip entries
    /// </summary>
    /// <remarks>
    /// Extra data contains 0 or more values each prefixed by a header tag and length.
    /// They contain zero or more bytes of actual data.
    /// The data is held internally using a copy on write strategy.  This is more efficient but
    /// means that for extra data created by passing in data can have the values modified by the caller
    /// in some circumstances.
    /// </remarks>
    sealed public class ZipExtraData : IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initialise a default instance.
        /// </summary>
        public ZipExtraData()
        {
            Clear();
        }

        /// <summary>
        /// Initialise with known extra data.
        /// </summary>
        /// <param name="data">The extra data.</param>
        public ZipExtraData(byte[] data)
        {
            if (data == null)
            {
                _data = new byte[0];
            }
            else
            {
                _data = data;
            }
        }
        #endregion

        /// <summary>
        /// Get the raw extra data value
        /// </summary>
        /// <returns>Returns the raw byte[] extra data this instance represents.</returns>
        public byte[] GetEntryData()
        {
            if (Length > ushort.MaxValue)
            {
                throw new ZipException("Data exceeds maximum length");
            }

            return (byte[])_data.Clone();
        }

        /// <summary>
        /// Clear the stored data.
        /// </summary>
        public void Clear()
        {
            if ((_data == null) || (_data.Length != 0))
            {
                _data = new byte[0];
            }
        }

        /// <summary>
        /// Gets the current extra data length.
        /// </summary>
        public int Length
        {
            get { return _data.Length; }
        }

        /// <summary>
        /// Get a read-only <see cref="Stream"/> for the associated tag.
        /// </summary>
        /// <param name="tag">The tag to locate data for.</param>
        /// <returns>Returns a <see cref="Stream"/> containing tag data or null if no tag was found.</returns>
        public Stream GetStreamForTag(int tag)
        {
            Stream result = null;
            if (Find(tag))
            {
                result = new MemoryStream(_data, _index, _readValueLength, false);
            }
            return result;
        }

        /// <summary>
        /// Get the <see cref="ITaggedData">tagged data</see> for a tag.
        /// </summary>
        /// <param name="tag">The tag to search for.</param>
        /// <returns>Returns a <see cref="ITaggedData">tagged value</see> or null if none found.</returns>
        private ITaggedData GetData(short tag)
        {
            ITaggedData result = null;
            if (Find(tag))
            {
                result = Create(tag, _data, _readValueStart, _readValueLength);
            }
            return result;
        }

        static ITaggedData Create(short tag, byte[] data, int offset, int count)
        {
            ITaggedData result = null;
            switch (tag)
            {
                case 0x000A:
                    result = new NTTaggedData();
                    break;
                case 0x5455:
                    result = new ExtendedUnixData();
                    break;
                default:
                    result = new RawTaggedData(tag);
                    break;
            }
            result.SetData(data, offset, count);
            return result;
        }

        /// <summary>
        /// Get the length of the last value found by <see cref="Find"/>
        /// </summary>
        /// <remarks>This is only valid if <see cref="Find"/> has previously returned true.</remarks>
        public int ValueLength
        {
            get { return _readValueLength; }
        }

        /// <summary>
        /// Get the index for the current read value.
        /// </summary>
        /// <remarks>This is only valid if <see cref="Find"/> has previously returned true.
        /// Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
        /// <see cref="ReadInt"/>, <see cref="ReadShort"/> and <see cref="ReadLong"/>. </remarks>
        public int CurrentReadIndex
        {
            get { return _index; }
        }

        /// <summary>
        /// Get the number of bytes remaining to be read for the current value;
        /// </summary>
        public int UnreadCount
        {
            get
            {
                if ((_readValueStart > _data.Length) ||
                    (_readValueStart < 4))
                {
                    throw new ZipException("Find must be called before calling a Read method");
                }

                return _readValueStart + _readValueLength - _index;
            }
        }

        /// <summary>
        /// Find an extra data value
        /// </summary>
        /// <param name="headerID">The identifier for the value to find.</param>
        /// <returns>Returns true if the value was found; false otherwise.</returns>
        public bool Find(int headerID)
        {
            _readValueStart = _data.Length;
            _readValueLength = 0;
            _index = 0;

            int localLength = _readValueStart;
            int localTag = headerID - 1;

            // Trailing bytes that cant make up an entry (as there arent enough
            // bytes for a tag and length) are ignored!
            while ((localTag != headerID) && (_index < _data.Length - 3))
            {
                localTag = ReadShortInternal();
                localLength = ReadShortInternal();
                if (localTag != headerID)
                {
                    _index += localLength;
                }
            }

            bool result = (localTag == headerID) && ((_index + localLength) <= _data.Length);

            if (result)
            {
                _readValueStart = _index;
                _readValueLength = localLength;
            }

            return result;
        }

        /// <summary>
        /// Add a new entry to extra data.
        /// </summary>
        /// <param name="taggedData">The <see cref="ITaggedData"/> value to add.</param>
        public void AddEntry(ITaggedData taggedData)
        {
            if (taggedData == null)
            {
                throw new ArgumentNullException("taggedData");
            }
            AddEntry(taggedData.TagID, taggedData.GetData());
        }

        /// <summary>
        /// Add a new entry to extra data
        /// </summary>
        /// <param name="headerID">The ID for this entry.</param>
        /// <param name="fieldData">The data to add.</param>
        /// <remarks>If the ID already exists its contents are replaced.</remarks>
        public void AddEntry(int headerID, byte[] fieldData)
        {
            if ((headerID > ushort.MaxValue) || (headerID < 0))
            {
                throw new ArgumentOutOfRangeException("headerID");
            }

            int addLength = (fieldData == null) ? 0 : fieldData.Length;

            if (addLength > ushort.MaxValue)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("fieldData");
#else
                throw new ArgumentOutOfRangeException("fieldData", "exceeds maximum length");
#endif
            }

            // Test for new length before adjusting data.
            int newLength = _data.Length + addLength + 4;

            if (Find(headerID))
            {
                newLength -= (ValueLength + 4);
            }

            if (newLength > ushort.MaxValue)
            {
                throw new ZipException("Data exceeds maximum length");
            }

            Delete(headerID);

            byte[] newData = new byte[newLength];
            _data.CopyTo(newData, 0);
            int index = _data.Length;
            _data = newData;
            SetShort(ref index, headerID);
            SetShort(ref index, addLength);
            if (fieldData != null)
            {
                fieldData.CopyTo(newData, index);
            }
        }

        /// <summary>
        /// Start adding a new entry.
        /// </summary>
        /// <remarks>Add data using <see cref="AddData(byte[])"/>, <see cref="AddLeShort"/>, <see cref="AddLeInt"/>, or <see cref="AddLeLong"/>.
        /// The new entry is completed and actually added by calling <see cref="AddNewEntry"/></remarks>
        /// <seealso cref="AddEntry(ITaggedData)"/>
        public void StartNewEntry()
        {
            _newEntry = new MemoryStream();
        }

        /// <summary>
        /// Add entry data added since <see cref="StartNewEntry"/> using the ID passed.
        /// </summary>
        /// <param name="headerID">The identifier to use for this entry.</param>
        public void AddNewEntry(int headerID)
        {
            byte[] newData = _newEntry.ToArray();
            _newEntry = null;
            AddEntry(headerID, newData);
        }

        /// <summary>
        /// Add a byte of data to the pending new entry.
        /// </summary>
        /// <param name="data">The byte to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddData(byte data)
        {
            _newEntry.WriteByte(data);
        }

        /// <summary>
        /// Add data to a pending new entry.
        /// </summary>
        /// <param name="data">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddData(byte[] data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _newEntry.Write(data, 0, data.Length);
        }

        /// <summary>
        /// Add a short value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeShort(int toAdd)
        {
            unchecked
            {
                _newEntry.WriteByte((byte)toAdd);
                _newEntry.WriteByte((byte)(toAdd >> 8));
            }
        }

        /// <summary>
        /// Add an integer value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeInt(int toAdd)
        {
            unchecked
            {
                AddLeShort((short)toAdd);
                AddLeShort((short)(toAdd >> 16));
            }
        }

        /// <summary>
        /// Add a long value in little endian order to the pending new entry.
        /// </summary>
        /// <param name="toAdd">The data to add.</param>
        /// <seealso cref="StartNewEntry"/>
        public void AddLeLong(long toAdd)
        {
            unchecked
            {
                AddLeInt((int)(toAdd & 0xffffffff));
                AddLeInt((int)(toAdd >> 32));
            }
        }

        /// <summary>
        /// Delete an extra data field.
        /// </summary>
        /// <param name="headerID">The identifier of the field to delete.</param>
        /// <returns>Returns true if the field was found and deleted.</returns>
        public bool Delete(int headerID)
        {
            bool result = false;

            if (Find(headerID))
            {
                result = true;
                int trueStart = _readValueStart - 4;

                byte[] newData = new byte[_data.Length - (ValueLength + 4)];
                Array.Copy(_data, 0, newData, 0, trueStart);

                int trueEnd = trueStart + ValueLength + 4;
                Array.Copy(_data, trueEnd, newData, trueStart, _data.Length - trueEnd);
                _data = newData;
            }
            return result;
        }

        #region Reading Support
        /// <summary>
        /// Read a long in little endian form from the last <see cref="Find">found</see> data value
        /// </summary>
        /// <returns>Returns the long value read.</returns>
        public long ReadLong()
        {
            ReadCheck(8);
            return (ReadInt() & 0xffffffff) | (((long)ReadInt()) << 32);
        }

        /// <summary>
        /// Read an integer in little endian form from the last <see cref="Find">found</see> data value.
        /// </summary>
        /// <returns>Returns the integer read.</returns>
        public int ReadInt()
        {
            ReadCheck(4);

            int result = _data[_index] + (_data[_index + 1] << 8) +
                (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
            _index += 4;
            return result;
        }

        /// <summary>
        /// Read a short value in little endian form from the last <see cref="Find">found</see> data value.
        /// </summary>
        /// <returns>Returns the short value read.</returns>
        public int ReadShort()
        {
            ReadCheck(2);
            int result = _data[_index] + (_data[_index + 1] << 8);
            _index += 2;
            return result;
        }

        /// <summary>
        /// Read a byte from an extra data
        /// </summary>
        /// <returns>The byte value read or -1 if the end of data has been reached.</returns>
        public int ReadByte()
        {
            int result = -1;
            if ((_index < _data.Length) && (_readValueStart + _readValueLength > _index))
            {
                result = _data[_index];
                _index += 1;
            }
            return result;
        }

        /// <summary>
        /// Skip data during reading.
        /// </summary>
        /// <param name="amount">The number of bytes to skip.</param>
        public void Skip(int amount)
        {
            ReadCheck(amount);
            _index += amount;
        }

        void ReadCheck(int length)
        {
            if ((_readValueStart > _data.Length) ||
                (_readValueStart < 4))
            {
                throw new ZipException("Find must be called before calling a Read method");
            }

            if (_index > _readValueStart + _readValueLength - length)
            {
                throw new ZipException("End of extra data");
            }

            if (_index + length < 4)
            {
                throw new ZipException("Cannot read before start of tag");
            }
        }

        /// <summary>
        /// Internal form of <see cref="ReadShort"/> that reads data at any location.
        /// </summary>
        /// <returns>Returns the short value read.</returns>
        int ReadShortInternal()
        {
            if (_index > _data.Length - 2)
            {
                throw new ZipException("End of extra data");
            }

            int result = _data[_index] + (_data[_index + 1] << 8);
            _index += 2;
            return result;
        }

        void SetShort(ref int index, int source)
        {
            _data[index] = (byte)source;
            _data[index + 1] = (byte)(source >> 8);
            index += 2;
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Dispose of this instance.
        /// </summary>
        public void Dispose()
        {
            if (_newEntry != null)
            {
                _newEntry.Close();
            }
        }

        #endregion

        #region Instance Fields
        int _index;
        int _readValueStart;
        int _readValueLength;

        MemoryStream _newEntry;
        byte[] _data;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Globalization;

#if !NETCF_1_0
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    using ICSharpCode.SharpZipLib.Core;
    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    #region Keys Required Event Args
    /// <summary>
    /// Arguments used with KeysRequiredEvent
    /// </summary>
    public class KeysRequiredEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="KeysRequiredEventArgs"></see>
        /// </summary>
        /// <param name="name">The name of the file for which keys are required.</param>
        public KeysRequiredEventArgs(string name)
        {
            fileName = name;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="KeysRequiredEventArgs"></see>
        /// </summary>
        /// <param name="name">The name of the file for which keys are required.</param>
        /// <param name="keyValue">The current key value.</param>
        public KeysRequiredEventArgs(string name, byte[] keyValue)
        {
            fileName = name;
            key = keyValue;
        }

        #endregion
        #region Properties
        /// <summary>
        /// Gets the name of the file for which keys are required.
        /// </summary>
        public string FileName
        {
            get { return fileName; }
        }

        /// <summary>
        /// Gets or sets the key value
        /// </summary>
        public byte[] Key
        {
            get { return key; }
            set { key = value; }
        }
        #endregion

        #region Instance Fields
        string fileName;
        byte[] key;
        #endregion
    }
    #endregion

    #region Test Definitions
    /// <summary>
    /// The strategy to apply to testing.
    /// </summary>
    public enum TestStrategy
    {
        /// <summary>
        /// Find the first error only.
        /// </summary>
        FindFirstError,
        /// <summary>
        /// Find all possible errors.
        /// </summary>
        FindAllErrors,
    }

    /// <summary>
    /// The operation in progress reported by a <see cref="ZipTestResultHandler"/> during testing.
    /// </summary>
    /// <seealso cref="ZipFile.TestArchive(bool)">TestArchive</seealso>
    public enum TestOperation
    {
        /// <summary>
        /// Setting up testing.
        /// </summary>
        Initialising,

        /// <summary>
        /// Testing an individual entries header
        /// </summary>
        EntryHeader,

        /// <summary>
        /// Testing an individual entries data
        /// </summary>
        EntryData,

        /// <summary>
        /// Testing an individual entry has completed.
        /// </summary>
        EntryComplete,

        /// <summary>
        /// Running miscellaneous tests
        /// </summary>
        MiscellaneousTests,

        /// <summary>
        /// Testing is complete
        /// </summary>
        Complete,
    }

    /// <summary>
    /// Status returned returned by <see cref="ZipTestResultHandler"/> during testing.
    /// </summary>
    /// <seealso cref="ZipFile.TestArchive(bool)">TestArchive</seealso>
    public class TestStatus
    {
        #region Constructors
        /// <summary>
        /// Initialise a new instance of <see cref="TestStatus"/>
        /// </summary>
        /// <param name="file">The <see cref="ZipFile"/> this status applies to.</param>
        public TestStatus(ZipFile file)
        {
            file_ = file;
        }
        #endregion

        #region Properties

        /// <summary>
        /// Get the current <see cref="TestOperation"/> in progress.
        /// </summary>
        public TestOperation Operation
        {
            get { return operation_; }
        }

        /// <summary>
        /// Get the <see cref="ZipFile"/> this status is applicable to.
        /// </summary>
        public ZipFile File
        {
            get { return file_; }
        }

        /// <summary>
        /// Get the current/last entry tested.
        /// </summary>
        public ZipEntry Entry
        {
            get { return entry_; }
        }

        /// <summary>
        /// Get the number of errors detected so far.
        /// </summary>
        public int ErrorCount
        {
            get { return errorCount_; }
        }

        /// <summary>
        /// Get the number of bytes tested so far for the current entry.
        /// </summary>
        public long BytesTested
        {
            get { return bytesTested_; }
        }

        /// <summary>
        /// Get a value indicating wether the last entry test was valid.
        /// </summary>
        public bool EntryValid
        {
            get { return entryValid_; }
        }
        #endregion

        #region Internal API
        internal void AddError()
        {
            errorCount_++;
            entryValid_ = false;
        }

        internal void SetOperation(TestOperation operation)
        {
            operation_ = operation;
        }

        internal void SetEntry(ZipEntry entry)
        {
            entry_ = entry;
            entryValid_ = true;
            bytesTested_ = 0;
        }

        internal void SetBytesTested(long value)
        {
            bytesTested_ = value;
        }
        #endregion

        #region Instance Fields
        ZipFile file_;
        ZipEntry entry_;
        bool entryValid_;
        int errorCount_;
        long bytesTested_;
        TestOperation operation_;
        #endregion
    }

    /// <summary>
    /// Delegate invoked during <see cref="ZipFile.TestArchive(bool, TestStrategy, ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
    /// </summary>
    /// <remarks>If the message is non-null an error has occured.  If the message is null
    /// the operation as found in <see cref="TestStatus">status</see> has started.</remarks>
    public delegate void ZipTestResultHandler(TestStatus status, string message);
    #endregion

    #region Update Definitions
    /// <summary>
    /// The possible ways of <see cref="ZipFile.CommitUpdate()">applying updates</see> to an archive.
    /// </summary>
    public enum FileUpdateMode
    {
        /// <summary>
        /// Perform all updates on temporary files ensuring that the original file is saved.
        /// </summary>
        Safe,
        /// <summary>
        /// Update the archive directly, which is faster but less safe.
        /// </summary>
        Direct,
    }
    #endregion

    #region ZipFile Class
    /// <summary>
    /// This class represents a Zip archive.  You can ask for the contained
    /// entries, or get an input stream for a file entry.  The entry is
    /// automatically decompressed.
    /// 
    /// You can also update the archive adding or deleting entries.
    /// 
    /// This class is thread safe for input:  You can open input streams for arbitrary
    /// entries in different threads.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// <example>
    /// <code>
    /// using System;
    /// using System.Text;
    /// using System.Collections;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	static public void Main(string[] args)
    /// 	{
    /// 		using (ZipFile zFile = new ZipFile(args[0])) {
    /// 			Console.WriteLine("Listing of : " + zFile.Name);
    /// 			Console.WriteLine("");
    /// 			Console.WriteLine("Raw Size    Size      Date     Time     Name");
    /// 			Console.WriteLine("--------  --------  --------  ------  ---------");
    /// 			foreach (ZipEntry e in zFile) {
    /// 				if ( e.IsFile ) {
    /// 					DateTime d = e.DateTime;
    /// 					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
    /// 						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
    /// 						e.Name);
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }
    /// </code>
    /// </example>
    public class ZipFile : IEnumerable, IDisposable
    {
        #region KeyHandling

        /// <summary>
        /// Delegate for handling keys/password setting during compresion/decompression.
        /// </summary>
        public delegate void KeysRequiredEventHandler(
            object sender,
            KeysRequiredEventArgs e
        );

        /// <summary>
        /// Event handler for handling encryption keys.
        /// </summary>
        public KeysRequiredEventHandler KeysRequired;

        /// <summary>
        /// Handles getting of encryption keys when required.
        /// </summary>
        /// <param name="fileName">The file for which encryption keys are required.</param>
        void OnKeysRequired(string fileName)
        {
            if (KeysRequired != null)
            {
                KeysRequiredEventArgs krea = new KeysRequiredEventArgs(fileName, key);
                KeysRequired(this, krea);
                key = krea.Key;
            }
        }

        /// <summary>
        /// Get/set the encryption key value.
        /// </summary>
        byte[] Key
        {
            get { return key; }
            set { key = value; }
        }

#if !NETCF_1_0
        /// <summary>
        /// Password to be used for encrypting/decrypting files.
        /// </summary>
        /// <remarks>Set to null if no password is required.</remarks>
        public string Password
        {
            set
            {
                if ((value == null) || (value.Length == 0))
                {
                    key = null;
                }
                else
                {
                    rawPassword_ = value;
                    key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(value));
                }
            }
        }
#endif

        /// <summary>
        /// Get a value indicating wether encryption keys are currently available.
        /// </summary>
        bool HaveKeys
        {
            get { return key != null; }
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Opens a Zip file with the given name for reading.
        /// </summary>
        /// <param name="name">The name of the file to open.</param>
        /// <exception cref="ArgumentNullException">The argument supplied is null.</exception>
        /// <exception cref="IOException">
        /// An i/o error occurs
        /// </exception>
        /// <exception cref="ZipException">
        /// The file doesn't contain a valid zip archive.
        /// </exception>
        public ZipFile(string name)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            name_ = name;

            baseStream_ = File.Open(name, FileMode.Open, FileAccess.Read, FileShare.Read);
            isStreamOwner = true;

            try
            {
                ReadEntries();
            }
            catch
            {
                DisposeInternal(true);
                throw;
            }
        }

        /// <summary>
        /// Opens a Zip file reading the given <see cref="FileStream"/>.
        /// </summary>
        /// <param name="file">The <see cref="FileStream"/> to read archive data from.</param>
        /// <exception cref="ArgumentNullException">The supplied argument is null.</exception>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="ZipException">
        /// The file doesn't contain a valid zip archive.
        /// </exception>
        public ZipFile(FileStream file)
        {
            if (file == null)
            {
                throw new ArgumentNullException("file");
            }

            if (!file.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "file");
            }

            baseStream_ = file;
            name_ = file.Name;
            isStreamOwner = true;

            try
            {
                ReadEntries();
            }
            catch
            {
                DisposeInternal(true);
                throw;
            }
        }

        /// <summary>
        /// Opens a Zip file reading the given <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to read archive data from.</param>
        /// <exception cref="IOException">
        /// An i/o error occurs
        /// </exception>
        /// <exception cref="ZipException">
        /// The stream doesn't contain a valid zip archive.<br/>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The <see cref="Stream">stream</see> doesnt support seeking.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// The <see cref="Stream">stream</see> argument is null.
        /// </exception>
        public ZipFile(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (!stream.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "stream");
            }

            baseStream_ = stream;
            isStreamOwner = true;

            if (baseStream_.Length > 0)
            {
                try
                {
                    ReadEntries();
                }
                catch
                {
                    DisposeInternal(true);
                    throw;
                }
            }
            else
            {
                entries_ = new ZipEntry[0];
                isNewArchive_ = true;
            }
        }

        /// <summary>
        /// Initialises a default <see cref="ZipFile"/> instance with no entries and no file storage.
        /// </summary>
        internal ZipFile()
        {
            entries_ = new ZipEntry[0];
            isNewArchive_ = true;
        }

        #endregion

        #region Destructors and Closing
        /// <summary>
        /// Finalize this instance.
        /// </summary>
        ~ZipFile()
        {
            Dispose(false);
        }

        /// <summary>
        /// Closes the ZipFile.  If the stream is <see cref="IsStreamOwner">owned</see> then this also closes the underlying input stream.
        /// Once closed, no further instance methods should be called.
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An i/o error occurs.
        /// </exception>
        public void Close()
        {
            DisposeInternal(true);
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Creators
        /// <summary>
        /// Create a new <see cref="ZipFile"/> whose data will be stored in a file.
        /// </summary>
        /// <param name="fileName">The name of the archive to create.</param>
        /// <returns>Returns the newly created <see cref="ZipFile"/></returns>
        /// <exception cref="ArgumentNullException"><paramref name="fileName"></paramref> is null</exception>
        public static ZipFile Create(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            FileStream fs = File.Create(fileName);

            ZipFile result = new ZipFile();
            result.name_ = fileName;
            result.baseStream_ = fs;
            result.isStreamOwner = true;
            return result;
        }

        /// <summary>
        /// Create a new <see cref="ZipFile"/> whose data will be stored on a stream.
        /// </summary>
        /// <param name="outStream">The stream providing data storage.</param>
        /// <returns>Returns the newly created <see cref="ZipFile"/></returns>
        /// <exception cref="ArgumentNullException"><paramref name="outStream"> is null</paramref></exception>
        /// <exception cref="ArgumentException"><paramref name="outStream"> doesnt support writing.</paramref></exception>
        public static ZipFile Create(Stream outStream)
        {
            if (outStream == null)
            {
                throw new ArgumentNullException("outStream");
            }

            if (!outStream.CanWrite)
            {
                throw new ArgumentException("Stream is not writeable", "outStream");
            }

            if (!outStream.CanSeek)
            {
                throw new ArgumentException("Stream is not seekable", "outStream");
            }

            ZipFile result = new ZipFile();
            result.baseStream_ = outStream;
            return result;
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
        /// If the flag is true then the stream will be closed when <see cref="Close">Close</see> is called.
        /// </summary>
        /// <remarks>
        /// The default value is true in all cases.
        /// </remarks>
        public bool IsStreamOwner
        {
            get { return isStreamOwner; }
            set { isStreamOwner = value; }
        }

        /// <summary>
        /// Get a value indicating wether
        /// this archive is embedded in another file or not.
        /// </summary>
        public bool IsEmbeddedArchive
        {
            // Not strictly correct in all circumstances currently
            get { return offsetOfFirstEntry > 0; }
        }

        /// <summary>
        /// Get a value indicating that this archive is a new one.
        /// </summary>
        public bool IsNewArchive
        {
            get { return isNewArchive_; }
        }

        /// <summary>
        /// Gets the comment for the zip file.
        /// </summary>
        public string ZipFileComment
        {
            get { return comment_; }
        }

        /// <summary>
        /// Gets the name of this zip file.
        /// </summary>
        public string Name
        {
            get { return name_; }
        }

        /// <summary>
        /// Gets the number of entries in this zip file.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The Zip file has been closed.
        /// </exception>
        [Obsolete("Use the Count property instead")]
        public int Size
        {
            get
            {
                return entries_.Length;
            }
        }

        /// <summary>
        /// Get the number of entries contained in this <see cref="ZipFile"/>.
        /// </summary>
        public long Count
        {
            get
            {
                return entries_.Length;
            }
        }

        /// <summary>
        /// Indexer property for ZipEntries
        /// </summary>
        [System.Runtime.CompilerServices.IndexerNameAttribute("EntryByIndex")]
        public ZipEntry this[int index]
        {
            get
            {
                return (ZipEntry)entries_[index].Clone();
            }
        }

        #endregion

        #region Input Handling
        /// <summary>
        /// Gets an enumerator for the Zip entries in this Zip file.
        /// </summary>
        /// <returns>Returns an <see cref="IEnumerator"/> for this archive.</returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public IEnumerator GetEnumerator()
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            return new ZipEntryEnumerator(entries_);
        }

        /// <summary>
        /// Return the index of the entry with a matching name
        /// </summary>
        /// <param name="name">Entry name to find</param>
        /// <param name="ignoreCase">If true the comparison is case insensitive</param>
        /// <returns>The index position of the matching entry or -1 if not found</returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public int FindEntry(string name, bool ignoreCase)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            // TODO: This will be slow as the next ice age for huge archives!
            for (int i = 0; i < entries_.Length; i++)
            {
                if (string.Compare(name, entries_[i].Name, ignoreCase, CultureInfo.InvariantCulture) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Searches for a zip entry in this archive with the given name.
        /// String comparisons are case insensitive
        /// </summary>
        /// <param name="name">
        /// The name to find. May contain directory components separated by slashes ('/').
        /// </param>
        /// <returns>
        /// A clone of the zip entry, or null if no entry with that name exists.
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// The Zip file has been closed.
        /// </exception>
        public ZipEntry GetEntry(string name)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            int index = FindEntry(name, true);
            return (index >= 0) ? (ZipEntry)entries_[index].Clone() : null;
        }

        /// <summary>
        /// Gets an input stream for reading the given zip entry data in an uncompressed form.
        /// Normally the <see cref="ZipEntry"/> should be an entry returned by GetEntry().
        /// </summary>
        /// <param name="entry">The <see cref="ZipEntry"/> to obtain a data <see cref="Stream"/> for</param>
        /// <returns>An input <see cref="Stream"/> containing data for this <see cref="ZipEntry"/></returns>
        /// <exception cref="ObjectDisposedException">
        /// The ZipFile has already been closed
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The compression method for the entry is unknown
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// The entry is not found in the ZipFile
        /// </exception>
        public Stream GetInputStream(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            long index = entry.ZipFileIndex;
            if ((index < 0) || (index >= entries_.Length) || (entries_[index].Name != entry.Name))
            {
                index = FindEntry(entry.Name, true);
                if (index < 0)
                {
                    throw new ZipException("Entry cannot be found");
                }
            }
            return GetInputStream(index);
        }

        /// <summary>
        /// Creates an input stream reading a zip entry
        /// </summary>
        /// <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
        /// <returns>
        /// An input <see cref="Stream"/> containing data for this <paramref name="entryIndex"/>
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// The ZipFile has already been closed
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The compression method for the entry is unknown
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// The entry is not found in the ZipFile
        /// </exception>
        public Stream GetInputStream(long entryIndex)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            long start = LocateEntry(entries_[entryIndex]);
            CompressionMethod method = entries_[entryIndex].CompressionMethod;
            Stream result = new PartialInputStream(this, start, entries_[entryIndex].CompressedSize);

            if (entries_[entryIndex].IsCrypted == true)
            {
#if NETCF_1_0
				throw new ZipException("decryption not supported for Compact Framework 1.0");
#else
                result = CreateAndInitDecryptionStream(result, entries_[entryIndex]);
                if (result == null)
                {
                    throw new ZipException("Unable to decrypt this entry");
                }
#endif
            }

            switch (method)
            {
                case CompressionMethod.Stored:
                    // read as is.
                    break;

                case CompressionMethod.Deflated:
                    // No need to worry about ownership and closing as underlying stream close does nothing.
                    result = new InflaterInputStream(result, new Inflater(true));
                    break;

                default:
                    throw new ZipException("Unsupported compression method " + method);
            }

            return result;
        }

        #endregion

        #region Archive Testing
        /// <summary>
        /// Test an archive for integrity/validity
        /// </summary>
        /// <param name="testData">Perform low level data Crc check</param>
        /// <returns>true if all tests pass, false otherwise</returns>
        /// <remarks>Testing will terminate on the first error found.</remarks>
        public bool TestArchive(bool testData)
        {
            return TestArchive(testData, TestStrategy.FindFirstError, null);
        }

        /// <summary>
        /// Test an archive for integrity/validity
        /// </summary>
        /// <param name="testData">Perform low level data Crc check</param>
        /// <param name="strategy">The <see cref="TestStrategy"></see> to apply.</param>
        /// <param name="resultHandler">The <see cref="ZipTestResultHandler"></see> handler to call during testing.</param>
        /// <returns>true if all tests pass, false otherwise</returns>
        /// <exception cref="ObjectDisposedException">The object has already been closed.</exception>
        public bool TestArchive(bool testData, TestStrategy strategy, ZipTestResultHandler resultHandler)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            TestStatus status = new TestStatus(this);

            if (resultHandler != null)
            {
                resultHandler(status, null);
            }

            HeaderTest test = testData ? (HeaderTest.Header | HeaderTest.Extract) : HeaderTest.Header;

            bool testing = true;

            try
            {
                int entryIndex = 0;

                while (testing && (entryIndex < Count))
                {
                    if (resultHandler != null)
                    {
                        status.SetEntry(this[entryIndex]);
                        status.SetOperation(TestOperation.EntryHeader);
                        resultHandler(status, null);
                    }

                    try
                    {
                        TestLocalHeader(this[entryIndex], test);
                    }
                    catch (ZipException ex)
                    {
                        status.AddError();

                        if (resultHandler != null)
                        {
                            resultHandler(status,
                                string.Format("Exception during test - '{0}'", ex.Message));
                        }

                        if (strategy == TestStrategy.FindFirstError)
                        {
                            testing = false;
                        }
                    }

                    if (testing && testData && this[entryIndex].IsFile)
                    {
                        if (resultHandler != null)
                        {
                            status.SetOperation(TestOperation.EntryData);
                            resultHandler(status, null);
                        }

                        Crc32 crc = new Crc32();

                        using (Stream entryStream = this.GetInputStream(this[entryIndex]))
                        {

                            byte[] buffer = new byte[4096];
                            long totalBytes = 0;
                            int bytesRead;
                            while ((bytesRead = entryStream.Read(buffer, 0, buffer.Length)) > 0)
                            {
                                crc.Update(buffer, 0, bytesRead);

                                if (resultHandler != null)
                                {
                                    totalBytes += bytesRead;
                                    status.SetBytesTested(totalBytes);
                                    resultHandler(status, null);
                                }
                            }
                        }

                        if (this[entryIndex].Crc != crc.Value)
                        {
                            status.AddError();

                            if (resultHandler != null)
                            {
                                resultHandler(status, "CRC mismatch");
                            }

                            if (strategy == TestStrategy.FindFirstError)
                            {
                                testing = false;
                            }
                        }

                        if ((this[entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0)
                        {
                            ZipHelperStream helper = new ZipHelperStream(baseStream_);
                            DescriptorData data = new DescriptorData();
                            helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64, data);
                            if (this[entryIndex].Crc != data.Crc)
                            {
                                status.AddError();
                            }

                            if (this[entryIndex].CompressedSize != data.CompressedSize)
                            {
                                status.AddError();
                            }

                            if (this[entryIndex].Size != data.Size)
                            {
                                status.AddError();
                            }
                        }
                    }

                    if (resultHandler != null)
                    {
                        status.SetOperation(TestOperation.EntryComplete);
                        resultHandler(status, null);
                    }

                    entryIndex += 1;
                }

                if (resultHandler != null)
                {
                    status.SetOperation(TestOperation.MiscellaneousTests);
                    resultHandler(status, null);
                }

                // TODO: the 'Corrina Johns' test where local headers are missing from
                // the central directory.  They are therefore invisible to many archivers.
            }
            catch (Exception ex)
            {
                status.AddError();

                if (resultHandler != null)
                {
                    resultHandler(status, string.Format("Exception during test - '{0}'", ex.Message));
                }
            }

            if (resultHandler != null)
            {
                status.SetOperation(TestOperation.Complete);
                status.SetEntry(null);
                resultHandler(status, null);
            }

            return (status.ErrorCount == 0);
        }

        [Flags]
        enum HeaderTest
        {
            Extract = 0x01,     // Check that this header represents an entry whose data can be extracted
            Header = 0x02,     // Check that this header contents are valid
        }

        /// <summary>
        /// Test a local header against that provided from the central directory
        /// </summary>
        /// <param name="entry">
        /// The entry to test against
        /// </param>
        /// <param name="tests">The type of <see cref="HeaderTest">tests</see> to carry out.</param>
        /// <returns>The offset of the entries data in the file</returns>
        long TestLocalHeader(ZipEntry entry, HeaderTest tests)
        {
            lock (baseStream_)
            {
                bool testHeader = (tests & HeaderTest.Header) != 0;
                bool testData = (tests & HeaderTest.Extract) != 0;

                baseStream_.Seek(offsetOfFirstEntry + entry.Offset, SeekOrigin.Begin);
                if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature)
                {
                    throw new ZipException(string.Format("Wrong local header signature @{0:X}", offsetOfFirstEntry + entry.Offset));
                }

                short extractVersion = (short)ReadLEUshort();
                short localFlags = (short)ReadLEUshort();
                short compressionMethod = (short)ReadLEUshort();
                short fileTime = (short)ReadLEUshort();
                short fileDate = (short)ReadLEUshort();
                uint crcValue = ReadLEUint();
                long compressedSize = ReadLEUint();
                long size = ReadLEUint();
                int storedNameLength = ReadLEUshort();
                int extraDataLength = ReadLEUshort();

                byte[] nameData = new byte[storedNameLength];
                StreamUtils.ReadFully(baseStream_, nameData);

                byte[] extraData = new byte[extraDataLength];
                StreamUtils.ReadFully(baseStream_, extraData);

                ZipExtraData localExtraData = new ZipExtraData(extraData);

                // Extra data / zip64 checks
                if (localExtraData.Find(1))
                {
                    // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64
                    // and size or compressedSize = MaxValue, due to rogue creators.

                    size = localExtraData.ReadLong();
                    compressedSize = localExtraData.ReadLong();

                    if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0)
                    {
                        // These may be valid if patched later
                        if ((size != -1) && (size != entry.Size))
                        {
                            throw new ZipException("Size invalid for descriptor");
                        }

                        if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))
                        {
                            throw new ZipException("Compressed size invalid for descriptor");
                        }
                    }
                }
                else
                {
                    // No zip64 extra data but entry requires it.
                    if ((extractVersion >= ZipConstants.VersionZip64) &&
                        (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))
                    {
                        throw new ZipException("Required Zip64 extended information missing");
                    }
                }

                if (testData)
                {
                    if (entry.IsFile)
                    {
                        if (!entry.IsCompressionMethodSupported())
                        {
                            throw new ZipException("Compression method not supported");
                        }

                        if ((extractVersion > ZipConstants.VersionMadeBy)
                            || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))
                        {
                            throw new ZipException(string.Format("Version required to extract this entry not supported ({0})", extractVersion));
                        }

                        if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)
                        {
                            throw new ZipException("The library does not support the zip version required to extract this entry");
                        }
                    }
                }

                if (testHeader)
                {
                    if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..
                        (extractVersion != 10) &&
                        (extractVersion != 11) &&
                        (extractVersion != 20) &&
                        (extractVersion != 21) &&
                        (extractVersion != 25) &&
                        (extractVersion != 27) &&
                        (extractVersion != 45) &&
                        (extractVersion != 46) &&
                        (extractVersion != 50) &&
                        (extractVersion != 51) &&
                        (extractVersion != 52) &&
                        (extractVersion != 61) &&
                        (extractVersion != 62) &&
                        (extractVersion != 63)
                        )
                    {
                        throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})", extractVersion));
                    }

                    // Local entry flags dont have reserved bit set on.
                    if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0)
                    {
                        throw new ZipException("Reserved bit flags cannot be set.");
                    }

                    // Encryption requires extract version >= 20
                    if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))
                    {
                        throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", extractVersion));
                    }

                    // Strong encryption requires encryption flag to be set and extract version >= 50.
                    if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0)
                    {
                        if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0)
                        {
                            throw new ZipException("Strong encryption flag set but encryption flag is not set");
                        }

                        if (extractVersion < 50)
                        {
                            throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", extractVersion));
                        }
                    }

                    // Patched entries require extract version >= 27
                    if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27))
                    {
                        throw new ZipException(string.Format("Patched data requires higher version than ({0})", extractVersion));
                    }

                    // Central header flags match local entry flags.
                    if (localFlags != entry.Flags)
                    {
                        throw new ZipException("Central header/local header flags mismatch");
                    }

                    // Central header compression method matches local entry
                    if (entry.CompressionMethod != (CompressionMethod)compressionMethod)
                    {
                        throw new ZipException("Central header/local header compression method mismatch");
                    }

                    if (entry.Version != extractVersion)
                    {
                        throw new ZipException("Extract version mismatch");
                    }

                    // Strong encryption and extract version match
                    if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0)
                    {
                        if (extractVersion < 62)
                        {
                            throw new ZipException("Strong encryption flag set but version not high enough");
                        }
                    }

                    if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0)
                    {
                        if ((fileTime != 0) || (fileDate != 0))
                        {
                            throw new ZipException("Header masked set but date/time values non-zero");
                        }
                    }

                    if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0)
                    {
                        if (crcValue != (uint)entry.Crc)
                        {
                            throw new ZipException("Central header/local header crc mismatch");
                        }
                    }

                    // Crc valid for empty entry.
                    // This will also apply to streamed entries where size isnt known and the header cant be patched
                    if ((size == 0) && (compressedSize == 0))
                    {
                        if (crcValue != 0)
                        {
                            throw new ZipException("Invalid CRC for empty entry");
                        }
                    }

                    // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings
                    // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably
                    if (entry.Name.Length > storedNameLength)
                    {
                        throw new ZipException("File name length mismatch");
                    }

                    // Name data has already been read convert it and compare.
                    string localName = ZipConstants.ConvertToStringExt(localFlags, nameData);

                    // Central directory and local entry name match
                    if (localName != entry.Name)
                    {
                        throw new ZipException("Central header and local header file name mismatch");
                    }

                    // Directories have zero actual size but can have compressed size
                    if (entry.IsDirectory)
                    {
                        if (size > 0)
                        {
                            throw new ZipException("Directory cannot have size");
                        }

                        // There may be other cases where the compressed size can be greater than this?
                        // If so until details are known we will be strict.
                        if (entry.IsCrypted)
                        {
                            if (compressedSize > ZipConstants.CryptoHeaderSize + 2)
                            {
                                throw new ZipException("Directory compressed size invalid");
                            }
                        }
                        else if (compressedSize > 2)
                        {
                            // When not compressed the directory size can validly be 2 bytes
                            // if the true size wasnt known when data was originally being written.
                            // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes
                            throw new ZipException("Directory compressed size invalid");
                        }
                    }

                    if (!ZipNameTransform.IsValidName(localName, true))
                    {
                        throw new ZipException("Name is invalid");
                    }
                }

                // Tests that apply to both data and header.

                // Size can be verified only if it is known in the local header.
                // it will always be known in the central header.
                if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||
                    ((size > 0) || (compressedSize > 0)))
                {

                    if (size != entry.Size)
                    {
                        throw new ZipException(
                            string.Format("Size mismatch between central header({0}) and local header({1})",
                                entry.Size, size));
                    }

                    if (compressedSize != entry.CompressedSize &&
                        compressedSize != 0xFFFFFFFF && compressedSize != -1)
                    {
                        throw new ZipException(
                            string.Format("Compressed size mismatch between central header({0}) and local header({1})",
                            entry.CompressedSize, compressedSize));
                    }
                }

                int extraLength = storedNameLength + extraDataLength;
                return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;
            }
        }

        #endregion

        #region Updating

        const int DefaultBufferSize = 4096;

        /// <summary>
        /// The kind of update to apply.
        /// </summary>
        enum UpdateCommand
        {
            Copy,       // Copy original file contents.
            Modify,     // Change encryption, compression, attributes, name, time etc, of an existing file.
            Add,        // Add a new file to the archive.
        }

        #region Properties
        /// <summary>
        /// Get / set the <see cref="INameTransform"/> to apply to names when updating.
        /// </summary>
        public INameTransform NameTransform
        {
            get
            {
                return updateEntryFactory_.NameTransform;
            }

            set
            {
                updateEntryFactory_.NameTransform = value;
            }
        }

        /// <summary>
        /// Get/set the <see cref="IEntryFactory"/> used to generate <see cref="ZipEntry"/> values
        /// during updates.
        /// </summary>
        public IEntryFactory EntryFactory
        {
            get
            {
                return updateEntryFactory_;
            }

            set
            {
                if (value == null)
                {
                    updateEntryFactory_ = new ZipEntryFactory();
                }
                else
                {
                    updateEntryFactory_ = value;
                }
            }
        }

        /// <summary>
        /// Get /set the buffer size to be used when updating this zip file.
        /// </summary>
        public int BufferSize
        {
            get { return bufferSize_; }
            set
            {
                if (value < 1024)
                {
#if NETCF_1_0					
					throw new ArgumentOutOfRangeException("value");
#else
                    throw new ArgumentOutOfRangeException("value", "cannot be below 1024");
#endif
                }

                if (bufferSize_ != value)
                {
                    bufferSize_ = value;
                    copyBuffer_ = null;
                }
            }
        }

        /// <summary>
        /// Get a value indicating an update has <see cref="BeginUpdate()">been started</see>.
        /// </summary>
        public bool IsUpdating
        {
            get { return updates_ != null; }
        }

        /// <summary>
        /// Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
        /// </summary>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        #endregion

        #region Immediate updating
        //		TBD: Direct form of updating
        // 
        //		public void Update(IEntryMatcher deleteMatcher)
        //		{
        //		}
        //
        //		public void Update(IScanner addScanner)
        //		{
        //		}
        #endregion

        #region Deferred Updating
        /// <summary>
        /// Begin updating this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <param name="archiveStorage">The <see cref="IArchiveStorage">archive storage</see> for use during the update.</param>
        /// <param name="dataSource">The <see cref="IDynamicDataSource">data source</see> to utilise during updating.</param>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentNullException">One of the arguments provided is null</exception>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void BeginUpdate(IArchiveStorage archiveStorage, IDynamicDataSource dataSource)
        {
            if (archiveStorage == null)
            {
                throw new ArgumentNullException("archiveStorage");
            }

            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            if (IsEmbeddedArchive)
            {
                throw new ZipException("Cannot update embedded/SFX archives");
            }

            archiveStorage_ = archiveStorage;
            updateDataSource_ = dataSource;

            // NOTE: the baseStream_ may not currently support writing or seeking.

            updateIndex_ = new Hashtable();

            updates_ = new ArrayList(entries_.Length);
            foreach (ZipEntry entry in entries_)
            {
                int index = updates_.Add(new ZipUpdate(entry));
                updateIndex_.Add(entry.Name, index);
            }

            // We must sort by offset before using offset's calculated sizes
            updates_.Sort(new UpdateComparer());

            int idx = 0;
            foreach (ZipUpdate update in updates_)
            {
                //If last entry, there is no next entry offset to use
                if (idx == updates_.Count - 1)
                    break;

                update.OffsetBasedSize = ((ZipUpdate)updates_[idx + 1]).Entry.Offset - update.Entry.Offset;
                idx++;
            }
            updateCount_ = updates_.Count;

            contentsEdited_ = false;
            commentEdited_ = false;
            newComment_ = null;
        }

        /// <summary>
        /// Begin updating to this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <param name="archiveStorage">The storage to use during the update.</param>
        public void BeginUpdate(IArchiveStorage archiveStorage)
        {
            BeginUpdate(archiveStorage, new DynamicDiskDataSource());
        }

        /// <summary>
        /// Begin updating this <see cref="ZipFile"/> archive.
        /// </summary>
        /// <seealso cref="BeginUpdate(IArchiveStorage)"/>
        /// <seealso cref="CommitUpdate"></seealso>
        /// <seealso cref="AbortUpdate"></seealso>
        public void BeginUpdate()
        {
            if (Name == null)
            {
                BeginUpdate(new MemoryArchiveStorage(), new DynamicDiskDataSource());
            }
            else
            {
                BeginUpdate(new DiskArchiveStorage(this), new DynamicDiskDataSource());
            }
        }

        /// <summary>
        /// Commit current updates, updating this archive.
        /// </summary>
        /// <seealso cref="BeginUpdate()"></seealso>
        /// <seealso cref="AbortUpdate"></seealso>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void CommitUpdate()
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            CheckUpdating();

            try
            {
                updateIndex_.Clear();
                updateIndex_ = null;

                if (contentsEdited_)
                {
                    RunUpdates();
                }
                else if (commentEdited_)
                {
                    UpdateCommentOnly();
                }
                else
                {
                    // Create an empty archive if none existed originally.
                    if (entries_.Length == 0)
                    {
                        byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipConstants.ConvertToArray(comment_);
                        using (ZipHelperStream zhs = new ZipHelperStream(baseStream_))
                        {
                            zhs.WriteEndOfCentralDirectory(0, 0, 0, theComment);
                        }
                    }
                }

            }
            finally
            {
                PostUpdateCleanup();
            }
        }

        /// <summary>
        /// Abort updating leaving the archive unchanged.
        /// </summary>
        /// <seealso cref="BeginUpdate()"></seealso>
        /// <seealso cref="CommitUpdate"></seealso>
        public void AbortUpdate()
        {
            PostUpdateCleanup();
        }

        /// <summary>
        /// Set the file comment to be recorded when the current update is <see cref="CommitUpdate">commited</see>.
        /// </summary>
        /// <param name="comment">The comment to record.</param>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        public void SetComment(string comment)
        {
            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            CheckUpdating();

            newComment_ = new ZipString(comment);

            if (newComment_.RawLength > 0xffff)
            {
                newComment_ = null;
                throw new ZipException("Comment length exceeds maximum - 65535");
            }

            // We dont take account of the original and current comment appearing to be the same
            // as encoding may be different.
            commentEdited_ = true;
        }

        #endregion

        #region Adding Entries

        void AddUpdate(ZipUpdate update)
        {
            contentsEdited_ = true;

            int index = FindExistingUpdate(update.Entry.Name);

            if (index >= 0)
            {
                if (updates_[index] == null)
                {
                    updateCount_ += 1;
                }

                // Direct replacement is faster than delete and add.
                updates_[index] = update;
            }
            else
            {
                index = updates_.Add(update);
                updateCount_ += 1;
                updateIndex_.Add(update.Entry.Name, index);
            }
        }

        /// <summary>
        /// Add a new entry to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <param name="useUnicodeText">Ensure Unicode text is used for name and comment for this entry.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        /// <exception cref="ObjectDisposedException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Compression method is not supported.</exception>
        public void Add(string fileName, CompressionMethod compressionMethod, bool useUnicodeText)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (isDisposed_)
            {
                throw new ObjectDisposedException("ZipFile");
            }

            if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
            {
                throw new ArgumentOutOfRangeException("compressionMethod");
            }

            CheckUpdating();
            contentsEdited_ = true;

            ZipEntry entry = EntryFactory.MakeFileEntry(fileName);
            entry.IsUnicodeText = useUnicodeText;
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(fileName, entry));
        }

        /// <summary>
        /// Add a new entry to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <exception cref="ArgumentNullException">ZipFile has been closed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">The compression method is not supported.</exception>
        public void Add(string fileName, CompressionMethod compressionMethod)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
            {
                throw new ArgumentOutOfRangeException("compressionMethod");
            }

            CheckUpdating();
            contentsEdited_ = true;

            ZipEntry entry = EntryFactory.MakeFileEntry(fileName);
            entry.CompressionMethod = compressionMethod;
            AddUpdate(new ZipUpdate(fileName, entry));
        }

        /// <summary>
        /// Add a file to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        public void Add(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(fileName, EntryFactory.MakeFileEntry(fileName)));
        }

        /// <summary>
        /// Add a file to the archive.
        /// </summary>
        /// <param name="fileName">The name of the file to add.</param>
        /// <param name="entryName">The name to use for the <see cref="ZipEntry"/> on the Zip file created.</param>
        /// <exception cref="ArgumentNullException">Argument supplied is null.</exception>
        public void Add(string fileName, string entryName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(fileName, EntryFactory.MakeFileEntry(entryName)));
        }


        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        public void Add(IStaticDataSource dataSource, string entryName)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();
            AddUpdate(new ZipUpdate(dataSource, EntryFactory.MakeFileEntry(entryName, false)));
        }

        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();

            ZipEntry entry = EntryFactory.MakeFileEntry(entryName, false);
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(dataSource, entry));
        }

        /// <summary>
        /// Add a file entry with data.
        /// </summary>
        /// <param name="dataSource">The source of the data for this entry.</param>
        /// <param name="entryName">The name to give to the entry.</param>
        /// <param name="compressionMethod">The compression method to use.</param>
        /// <param name="useUnicodeText">Ensure Unicode text is used for name and comments for this entry.</param>
        public void Add(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod, bool useUnicodeText)
        {
            if (dataSource == null)
            {
                throw new ArgumentNullException("dataSource");
            }

            if (entryName == null)
            {
                throw new ArgumentNullException("entryName");
            }

            CheckUpdating();

            ZipEntry entry = EntryFactory.MakeFileEntry(entryName, false);
            entry.IsUnicodeText = useUnicodeText;
            entry.CompressionMethod = compressionMethod;

            AddUpdate(new ZipUpdate(dataSource, entry));
        }

        /// <summary>
        /// Add a <see cref="ZipEntry"/> that contains no data.
        /// </summary>
        /// <param name="entry">The entry to add.</param>
        /// <remarks>This can be used to add directories, volume labels, or empty file entries.</remarks>
        public void Add(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            CheckUpdating();

            if ((entry.Size != 0) || (entry.CompressedSize != 0))
            {
                throw new ZipException("Entry cannot have any data");
            }

            AddUpdate(new ZipUpdate(UpdateCommand.Add, entry));
        }

        /// <summary>
        /// Add a directory entry to the archive.
        /// </summary>
        /// <param name="directoryName">The directory to add.</param>
        public void AddDirectory(string directoryName)
        {
            if (directoryName == null)
            {
                throw new ArgumentNullException("directoryName");
            }

            CheckUpdating();

            ZipEntry dirEntry = EntryFactory.MakeDirectoryEntry(directoryName);
            AddUpdate(new ZipUpdate(UpdateCommand.Add, dirEntry));
        }

        #endregion

        #region Modifying Entries
        /* Modify not yet ready for public consumption.
   Direct modification of an entry should not overwrite original data before its read.
   Safe mode is trivial in this sense.
		public void Modify(ZipEntry original, ZipEntry updated)
		{
			if ( original == null ) {
				throw new ArgumentNullException("original");
			}

			if ( updated == null ) {
				throw new ArgumentNullException("updated");
			}

			CheckUpdating();
			contentsEdited_ = true;
			updates_.Add(new ZipUpdate(original, updated));
		}
*/
        #endregion

        #region Deleting Entries
        /// <summary>
        /// Delete an entry by name
        /// </summary>
        /// <param name="fileName">The filename to delete</param>
        /// <returns>True if the entry was found and deleted; false otherwise.</returns>
        public bool Delete(string fileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            CheckUpdating();

            bool result = false;
            int index = FindExistingUpdate(fileName);
            if ((index >= 0) && (updates_[index] != null))
            {
                result = true;
                contentsEdited_ = true;
                updates_[index] = null;
                updateCount_ -= 1;
            }
            else
            {
                throw new ZipException("Cannot find entry to delete");
            }
            return result;
        }

        /// <summary>
        /// Delete a <see cref="ZipEntry"/> from the archive.
        /// </summary>
        /// <param name="entry">The entry to delete.</param>
        public void Delete(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            CheckUpdating();

            int index = FindExistingUpdate(entry);
            if (index >= 0)
            {
                contentsEdited_ = true;
                updates_[index] = null;
                updateCount_ -= 1;
            }
            else
            {
                throw new ZipException("Cannot find entry to delete");
            }
        }

        #endregion

        #region Update Support

        #region Writing Values/Headers
        void WriteLEShort(int value)
        {
            baseStream_.WriteByte((byte)(value & 0xff));
            baseStream_.WriteByte((byte)((value >> 8) & 0xff));
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        void WriteLEUshort(ushort value)
        {
            baseStream_.WriteByte((byte)(value & 0xff));
            baseStream_.WriteByte((byte)(value >> 8));
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        void WriteLEInt(int value)
        {
            WriteLEShort(value & 0xffff);
            WriteLEShort(value >> 16);
        }

        /// <summary>
        /// Write an unsigned int in little endian byte order.
        /// </summary>
        void WriteLEUint(uint value)
        {
            WriteLEUshort((ushort)(value & 0xffff));
            WriteLEUshort((ushort)(value >> 16));
        }

        /// <summary>
        /// Write a long in little endian byte order.
        /// </summary>
        void WriteLeLong(long value)
        {
            WriteLEInt((int)(value & 0xffffffff));
            WriteLEInt((int)(value >> 32));
        }

        void WriteLEUlong(ulong value)
        {
            WriteLEUint((uint)(value & 0xffffffff));
            WriteLEUint((uint)(value >> 32));
        }

        void WriteLocalEntryHeader(ZipUpdate update)
        {
            ZipEntry entry = update.OutEntry;

            // TODO: Local offset will require adjusting for multi-disk zip files.
            entry.Offset = baseStream_.Position;

            // TODO: Need to clear any entry flags that dont make sense or throw an exception here.
            if (update.Command != UpdateCommand.Copy)
            {
                if (entry.CompressionMethod == CompressionMethod.Deflated)
                {
                    if (entry.Size == 0)
                    {
                        // No need to compress - no data.
                        entry.CompressedSize = entry.Size;
                        entry.Crc = 0;
                        entry.CompressionMethod = CompressionMethod.Stored;
                    }
                }
                else if (entry.CompressionMethod == CompressionMethod.Stored)
                {
                    entry.Flags &= ~(int)GeneralBitFlags.Descriptor;
                }

                if (HaveKeys)
                {
                    entry.IsCrypted = true;
                    if (entry.Crc < 0)
                    {
                        entry.Flags |= (int)GeneralBitFlags.Descriptor;
                    }
                }
                else
                {
                    entry.IsCrypted = false;
                }

                switch (useZip64_)
                {
                    case UseZip64.Dynamic:
                        if (entry.Size < 0)
                        {
                            entry.ForceZip64();
                        }
                        break;

                    case UseZip64.On:
                        entry.ForceZip64();
                        break;

                    case UseZip64.Off:
                        // Do nothing.  The entry itself may be using Zip64 independantly.
                        break;
                }
            }

            // Write the local file header
            WriteLEInt(ZipConstants.LocalHeaderSignature);

            WriteLEShort(entry.Version);
            WriteLEShort(entry.Flags);

            WriteLEShort((byte)entry.CompressionMethod);
            WriteLEInt((int)entry.DosTime);

            if (!entry.HasCrc)
            {
                // Note patch address for updating CRC later.
                update.CrcPatchOffset = baseStream_.Position;
                WriteLEInt((int)0);
            }
            else
            {
                WriteLEInt(unchecked((int)entry.Crc));
            }

            if (entry.LocalHeaderRequiresZip64)
            {
                WriteLEInt(-1);
                WriteLEInt(-1);
            }
            else
            {
                if ((entry.CompressedSize < 0) || (entry.Size < 0))
                {
                    update.SizePatchOffset = baseStream_.Position;
                }

                WriteLEInt((int)entry.CompressedSize);
                WriteLEInt((int)entry.Size);
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64)
            {
                ed.StartNewEntry();

                // Local entry header always includes size and compressed size.
                // NOTE the order of these fields is reversed when compared to the normal headers!
                ed.AddLeLong(entry.Size);
                ed.AddLeLong(entry.CompressedSize);
                ed.AddNewEntry(1);
            }
            else
            {
                ed.Delete(1);
            }

            entry.ExtraData = ed.GetEntryData();

            WriteLEShort(name.Length);
            WriteLEShort(entry.ExtraData.Length);

            if (name.Length > 0)
            {
                baseStream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64)
            {
                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cannot find extra data");
                }

                update.SizePatchOffset = baseStream_.Position + ed.CurrentReadIndex;
            }

            if (entry.ExtraData.Length > 0)
            {
                baseStream_.Write(entry.ExtraData, 0, entry.ExtraData.Length);
            }
        }

        int WriteCentralDirectoryHeader(ZipEntry entry)
        {
            if (entry.CompressedSize < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown csize");
            }

            if (entry.Size < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown size");
            }

            if (entry.Crc < 0)
            {
                throw new ZipException("Attempt to write central directory entry with unknown crc");
            }

            // Write the central file header
            WriteLEInt(ZipConstants.CentralHeaderSignature);

            // Version made by
            WriteLEShort(ZipConstants.VersionMadeBy);

            // Version required to extract
            WriteLEShort(entry.Version);

            WriteLEShort(entry.Flags);

            unchecked
            {
                WriteLEShort((byte)entry.CompressionMethod);
                WriteLEInt((int)entry.DosTime);
                WriteLEInt((int)entry.Crc);
            }

            if ((entry.IsZip64Forced()) || (entry.CompressedSize >= 0xffffffff))
            {
                WriteLEInt(-1);
            }
            else
            {
                WriteLEInt((int)(entry.CompressedSize & 0xffffffff));
            }

            if ((entry.IsZip64Forced()) || (entry.Size >= 0xffffffff))
            {
                WriteLEInt(-1);
            }
            else
            {
                WriteLEInt((int)entry.Size);
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name is too long.");
            }

            WriteLEShort(name.Length);

            // Central header extra data is different to local header version so regenerate.
            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.CentralHeaderRequiresZip64)
            {
                ed.StartNewEntry();

                if ((entry.Size >= 0xffffffff) || (useZip64_ == UseZip64.On))
                {
                    ed.AddLeLong(entry.Size);
                }

                if ((entry.CompressedSize >= 0xffffffff) || (useZip64_ == UseZip64.On))
                {
                    ed.AddLeLong(entry.CompressedSize);
                }

                if (entry.Offset >= 0xffffffff)
                {
                    ed.AddLeLong(entry.Offset);
                }

                // Number of disk on which this file starts isnt supported and is never written here.
                ed.AddNewEntry(1);
            }
            else
            {
                // Should have already be done when local header was added.
                ed.Delete(1);
            }

            byte[] centralExtraData = ed.GetEntryData();

            WriteLEShort(centralExtraData.Length);
            WriteLEShort(entry.Comment != null ? entry.Comment.Length : 0);

            WriteLEShort(0);	// disk number
            WriteLEShort(0);	// internal file attributes

            // External file attributes...
            if (entry.ExternalFileAttributes != -1)
            {
                WriteLEInt(entry.ExternalFileAttributes);
            }
            else
            {
                if (entry.IsDirectory)
                {
                    WriteLEUint(16);
                }
                else
                {
                    WriteLEUint(0);
                }
            }

            if (entry.Offset >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);
            }
            else
            {
                WriteLEUint((uint)(int)entry.Offset);
            }

            if (name.Length > 0)
            {
                baseStream_.Write(name, 0, name.Length);
            }

            if (centralExtraData.Length > 0)
            {
                baseStream_.Write(centralExtraData, 0, centralExtraData.Length);
            }

            byte[] rawComment = (entry.Comment != null) ? Encoding.ASCII.GetBytes(entry.Comment) : new byte[0];

            if (rawComment.Length > 0)
            {
                baseStream_.Write(rawComment, 0, rawComment.Length);
            }

            return ZipConstants.CentralHeaderBaseSize + name.Length + centralExtraData.Length + rawComment.Length;
        }
        #endregion

        void PostUpdateCleanup()
        {
            updateDataSource_ = null;
            updates_ = null;
            updateIndex_ = null;

            if (archiveStorage_ != null)
            {
                archiveStorage_.Dispose();
                archiveStorage_ = null;
            }
        }

        string GetTransformedFileName(string name)
        {
            INameTransform transform = NameTransform;
            return (transform != null) ?
                transform.TransformFile(name) :
                name;
        }

        string GetTransformedDirectoryName(string name)
        {
            INameTransform transform = NameTransform;
            return (transform != null) ?
                transform.TransformDirectory(name) :
                name;
        }

        /// <summary>
        /// Get a raw memory buffer.
        /// </summary>
        /// <returns>Returns a raw memory buffer.</returns>
        byte[] GetBuffer()
        {
            if (copyBuffer_ == null)
            {
                copyBuffer_ = new byte[bufferSize_];
            }
            return copyBuffer_;
        }

        void CopyDescriptorBytes(ZipUpdate update, Stream dest, Stream source)
        {
            int bytesToCopy = GetDescriptorSize(update);

            if (bytesToCopy > 0)
            {
                byte[] buffer = GetBuffer();

                while (bytesToCopy > 0)
                {
                    int readSize = Math.Min(buffer.Length, bytesToCopy);

                    int bytesRead = source.Read(buffer, 0, readSize);
                    if (bytesRead > 0)
                    {
                        dest.Write(buffer, 0, bytesRead);
                        bytesToCopy -= bytesRead;
                    }
                    else
                    {
                        throw new ZipException("Unxpected end of stream");
                    }
                }
            }
        }

        void CopyBytes(ZipUpdate update, Stream destination, Stream source,
            long bytesToCopy, bool updateCrc)
        {
            if (destination == source)
            {
                throw new InvalidOperationException("Destination and source are the same");
            }

            // NOTE: Compressed size is updated elsewhere.
            Crc32 crc = new Crc32();
            byte[] buffer = GetBuffer();

            long targetBytes = bytesToCopy;
            long totalBytesRead = 0;

            int bytesRead;
            do
            {
                int readSize = buffer.Length;

                if (bytesToCopy < readSize)
                {
                    readSize = (int)bytesToCopy;
                }

                bytesRead = source.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    if (updateCrc)
                    {
                        crc.Update(buffer, 0, bytesRead);
                    }
                    destination.Write(buffer, 0, bytesRead);
                    bytesToCopy -= bytesRead;
                    totalBytesRead += bytesRead;
                }
            }
            while ((bytesRead > 0) && (bytesToCopy > 0));

            if (totalBytesRead != targetBytes)
            {
                throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", targetBytes, totalBytesRead));
            }

            if (updateCrc)
            {
                update.OutEntry.Crc = crc.Value;
            }
        }

        /// <summary>
        /// Get the size of the source descriptor for a <see cref="ZipUpdate"/>.
        /// </summary>
        /// <param name="update">The update to get the size for.</param>
        /// <returns>The descriptor size, zero if there isnt one.</returns>
        int GetDescriptorSize(ZipUpdate update)
        {
            int result = 0;
            if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)
            {
                result = ZipConstants.DataDescriptorSize - 4;
                if (update.Entry.LocalHeaderRequiresZip64)
                {
                    result = ZipConstants.Zip64DataDescriptorSize - 4;
                }
            }
            return result;
        }

        void CopyDescriptorBytesDirect(ZipUpdate update, Stream stream, ref long destinationPosition, long sourcePosition)
        {
            int bytesToCopy = GetDescriptorSize(update);

            while (bytesToCopy > 0)
            {
                int readSize = (int)bytesToCopy;
                byte[] buffer = GetBuffer();

                stream.Position = sourcePosition;
                int bytesRead = stream.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    stream.Position = destinationPosition;
                    stream.Write(buffer, 0, bytesRead);
                    bytesToCopy -= bytesRead;
                    destinationPosition += bytesRead;
                    sourcePosition += bytesRead;
                }
                else
                {
                    throw new ZipException("Unxpected end of stream");
                }
            }
        }

        void CopyEntryDataDirect(ZipUpdate update, Stream stream, bool updateCrc, ref long destinationPosition, ref long sourcePosition)
        {
            long bytesToCopy = update.Entry.CompressedSize;

            // NOTE: Compressed size is updated elsewhere.
            Crc32 crc = new Crc32();
            byte[] buffer = GetBuffer();

            long targetBytes = bytesToCopy;
            long totalBytesRead = 0;

            int bytesRead;
            do
            {
                int readSize = buffer.Length;

                if (bytesToCopy < readSize)
                {
                    readSize = (int)bytesToCopy;
                }

                stream.Position = sourcePosition;
                bytesRead = stream.Read(buffer, 0, readSize);
                if (bytesRead > 0)
                {
                    if (updateCrc)
                    {
                        crc.Update(buffer, 0, bytesRead);
                    }
                    stream.Position = destinationPosition;
                    stream.Write(buffer, 0, bytesRead);

                    destinationPosition += bytesRead;
                    sourcePosition += bytesRead;
                    bytesToCopy -= bytesRead;
                    totalBytesRead += bytesRead;
                }
            }
            while ((bytesRead > 0) && (bytesToCopy > 0));

            if (totalBytesRead != targetBytes)
            {
                throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", targetBytes, totalBytesRead));
            }

            if (updateCrc)
            {
                update.OutEntry.Crc = crc.Value;
            }
        }

        int FindExistingUpdate(ZipEntry entry)
        {
            int result = -1;
            string convertedName = GetTransformedFileName(entry.Name);

            if (updateIndex_.ContainsKey(convertedName))
            {
                result = (int)updateIndex_[convertedName];
            }
            /*
                        // This is slow like the coming of the next ice age but takes less storage and may be useful
                        // for CF?
                        for (int index = 0; index < updates_.Count; ++index)
                        {
                            ZipUpdate zu = ( ZipUpdate )updates_[index];
                            if ( (zu.Entry.ZipFileIndex == entry.ZipFileIndex) &&
                                (string.Compare(convertedName, zu.Entry.Name, true, CultureInfo.InvariantCulture) == 0) ) {
                                result = index;
                                break;
                            }
                        }
             */
            return result;
        }

        int FindExistingUpdate(string fileName)
        {
            int result = -1;

            string convertedName = GetTransformedFileName(fileName);

            if (updateIndex_.ContainsKey(convertedName))
            {
                result = (int)updateIndex_[convertedName];
            }

            /*
                        // This is slow like the coming of the next ice age but takes less storage and may be useful
                        // for CF?
                        for ( int index = 0; index < updates_.Count; ++index ) {
                            if ( string.Compare(convertedName, (( ZipUpdate )updates_[index]).Entry.Name,
                                true, CultureInfo.InvariantCulture) == 0 ) {
                                result = index;
                                break;
                            }
                        }
             */

            return result;
        }

        /// <summary>
        /// Get an output stream for the specified <see cref="ZipEntry"/>
        /// </summary>
        /// <param name="entry">The entry to get an output stream for.</param>
        /// <returns>The output stream obtained for the entry.</returns>
        Stream GetOutputStream(ZipEntry entry)
        {
            Stream result = baseStream_;

            if (entry.IsCrypted == true)
            {
#if NETCF_1_0
				throw new ZipException("Encryption not supported for Compact Framework 1.0");
#else
                result = CreateAndInitEncryptionStream(result, entry);
#endif
            }

            switch (entry.CompressionMethod)
            {
                case CompressionMethod.Stored:
                    result = new UncompressedStream(result);
                    break;

                case CompressionMethod.Deflated:
                    DeflaterOutputStream dos = new DeflaterOutputStream(result, new Deflater(9, true));
                    dos.IsStreamOwner = false;
                    result = dos;
                    break;

                default:
                    throw new ZipException("Unknown compression method " + entry.CompressionMethod);
            }
            return result;
        }

        void AddEntry(ZipFile workFile, ZipUpdate update)
        {
            Stream source = null;

            if (update.Entry.IsFile)
            {
                source = update.GetSource();

                if (source == null)
                {
                    source = updateDataSource_.GetSource(update.Entry, update.Filename);
                }
            }

            if (source != null)
            {
                using (source)
                {
                    long sourceStreamLength = source.Length;
                    if (update.OutEntry.Size < 0)
                    {
                        update.OutEntry.Size = sourceStreamLength;
                    }
                    else
                    {
                        // Check for errant entries.
                        if (update.OutEntry.Size != sourceStreamLength)
                        {
                            throw new ZipException("Entry size/stream size mismatch");
                        }
                    }

                    workFile.WriteLocalEntryHeader(update);

                    long dataStart = workFile.baseStream_.Position;

                    using (Stream output = workFile.GetOutputStream(update.OutEntry))
                    {
                        CopyBytes(update, output, source, sourceStreamLength, true);
                    }

                    long dataEnd = workFile.baseStream_.Position;
                    update.OutEntry.CompressedSize = dataEnd - dataStart;

                    if ((update.OutEntry.Flags & (int)GeneralBitFlags.Descriptor) == (int)GeneralBitFlags.Descriptor)
                    {
                        ZipHelperStream helper = new ZipHelperStream(workFile.baseStream_);
                        helper.WriteDataDescriptor(update.OutEntry);
                    }
                }
            }
            else
            {
                workFile.WriteLocalEntryHeader(update);
                update.OutEntry.CompressedSize = 0;
            }

        }

        void ModifyEntry(ZipFile workFile, ZipUpdate update)
        {
            workFile.WriteLocalEntryHeader(update);
            long dataStart = workFile.baseStream_.Position;

            // TODO: This is slow if the changes don't effect the data!!
            if (update.Entry.IsFile && (update.Filename != null))
            {
                using (Stream output = workFile.GetOutputStream(update.OutEntry))
                {
                    using (Stream source = this.GetInputStream(update.Entry))
                    {
                        CopyBytes(update, output, source, source.Length, true);
                    }
                }
            }

            long dataEnd = workFile.baseStream_.Position;
            update.Entry.CompressedSize = dataEnd - dataStart;
        }

        void CopyEntryDirect(ZipFile workFile, ZipUpdate update, ref long destinationPosition)
        {
            bool skipOver = false;
            if (update.Entry.Offset == destinationPosition)
            {
                skipOver = true;
            }

            if (!skipOver)
            {
                baseStream_.Position = destinationPosition;
                workFile.WriteLocalEntryHeader(update);
                destinationPosition = baseStream_.Position;
            }

            long sourcePosition = 0;

            const int NameLengthOffset = 26;

            // TODO: Add base for SFX friendly handling
            long entryDataOffset = update.Entry.Offset + NameLengthOffset;

            baseStream_.Seek(entryDataOffset, SeekOrigin.Begin);

            // Clumsy way of handling retrieving the original name and extra data length for now.
            // TODO: Stop re-reading name and data length in CopyEntryDirect.
            uint nameLength = ReadLEUshort();
            uint extraLength = ReadLEUshort();

            sourcePosition = baseStream_.Position + nameLength + extraLength;

            if (skipOver)
            {
                if (update.OffsetBasedSize != -1)
                    destinationPosition += update.OffsetBasedSize;
                else
                    // TODO: Find out why this calculation comes up 4 bytes short on some entries in ODT (Office Document Text) archives.
                    // WinZip produces a warning on these entries:
                    // "caution: value of lrec.csize (compressed size) changed from ..."
                    destinationPosition +=
                        (sourcePosition - entryDataOffset) + NameLengthOffset +	// Header size
                        update.Entry.CompressedSize + GetDescriptorSize(update);
            }
            else
            {
                if (update.Entry.CompressedSize > 0)
                {
                    CopyEntryDataDirect(update, baseStream_, false, ref destinationPosition, ref sourcePosition);
                }
                CopyDescriptorBytesDirect(update, baseStream_, ref destinationPosition, sourcePosition);
            }
        }

        void CopyEntry(ZipFile workFile, ZipUpdate update)
        {
            workFile.WriteLocalEntryHeader(update);

            if (update.Entry.CompressedSize > 0)
            {
                const int NameLengthOffset = 26;

                long entryDataOffset = update.Entry.Offset + NameLengthOffset;

                // TODO: This wont work for SFX files!
                baseStream_.Seek(entryDataOffset, SeekOrigin.Begin);

                uint nameLength = ReadLEUshort();
                uint extraLength = ReadLEUshort();

                baseStream_.Seek(nameLength + extraLength, SeekOrigin.Current);

                CopyBytes(update, workFile.baseStream_, baseStream_, update.Entry.CompressedSize, false);
            }
            CopyDescriptorBytes(update, workFile.baseStream_, baseStream_);
        }

        void Reopen(Stream source)
        {
            if (source == null)
            {
                throw new ZipException("Failed to reopen archive - no source");
            }

            isNewArchive_ = false;
            baseStream_ = source;
            ReadEntries();
        }

        void Reopen()
        {
            if (Name == null)
            {
                throw new InvalidOperationException("Name is not known cannot Reopen");
            }

            Reopen(File.Open(Name, FileMode.Open, FileAccess.Read, FileShare.Read));
        }

        void UpdateCommentOnly()
        {
            long baseLength = baseStream_.Length;

            ZipHelperStream updateFile = null;

            if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)
            {
                Stream copyStream = archiveStorage_.MakeTemporaryCopy(baseStream_);
                updateFile = new ZipHelperStream(copyStream);
                updateFile.IsStreamOwner = true;

                baseStream_.Close();
                baseStream_ = null;
            }
            else
            {
                if (archiveStorage_.UpdateMode == FileUpdateMode.Direct)
                {
                    // TODO: archiveStorage wasnt originally intended for this use.
                    // Need to revisit this to tidy up handling as archive storage currently doesnt 
                    // handle the original stream well.
                    // The problem is when using an existing zip archive with an in memory archive storage.
                    // The open stream wont support writing but the memory storage should open the same file not an in memory one.

                    // Need to tidy up the archive storage interface and contract basically.
                    baseStream_ = archiveStorage_.OpenForDirectUpdate(baseStream_);
                    updateFile = new ZipHelperStream(baseStream_);
                }
                else
                {
                    baseStream_.Close();
                    baseStream_ = null;
                    updateFile = new ZipHelperStream(Name);
                }
            }

            using (updateFile)
            {
                long locatedCentralDirOffset =
                    updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature,
                                                        baseLength, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);
                if (locatedCentralDirOffset < 0)
                {
                    throw new ZipException("Cannot find central directory");
                }

                const int CentralHeaderCommentSizeOffset = 16;
                updateFile.Position += CentralHeaderCommentSizeOffset;

                byte[] rawComment = newComment_.RawComment;

                updateFile.WriteLEShort(rawComment.Length);
                updateFile.Write(rawComment, 0, rawComment.Length);
                updateFile.SetLength(updateFile.Position);
            }

            if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)
            {
                Reopen(archiveStorage_.ConvertTemporaryToFinal());
            }
            else
            {
                ReadEntries();
            }
        }

        /// <summary>
        /// Class used to sort updates.
        /// </summary>
        class UpdateComparer : IComparer
        {
            /// <summary>
            /// Compares two objects and returns a value indicating whether one is 
            /// less than, equal to or greater than the other.
            /// </summary>
            /// <param name="x">First object to compare</param>
            /// <param name="y">Second object to compare.</param>
            /// <returns>Compare result.</returns>
            public int Compare(
                object x,
                object y)
            {
                ZipUpdate zx = x as ZipUpdate;
                ZipUpdate zy = y as ZipUpdate;

                int result;

                if (zx == null)
                {
                    if (zy == null)
                    {
                        result = 0;
                    }
                    else
                    {
                        result = -1;
                    }
                }
                else if (zy == null)
                {
                    result = 1;
                }
                else
                {
                    int xCmdValue = ((zx.Command == UpdateCommand.Copy) || (zx.Command == UpdateCommand.Modify)) ? 0 : 1;
                    int yCmdValue = ((zy.Command == UpdateCommand.Copy) || (zy.Command == UpdateCommand.Modify)) ? 0 : 1;

                    result = xCmdValue - yCmdValue;
                    if (result == 0)
                    {
                        long offsetDiff = zx.Entry.Offset - zy.Entry.Offset;
                        if (offsetDiff < 0)
                        {
                            result = -1;
                        }
                        else if (offsetDiff == 0)
                        {
                            result = 0;
                        }
                        else
                        {
                            result = 1;
                        }
                    }
                }
                return result;
            }
        }

        void RunUpdates()
        {
            long sizeEntries = 0;
            long endOfStream = 0;
            bool directUpdate = false;
            long destinationPosition = 0; // NOT SFX friendly

            ZipFile workFile;

            if (IsNewArchive)
            {
                workFile = this;
                workFile.baseStream_.Position = 0;
                directUpdate = true;
            }
            else if (archiveStorage_.UpdateMode == FileUpdateMode.Direct)
            {
                workFile = this;
                workFile.baseStream_.Position = 0;
                directUpdate = true;

                // Sort the updates by offset within copies/modifies, then adds.
                // This ensures that data required by copies will not be overwritten.
                updates_.Sort(new UpdateComparer());
            }
            else
            {
                workFile = ZipFile.Create(archiveStorage_.GetTemporaryOutput());
                workFile.UseZip64 = UseZip64;

                if (key != null)
                {
                    workFile.key = (byte[])key.Clone();
                }
            }

            try
            {
                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        switch (update.Command)
                        {
                            case UpdateCommand.Copy:
                                if (directUpdate)
                                {
                                    CopyEntryDirect(workFile, update, ref destinationPosition);
                                }
                                else
                                {
                                    CopyEntry(workFile, update);
                                }
                                break;

                            case UpdateCommand.Modify:
                                // TODO: Direct modifying of an entry will take some legwork.
                                ModifyEntry(workFile, update);
                                break;

                            case UpdateCommand.Add:
                                if (!IsNewArchive && directUpdate)
                                {
                                    workFile.baseStream_.Position = destinationPosition;
                                }

                                AddEntry(workFile, update);

                                if (directUpdate)
                                {
                                    destinationPosition = workFile.baseStream_.Position;
                                }
                                break;
                        }
                    }
                }

                if (!IsNewArchive && directUpdate)
                {
                    workFile.baseStream_.Position = destinationPosition;
                }

                long centralDirOffset = workFile.baseStream_.Position;

                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        sizeEntries += workFile.WriteCentralDirectoryHeader(update.OutEntry);
                    }
                }

                byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipConstants.ConvertToArray(comment_);
                using (ZipHelperStream zhs = new ZipHelperStream(workFile.baseStream_))
                {
                    zhs.WriteEndOfCentralDirectory(updateCount_, sizeEntries, centralDirOffset, theComment);
                }

                endOfStream = workFile.baseStream_.Position;

                // And now patch entries...
                foreach (ZipUpdate update in updates_)
                {
                    if (update != null)
                    {
                        // If the size of the entry is zero leave the crc as 0 as well.
                        // The calculated crc will be all bits on...
                        if ((update.CrcPatchOffset > 0) && (update.OutEntry.CompressedSize > 0))
                        {
                            workFile.baseStream_.Position = update.CrcPatchOffset;
                            workFile.WriteLEInt((int)update.OutEntry.Crc);
                        }

                        if (update.SizePatchOffset > 0)
                        {
                            workFile.baseStream_.Position = update.SizePatchOffset;
                            if (update.OutEntry.LocalHeaderRequiresZip64)
                            {
                                workFile.WriteLeLong(update.OutEntry.Size);
                                workFile.WriteLeLong(update.OutEntry.CompressedSize);
                            }
                            else
                            {
                                workFile.WriteLEInt((int)update.OutEntry.CompressedSize);
                                workFile.WriteLEInt((int)update.OutEntry.Size);
                            }
                        }
                    }
                }
            }
            catch
            {
                workFile.Close();
                if (!directUpdate && (workFile.Name != null))
                {
                    File.Delete(workFile.Name);
                }
                throw;
            }

            if (directUpdate)
            {
                workFile.baseStream_.SetLength(endOfStream);
                workFile.baseStream_.Flush();
                isNewArchive_ = false;
                ReadEntries();
            }
            else
            {
                baseStream_.Close();
                Reopen(archiveStorage_.ConvertTemporaryToFinal());
            }
        }

        void CheckUpdating()
        {
            if (updates_ == null)
            {
                throw new InvalidOperationException("BeginUpdate has not been called");
            }
        }

        #endregion

        #region ZipUpdate class
        /// <summary>
        /// Represents a pending update to a Zip file.
        /// </summary>
        class ZipUpdate
        {
            #region Constructors
            public ZipUpdate(string fileName, ZipEntry entry)
            {
                command_ = UpdateCommand.Add;
                entry_ = entry;
                filename_ = fileName;
            }

            [Obsolete]
            public ZipUpdate(string fileName, string entryName, CompressionMethod compressionMethod)
            {
                command_ = UpdateCommand.Add;
                entry_ = new ZipEntry(entryName);
                entry_.CompressionMethod = compressionMethod;
                filename_ = fileName;
            }

            [Obsolete]
            public ZipUpdate(string fileName, string entryName)
                : this(fileName, entryName, CompressionMethod.Deflated)
            {
                // Do nothing.
            }

            [Obsolete]
            public ZipUpdate(IStaticDataSource dataSource, string entryName, CompressionMethod compressionMethod)
            {
                command_ = UpdateCommand.Add;
                entry_ = new ZipEntry(entryName);
                entry_.CompressionMethod = compressionMethod;
                dataSource_ = dataSource;
            }

            public ZipUpdate(IStaticDataSource dataSource, ZipEntry entry)
            {
                command_ = UpdateCommand.Add;
                entry_ = entry;
                dataSource_ = dataSource;
            }

            public ZipUpdate(ZipEntry original, ZipEntry updated)
            {
                throw new ZipException("Modify not currently supported");
                /*
                    command_ = UpdateCommand.Modify;
                    entry_ = ( ZipEntry )original.Clone();
                    outEntry_ = ( ZipEntry )updated.Clone();
                */
            }

            public ZipUpdate(UpdateCommand command, ZipEntry entry)
            {
                command_ = command;
                entry_ = (ZipEntry)entry.Clone();
            }


            /// <summary>
            /// Copy an existing entry.
            /// </summary>
            /// <param name="entry">The existing entry to copy.</param>
            public ZipUpdate(ZipEntry entry)
                : this(UpdateCommand.Copy, entry)
            {
                // Do nothing.
            }
            #endregion

            /// <summary>
            /// Get the <see cref="ZipEntry"/> for this update.
            /// </summary>
            /// <remarks>This is the source or original entry.</remarks>
            public ZipEntry Entry
            {
                get { return entry_; }
            }

            /// <summary>
            /// Get the <see cref="ZipEntry"/> that will be written to the updated/new file.
            /// </summary>
            public ZipEntry OutEntry
            {
                get
                {
                    if (outEntry_ == null)
                    {
                        outEntry_ = (ZipEntry)entry_.Clone();
                    }

                    return outEntry_;
                }
            }

            /// <summary>
            /// Get the command for this update.
            /// </summary>
            public UpdateCommand Command
            {
                get { return command_; }
            }

            /// <summary>
            /// Get the filename if any for this update.  Null if none exists.
            /// </summary>
            public string Filename
            {
                get { return filename_; }
            }

            /// <summary>
            /// Get/set the location of the size patch for this update.
            /// </summary>
            public long SizePatchOffset
            {
                get { return sizePatchOffset_; }
                set { sizePatchOffset_ = value; }
            }

            /// <summary>
            /// Get /set the location of the crc patch for this update.
            /// </summary>
            public long CrcPatchOffset
            {
                get { return crcPatchOffset_; }
                set { crcPatchOffset_ = value; }
            }

            /// <summary>
            /// Get/set the size calculated by offset.
            /// Specifically, the difference between this and next entry's starting offset.
            /// </summary>
            public long OffsetBasedSize
            {
                get { return _offsetBasedSize; }
                set { _offsetBasedSize = value; }
            }

            public Stream GetSource()
            {
                Stream result = null;
                if (dataSource_ != null)
                {
                    result = dataSource_.GetSource();
                }

                return result;
            }

            #region Instance Fields
            ZipEntry entry_;
            ZipEntry outEntry_;
            UpdateCommand command_;
            IStaticDataSource dataSource_;
            string filename_;
            long sizePatchOffset_ = -1;
            long crcPatchOffset_ = -1;
            long _offsetBasedSize = -1;
            #endregion
        }

        #endregion
        #endregion

        #region Disposing

        #region IDisposable Members
        void IDisposable.Dispose()
        {
            Close();
        }
        #endregion

        void DisposeInternal(bool disposing)
        {
            if (!isDisposed_)
            {
                isDisposed_ = true;
                entries_ = new ZipEntry[0];

                if (IsStreamOwner && (baseStream_ != null))
                {
                    lock (baseStream_)
                    {
                        baseStream_.Close();
                    }
                }

                PostUpdateCleanup();
            }
        }

        /// <summary>
        /// Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources;
        /// false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            DisposeInternal(disposing);
        }

        #endregion

        #region Internal routines
        #region Reading
        /// <summary>
        /// Read an unsigned short in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="EndOfStreamException">
        /// The stream ends prematurely
        /// </exception>
        ushort ReadLEUshort()
        {
            int data1 = baseStream_.ReadByte();

            if (data1 < 0)
            {
                throw new EndOfStreamException("End of stream");
            }

            int data2 = baseStream_.ReadByte();

            if (data2 < 0)
            {
                throw new EndOfStreamException("End of stream");
            }


            return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));
        }

        /// <summary>
        /// Read a uint in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        uint ReadLEUint()
        {
            return (uint)(ReadLEUshort() | (ReadLEUshort() << 16));
        }

        ulong ReadLEUlong()
        {
            return ReadLEUint() | ((ulong)ReadLEUint() << 32);
        }

        #endregion
        // NOTE this returns the offset of the first byte after the signature.
        long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)
        {
            using (ZipHelperStream les = new ZipHelperStream(baseStream_))
            {
                return les.LocateBlockWithSignature(signature, endLocation, minimumBlockSize, maximumVariableData);
            }
        }

        /// <summary>
        /// Search for and read the central directory of a zip file filling the entries array.
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The central directory is malformed or cannot be found
        /// </exception>
        void ReadEntries()
        {
            // Search for the End Of Central Directory.  When a zip comment is
            // present the directory will start earlier
            // 
            // The search is limited to 64K which is the maximum size of a trailing comment field to aid speed.
            // This should be compatible with both SFX and ZIP files but has only been tested for Zip files
            // If a SFX file has the Zip data attached as a resource and there are other resources occuring later then
            // this could be invalid.
            // Could also speed this up by reading memory in larger blocks.			

            if (baseStream_.CanSeek == false)
            {
                throw new ZipException("ZipFile stream must be seekable");
            }

            long locatedEndOfCentralDir = LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature,
                baseStream_.Length, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);

            if (locatedEndOfCentralDir < 0)
            {
                throw new ZipException("Cannot find central directory");
            }

            // Read end of central directory record
            ushort thisDiskNumber = ReadLEUshort();
            ushort startCentralDirDisk = ReadLEUshort();
            ulong entriesForThisDisk = ReadLEUshort();
            ulong entriesForWholeCentralDir = ReadLEUshort();
            ulong centralDirSize = ReadLEUint();
            long offsetOfCentralDir = ReadLEUint();
            uint commentSize = ReadLEUshort();

            if (commentSize > 0)
            {
                byte[] comment = new byte[commentSize];

                StreamUtils.ReadFully(baseStream_, comment);
                comment_ = ZipConstants.ConvertToString(comment);
            }
            else
            {
                comment_ = string.Empty;
            }

            bool isZip64 = false;

            // Check if zip64 header information is required.
            if ((thisDiskNumber == 0xffff) ||
                (startCentralDirDisk == 0xffff) ||
                (entriesForThisDisk == 0xffff) ||
                (entriesForWholeCentralDir == 0xffff) ||
                (centralDirSize == 0xffffffff) ||
                (offsetOfCentralDir == 0xffffffff))
            {
                isZip64 = true;

                long offset = LocateBlockWithSignature(ZipConstants.Zip64CentralDirLocatorSignature, locatedEndOfCentralDir, 0, 0x1000);
                if (offset < 0)
                {
                    throw new ZipException("Cannot find Zip64 locator");
                }

                // number of the disk with the start of the zip64 end of central directory 4 bytes 
                // relative offset of the zip64 end of central directory record 8 bytes 
                // total number of disks 4 bytes 
                ReadLEUint(); // startDisk64 is not currently used
                ulong offset64 = ReadLEUlong();
                uint totalDisks = ReadLEUint();

                baseStream_.Position = (long)offset64;
                long sig64 = ReadLEUint();

                if (sig64 != ZipConstants.Zip64CentralFileHeaderSignature)
                {
                    throw new ZipException(string.Format("Invalid Zip64 Central directory signature at {0:X}", offset64));
                }

                // NOTE: Record size = SizeOfFixedFields + SizeOfVariableData - 12.
                ulong recordSize = ReadLEUlong();
                int versionMadeBy = ReadLEUshort();
                int versionToExtract = ReadLEUshort();
                uint thisDisk = ReadLEUint();
                uint centralDirDisk = ReadLEUint();
                entriesForThisDisk = ReadLEUlong();
                entriesForWholeCentralDir = ReadLEUlong();
                centralDirSize = ReadLEUlong();
                offsetOfCentralDir = (long)ReadLEUlong();

                // NOTE: zip64 extensible data sector (variable size) is ignored.
            }

            entries_ = new ZipEntry[entriesForThisDisk];

            // SFX/embedded support, find the offset of the first entry vis the start of the stream
            // This applies to Zip files that are appended to the end of an SFX stub.
            // Or are appended as a resource to an executable.
            // Zip files created by some archivers have the offsets altered to reflect the true offsets
            // and so dont require any adjustment here...
            // TODO: Difficulty with Zip64 and SFX offset handling needs resolution - maths?
            if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize)))
            {
                offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);
                if (offsetOfFirstEntry <= 0)
                {
                    throw new ZipException("Invalid embedded zip archive");
                }
            }

            baseStream_.Seek(offsetOfFirstEntry + offsetOfCentralDir, SeekOrigin.Begin);

            for (ulong i = 0; i < entriesForThisDisk; i++)
            {
                if (ReadLEUint() != ZipConstants.CentralHeaderSignature)
                {
                    throw new ZipException("Wrong Central Directory signature");
                }

                int versionMadeBy = ReadLEUshort();
                int versionToExtract = ReadLEUshort();
                int bitFlags = ReadLEUshort();
                int method = ReadLEUshort();
                uint dostime = ReadLEUint();
                uint crc = ReadLEUint();
                long csize = (long)ReadLEUint();
                long size = (long)ReadLEUint();
                int nameLen = ReadLEUshort();
                int extraLen = ReadLEUshort();
                int commentLen = ReadLEUshort();

                int diskStartNo = ReadLEUshort();  // Not currently used
                int internalAttributes = ReadLEUshort();  // Not currently used

                uint externalAttributes = ReadLEUint();
                long offset = ReadLEUint();

                byte[] buffer = new byte[Math.Max(nameLen, commentLen)];

                StreamUtils.ReadFully(baseStream_, buffer, 0, nameLen);
                string name = ZipConstants.ConvertToStringExt(bitFlags, buffer, nameLen);

                ZipEntry entry = new ZipEntry(name, versionToExtract, versionMadeBy, (CompressionMethod)method);
                entry.Crc = crc & 0xffffffffL;
                entry.Size = size & 0xffffffffL;
                entry.CompressedSize = csize & 0xffffffffL;
                entry.Flags = bitFlags;
                entry.DosTime = (uint)dostime;
                entry.ZipFileIndex = (long)i;
                entry.Offset = offset;
                entry.ExternalFileAttributes = (int)externalAttributes;

                if ((bitFlags & 8) == 0)
                {
                    entry.CryptoCheckValue = (byte)(crc >> 24);
                }
                else
                {
                    entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);
                }

                if (extraLen > 0)
                {
                    byte[] extra = new byte[extraLen];
                    StreamUtils.ReadFully(baseStream_, extra);
                    entry.ExtraData = extra;
                }

                entry.ProcessExtraData(false);

                if (commentLen > 0)
                {
                    StreamUtils.ReadFully(baseStream_, buffer, 0, commentLen);
                    entry.Comment = ZipConstants.ConvertToStringExt(bitFlags, buffer, commentLen);
                }

                entries_[i] = entry;
            }
        }

        /// <summary>
        /// Locate the data for a given entry.
        /// </summary>
        /// <returns>
        /// The start offset of the data.
        /// </returns>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The stream ends prematurely
        /// </exception>
        /// <exception cref="ICSharpCode.SharpZipLib.Zip.ZipException">
        /// The local header signature is invalid, the entry and central header file name lengths are different
        /// or the local and entry compression methods dont match
        /// </exception>
        long LocateEntry(ZipEntry entry)
        {
            return TestLocalHeader(entry, HeaderTest.Extract);
        }

#if !NETCF_1_0
        Stream CreateAndInitDecryptionStream(Stream baseStream, ZipEntry entry)
        {
            CryptoStream result = null;

            if ((entry.Version < ZipConstants.VersionStrongEncryption)
                || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0)
            {
                PkzipClassicManaged classicManaged = new PkzipClassicManaged();

                OnKeysRequired(entry.Name);
                if (HaveKeys == false)
                {
                    throw new ZipException("No password available for encrypted stream");
                }

                result = new CryptoStream(baseStream, classicManaged.CreateDecryptor(key, null), CryptoStreamMode.Read);
                CheckClassicPassword(result, entry);
            }
            else
            {
#if !NET_1_1 && !NETCF_2_0
                if (entry.Version == ZipConstants.VERSION_AES)
                {
                    //
                    OnKeysRequired(entry.Name);
                    if (HaveKeys == false)
                    {
                        throw new ZipException("No password available for AES encrypted stream");
                    }
                    int saltLen = entry.AESSaltLen;
                    byte[] saltBytes = new byte[saltLen];
                    int saltIn = baseStream.Read(saltBytes, 0, saltLen);
                    if (saltIn != saltLen)
                        throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);
                    //
                    byte[] pwdVerifyRead = new byte[2];
                    baseStream.Read(pwdVerifyRead, 0, 2);
                    int blockSize = entry.AESKeySize / 8;	// bits to bytes

                    ZipAESTransform decryptor = new ZipAESTransform(rawPassword_, saltBytes, blockSize, false);
                    byte[] pwdVerifyCalc = decryptor.PwdVerifier;
                    if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])
                        throw new Exception("Invalid password for AES");
                    result = new ZipAESStream(baseStream, decryptor, CryptoStreamMode.Read);
                }
                else
#endif
                {
                    throw new ZipException("Decryption method not supported");
                }
            }

            return result;
        }

        Stream CreateAndInitEncryptionStream(Stream baseStream, ZipEntry entry)
        {
            CryptoStream result = null;
            if ((entry.Version < ZipConstants.VersionStrongEncryption)
                || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0)
            {
                PkzipClassicManaged classicManaged = new PkzipClassicManaged();

                OnKeysRequired(entry.Name);
                if (HaveKeys == false)
                {
                    throw new ZipException("No password available for encrypted stream");
                }

                // Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream
                // which doesnt do this.
                result = new CryptoStream(new UncompressedStream(baseStream),
                    classicManaged.CreateEncryptor(key, null), CryptoStreamMode.Write);

                if ((entry.Crc < 0) || (entry.Flags & 8) != 0)
                {
                    WriteEncryptionHeader(result, entry.DosTime << 16);
                }
                else
                {
                    WriteEncryptionHeader(result, entry.Crc);
                }
            }
            return result;
        }

        static void CheckClassicPassword(CryptoStream classicCryptoStream, ZipEntry entry)
        {
            byte[] cryptbuffer = new byte[ZipConstants.CryptoHeaderSize];
            StreamUtils.ReadFully(classicCryptoStream, cryptbuffer);
            if (cryptbuffer[ZipConstants.CryptoHeaderSize - 1] != entry.CryptoCheckValue)
            {
                throw new ZipException("Invalid password");
            }
        }
#endif

        static void WriteEncryptionHeader(Stream stream, long crcValue)
        {
            byte[] cryptBuffer = new byte[ZipConstants.CryptoHeaderSize];
            Random rnd = new Random();
            rnd.NextBytes(cryptBuffer);
            cryptBuffer[11] = (byte)(crcValue >> 24);
            stream.Write(cryptBuffer, 0, cryptBuffer.Length);
        }

        #endregion

        #region Instance Fields
        bool isDisposed_;
        string name_;
        string comment_;
        string rawPassword_;
        Stream baseStream_;
        bool isStreamOwner;
        long offsetOfFirstEntry;
        ZipEntry[] entries_;
        byte[] key;
        bool isNewArchive_;

        // Default is dynamic which is not backwards compatible and can cause problems
        // with XP's built in compression which cant read Zip64 archives.
        // However it does avoid the situation were a large file is added and cannot be completed correctly.
        // Hint: Set always ZipEntry size before they are added to an archive and this setting isnt needed.
        UseZip64 useZip64_ = UseZip64.Dynamic;

        #region Zip Update Instance Fields
        ArrayList updates_;
        long updateCount_; // Count is managed manually as updates_ can contain nulls!
        Hashtable updateIndex_;
        IArchiveStorage archiveStorage_;
        IDynamicDataSource updateDataSource_;
        bool contentsEdited_;
        int bufferSize_ = DefaultBufferSize;
        byte[] copyBuffer_;
        ZipString newComment_;
        bool commentEdited_;
        IEntryFactory updateEntryFactory_ = new ZipEntryFactory();
        #endregion
        #endregion

        #region Support Classes
        /// <summary>
        /// Represents a string from a <see cref="ZipFile"/> which is stored as an array of bytes.
        /// </summary>
        class ZipString
        {
            #region Constructors
            /// <summary>
            /// Initialise a <see cref="ZipString"/> with a string.
            /// </summary>
            /// <param name="comment">The textual string form.</param>
            public ZipString(string comment)
            {
                comment_ = comment;
                isSourceString_ = true;
            }

            /// <summary>
            /// Initialise a <see cref="ZipString"/> using a string in its binary 'raw' form.
            /// </summary>
            /// <param name="rawString"></param>
            public ZipString(byte[] rawString)
            {
                rawComment_ = rawString;
            }
            #endregion

            /// <summary>
            /// Get a value indicating the original source of data for this instance.
            /// True if the source was a string; false if the source was binary data.
            /// </summary>
            public bool IsSourceString
            {
                get { return isSourceString_; }
            }

            /// <summary>
            /// Get the length of the comment when represented as raw bytes.
            /// </summary>
            public int RawLength
            {
                get
                {
                    MakeBytesAvailable();
                    return rawComment_.Length;
                }
            }

            /// <summary>
            /// Get the comment in its 'raw' form as plain bytes.
            /// </summary>
            public byte[] RawComment
            {
                get
                {
                    MakeBytesAvailable();
                    return (byte[])rawComment_.Clone();
                }
            }

            /// <summary>
            /// Reset the comment to its initial state.
            /// </summary>
            public void Reset()
            {
                if (isSourceString_)
                {
                    rawComment_ = null;
                }
                else
                {
                    comment_ = null;
                }
            }

            void MakeTextAvailable()
            {
                if (comment_ == null)
                {
                    comment_ = ZipConstants.ConvertToString(rawComment_);
                }
            }

            void MakeBytesAvailable()
            {
                if (rawComment_ == null)
                {
                    rawComment_ = ZipConstants.ConvertToArray(comment_);
                }
            }

            /// <summary>
            /// Implicit conversion of comment to a string.
            /// </summary>
            /// <param name="zipString">The <see cref="ZipString"/> to convert to a string.</param>
            /// <returns>The textual equivalent for the input value.</returns>
            static public implicit operator string(ZipString zipString)
            {
                zipString.MakeTextAvailable();
                return zipString.comment_;
            }

            #region Instance Fields
            string comment_;
            byte[] rawComment_;
            bool isSourceString_;
            #endregion
        }

        /// <summary>
        /// An <see cref="IEnumerator">enumerator</see> for <see cref="ZipEntry">Zip entries</see>
        /// </summary>
        class ZipEntryEnumerator : IEnumerator
        {
            #region Constructors
            public ZipEntryEnumerator(ZipEntry[] entries)
            {
                array = entries;
            }

            #endregion
            #region IEnumerator Members
            public object Current
            {
                get
                {
                    return array[index];
                }
            }

            public void Reset()
            {
                index = -1;
            }

            public bool MoveNext()
            {
                return (++index < array.Length);
            }
            #endregion
            #region Instance Fields
            ZipEntry[] array;
            int index = -1;
            #endregion
        }

        /// <summary>
        /// An <see cref="UncompressedStream"/> is a stream that you can write uncompressed data
        /// to and flush, but cannot read, seek or do anything else to.
        /// </summary>
        class UncompressedStream : Stream
        {
            #region Constructors
            public UncompressedStream(Stream baseStream)
            {
                baseStream_ = baseStream;
            }

            #endregion

            /// <summary>
            /// Close this stream instance.
            /// </summary>
            public override void Close()
            {
                // Do nothing
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports reading.
            /// </summary>
            public override bool CanRead
            {
                get
                {
                    return false;
                }
            }

            /// <summary>
            /// Write any buffered data to underlying storage.
            /// </summary>
            public override void Flush()
            {
                baseStream_.Flush();
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports writing.
            /// </summary>
            public override bool CanWrite
            {
                get
                {
                    return baseStream_.CanWrite;
                }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports seeking.
            /// </summary>
            public override bool CanSeek
            {
                get
                {
                    return false;
                }
            }

            /// <summary>
            /// Get the length in bytes of the stream.
            /// </summary>
            public override long Length
            {
                get
                {
                    return 0;
                }
            }

            /// <summary>
            /// Gets or sets the position within the current stream.
            /// </summary>
            public override long Position
            {
                get
                {
                    return baseStream_.Position;
                }

                set
                {
                }
            }

            /// <summary>
            /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            /// </summary>
            /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
            /// <returns>
            /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            /// </returns>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override int Read(byte[] buffer, int offset, int count)
            {
                return 0;
            }

            /// <summary>
            /// Sets the position within the current stream.
            /// </summary>
            /// <param name="offset">A byte offset relative to the origin parameter.</param>
            /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            /// <returns>
            /// The new position within the current stream.
            /// </returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Seek(long offset, SeekOrigin origin)
            {
                return 0;
            }

            /// <summary>
            /// Sets the length of the current stream.
            /// </summary>
            /// <param name="value">The desired length of the current stream in bytes.</param>
            /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override void SetLength(long value)
            {
            }

            /// <summary>
            /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            /// </summary>
            /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            /// <param name="count">The number of bytes to be written to the current stream.</param>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override void Write(byte[] buffer, int offset, int count)
            {
                baseStream_.Write(buffer, offset, count);
            }

            #region Instance Fields
            Stream baseStream_;
            #endregion
        }

        /// <summary>
        /// A <see cref="PartialInputStream"/> is an <see cref="InflaterInputStream"/>
        /// whose data is only a part or subsection of a file.
        /// </summary>
        class PartialInputStream : Stream
        {
            #region Constructors
            /// <summary>
            /// Initialise a new instance of the <see cref="PartialInputStream"/> class.
            /// </summary>
            /// <param name="zipFile">The <see cref="ZipFile"/> containing the underlying stream to use for IO.</param>
            /// <param name="start">The start of the partial data.</param>
            /// <param name="length">The length of the partial data.</param>
            public PartialInputStream(ZipFile zipFile, long start, long length)
            {
                start_ = start;
                length_ = length;

                // Although this is the only time the zipfile is used
                // keeping a reference here prevents premature closure of
                // this zip file and thus the baseStream_.

                // Code like this will cause apparently random failures depending
                // on the size of the files and when garbage is collected.
                //
                // ZipFile z = new ZipFile (stream);
                // Stream reader = z.GetInputStream(0);
                // uses reader here....
                zipFile_ = zipFile;
                baseStream_ = zipFile_.baseStream_;
                readPos_ = start;
                end_ = start + length;
            }
            #endregion

            /// <summary>
            /// Read a byte from this stream.
            /// </summary>
            /// <returns>Returns the byte read or -1 on end of stream.</returns>
            public override int ReadByte()
            {
                if (readPos_ >= end_)
                {
                    // -1 is the correct value at end of stream.
                    return -1;
                }

                lock (baseStream_)
                {
                    baseStream_.Seek(readPos_++, SeekOrigin.Begin);
                    return baseStream_.ReadByte();
                }
            }

            /// <summary>
            /// Close this <see cref="PartialInputStream">partial input stream</see>.
            /// </summary>
            /// <remarks>
            /// The underlying stream is not closed.  Close the parent ZipFile class to do that.
            /// </remarks>
            public override void Close()
            {
                // Do nothing at all!
            }

            /// <summary>
            /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            /// </summary>
            /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
            /// <returns>
            /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            /// </returns>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override int Read(byte[] buffer, int offset, int count)
            {
                lock (baseStream_)
                {
                    if (count > end_ - readPos_)
                    {
                        count = (int)(end_ - readPos_);
                        if (count == 0)
                        {
                            return 0;
                        }
                    }

                    baseStream_.Seek(readPos_, SeekOrigin.Begin);
                    int readCount = baseStream_.Read(buffer, offset, count);
                    if (readCount > 0)
                    {
                        readPos_ += readCount;
                    }
                    return readCount;
                }
            }

            /// <summary>
            /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            /// </summary>
            /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            /// <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            /// <param name="count">The number of bytes to be written to the current stream.</param>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            /// <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            /// <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
            public override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            /// <summary>
            /// When overridden in a derived class, sets the length of the current stream.
            /// </summary>
            /// <param name="value">The desired length of the current stream in bytes.</param>
            /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            /// <summary>
            /// When overridden in a derived class, sets the position within the current stream.
            /// </summary>
            /// <param name="offset">A byte offset relative to the origin parameter.</param>
            /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            /// <returns>
            /// The new position within the current stream.
            /// </returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Seek(long offset, SeekOrigin origin)
            {
                long newPos = readPos_;

                switch (origin)
                {
                    case SeekOrigin.Begin:
                        newPos = start_ + offset;
                        break;

                    case SeekOrigin.Current:
                        newPos = readPos_ + offset;
                        break;

                    case SeekOrigin.End:
                        newPos = end_ + offset;
                        break;
                }

                if (newPos < start_)
                {
                    throw new ArgumentException("Negative position is invalid");
                }

                if (newPos >= end_)
                {
                    throw new IOException("Cannot seek past end");
                }
                readPos_ = newPos;
                return readPos_;
            }

            /// <summary>
            /// Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            /// </summary>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            public override void Flush()
            {
                // Nothing to do.
            }

            /// <summary>
            /// Gets or sets the position within the current stream.
            /// </summary>
            /// <value></value>
            /// <returns>The current position within the stream.</returns>
            /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            /// <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Position
            {
                get { return readPos_ - start_; }
                set
                {
                    long newPos = start_ + value;

                    if (newPos < start_)
                    {
                        throw new ArgumentException("Negative position is invalid");
                    }

                    if (newPos >= end_)
                    {
                        throw new InvalidOperationException("Cannot seek past end");
                    }
                    readPos_ = newPos;
                }
            }

            /// <summary>
            /// Gets the length in bytes of the stream.
            /// </summary>
            /// <value></value>
            /// <returns>A long value representing the length of the stream in bytes.</returns>
            /// <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            public override long Length
            {
                get { return length_; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports writing.
            /// </summary>
            /// <value>false</value>
            /// <returns>true if the stream supports writing; otherwise, false.</returns>
            public override bool CanWrite
            {
                get { return false; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports seeking.
            /// </summary>
            /// <value>true</value>
            /// <returns>true if the stream supports seeking; otherwise, false.</returns>
            public override bool CanSeek
            {
                get { return true; }
            }

            /// <summary>
            /// Gets a value indicating whether the current stream supports reading.
            /// </summary>
            /// <value>true.</value>
            /// <returns>true if the stream supports reading; otherwise, false.</returns>
            public override bool CanRead
            {
                get { return true; }
            }

#if !NET_1_0 && !NET_1_1 && !NETCF_1_0
            /// <summary>
            /// Gets a value that determines whether the current stream can time out.
            /// </summary>
            /// <value></value>
            /// <returns>A value that determines whether the current stream can time out.</returns>
            public override bool CanTimeout
            {
                get { return baseStream_.CanTimeout; }
            }
#endif
            #region Instance Fields
            ZipFile zipFile_;
            Stream baseStream_;
            long start_;
            long length_;
            long readPos_;
            long end_;
            #endregion
        }
        #endregion
    }

    #endregion

    #region DataSources
    /// <summary>
    /// Provides a static way to obtain a source of data for an entry.
    /// </summary>
    public interface IStaticDataSource
    {
        /// <summary>
        /// Get a source of data by creating a new stream.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> to use for compression input.</returns>
        /// <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        Stream GetSource();
    }

    /// <summary>
    /// Represents a source of data that can dynamically provide
    /// multiple <see cref="Stream">data sources</see> based on the parameters passed.
    /// </summary>
    public interface IDynamicDataSource
    {
        /// <summary>
        /// Get a data source.
        /// </summary>
        /// <param name="entry">The <see cref="ZipEntry"/> to get a source for.</param>
        /// <param name="name">The name for data if known.</param>
        /// <returns>Returns a <see cref="Stream"/> to use for compression input.</returns>
        /// <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        Stream GetSource(ZipEntry entry, string name);
    }

    /// <summary>
    /// Default implementation of a <see cref="IStaticDataSource"/> for use with files stored on disk.
    /// </summary>
    public class StaticDiskDataSource : IStaticDataSource
    {
        /// <summary>
        /// Initialise a new instnace of <see cref="StaticDiskDataSource"/>
        /// </summary>
        /// <param name="fileName">The name of the file to obtain data from.</param>
        public StaticDiskDataSource(string fileName)
        {
            fileName_ = fileName;
        }

        #region IDataSource Members

        /// <summary>
        /// Get a <see cref="Stream"/> providing data.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> provising data.</returns>
        public Stream GetSource()
        {
            return File.Open(fileName_, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        #endregion
        #region Instance Fields
        string fileName_;
        #endregion
    }


    /// <summary>
    /// Default implementation of <see cref="IDynamicDataSource"/> for files stored on disk.
    /// </summary>
    public class DynamicDiskDataSource : IDynamicDataSource
    {
        /// <summary>
        /// Initialise a default instance of <see cref="DynamicDiskDataSource"/>.
        /// </summary>
        public DynamicDiskDataSource()
        {
        }

        #region IDataSource Members
        /// <summary>
        /// Get a <see cref="Stream"/> providing data for an entry.
        /// </summary>
        /// <param name="entry">The entry to provide data for.</param>
        /// <param name="name">The file name for data if known.</param>
        /// <returns>Returns a stream providing data; or null if not available</returns>
        public Stream GetSource(ZipEntry entry, string name)
        {
            Stream result = null;

            if (name != null)
            {
                result = File.Open(name, FileMode.Open, FileAccess.Read, FileShare.Read);
            }

            return result;
        }

        #endregion
    }

    #endregion

    #region Archive Storage
    /// <summary>
    /// Defines facilities for data storage when updating Zip Archives.
    /// </summary>
    public interface IArchiveStorage
    {
        /// <summary>
        /// Get the <see cref="FileUpdateMode"/> to apply during updates.
        /// </summary>
        FileUpdateMode UpdateMode { get; }

        /// <summary>
        /// Get an empty <see cref="Stream"/> that can be used for temporary output.
        /// </summary>
        /// <returns>Returns a temporary output <see cref="Stream"/></returns>
        /// <seealso cref="ConvertTemporaryToFinal"></seealso>
        Stream GetTemporaryOutput();

        /// <summary>
        /// Convert a temporary output stream to a final stream.
        /// </summary>
        /// <returns>The resulting final <see cref="Stream"/></returns>
        /// <seealso cref="GetTemporaryOutput"/>
        Stream ConvertTemporaryToFinal();

        /// <summary>
        /// Make a temporary copy of the original stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        Stream MakeTemporaryCopy(Stream stream);

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The current stream.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>This may be the current stream passed.</remarks>
        Stream OpenForDirectUpdate(Stream stream);

        /// <summary>
        /// Dispose of this instance.
        /// </summary>
        void Dispose();
    }

    /// <summary>
    /// An abstract <see cref="IArchiveStorage"/> suitable for extension by inheritance.
    /// </summary>
    abstract public class BaseArchiveStorage : IArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="BaseArchiveStorage"/> class.
        /// </summary>
        /// <param name="updateMode">The update mode.</param>
        protected BaseArchiveStorage(FileUpdateMode updateMode)
        {
            updateMode_ = updateMode;
        }
        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets a temporary output <see cref="Stream"/>
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        /// <seealso cref="ConvertTemporaryToFinal"></seealso>
        public abstract Stream GetTemporaryOutput();

        /// <summary>
        /// Converts the temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        /// <seealso cref="GetTemporaryOutput"/>
        public abstract Stream ConvertTemporaryToFinal();

        /// <summary>
        /// Make a temporary copy of a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to make a copy of.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public abstract Stream MakeTemporaryCopy(Stream stream);

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to open for direct update.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        public abstract Stream OpenForDirectUpdate(Stream stream);

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public abstract void Dispose();

        /// <summary>
        /// Gets the update mode applicable.
        /// </summary>
        /// <value>The update mode.</value>
        public FileUpdateMode UpdateMode
        {
            get
            {
                return updateMode_;
            }
        }

        #endregion

        #region Instance Fields
        FileUpdateMode updateMode_;
        #endregion
    }

    /// <summary>
    /// An <see cref="IArchiveStorage"/> implementation suitable for hard disks.
    /// </summary>
    public class DiskArchiveStorage : BaseArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="DiskArchiveStorage"/> class.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="updateMode">The update mode.</param>
        public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode)
            : base(updateMode)
        {
            if (file.Name == null)
            {
                throw new ZipException("Cant handle non file archives");
            }

            fileName_ = file.Name;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DiskArchiveStorage"/> class.
        /// </summary>
        /// <param name="file">The file.</param>
        public DiskArchiveStorage(ZipFile file)
            : this(file, FileUpdateMode.Safe)
        {
        }
        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets a temporary output <see cref="Stream"/> for performing updates on.
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        public override Stream GetTemporaryOutput()
        {
            if (temporaryName_ != null)
            {
                temporaryName_ = GetTempFileName(temporaryName_, true);
                temporaryStream_ = File.Open(temporaryName_, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
            }
            else
            {
                // Determine where to place files based on internal strategy.
                // Currently this is always done in system temp directory.
                temporaryName_ = Path.GetTempFileName();
                temporaryStream_ = File.Open(temporaryName_, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
            }

            return temporaryStream_;
        }

        /// <summary>
        /// Converts a temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        public override Stream ConvertTemporaryToFinal()
        {
            if (temporaryStream_ == null)
            {
                throw new ZipException("No temporary stream has been created");
            }

            Stream result = null;

            string moveTempName = GetTempFileName(fileName_, false);
            bool newFileCreated = false;

            try
            {
                temporaryStream_.Close();
                File.Move(fileName_, moveTempName);
                File.Move(temporaryName_, fileName_);
                newFileCreated = true;
                File.Delete(moveTempName);

                result = File.Open(fileName_, FileMode.Open, FileAccess.Read, FileShare.Read);
            }
            catch (Exception)
            {
                result = null;

                // Try to roll back changes...
                if (!newFileCreated)
                {
                    File.Move(moveTempName, fileName_);
                    File.Delete(temporaryName_);
                }

                throw;
            }

            return result;
        }

        /// <summary>
        /// Make a temporary copy of a stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public override Stream MakeTemporaryCopy(Stream stream)
        {
            stream.Close();

            temporaryName_ = GetTempFileName(fileName_, true);
            File.Copy(fileName_, temporaryName_, true);

            temporaryStream_ = new FileStream(temporaryName_,
                FileMode.Open,
                FileAccess.ReadWrite);
            return temporaryStream_;
        }

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The current stream.</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>If the <paramref name="current"/> stream is not null this is used as is.</remarks>
        public override Stream OpenForDirectUpdate(Stream stream)
        {
            Stream result;
            if ((stream == null) || !stream.CanWrite)
            {
                if (stream != null)
                {
                    stream.Close();
                }

                result = new FileStream(fileName_,
                        FileMode.Open,
                        FileAccess.ReadWrite);
            }
            else
            {
                result = stream;
            }

            return result;
        }

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public override void Dispose()
        {
            if (temporaryStream_ != null)
            {
                temporaryStream_.Close();
            }
        }

        #endregion

        #region Internal routines
        static string GetTempFileName(string original, bool makeTempFile)
        {
            string result = null;

            if (original == null)
            {
                result = Path.GetTempFileName();
            }
            else
            {
                int counter = 0;
                int suffixSeed = DateTime.Now.Second;

                while (result == null)
                {
                    counter += 1;
                    string newName = string.Format("{0}.{1}{2}.tmp", original, suffixSeed, counter);
                    if (!File.Exists(newName))
                    {
                        if (makeTempFile)
                        {
                            try
                            {
                                // Try and create the file.
                                using (FileStream stream = File.Create(newName))
                                {
                                }
                                result = newName;
                            }
                            catch
                            {
                                suffixSeed = DateTime.Now.Second;
                            }
                        }
                        else
                        {
                            result = newName;
                        }
                    }
                }
            }
            return result;
        }
        #endregion

        #region Instance Fields
        Stream temporaryStream_;
        string fileName_;
        string temporaryName_;
        #endregion
    }

    /// <summary>
    /// An <see cref="IArchiveStorage"/> implementation suitable for in memory streams.
    /// </summary>
    public class MemoryArchiveStorage : BaseArchiveStorage
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MemoryArchiveStorage"/> class.
        /// </summary>
        public MemoryArchiveStorage()
            : base(FileUpdateMode.Direct)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MemoryArchiveStorage"/> class.
        /// </summary>
        /// <param name="updateMode">The <see cref="FileUpdateMode"/> to use</param>
        /// <remarks>This constructor is for testing as memory streams dont really require safe mode.</remarks>
        public MemoryArchiveStorage(FileUpdateMode updateMode)
            : base(updateMode)
        {
        }

        #endregion

        #region Properties
        /// <summary>
        /// Get the stream returned by <see cref="ConvertTemporaryToFinal"/> if this was in fact called.
        /// </summary>
        public MemoryStream FinalStream
        {
            get { return finalStream_; }
        }

        #endregion

        #region IArchiveStorage Members

        /// <summary>
        /// Gets the temporary output <see cref="Stream"/>
        /// </summary>
        /// <returns>Returns the temporary output stream.</returns>
        public override Stream GetTemporaryOutput()
        {
            temporaryStream_ = new MemoryStream();
            return temporaryStream_;
        }

        /// <summary>
        /// Converts the temporary <see cref="Stream"/> to its final form.
        /// </summary>
        /// <returns>Returns a <see cref="Stream"/> that can be used to read
        /// the final storage for the archive.</returns>
        public override Stream ConvertTemporaryToFinal()
        {
            if (temporaryStream_ == null)
            {
                throw new ZipException("No temporary stream has been created");
            }

            finalStream_ = new MemoryStream(temporaryStream_.ToArray());
            return finalStream_;
        }

        /// <summary>
        /// Make a temporary copy of the original stream.
        /// </summary>
        /// <param name="stream">The <see cref="Stream"/> to copy.</param>
        /// <returns>Returns a temporary output <see cref="Stream"/> that is a copy of the input.</returns>
        public override Stream MakeTemporaryCopy(Stream stream)
        {
            temporaryStream_ = new MemoryStream();
            stream.Position = 0;
            StreamUtils.Copy(stream, temporaryStream_, new byte[4096]);
            return temporaryStream_;
        }

        /// <summary>
        /// Return a stream suitable for performing direct updates on the original source.
        /// </summary>
        /// <param name="stream">The original source stream</param>
        /// <returns>Returns a stream suitable for direct updating.</returns>
        /// <remarks>If the <paramref name="stream"/> passed is not null this is used;
        /// otherwise a new <see cref="MemoryStream"/> is returned.</remarks>
        public override Stream OpenForDirectUpdate(Stream stream)
        {
            Stream result;
            if ((stream == null) || !stream.CanWrite)
            {

                result = new MemoryStream();

                if (stream != null)
                {
                    stream.Position = 0;
                    StreamUtils.Copy(stream, result, new byte[4096]);

                    stream.Close();
                }
            }
            else
            {
                result = stream;
            }

            return result;
        }

        /// <summary>
        /// Disposes this instance.
        /// </summary>
        public override void Dispose()
        {
            if (temporaryStream_ != null)
            {
                temporaryStream_.Close();
            }
        }

        #endregion

        #region Instance Fields
        MemoryStream temporaryStream_;
        MemoryStream finalStream_;
        #endregion
    }

    #endregion
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;
    /// <summary>
    /// Holds data pertinent to a data descriptor.
    /// </summary>
    public class DescriptorData
    {
        /// <summary>
        /// Get /set the compressed size of data.
        /// </summary>
        public long CompressedSize
        {
            get { return compressedSize; }
            set { compressedSize = value; }
        }

        /// <summary>
        /// Get / set the uncompressed size of data
        /// </summary>
        public long Size
        {
            get { return size; }
            set { size = value; }
        }

        /// <summary>
        /// Get /set the crc value.
        /// </summary>
        public long Crc
        {
            get { return crc; }
            set { crc = (value & 0xffffffff); }
        }

        #region Instance Fields
        long size;
        long compressedSize;
        long crc;
        #endregion
    }

    class EntryPatchData
    {
        public long SizePatchOffset
        {
            get { return sizePatchOffset_; }
            set { sizePatchOffset_ = value; }
        }

        public long CrcPatchOffset
        {
            get { return crcPatchOffset_; }
            set { crcPatchOffset_ = value; }
        }

        #region Instance Fields
        long sizePatchOffset_;
        long crcPatchOffset_;
        #endregion
    }

    /// <summary>
    /// This class assists with writing/reading from Zip files.
    /// </summary>
    internal class ZipHelperStream : Stream
    {
        #region Constructors
        /// <summary>
        /// Initialise an instance of this class.
        /// </summary>
        /// <param name="name">The name of the file to open.</param>
        public ZipHelperStream(string name)
        {
            stream_ = new FileStream(name, FileMode.Open, FileAccess.ReadWrite);
            isOwner_ = true;
        }

        /// <summary>
        /// Initialise a new instance of <see cref="ZipHelperStream"/>.
        /// </summary>
        /// <param name="stream">The stream to use.</param>
        public ZipHelperStream(Stream stream)
        {
            stream_ = stream;
        }
        #endregion

        /// <summary>
        /// Get / set a value indicating wether the the underlying stream is owned or not.
        /// </summary>
        /// <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        public bool IsStreamOwner
        {
            get { return isOwner_; }
            set { isOwner_ = value; }
        }

        #region Base Stream Methods
        public override bool CanRead
        {
            get { return stream_.CanRead; }
        }

        public override bool CanSeek
        {
            get { return stream_.CanSeek; }
        }

#if !NET_1_0 && !NET_1_1 && !NETCF_1_0
        public override bool CanTimeout
        {
            get { return stream_.CanTimeout; }
        }
#endif

        public override long Length
        {
            get { return stream_.Length; }
        }

        public override long Position
        {
            get { return stream_.Position; }
            set { stream_.Position = value; }
        }

        public override bool CanWrite
        {
            get { return stream_.CanWrite; }
        }

        public override void Flush()
        {
            stream_.Flush();
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            return stream_.Seek(offset, origin);
        }

        public override void SetLength(long value)
        {
            stream_.SetLength(value);
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            return stream_.Read(buffer, offset, count);
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            stream_.Write(buffer, offset, count);
        }

        /// <summary>
        /// Close the stream.
        /// </summary>
        /// <remarks>
        /// The underlying stream is closed only if <see cref="IsStreamOwner"/> is true.
        /// </remarks>
        override public void Close()
        {
            Stream toClose = stream_;
            stream_ = null;
            if (isOwner_ && (toClose != null))
            {
                isOwner_ = false;
                toClose.Close();
            }
        }
        #endregion

        // Write the local file header
        // TODO: ZipHelperStream.WriteLocalHeader is not yet used and needs checking for ZipFile and ZipOuptutStream usage
        void WriteLocalHeader(ZipEntry entry, EntryPatchData patchData)
        {
            CompressionMethod method = entry.CompressionMethod;
            bool headerInfoAvailable = true; // How to get this?
            bool patchEntryHeader = false;

            WriteLEInt(ZipConstants.LocalHeaderSignature);

            WriteLEShort(entry.Version);
            WriteLEShort(entry.Flags);
            WriteLEShort((byte)method);
            WriteLEInt((int)entry.DosTime);

            if (headerInfoAvailable == true)
            {
                WriteLEInt((int)entry.Crc);
                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLEInt(-1);
                    WriteLEInt(-1);
                }
                else
                {
                    WriteLEInt(entry.IsCrypted ? (int)entry.CompressedSize + ZipConstants.CryptoHeaderSize : (int)entry.CompressedSize);
                    WriteLEInt((int)entry.Size);
                }
            }
            else
            {
                if (patchData != null)
                {
                    patchData.CrcPatchOffset = stream_.Position;
                }
                WriteLEInt(0);	// Crc

                if (patchData != null)
                {
                    patchData.SizePatchOffset = stream_.Position;
                }

                // For local header both sizes appear in Zip64 Extended Information
                if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
                {
                    WriteLEInt(-1);
                    WriteLEInt(-1);
                }
                else
                {
                    WriteLEInt(0);	// Compressed size
                    WriteLEInt(0);	// Uncompressed size
                }
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64 && (headerInfoAvailable || patchEntryHeader))
            {
                ed.StartNewEntry();
                if (headerInfoAvailable)
                {
                    ed.AddLeLong(entry.Size);
                    ed.AddLeLong(entry.CompressedSize);
                }
                else
                {
                    ed.AddLeLong(-1);
                    ed.AddLeLong(-1);
                }
                ed.AddNewEntry(1);

                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cant find extra data");
                }

                if (patchData != null)
                {
                    patchData.SizePatchOffset = ed.CurrentReadIndex;
                }
            }
            else
            {
                ed.Delete(1);
            }

            byte[] extra = ed.GetEntryData();

            WriteLEShort(name.Length);
            WriteLEShort(extra.Length);

            if (name.Length > 0)
            {
                stream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
            {
                patchData.SizePatchOffset += stream_.Position;
            }

            if (extra.Length > 0)
            {
                stream_.Write(extra, 0, extra.Length);
            }
        }

        /// <summary>
        /// Locates a block with the desired <paramref name="signature"/>.
        /// </summary>
        /// <param name="signature">The signature to find.</param>
        /// <param name="endLocation">Location, marking the end of block.</param>
        /// <param name="minimumBlockSize">Minimum size of the block.</param>
        /// <param name="maximumVariableData">The maximum variable data.</param>
        /// <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        public long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)
        {
            long pos = endLocation - minimumBlockSize;
            if (pos < 0)
            {
                return -1;
            }

            long giveUpMarker = Math.Max(pos - maximumVariableData, 0);

            // TODO: This loop could be optimised for speed.
            do
            {
                if (pos < giveUpMarker)
                {
                    return -1;
                }
                Seek(pos--, SeekOrigin.Begin);
            } while (ReadLEInt() != signature);

            return Position;
        }

        /// <summary>
        /// Write Zip64 end of central directory records (File header and locator).
        /// </summary>
        /// <param name="noOfEntries">The number of entries in the central directory.</param>
        /// <param name="sizeEntries">The size of entries in the central directory.</param>
        /// <param name="centralDirOffset">The offset of the dentral directory.</param>
        public void WriteZip64EndOfCentralDirectory(long noOfEntries, long sizeEntries, long centralDirOffset)
        {
            long centralSignatureOffset = stream_.Position;
            WriteLEInt(ZipConstants.Zip64CentralFileHeaderSignature);
            WriteLELong(44);    // Size of this record (total size of remaining fields in header or full size - 12)
            WriteLEShort(ZipConstants.VersionMadeBy);   // Version made by
            WriteLEShort(ZipConstants.VersionZip64);   // Version to extract
            WriteLEInt(0);      // Number of this disk
            WriteLEInt(0);      // number of the disk with the start of the central directory
            WriteLELong(noOfEntries);       // No of entries on this disk
            WriteLELong(noOfEntries);       // Total No of entries in central directory
            WriteLELong(sizeEntries);       // Size of the central directory
            WriteLELong(centralDirOffset);  // offset of start of central directory
            // zip64 extensible data sector not catered for here (variable size)

            // Write the Zip64 end of central directory locator
            WriteLEInt(ZipConstants.Zip64CentralDirLocatorSignature);

            // no of the disk with the start of the zip64 end of central directory
            WriteLEInt(0);

            // relative offset of the zip64 end of central directory record
            WriteLELong(centralSignatureOffset);

            // total number of disks
            WriteLEInt(1);
        }

        /// <summary>
        /// Write the required records to end the central directory.
        /// </summary>
        /// <param name="noOfEntries">The number of entries in the directory.</param>
        /// <param name="sizeEntries">The size of the entries in the directory.</param>
        /// <param name="startOfCentralDirectory">The start of the central directory.</param>
        /// <param name="comment">The archive comment.  (This can be null).</param>
        public void WriteEndOfCentralDirectory(long noOfEntries, long sizeEntries,
            long startOfCentralDirectory, byte[] comment)
        {

            if ((noOfEntries >= 0xffff) ||
                (startOfCentralDirectory >= 0xffffffff) ||
                (sizeEntries >= 0xffffffff))
            {
                WriteZip64EndOfCentralDirectory(noOfEntries, sizeEntries, startOfCentralDirectory);
            }

            WriteLEInt(ZipConstants.EndOfCentralDirectorySignature);

            // TODO: ZipFile Multi disk handling not done
            WriteLEShort(0);                    // number of this disk
            WriteLEShort(0);                    // no of disk with start of central dir


            // Number of entries
            if (noOfEntries >= 0xffff)
            {
                WriteLEUshort(0xffff);  // Zip64 marker
                WriteLEUshort(0xffff);
            }
            else
            {
                WriteLEShort((short)noOfEntries);          // entries in central dir for this disk
                WriteLEShort((short)noOfEntries);          // total entries in central directory
            }

            // Size of the central directory
            if (sizeEntries >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);    // Zip64 marker
            }
            else
            {
                WriteLEInt((int)sizeEntries);
            }


            // offset of start of central directory
            if (startOfCentralDirectory >= 0xffffffff)
            {
                WriteLEUint(0xffffffff);    // Zip64 marker
            }
            else
            {
                WriteLEInt((int)startOfCentralDirectory);
            }

            int commentLength = (comment != null) ? comment.Length : 0;

            if (commentLength > 0xffff)
            {
                throw new ZipException(string.Format("Comment length({0}) is too long can only be 64K", commentLength));
            }

            WriteLEShort(commentLength);

            if (commentLength > 0)
            {
                Write(comment, 0, comment.Length);
            }
        }

        #region LE value reading/writing
        /// <summary>
        /// Read an unsigned short in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        public int ReadLEShort()
        {
            int byteValue1 = stream_.ReadByte();

            if (byteValue1 < 0)
            {
                throw new EndOfStreamException();
            }

            int byteValue2 = stream_.ReadByte();
            if (byteValue2 < 0)
            {
                throw new EndOfStreamException();
            }

            return byteValue1 | (byteValue2 << 8);
        }

        /// <summary>
        /// Read an int in little endian byte order.
        /// </summary>
        /// <returns>Returns the value read.</returns>
        /// <exception cref="IOException">
        /// An i/o error occurs.
        /// </exception>
        /// <exception cref="System.IO.EndOfStreamException">
        /// The file ends prematurely
        /// </exception>
        public int ReadLEInt()
        {
            return ReadLEShort() | (ReadLEShort() << 16);
        }

        /// <summary>
        /// Read a long in little endian byte order.
        /// </summary>
        /// <returns>The value read.</returns>
        public long ReadLELong()
        {
            return (uint)ReadLEInt() | ((long)ReadLEInt() << 32);
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEShort(int value)
        {
            stream_.WriteByte((byte)(value & 0xff));
            stream_.WriteByte((byte)((value >> 8) & 0xff));
        }

        /// <summary>
        /// Write a ushort in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUshort(ushort value)
        {
            stream_.WriteByte((byte)(value & 0xff));
            stream_.WriteByte((byte)(value >> 8));
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEInt(int value)
        {
            WriteLEShort(value);
            WriteLEShort(value >> 16);
        }

        /// <summary>
        /// Write a uint in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUint(uint value)
        {
            WriteLEUshort((ushort)(value & 0xffff));
            WriteLEUshort((ushort)(value >> 16));
        }

        /// <summary>
        /// Write a long in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLELong(long value)
        {
            WriteLEInt((int)value);
            WriteLEInt((int)(value >> 32));
        }

        /// <summary>
        /// Write a ulong in little endian byte order.
        /// </summary>
        /// <param name="value">The value to write.</param>
        public void WriteLEUlong(ulong value)
        {
            WriteLEUint((uint)(value & 0xffffffff));
            WriteLEUint((uint)(value >> 32));
        }

        #endregion

        /// <summary>
        /// Write a data descriptor.
        /// </summary>
        /// <param name="entry">The entry to write a descriptor for.</param>
        /// <returns>Returns the number of descriptor bytes written.</returns>
        public int WriteDataDescriptor(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            int result = 0;

            // Add data descriptor if flagged as required
            if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)
            {
                // The signature is not PKZIP originally but is now described as optional
                // in the PKZIP Appnote documenting trhe format.
                WriteLEInt(ZipConstants.DataDescriptorSignature);
                WriteLEInt(unchecked((int)(entry.Crc)));

                result += 8;

                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLELong(entry.CompressedSize);
                    WriteLELong(entry.Size);
                    result += 16;
                }
                else
                {
                    WriteLEInt((int)entry.CompressedSize);
                    WriteLEInt((int)entry.Size);
                    result += 8;
                }
            }

            return result;
        }

        /// <summary>
        /// Read data descriptor at the end of compressed data.
        /// </summary>
        /// <param name="zip64">if set to <c>true</c> [zip64].</param>
        /// <param name="data">The data to fill in.</param>
        /// <returns>Returns the number of bytes read in the descriptor.</returns>
        public void ReadDataDescriptor(bool zip64, DescriptorData data)
        {
            int intValue = ReadLEInt();

            // In theory this may not be a descriptor according to PKZIP appnote.
            // In practise its always there.
            if (intValue != ZipConstants.DataDescriptorSignature)
            {
                throw new ZipException("Data descriptor signature not found");
            }

            data.Crc = ReadLEInt();

            if (zip64)
            {
                data.CompressedSize = ReadLELong();
                data.Size = ReadLELong();
            }
            else
            {
                data.CompressedSize = ReadLEInt();
                data.Size = ReadLEInt();
            }
        }

        #region Instance Fields
        bool isOwner_;
        Stream stream_;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;

#if !NETCF_1_0
    using ICSharpCode.SharpZipLib.Encryption;
#endif
    /// <summary>
    /// This is an InflaterInputStream that reads the files baseInputStream an zip archive
    /// one after another.  It has a special method to get the zip entry of
    /// the next file.  The zip entry contains information about the file name
    /// size, compressed size, Crc, etc.
    /// It includes support for Stored and Deflated entries.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// 
    /// <example> This sample shows how to read a zip file
    /// <code lang="C#">
    /// using System;
    /// using System.Text;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	public static void Main(string[] args)
    /// 	{
    /// 		using ( ZipInputStream s = new ZipInputStream(File.OpenRead(args[0]))) {
    ///
    /// 			ZipEntry theEntry;
    /// 			const int size = 2048;
    /// 			byte[] data = new byte[2048];
    /// 			
    /// 			while ((theEntry = s.GetNextEntry()) != null) {
    ///                 if ( entry.IsFile ) {
    /// 				    Console.Write("Show contents (y/n) ?");
    /// 				    if (Console.ReadLine() == "y") {
    /// 				    	while (true) {
    /// 				    		size = s.Read(data, 0, data.Length);
    /// 				    		if (size > 0) {
    /// 				    			Console.Write(new ASCIIEncoding().GetString(data, 0, size));
    /// 				    		} else {
    /// 				    			break;
    /// 				    		}
    /// 				    	}
    /// 				    }
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }
    /// </code>
    /// </example>
    public class ZipInputStream : InflaterInputStream
    {
        #region Instance Fields

        /// <summary>
        /// Delegate for reading bytes from a stream. 
        /// </summary>
        delegate int ReadDataHandler(byte[] b, int offset, int length);

        /// <summary>
        /// The current reader this instance.
        /// </summary>
        ReadDataHandler internalReader;

        Crc32 crc = new Crc32();
        ZipEntry entry;

        long size;
        int method;
        int flags;
        string password;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new Zip input stream, for reading a zip archive.
        /// </summary>
        /// <param name="baseInputStream">The underlying <see cref="Stream"/> providing data.</param>
        public ZipInputStream(Stream baseInputStream)
            : base(baseInputStream, new Inflater(true))
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
        }

        /// <summary>
        /// Creates a new Zip input stream, for reading a zip archive.
        /// </summary>
        /// <param name="baseInputStream">The underlying <see cref="Stream"/> providing data.</param>
        /// <param name="bufferSize">Size of the buffer.</param>
        public ZipInputStream(Stream baseInputStream, int bufferSize)
            : base(baseInputStream, new Inflater(true), bufferSize)
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
        }
        #endregion

        /// <summary>
        /// Optional password used for encryption when non-null
        /// </summary>
        /// <value>A password for all encrypted <see cref="ZipEntry">entries </see> in this <see cref="ZipInputStream"/></value>
        public string Password
        {
            get
            {
                return password;
            }
            set
            {
                password = value;
            }
        }


        /// <summary>
        /// Gets a value indicating if there is a current entry and it can be decompressed
        /// </summary>
        /// <remarks>
        /// The entry can only be decompressed if the library supports the zip features required to extract it.
        /// See the <see cref="ZipEntry.Version">ZipEntry Version</see> property for more details.
        /// </remarks>
        public bool CanDecompressEntry
        {
            get
            {
                return (entry != null) && entry.CanDecompress;
            }
        }

        /// <summary>
        /// Advances to the next entry in the archive
        /// </summary>
        /// <returns>
        /// The next <see cref="ZipEntry">entry</see> in the archive or null if there are no more entries.
        /// </returns>
        /// <remarks>
        /// If the previous entry is still open <see cref="CloseEntry">CloseEntry</see> is called.
        /// </remarks>
        /// <exception cref="InvalidOperationException">
        /// Input stream is closed
        /// </exception>
        /// <exception cref="ZipException">
        /// Password is not set, password is invalid, compression method is invalid,
        /// version required to extract is not supported
        /// </exception>
        public ZipEntry GetNextEntry()
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed.");
            }

            if (entry != null)
            {
                CloseEntry();
            }

            int header = inputBuffer.ReadLeInt();

            if (header == ZipConstants.CentralHeaderSignature ||
                header == ZipConstants.EndOfCentralDirectorySignature ||
                header == ZipConstants.CentralHeaderDigitalSignature ||
                header == ZipConstants.ArchiveExtraDataSignature ||
                header == ZipConstants.Zip64CentralFileHeaderSignature)
            {
                // No more individual entries exist
                Close();
                return null;
            }

            // -jr- 07-Dec-2003 Ignore spanning temporary signatures if found
            // Spanning signature is same as descriptor signature and is untested as yet.
            if ((header == ZipConstants.SpanningTempSignature) || (header == ZipConstants.SpanningSignature))
            {
                header = inputBuffer.ReadLeInt();
            }

            if (header != ZipConstants.LocalHeaderSignature)
            {
                throw new ZipException("Wrong Local header signature: 0x" + String.Format("{0:X}", header));
            }

            short versionRequiredToExtract = (short)inputBuffer.ReadLeShort();

            flags = inputBuffer.ReadLeShort();
            method = inputBuffer.ReadLeShort();
            uint dostime = (uint)inputBuffer.ReadLeInt();
            int crc2 = inputBuffer.ReadLeInt();
            csize = inputBuffer.ReadLeInt();
            size = inputBuffer.ReadLeInt();
            int nameLen = inputBuffer.ReadLeShort();
            int extraLen = inputBuffer.ReadLeShort();

            bool isCrypted = (flags & 1) == 1;

            byte[] buffer = new byte[nameLen];
            inputBuffer.ReadRawBuffer(buffer);

            string name = ZipConstants.ConvertToStringExt(flags, buffer);

            entry = new ZipEntry(name, versionRequiredToExtract);
            entry.Flags = flags;

            entry.CompressionMethod = (CompressionMethod)method;

            if ((flags & 8) == 0)
            {
                entry.Crc = crc2 & 0xFFFFFFFFL;
                entry.Size = size & 0xFFFFFFFFL;
                entry.CompressedSize = csize & 0xFFFFFFFFL;

                entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);

            }
            else
            {

                // This allows for GNU, WinZip and possibly other archives, the PKZIP spec
                // says these values are zero under these circumstances.
                if (crc2 != 0)
                {
                    entry.Crc = crc2 & 0xFFFFFFFFL;
                }

                if (size != 0)
                {
                    entry.Size = size & 0xFFFFFFFFL;
                }

                if (csize != 0)
                {
                    entry.CompressedSize = csize & 0xFFFFFFFFL;
                }

                entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);
            }

            entry.DosTime = dostime;

            // If local header requires Zip64 is true then the extended header should contain
            // both values.

            // Handle extra data if present.  This can set/alter some fields of the entry.
            if (extraLen > 0)
            {
                byte[] extra = new byte[extraLen];
                inputBuffer.ReadRawBuffer(extra);
                entry.ExtraData = extra;
            }

            entry.ProcessExtraData(true);
            if (entry.CompressedSize >= 0)
            {
                csize = entry.CompressedSize;
            }

            if (entry.Size >= 0)
            {
                size = entry.Size;
            }

            if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size)))
            {
                throw new ZipException("Stored, but compressed != uncompressed");
            }

            // Determine how to handle reading of data if this is attempted.
            if (entry.IsCompressionMethodSupported())
            {
                internalReader = new ReadDataHandler(InitialRead);
            }
            else
            {
                internalReader = new ReadDataHandler(ReadingNotSupported);
            }

            return entry;
        }

        /// <summary>
        /// Read data descriptor at the end of compressed data. 
        /// </summary>
        void ReadDataDescriptor()
        {
            if (inputBuffer.ReadLeInt() != ZipConstants.DataDescriptorSignature)
            {
                throw new ZipException("Data descriptor signature not found");
            }

            entry.Crc = inputBuffer.ReadLeInt() & 0xFFFFFFFFL;

            if (entry.LocalHeaderRequiresZip64)
            {
                csize = inputBuffer.ReadLeLong();
                size = inputBuffer.ReadLeLong();
            }
            else
            {
                csize = inputBuffer.ReadLeInt();
                size = inputBuffer.ReadLeInt();
            }
            entry.CompressedSize = csize;
            entry.Size = size;
        }

        /// <summary>
        /// Complete cleanup as the final part of closing.
        /// </summary>
        /// <param name="testCrc">True if the crc value should be tested</param>
        void CompleteCloseEntry(bool testCrc)
        {
            StopDecrypting();

            if ((flags & 8) != 0)
            {
                ReadDataDescriptor();
            }

            size = 0;

            if (testCrc &&
                ((crc.Value & 0xFFFFFFFFL) != entry.Crc) && (entry.Crc != -1))
            {
                throw new ZipException("CRC mismatch");
            }

            crc.Reset();

            if (method == (int)CompressionMethod.Deflated)
            {
                inf.Reset();
            }
            entry = null;
        }

        /// <summary>
        /// Closes the current zip entry and moves to the next one.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The stream is closed
        /// </exception>
        /// <exception cref="ZipException">
        /// The Zip stream ends early
        /// </exception>
        public void CloseEntry()
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed");
            }

            if (entry == null)
            {
                return;
            }

            if (method == (int)CompressionMethod.Deflated)
            {
                if ((flags & 8) != 0)
                {
                    // We don't know how much we must skip, read until end.
                    byte[] tmp = new byte[4096];

                    // Read will close this entry
                    while (Read(tmp, 0, tmp.Length) > 0)
                    {
                    }
                    return;
                }

                csize -= inf.TotalIn;
                inputBuffer.Available += inf.RemainingInput;
            }

            if ((inputBuffer.Available > csize) && (csize >= 0))
            {
                inputBuffer.Available = (int)((long)inputBuffer.Available - csize);
            }
            else
            {
                csize -= inputBuffer.Available;
                inputBuffer.Available = 0;
                while (csize != 0)
                {
                    long skipped = base.Skip(csize);

                    if (skipped <= 0)
                    {
                        throw new ZipException("Zip archive ends early.");
                    }

                    csize -= skipped;
                }
            }

            CompleteCloseEntry(false);
        }

        /// <summary>
        /// Returns 1 if there is an entry available
        /// Otherwise returns 0.
        /// </summary>
        public override int Available
        {
            get
            {
                return entry != null ? 1 : 0;
            }
        }

        /// <summary>
        /// Returns the current size that can be read from the current entry if available
        /// </summary>
        /// <exception cref="ZipException">Thrown if the entry size is not known.</exception>
        /// <exception cref="InvalidOperationException">Thrown if no entry is currently available.</exception>
        public override long Length
        {
            get
            {
                if (entry != null)
                {
                    if (entry.Size >= 0)
                    {
                        return entry.Size;
                    }
                    else
                    {
                        throw new ZipException("Length not available for the current entry");
                    }
                }
                else
                {
                    throw new InvalidOperationException("No current entry");
                }
            }

        }

        /// <summary>
        /// Reads a byte from the current zip entry.
        /// </summary>
        /// <returns>
        /// The byte or -1 if end of stream is reached.
        /// </returns>
        public override int ReadByte()
        {
            byte[] b = new byte[1];
            if (Read(b, 0, 1) <= 0)
            {
                return -1;
            }
            return b[0] & 0xff;
        }

        /// <summary>
        /// Handle attempts to read by throwing an <see cref="InvalidOperationException"/>.
        /// </summary>
        /// <param name="destination">The destination array to store data in.</param>
        /// <param name="offset">The offset at which data read should be stored.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>Returns the number of bytes actually read.</returns>
        int ReadingNotAvailable(byte[] destination, int offset, int count)
        {
            throw new InvalidOperationException("Unable to read from this stream");
        }

        /// <summary>
        /// Handle attempts to read from this entry by throwing an exception
        /// </summary>
        int ReadingNotSupported(byte[] destination, int offset, int count)
        {
            throw new ZipException("The compression method for this entry is not supported");
        }

        /// <summary>
        /// Perform the initial read on an entry which may include 
        /// reading encryption headers and setting up inflation.
        /// </summary>
        /// <param name="destination">The destination to fill with data read.</param>
        /// <param name="offset">The offset to start reading at.</param>
        /// <param name="count">The maximum number of bytes to read.</param>
        /// <returns>The actual number of bytes read.</returns>
        int InitialRead(byte[] destination, int offset, int count)
        {
            if (!CanDecompressEntry)
            {
                throw new ZipException("Library cannot extract this entry. Version required is (" + entry.Version.ToString() + ")");
            }

            // Handle encryption if required.
            if (entry.IsCrypted)
            {
#if NETCF_1_0
				throw new ZipException("Encryption not supported for Compact Framework 1.0");
#else
                if (password == null)
                {
                    throw new ZipException("No password set.");
                }

                // Generate and set crypto transform...
                PkzipClassicManaged managed = new PkzipClassicManaged();
                byte[] key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(password));

                inputBuffer.CryptoTransform = managed.CreateDecryptor(key, null);

                byte[] cryptbuffer = new byte[ZipConstants.CryptoHeaderSize];
                inputBuffer.ReadClearTextBuffer(cryptbuffer, 0, ZipConstants.CryptoHeaderSize);

                if (cryptbuffer[ZipConstants.CryptoHeaderSize - 1] != entry.CryptoCheckValue)
                {
                    throw new ZipException("Invalid password");
                }

                if (csize >= ZipConstants.CryptoHeaderSize)
                {
                    csize -= ZipConstants.CryptoHeaderSize;
                }
                else if ((entry.Flags & (int)GeneralBitFlags.Descriptor) == 0)
                {
                    throw new ZipException(string.Format("Entry compressed size {0} too small for encryption", csize));
                }
#endif
            }
            else
            {
#if !NETCF_1_0
                inputBuffer.CryptoTransform = null;
#endif
            }

            if ((csize > 0) || ((flags & (int)GeneralBitFlags.Descriptor) != 0))
            {
                if ((method == (int)CompressionMethod.Deflated) && (inputBuffer.Available > 0))
                {
                    inputBuffer.SetInflaterInput(inf);
                }

                internalReader = new ReadDataHandler(BodyRead);
                return BodyRead(destination, offset, count);
            }
            else
            {
                internalReader = new ReadDataHandler(ReadingNotAvailable);
                return 0;
            }
        }

        /// <summary>
        /// Read a block of bytes from the stream.
        /// </summary>
        /// <param name="buffer">The destination for the bytes.</param>
        /// <param name="offset">The index to start storing data.</param>
        /// <param name="count">The number of bytes to attempt to read.</param>
        /// <returns>Returns the number of bytes read.</returns>
        /// <remarks>Zero bytes read means end of stream.</remarks>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if ((buffer.Length - offset) < count)
            {
                throw new ArgumentException("Invalid offset/count combination");
            }

            return internalReader(buffer, offset, count);
        }

        /// <summary>
        /// Reads a block of bytes from the current zip entry.
        /// </summary>
        /// <returns>
        /// The number of bytes read (this may be less than the length requested, even before the end of stream), or 0 on end of stream.
        /// </returns>
        /// <exception name="IOException">
        /// An i/o error occured.
        /// </exception>
        /// <exception cref="ZipException">
        /// The deflated stream is corrupted.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The stream is not open.
        /// </exception>
        int BodyRead(byte[] buffer, int offset, int count)
        {
            if (crc == null)
            {
                throw new InvalidOperationException("Closed");
            }

            if ((entry == null) || (count <= 0))
            {
                return 0;
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException("Offset + count exceeds buffer size");
            }

            bool finished = false;

            switch (method)
            {
                case (int)CompressionMethod.Deflated:
                    count = base.Read(buffer, offset, count);
                    if (count <= 0)
                    {
                        if (!inf.IsFinished)
                        {
                            throw new ZipException("Inflater not finished!");
                        }
                        inputBuffer.Available = inf.RemainingInput;

                        // A csize of -1 is from an unpatched local header
                        if ((flags & 8) == 0 &&
                            (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size))
                        {
                            throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);
                        }
                        inf.Reset();
                        finished = true;
                    }
                    break;

                case (int)CompressionMethod.Stored:
                    if ((count > csize) && (csize >= 0))
                    {
                        count = (int)csize;
                    }

                    if (count > 0)
                    {
                        count = inputBuffer.ReadClearTextBuffer(buffer, offset, count);
                        if (count > 0)
                        {
                            csize -= count;
                            size -= count;
                        }
                    }

                    if (csize == 0)
                    {
                        finished = true;
                    }
                    else
                    {
                        if (count < 0)
                        {
                            throw new ZipException("EOF in stored block");
                        }
                    }
                    break;
            }

            if (count > 0)
            {
                crc.Update(buffer, offset, count);
            }

            if (finished)
            {
                CompleteCloseEntry(true);
            }

            return count;
        }

        /// <summary>
        /// Closes the zip input stream
        /// </summary>
        public override void Close()
        {
            internalReader = new ReadDataHandler(ReadingNotAvailable);
            crc = null;
            entry = null;

            base.Close();
        }
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Text;

    using ICSharpCode.SharpZipLib.Core;
    /// <summary>
    /// ZipNameTransform transforms names as per the Zip file naming convention.
    /// </summary>
    /// <remarks>The use of absolute names is supported although its use is not valid 
    /// according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
    public class ZipNameTransform : INameTransform
    {
        #region Constructors
        /// <summary>
        /// Initialize a new instance of <see cref="ZipNameTransform"></see>
        /// </summary>
        public ZipNameTransform()
        {
        }

        /// <summary>
        /// Initialize a new instance of <see cref="ZipNameTransform"></see>
        /// </summary>
        /// <param name="trimPrefix">The string to trim from the front of paths if found.</param>
        public ZipNameTransform(string trimPrefix)
        {
            TrimPrefix = trimPrefix;
        }
        #endregion

        /// <summary>
        /// Static constructor.
        /// </summary>
        static ZipNameTransform()
        {
            char[] invalidPathChars;
#if NET_1_0 || NET_1_1 || NETCF_1_0
			invalidPathChars = Path.InvalidPathChars;
#else
            invalidPathChars = Path.GetInvalidPathChars();
#endif
            int howMany = invalidPathChars.Length + 2;

            InvalidEntryCharsRelaxed = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryCharsRelaxed, 0, invalidPathChars.Length);
            InvalidEntryCharsRelaxed[howMany - 1] = '*';
            InvalidEntryCharsRelaxed[howMany - 2] = '?';

            howMany = invalidPathChars.Length + 4;
            InvalidEntryChars = new char[howMany];
            Array.Copy(invalidPathChars, 0, InvalidEntryChars, 0, invalidPathChars.Length);
            InvalidEntryChars[howMany - 1] = ':';
            InvalidEntryChars[howMany - 2] = '\\';
            InvalidEntryChars[howMany - 3] = '*';
            InvalidEntryChars[howMany - 4] = '?';
        }

        /// <summary>
        /// Transform a windows directory name according to the Zip file naming conventions.
        /// </summary>
        /// <param name="name">The directory name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformDirectory(string name)
        {
            name = TransformFile(name);
            if (name.Length > 0)
            {
                if (!name.EndsWith("/"))
                {
                    name += "/";
                }
            }
            else
            {
                throw new ZipException("Cannot have an empty directory name");
            }
            return name;
        }

        /// <summary>
        /// Transform a windows file name according to the Zip file naming conventions.
        /// </summary>
        /// <param name="name">The file name to transform.</param>
        /// <returns>The transformed name.</returns>
        public string TransformFile(string name)
        {
            if (name != null)
            {
                string lowerName = name.ToLower();
                if ((trimPrefix_ != null) && (lowerName.IndexOf(trimPrefix_) == 0))
                {
                    name = name.Substring(trimPrefix_.Length);
                }

                name = name.Replace(@"\", "/");
                name = WindowsPathUtils.DropPathRoot(name);

                // Drop any leading slashes.
                while ((name.Length > 0) && (name[0] == '/'))
                {
                    name = name.Remove(0, 1);
                }

                // Drop any trailing slashes.
                while ((name.Length > 0) && (name[name.Length - 1] == '/'))
                {
                    name = name.Remove(name.Length - 1, 1);
                }

                // Convert consecutive // characters to /
                int index = name.IndexOf("//");
                while (index >= 0)
                {
                    name = name.Remove(index, 1);
                    index = name.IndexOf("//");
                }

                name = MakeValidName(name, '_');
            }
            else
            {
                name = string.Empty;
            }
            return name;
        }

        /// <summary>
        /// Get/set the path prefix to be trimmed from paths if present.
        /// </summary>
        /// <remarks>The prefix is trimmed before any conversion from
        /// a windows path is done.</remarks>
        public string TrimPrefix
        {
            get { return trimPrefix_; }
            set
            {
                trimPrefix_ = value;
                if (trimPrefix_ != null)
                {
                    trimPrefix_ = trimPrefix_.ToLower();
                }
            }
        }

        /// <summary>
        /// Force a name to be valid by replacing invalid characters with a fixed value
        /// </summary>
        /// <param name="name">The name to force valid</param>
        /// <param name="replacement">The replacement character to use.</param>
        /// <returns>Returns a valid name</returns>
        static string MakeValidName(string name, char replacement)
        {
            int index = name.IndexOfAny(InvalidEntryChars);
            if (index >= 0)
            {
                StringBuilder builder = new StringBuilder(name);

                while (index >= 0)
                {
                    builder[index] = replacement;

                    if (index >= name.Length)
                    {
                        index = -1;
                    }
                    else
                    {
                        index = name.IndexOfAny(InvalidEntryChars, index + 1);
                    }
                }
                name = builder.ToString();
            }

            if (name.Length > 0xffff)
            {
                throw new PathTooLongException();
            }

            return name;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a zip entry.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <param name="relaxed">If true checking is relaxed about windows file names and absolute paths.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>Zip path names are actually in Unix format, and should only contain relative paths.
        /// This means that any path stored should not contain a drive or
        /// device letter, or a leading slash.  All slashes should forward slashes '/'.
        /// An empty name is valid for a file where the input comes from standard input.
        /// A null name is not considered valid.
        /// </remarks>
        public static bool IsValidName(string name, bool relaxed)
        {
            bool result = (name != null);

            if (result)
            {
                if (relaxed)
                {
                    result = name.IndexOfAny(InvalidEntryCharsRelaxed) < 0;
                }
                else
                {
                    result =
                        (name.IndexOfAny(InvalidEntryChars) < 0) &&
                        (name.IndexOf('/') != 0);
                }
            }

            return result;
        }

        /// <summary>
        /// Test a name to see if it is a valid name for a zip entry.
        /// </summary>
        /// <param name="name">The name to test.</param>
        /// <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
        /// <remarks>Zip path names are actually in unix format,
        /// and should only contain relative paths if a path is present.
        /// This means that the path stored should not contain a drive or
        /// device letter, or a leading slash.  All slashes should forward slashes '/'.
        /// An empty name is valid where the input comes from standard input.
        /// A null name is not considered valid.
        /// </remarks>
        public static bool IsValidName(string name)
        {
            bool result =
                (name != null) &&
                (name.IndexOfAny(InvalidEntryChars) < 0) &&
                (name.IndexOf('/') != 0)
                ;
            return result;
        }

        #region Instance Fields
        string trimPrefix_;
        #endregion

        #region Class Fields
        static readonly char[] InvalidEntryChars;
        static readonly char[] InvalidEntryCharsRelaxed;
        #endregion
    }
}

namespace ICSharpCode.SharpZipLib.Zip
{
    using System;
    using System.IO;
    using System.Collections;

    using ICSharpCode.SharpZipLib.Checksums;
    using ICSharpCode.SharpZipLib.Zip.Compression;
    using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
    /// <summary>
    /// This is a DeflaterOutputStream that writes the files into a zip
    /// archive one after another.  It has a special method to start a new
    /// zip entry.  The zip entries contains information about the file name
    /// size, compressed size, CRC, etc.
    /// 
    /// It includes support for Stored and Deflated entries.
    /// This class is not thread safe.
    /// <br/>
    /// <br/>Author of the original java version : Jochen Hoenicke
    /// </summary>
    /// <example> This sample shows how to create a zip file
    /// <code>
    /// using System;
    /// using System.IO;
    /// 
    /// using ICSharpCode.SharpZipLib.Core;
    /// using ICSharpCode.SharpZipLib.Zip;
    /// 
    /// class MainClass
    /// {
    /// 	public static void Main(string[] args)
    /// 	{
    /// 		string[] filenames = Directory.GetFiles(args[0]);
    /// 		byte[] buffer = new byte[4096];
    /// 		
    /// 		using ( ZipOutputStream s = new ZipOutputStream(File.Create(args[1])) ) {
    /// 		
    /// 			s.SetLevel(9); // 0 - store only to 9 - means best compression
    /// 		
    /// 			foreach (string file in filenames) {
    /// 				ZipEntry entry = new ZipEntry(file);
    /// 				s.PutNextEntry(entry);
    ///
    /// 				using (FileStream fs = File.OpenRead(file)) {
    ///						StreamUtils.Copy(fs, s, buffer);
    /// 				}
    /// 			}
    /// 		}
    /// 	}
    /// }	
    /// </code>
    /// </example>
    public class ZipOutputStream : DeflaterOutputStream
    {
        #region Constructors
        /// <summary>
        /// Creates a new Zip output stream, writing a zip archive.
        /// </summary>
        /// <param name="baseOutputStream">
        /// The output stream to which the archive contents are written.
        /// </param>
        public ZipOutputStream(Stream baseOutputStream)
            : base(baseOutputStream, new Deflater(Deflater.DEFAULT_COMPRESSION, true))
        {
        }

        /// <summary>
        /// Creates a new Zip output stream, writing a zip archive.
        /// </summary>
        /// <param name="baseOutputStream">The output stream to which the archive contents are written.</param>
        /// <param name="bufferSize">Size of the buffer to use.</param>
        public ZipOutputStream(Stream baseOutputStream, int bufferSize)
            : base(baseOutputStream, new Deflater(Deflater.DEFAULT_COMPRESSION, true), bufferSize)
        {
        }
        #endregion

        /// <summary>
        /// Gets a flag value of true if the central header has been added for this archive; false if it has not been added.
        /// </summary>
        /// <remarks>No further entries can be added once this has been done.</remarks>
        public bool IsFinished
        {
            get
            {
                return entries == null;
            }
        }

        /// <summary>
        /// Set the zip file comment.
        /// </summary>
        /// <param name="comment">
        /// The comment text for the entire archive.
        /// </param>
        /// <exception name ="ArgumentOutOfRangeException">
        /// The converted comment is longer than 0xffff bytes.
        /// </exception>
        public void SetComment(string comment)
        {
            // TODO: Its not yet clear how to handle unicode comments here.
            byte[] commentBytes = ZipConstants.ConvertToArray(comment);
            if (commentBytes.Length > 0xffff)
            {
                throw new ArgumentOutOfRangeException("comment");
            }
            zipComment = commentBytes;
        }

        /// <summary>
        /// Sets the compression level.  The new level will be activated
        /// immediately.
        /// </summary>
        /// <param name="level">The new compression level (1 to 9).</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Level specified is not supported.
        /// </exception>
        /// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Deflater"/>
        public void SetLevel(int level)
        {
            deflater_.SetLevel(level);
            defaultCompressionLevel = level;
        }

        /// <summary>
        /// Get the current deflater compression level
        /// </summary>
        /// <returns>The current compression level</returns>
        public int GetLevel()
        {
            return deflater_.GetLevel();
        }

        /// <summary>
        /// Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
        /// </summary>
        /// <remarks>Older archivers may not understand Zip64 extensions.
        /// If backwards compatability is an issue be careful when adding <see cref="ZipEntry.Size">entries</see> to an archive.
        /// Setting this property to off is workable but less desirable as in those circumstances adding a file
        /// larger then 4GB will fail.</remarks>
        public UseZip64 UseZip64
        {
            get { return useZip64_; }
            set { useZip64_ = value; }
        }

        /// <summary>
        /// Write an unsigned short in little endian byte order.
        /// </summary>
        private void WriteLeShort(int value)
        {
            unchecked
            {
                baseOutputStream_.WriteByte((byte)(value & 0xff));
                baseOutputStream_.WriteByte((byte)((value >> 8) & 0xff));
            }
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        private void WriteLeInt(int value)
        {
            unchecked
            {
                WriteLeShort(value);
                WriteLeShort(value >> 16);
            }
        }

        /// <summary>
        /// Write an int in little endian byte order.
        /// </summary>
        private void WriteLeLong(long value)
        {
            unchecked
            {
                WriteLeInt((int)value);
                WriteLeInt((int)(value >> 32));
            }
        }

        /// <summary>
        /// Starts a new Zip entry. It automatically closes the previous
        /// entry if present.
        /// All entry elements bar name are optional, but must be correct if present.
        /// If the compression method is stored and the output is not patchable
        /// the compression for that entry is automatically changed to deflate level 0
        /// </summary>
        /// <param name="entry">
        /// the entry.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// if entry passed is null.
        /// </exception>
        /// <exception cref="System.IO.IOException">
        /// if an I/O error occured.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        /// if stream was finished
        /// </exception>
        /// <exception cref="ZipException">
        /// Too many entries in the Zip file<br/>
        /// Entry name is too long<br/>
        /// Finish has already been called<br/>
        /// </exception>
        public void PutNextEntry(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }

            if (entries == null)
            {
                throw new InvalidOperationException("ZipOutputStream was finished");
            }

            if (curEntry != null)
            {
                CloseEntry();
            }

            if (entries.Count == int.MaxValue)
            {
                throw new ZipException("Too many entries for Zip file");
            }

            CompressionMethod method = entry.CompressionMethod;
            int compressionLevel = defaultCompressionLevel;

            // Clear flags that the library manages internally
            entry.Flags &= (int)GeneralBitFlags.UnicodeText;
            patchEntryHeader = false;

            bool headerInfoAvailable;

            // No need to compress - definitely no data.
            if (entry.Size == 0)
            {
                entry.CompressedSize = entry.Size;
                entry.Crc = 0;
                method = CompressionMethod.Stored;
                headerInfoAvailable = true;
            }
            else
            {
                headerInfoAvailable = (entry.Size >= 0) && entry.HasCrc;

                // Switch to deflation if storing isnt possible.
                if (method == CompressionMethod.Stored)
                {
                    if (!headerInfoAvailable)
                    {
                        if (!CanPatchEntries)
                        {
                            // Can't patch entries so storing is not possible.
                            method = CompressionMethod.Deflated;
                            compressionLevel = 0;
                        }
                    }
                    else // entry.size must be > 0
                    {
                        entry.CompressedSize = entry.Size;
                        headerInfoAvailable = entry.HasCrc;
                    }
                }
            }

            if (headerInfoAvailable == false)
            {
                if (CanPatchEntries == false)
                {
                    // Only way to record size and compressed size is to append a data descriptor
                    // after compressed data.

                    // Stored entries of this form have already been converted to deflating.
                    entry.Flags |= 8;
                }
                else
                {
                    patchEntryHeader = true;
                }
            }

            if (Password != null)
            {
                entry.IsCrypted = true;
                if (entry.Crc < 0)
                {
                    // Need to append a data descriptor as the crc isnt available for use
                    // with encryption, the date is used instead.  Setting the flag
                    // indicates this to the decompressor.
                    entry.Flags |= 8;
                }
            }

            entry.Offset = offset;
            entry.CompressionMethod = (CompressionMethod)method;

            curMethod = method;
            sizePatchPos = -1;

            if ((useZip64_ == UseZip64.On) || ((entry.Size < 0) && (useZip64_ == UseZip64.Dynamic)))
            {
                entry.ForceZip64();
            }

            // Write the local file header
            WriteLeInt(ZipConstants.LocalHeaderSignature);

            WriteLeShort(entry.Version);
            WriteLeShort(entry.Flags);
            WriteLeShort((byte)entry.CompressionMethodForHeader);
            WriteLeInt((int)entry.DosTime);

            // TODO: Refactor header writing.  Its done in several places.
            if (headerInfoAvailable == true)
            {
                WriteLeInt((int)entry.Crc);
                if (entry.LocalHeaderRequiresZip64)
                {
                    WriteLeInt(-1);
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt(entry.IsCrypted ? (int)entry.CompressedSize + ZipConstants.CryptoHeaderSize : (int)entry.CompressedSize);
                    WriteLeInt((int)entry.Size);
                }
            }
            else
            {
                if (patchEntryHeader)
                {
                    crcPatchPos = baseOutputStream_.Position;
                }
                WriteLeInt(0);	// Crc

                if (patchEntryHeader)
                {
                    sizePatchPos = baseOutputStream_.Position;
                }

                // For local header both sizes appear in Zip64 Extended Information
                if (entry.LocalHeaderRequiresZip64 || patchEntryHeader)
                {
                    WriteLeInt(-1);
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt(0);	// Compressed size
                    WriteLeInt(0);	// Uncompressed size
                }
            }

            byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

            if (name.Length > 0xFFFF)
            {
                throw new ZipException("Entry name too long.");
            }

            ZipExtraData ed = new ZipExtraData(entry.ExtraData);

            if (entry.LocalHeaderRequiresZip64)
            {
                ed.StartNewEntry();
                if (headerInfoAvailable)
                {
                    ed.AddLeLong(entry.Size);
                    ed.AddLeLong(entry.CompressedSize);
                }
                else
                {
                    ed.AddLeLong(-1);
                    ed.AddLeLong(-1);
                }
                ed.AddNewEntry(1);

                if (!ed.Find(1))
                {
                    throw new ZipException("Internal error cant find extra data");
                }

                if (patchEntryHeader)
                {
                    sizePatchPos = ed.CurrentReadIndex;
                }
            }
            else
            {
                ed.Delete(1);
            }

#if !NET_1_1 && !NETCF_2_0
            if (entry.AESKeySize > 0)
            {
                AddExtraDataAES(entry, ed);
            }
#endif
            byte[] extra = ed.GetEntryData();

            WriteLeShort(name.Length);
            WriteLeShort(extra.Length);

            if (name.Length > 0)
            {
                baseOutputStream_.Write(name, 0, name.Length);
            }

            if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)
            {
                sizePatchPos += baseOutputStream_.Position;
            }

            if (extra.Length > 0)
            {
                baseOutputStream_.Write(extra, 0, extra.Length);
            }

            offset += ZipConstants.LocalHeaderBaseSize + name.Length + extra.Length;
            // Fix offsetOfCentraldir for AES
            if (entry.AESKeySize > 0)
                offset += entry.AESOverheadSize;

            // Activate the entry.
            curEntry = entry;
            crc.Reset();
            if (method == CompressionMethod.Deflated)
            {
                deflater_.Reset();
                deflater_.SetLevel(compressionLevel);
            }
            size = 0;

            if (entry.IsCrypted)
            {
#if !NET_1_1 && !NETCF_2_0
                if (entry.AESKeySize > 0)
                {
                    WriteAESHeader(entry);
                }
                else
#endif
                {
                    if (entry.Crc < 0)
                    {			// so testing Zip will says its ok
                        WriteEncryptionHeader(entry.DosTime << 16);
                    }
                    else
                    {
                        WriteEncryptionHeader(entry.Crc);
                    }
                }
            }
        }

        /// <summary>
        /// Closes the current entry, updating header and footer information as required
        /// </summary>
        /// <exception cref="System.IO.IOException">
        /// An I/O error occurs.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        /// No entry is active.
        /// </exception>
        public void CloseEntry()
        {
            if (curEntry == null)
            {
                throw new InvalidOperationException("No open entry");
            }

            long csize = size;

            // First finish the deflater, if appropriate
            if (curMethod == CompressionMethod.Deflated)
            {
                if (size >= 0)
                {
                    base.Finish();
                    csize = deflater_.TotalOut;
                }
                else
                {
                    deflater_.Reset();
                }
            }

            // Write the AES Authentication Code (a hash of the compressed and encrypted data)
            if (curEntry.AESKeySize > 0)
            {
                baseOutputStream_.Write(AESAuthCode, 0, 10);
            }

            if (curEntry.Size < 0)
            {
                curEntry.Size = size;
            }
            else if (curEntry.Size != size)
            {
                throw new ZipException("size was " + size + ", but I expected " + curEntry.Size);
            }

            if (curEntry.CompressedSize < 0)
            {
                curEntry.CompressedSize = csize;
            }
            else if (curEntry.CompressedSize != csize)
            {
                throw new ZipException("compressed size was " + csize + ", but I expected " + curEntry.CompressedSize);
            }

            if (curEntry.Crc < 0)
            {
                curEntry.Crc = crc.Value;
            }
            else if (curEntry.Crc != crc.Value)
            {
                throw new ZipException("crc was " + crc.Value + ", but I expected " + curEntry.Crc);
            }

            offset += csize;

            if (curEntry.IsCrypted)
            {
                if (curEntry.AESKeySize > 0)
                {
                    curEntry.CompressedSize += curEntry.AESOverheadSize;

                }
                else
                {
                    curEntry.CompressedSize += ZipConstants.CryptoHeaderSize;
                }
            }

            // Patch the header if possible
            if (patchEntryHeader)
            {
                patchEntryHeader = false;

                long curPos = baseOutputStream_.Position;
                baseOutputStream_.Seek(crcPatchPos, SeekOrigin.Begin);
                WriteLeInt((int)curEntry.Crc);

                if (curEntry.LocalHeaderRequiresZip64)
                {

                    if (sizePatchPos == -1)
                    {
                        throw new ZipException("Entry requires zip64 but this has been turned off");
                    }

                    baseOutputStream_.Seek(sizePatchPos, SeekOrigin.Begin);
                    WriteLeLong(curEntry.Size);
                    WriteLeLong(curEntry.CompressedSize);
                }
                else
                {
                    WriteLeInt((int)curEntry.CompressedSize);
                    WriteLeInt((int)curEntry.Size);
                }
                baseOutputStream_.Seek(curPos, SeekOrigin.Begin);
            }

            // Add data descriptor if flagged as required
            if ((curEntry.Flags & 8) != 0)
            {
                WriteLeInt(ZipConstants.DataDescriptorSignature);
                WriteLeInt(unchecked((int)curEntry.Crc));

                if (curEntry.LocalHeaderRequiresZip64)
                {
                    WriteLeLong(curEntry.CompressedSize);
                    WriteLeLong(curEntry.Size);
                    offset += ZipConstants.Zip64DataDescriptorSize;
                }
                else
                {
                    WriteLeInt((int)curEntry.CompressedSize);
                    WriteLeInt((int)curEntry.Size);
                    offset += ZipConstants.DataDescriptorSize;
                }
            }

            entries.Add(curEntry);
            curEntry = null;
        }

        void WriteEncryptionHeader(long crcValue)
        {
            offset += ZipConstants.CryptoHeaderSize;

            InitializePassword(Password);

            byte[] cryptBuffer = new byte[ZipConstants.CryptoHeaderSize];
            Random rnd = new Random();
            rnd.NextBytes(cryptBuffer);
            cryptBuffer[11] = (byte)(crcValue >> 24);

            EncryptBlock(cryptBuffer, 0, cryptBuffer.Length);
            baseOutputStream_.Write(cryptBuffer, 0, cryptBuffer.Length);
        }

#if !NET_1_1 && !NETCF_2_0
        private static void AddExtraDataAES(ZipEntry entry, ZipExtraData extraData)
        {

            // Vendor Version: AE-1 IS 1. AE-2 is 2. With AE-2 no CRC is required and 0 is stored.
            const int VENDOR_VERSION = 2;
            // Vendor ID is the two ASCII characters "AE".
            const int VENDOR_ID = 0x4541; //not 6965;
            extraData.StartNewEntry();
            // Pack AES extra data field see http://www.winzip.com/aes_info.htm
            //extraData.AddLeShort(7);							// Data size (currently 7)
            extraData.AddLeShort(VENDOR_VERSION);				// 2 = AE-2
            extraData.AddLeShort(VENDOR_ID);					// "AE"
            extraData.AddData(entry.AESEncryptionStrength);		//  1 = 128, 2 = 192, 3 = 256
            extraData.AddLeShort((int)entry.CompressionMethod); // The actual compression method used to compress the file
            extraData.AddNewEntry(0x9901);
        }

        // Replaces WriteEncryptionHeader for AES
        //
        private void WriteAESHeader(ZipEntry entry)
        {
            byte[] salt;
            byte[] pwdVerifier;
            InitializeAESPassword(entry, Password, out salt, out pwdVerifier);
            // File format for AES:
            // Size (bytes)   Content
            // ------------   -------
            // Variable       Salt value
            // 2              Password verification value
            // Variable       Encrypted file data
            // 10             Authentication code
            //
            // Value in the "compressed size" fields of the local file header and the central directory entry
            // is the total size of all the items listed above. In other words, it is the total size of the
            // salt value, password verification value, encrypted data, and authentication code.
            baseOutputStream_.Write(salt, 0, salt.Length);
            baseOutputStream_.Write(pwdVerifier, 0, pwdVerifier.Length);
        }
#endif

        /// <summary>
        /// Writes the given buffer to the current entry.
        /// </summary>
        /// <param name="buffer">The buffer containing data to write.</param>
        /// <param name="offset">The offset of the first byte to write.</param>
        /// <param name="count">The number of bytes to write.</param>
        /// <exception cref="ZipException">Archive size is invalid</exception>
        /// <exception cref="System.InvalidOperationException">No entry is active.</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (curEntry == null)
            {
                throw new InvalidOperationException("No open entry.");
            }

            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (offset < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
                throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif
            }

            if (count < 0)
            {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
                throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif
            }

            if ((buffer.Length - offset) < count)
            {
                throw new ArgumentException("Invalid offset/count combination");
            }

            crc.Update(buffer, offset, count);
            size += count;

            switch (curMethod)
            {
                case CompressionMethod.Deflated:
                    base.Write(buffer, offset, count);
                    break;

                case CompressionMethod.Stored:
                    if (Password != null)
                    {
                        CopyAndEncrypt(buffer, offset, count);
                    }
                    else
                    {
                        baseOutputStream_.Write(buffer, offset, count);
                    }
                    break;
            }
        }

        void CopyAndEncrypt(byte[] buffer, int offset, int count)
        {
            const int CopyBufferSize = 4096;
            byte[] localBuffer = new byte[CopyBufferSize];
            while (count > 0)
            {
                int bufferCount = (count < CopyBufferSize) ? count : CopyBufferSize;

                Array.Copy(buffer, offset, localBuffer, 0, bufferCount);
                EncryptBlock(localBuffer, 0, bufferCount);
                baseOutputStream_.Write(localBuffer, 0, bufferCount);
                count -= bufferCount;
                offset += bufferCount;
            }
        }

        /// <summary>
        /// Finishes the stream.  This will write the central directory at the
        /// end of the zip file and flush the stream.
        /// </summary>
        /// <remarks>
        /// This is automatically called when the stream is closed.
        /// </remarks>
        /// <exception cref="System.IO.IOException">
        /// An I/O error occurs.
        /// </exception>
        /// <exception cref="ZipException">
        /// Comment exceeds the maximum length<br/>
        /// Entry name exceeds the maximum length
        /// </exception>
        public override void Finish()
        {
            if (entries == null)
            {
                return;
            }

            if (curEntry != null)
            {
                CloseEntry();
            }

            long numEntries = entries.Count;
            long sizeEntries = 0;

            foreach (ZipEntry entry in entries)
            {
                WriteLeInt(ZipConstants.CentralHeaderSignature);
                WriteLeShort(ZipConstants.VersionMadeBy);
                WriteLeShort(entry.Version);
                WriteLeShort(entry.Flags);
                WriteLeShort((short)entry.CompressionMethodForHeader);
                WriteLeInt((int)entry.DosTime);
                WriteLeInt((int)entry.Crc);

                if (entry.IsZip64Forced() ||
                    (entry.CompressedSize >= uint.MaxValue))
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.CompressedSize);
                }

                if (entry.IsZip64Forced() ||
                    (entry.Size >= uint.MaxValue))
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.Size);
                }

                byte[] name = ZipConstants.ConvertToArray(entry.Flags, entry.Name);

                if (name.Length > 0xffff)
                {
                    throw new ZipException("Name too long.");
                }

                ZipExtraData ed = new ZipExtraData(entry.ExtraData);

                if (entry.CentralHeaderRequiresZip64)
                {
                    ed.StartNewEntry();
                    if (entry.IsZip64Forced() ||
                        (entry.Size >= 0xffffffff))
                    {
                        ed.AddLeLong(entry.Size);
                    }

                    if (entry.IsZip64Forced() ||
                        (entry.CompressedSize >= 0xffffffff))
                    {
                        ed.AddLeLong(entry.CompressedSize);
                    }

                    if (entry.Offset >= 0xffffffff)
                    {
                        ed.AddLeLong(entry.Offset);
                    }

                    ed.AddNewEntry(1);
                }
                else
                {
                    ed.Delete(1);
                }

#if !NET_1_1 && !NETCF_2_0
                if (entry.AESKeySize > 0)
                {
                    AddExtraDataAES(entry, ed);
                }
#endif
                byte[] extra = ed.GetEntryData();

                byte[] entryComment =
                    (entry.Comment != null) ?
                    ZipConstants.ConvertToArray(entry.Flags, entry.Comment) :
                    new byte[0];

                if (entryComment.Length > 0xffff)
                {
                    throw new ZipException("Comment too long.");
                }

                WriteLeShort(name.Length);
                WriteLeShort(extra.Length);
                WriteLeShort(entryComment.Length);
                WriteLeShort(0);	// disk number
                WriteLeShort(0);	// internal file attributes
                // external file attributes

                if (entry.ExternalFileAttributes != -1)
                {
                    WriteLeInt(entry.ExternalFileAttributes);
                }
                else
                {
                    if (entry.IsDirectory)
                    {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)
                        WriteLeInt(16);
                    }
                    else
                    {
                        WriteLeInt(0);
                    }
                }

                if (entry.Offset >= uint.MaxValue)
                {
                    WriteLeInt(-1);
                }
                else
                {
                    WriteLeInt((int)entry.Offset);
                }

                if (name.Length > 0)
                {
                    baseOutputStream_.Write(name, 0, name.Length);
                }

                if (extra.Length > 0)
                {
                    baseOutputStream_.Write(extra, 0, extra.Length);
                }

                if (entryComment.Length > 0)
                {
                    baseOutputStream_.Write(entryComment, 0, entryComment.Length);
                }

                sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;
            }

            using (ZipHelperStream zhs = new ZipHelperStream(baseOutputStream_))
            {
                zhs.WriteEndOfCentralDirectory(numEntries, sizeEntries, offset, zipComment);
            }

            entries = null;
        }

        #region Instance Fields
        /// <summary>
        /// The entries for the archive.
        /// </summary>
        ArrayList entries = new ArrayList();

        /// <summary>
        /// Used to track the crc of data added to entries.
        /// </summary>
        Crc32 crc = new Crc32();

        /// <summary>
        /// The current entry being added.
        /// </summary>
        ZipEntry curEntry;

        int defaultCompressionLevel = Deflater.DEFAULT_COMPRESSION;

        CompressionMethod curMethod = CompressionMethod.Deflated;

        /// <summary>
        /// Used to track the size of data for an entry during writing.
        /// </summary>
        long size;

        /// <summary>
        /// Offset to be recorded for each entry in the central header.
        /// </summary>
        long offset;

        /// <summary>
        /// Comment for the entire archive recorded in central header.
        /// </summary>
        byte[] zipComment = new byte[0];

        /// <summary>
        /// Flag indicating that header patching is required for the current entry.
        /// </summary>
        bool patchEntryHeader;

        /// <summary>
        /// Position to patch crc
        /// </summary>
        long crcPatchPos = -1;

        /// <summary>
        /// Position to patch size.
        /// </summary>
        long sizePatchPos = -1;

        // Default is dynamic which is not backwards compatible and can cause problems
        // with XP's built in compression which cant read Zip64 archives.
        // However it does avoid the situation were a large file is added and cannot be completed correctly.
        // NOTE: Setting the size for entries before they are added is the best solution!
        UseZip64 useZip64_ = UseZip64.Dynamic;
        #endregion
    }
}

#if !NET_1_1 && !NETCF_2_0
namespace ICSharpCode.SharpZipLib.Encryption
{

    // Framework version 2.0 required for Rfc2898DeriveBytes 

    using System;
    using System.Security.Cryptography;
    /// <summary>
    /// Transforms stream using AES in CTR mode
    /// </summary>
    internal class ZipAESTransform : ICryptoTransform
    {

        private const int PWD_VER_LENGTH = 2;

        // WinZip use iteration count of 1000 for PBKDF2 key generation
        private const int KEY_ROUNDS = 1000;

        // For 128-bit AES (16 bytes) the encryption is implemented as expected.
        // For 256-bit AES (32 bytes) WinZip do full 256 bit AES of the nonce to create the encryption
        // block but use only the first 16 bytes of it, and discard the second half.
        private const int ENCRYPT_BLOCK = 16;

        private int _blockSize;
        private ICryptoTransform _encryptor;
        private readonly byte[] _counterNonce;
        private byte[] _encryptBuffer;
        private int _encrPos;
        private byte[] _pwdVerifier;
        private HMACSHA1 _hmacsha1;
        private bool _finalised;

        private bool _writeMode;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="key">Password string</param>
        /// <param name="saltBytes">Random bytes, length depends on encryption strength.
        /// 128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.</param>
        /// <param name="blockSize">The encryption strength, in bytes eg 16 for 128 bits.</param>
        /// <param name="writeMode">True when creating a zip, false when reading. For the AuthCode.</param>
        ///
        public ZipAESTransform(string key, byte[] saltBytes, int blockSize, bool writeMode)
        {

            if (blockSize != 16 && blockSize != 32)	// 24 valid for AES but not supported by Winzip
                throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
            if (saltBytes.Length != blockSize / 2)
                throw new Exception("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);
            // initialise the encryption buffer and buffer pos
            _blockSize = blockSize;
            _encryptBuffer = new byte[_blockSize];
            _encrPos = ENCRYPT_BLOCK;

            // Performs the equivalent of derive_key in Dr Brian Gladman's pwd2key.c
            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(key, saltBytes, KEY_ROUNDS);
            RijndaelManaged rm = new RijndaelManaged();
            rm.Mode = CipherMode.ECB;			// No feedback from cipher for CTR mode
            _counterNonce = new byte[_blockSize];
            byte[] byteKey1 = pdb.GetBytes(_blockSize);
            byte[] byteKey2 = pdb.GetBytes(_blockSize);
            _encryptor = rm.CreateEncryptor(byteKey1, byteKey2);
            _pwdVerifier = pdb.GetBytes(PWD_VER_LENGTH);
            //
            _hmacsha1 = new HMACSHA1(byteKey2);
            _writeMode = writeMode;
        }

        /// <summary>
        /// Implement the ICryptoTransform method.
        /// </summary>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {

            // Pass the data stream to the hash algorithm for generating the Auth Code.
            // This does not change the inputBuffer. Do this before decryption for read mode.
            if (!_writeMode)
            {
                _hmacsha1.TransformBlock(inputBuffer, inputOffset, inputCount, inputBuffer, inputOffset);
            }
            // Encrypt with AES in CTR mode. Regards to Dr Brian Gladman for this.
            int ix = 0;
            while (ix < inputCount)
            {
                if (_encrPos == ENCRYPT_BLOCK)
                {
                    /* increment encryption nonce   */
                    int j = 0;
                    while (++_counterNonce[j] == 0)
                    {
                        ++j;
                    }
                    /* encrypt the nonce to form next xor buffer    */
                    _encryptor.TransformBlock(_counterNonce, 0, _blockSize, _encryptBuffer, 0);
                    _encrPos = 0;
                }
                outputBuffer[ix + outputOffset] = (byte)(inputBuffer[ix + inputOffset] ^ _encryptBuffer[_encrPos++]);
                //
                ix++;
            }
            if (_writeMode)
            {
                // This does not change the buffer. 
                _hmacsha1.TransformBlock(outputBuffer, outputOffset, inputCount, outputBuffer, outputOffset);
            }
            return inputCount;
        }

        /// <summary>
        /// Returns the 2 byte password verifier
        /// </summary>
        public byte[] PwdVerifier
        {
            get
            {
                return _pwdVerifier;
            }
        }

        /// <summary>
        /// Returns the 10 byte AUTH CODE to be checked or appended immediately following the AES data stream.
        /// </summary>
        public byte[] GetAuthCode()
        {
            // We usually don't get advance notice of final block. Hash requres a TransformFinal.
            if (!_finalised)
            {
                byte[] dummy = new byte[0];
                _hmacsha1.TransformFinalBlock(dummy, 0, 0);
                _finalised = true;
            }
            return _hmacsha1.Hash;
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Not implemented.
        /// </summary>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {

            throw new NotImplementedException("ZipAESTransform.TransformFinalBlock");
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return _blockSize;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return _blockSize;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            _encryptor.Dispose();
        }

        #endregion

    }
}
#endif


#if !NET_1_1 && !NETCF_2_0
namespace ICSharpCode.SharpZipLib.Encryption
{
    using System;
    using System.IO;
    using System.Security.Cryptography;
    // Based on information from http://www.winzip.com/aes_info.htm
    // and http://www.gladman.me.uk/cryptography_technology/fileencrypt/

    /// <summary>
    /// Encrypts and decrypts AES ZIP
    /// </summary>
    internal class ZipAESStream : CryptoStream
    {

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="stream">The stream on which to perform the cryptographic transformation.</param>
        /// <param name="transform">Instance of ZipAESTransform</param>
        /// <param name="mode">Read or Write</param>
        public ZipAESStream(Stream stream, ZipAESTransform transform, CryptoStreamMode mode)
            : base(stream, transform, mode)
        {

            _stream = stream;
            _transform = transform;
            _slideBuffer = new byte[1024];

            _blockAndAuth = CRYPTO_BLOCK_SIZE + AUTH_CODE_LENGTH;

            // mode:
            //  CryptoStreamMode.Read means we read from "stream" and pass decrypted to our Read() method.
            //  Write bypasses this stream and uses the Transform directly.
            if (mode != CryptoStreamMode.Read)
            {
                throw new Exception("ZipAESStream only for read");
            }
        }

        // The final n bytes of the AES stream contain the Auth Code.
        private const int AUTH_CODE_LENGTH = 10;

        private Stream _stream;
        private ZipAESTransform _transform;
        private byte[] _slideBuffer;
        private int _slideBufStartPos;
        private int _slideBufFreePos;
        // Blocksize is always 16 here, even for AES-256 which has transform.InputBlockSize of 32.
        private const int CRYPTO_BLOCK_SIZE = 16;
        private int _blockAndAuth;

        /// <summary>
        /// Reads a sequence of bytes from the current CryptoStream into buffer,
        /// and advances the position within the stream by the number of bytes read.
        /// </summary>
        public override int Read(byte[] outBuffer, int offset, int count)
        {
            int nBytes = 0;
            while (nBytes < count)
            {
                // Calculate buffer quantities vs read-ahead size, and check for sufficient free space
                int byteCount = _slideBufFreePos - _slideBufStartPos;

                // Need to handle final block and Auth Code specially, but don't know total data length.
                // Maintain a read-ahead equal to the length of (crypto block + Auth Code). 
                // When that runs out we can detect these final sections.
                int lengthToRead = _blockAndAuth - byteCount;
                if (_slideBuffer.Length - _slideBufFreePos < lengthToRead)
                {
                    // Shift the data to the beginning of the buffer
                    int iTo = 0;
                    for (int iFrom = _slideBufStartPos; iFrom < _slideBufFreePos; iFrom++, iTo++)
                    {
                        _slideBuffer[iTo] = _slideBuffer[iFrom];
                    }
                    _slideBufFreePos -= _slideBufStartPos;		// Note the -=
                    _slideBufStartPos = 0;
                }
                int obtained = _stream.Read(_slideBuffer, _slideBufFreePos, lengthToRead);
                _slideBufFreePos += obtained;

                // Recalculate how much data we now have
                byteCount = _slideBufFreePos - _slideBufStartPos;
                if (byteCount >= _blockAndAuth)
                {
                    // At least a 16 byte block and an auth code remains.
                    _transform.TransformBlock(_slideBuffer,
                                              _slideBufStartPos,
                                              CRYPTO_BLOCK_SIZE,
                                              outBuffer,
                                              offset);
                    nBytes += CRYPTO_BLOCK_SIZE;
                    offset += CRYPTO_BLOCK_SIZE;
                    _slideBufStartPos += CRYPTO_BLOCK_SIZE;
                }
                else
                {
                    // Last round.
                    if (byteCount > AUTH_CODE_LENGTH)
                    {
                        // At least one byte of data plus auth code
                        int finalBlock = byteCount - AUTH_CODE_LENGTH;
                        _transform.TransformBlock(_slideBuffer,
                                                  _slideBufStartPos,
                                                  finalBlock,
                                                  outBuffer,
                                                  offset);

                        nBytes += finalBlock;
                        _slideBufStartPos += finalBlock;
                    }
                    else if (byteCount < AUTH_CODE_LENGTH)
                        throw new Exception("Internal error missed auth code");	// Coding bug
                    // Final block done. Check Auth code.
                    byte[] calcAuthCode = _transform.GetAuthCode();
                    for (int i = 0; i < AUTH_CODE_LENGTH; i++)
                    {
                        if (calcAuthCode[i] != _slideBuffer[_slideBufStartPos + i])
                        {
                            throw new Exception("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n"
                                + "The file may be damaged.");
                        }
                    }

                    break;	// Reached the auth code
                }
            }
            return nBytes;
        }

        /// <summary>
        /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream. </param>
        /// <param name="offset">The byte offset in buffer at which to begin copying bytes to the current stream. </param>
        /// <param name="count">The number of bytes to be written to the current stream. </param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            // ZipAESStream is used for reading but not for writing. Writing uses the ZipAESTransform directly.
            throw new NotImplementedException();
        }
    }
}
#endif

#if !NETCF_1_0
namespace ICSharpCode.SharpZipLib.Encryption
{
    using System;
    using System.Security.Cryptography;
    using ICSharpCode.SharpZipLib.Checksums;
    /// <summary>
    /// PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
    /// While it has been superceded by more recent and more powerful algorithms, its still in use and 
    /// is viable for preventing casual snooping
    /// </summary>
    public abstract class PkzipClassic : SymmetricAlgorithm
    {
        /// <summary>
        /// Generates new encryption keys based on given seed
        /// </summary>
        /// <param name="seed">The seed value to initialise keys with.</param>
        /// <returns>A new key value.</returns>
        static public byte[] GenerateKeys(byte[] seed)
        {
            if (seed == null)
            {
                throw new ArgumentNullException("seed");
            }

            if (seed.Length == 0)
            {
                throw new ArgumentException("Length is zero", "seed");
            }

            uint[] newKeys = new uint[] {
				0x12345678,
				0x23456789,
				0x34567890
			 };

            for (int i = 0; i < seed.Length; ++i)
            {
                newKeys[0] = Crc32.ComputeCrc32(newKeys[0], seed[i]);
                newKeys[1] = newKeys[1] + (byte)newKeys[0];
                newKeys[1] = newKeys[1] * 134775813 + 1;
                newKeys[2] = Crc32.ComputeCrc32(newKeys[2], (byte)(newKeys[1] >> 24));
            }

            byte[] result = new byte[12];
            result[0] = (byte)(newKeys[0] & 0xff);
            result[1] = (byte)((newKeys[0] >> 8) & 0xff);
            result[2] = (byte)((newKeys[0] >> 16) & 0xff);
            result[3] = (byte)((newKeys[0] >> 24) & 0xff);
            result[4] = (byte)(newKeys[1] & 0xff);
            result[5] = (byte)((newKeys[1] >> 8) & 0xff);
            result[6] = (byte)((newKeys[1] >> 16) & 0xff);
            result[7] = (byte)((newKeys[1] >> 24) & 0xff);
            result[8] = (byte)(newKeys[2] & 0xff);
            result[9] = (byte)((newKeys[2] >> 8) & 0xff);
            result[10] = (byte)((newKeys[2] >> 16) & 0xff);
            result[11] = (byte)((newKeys[2] >> 24) & 0xff);
            return result;
        }
    }

    /// <summary>
    /// PkzipClassicCryptoBase provides the low level facilities for encryption
    /// and decryption using the PkzipClassic algorithm.
    /// </summary>
    class PkzipClassicCryptoBase
    {
        /// <summary>
        /// Transform a single byte 
        /// </summary>
        /// <returns>
        /// The transformed value
        /// </returns>
        protected byte TransformByte()
        {
            uint temp = ((keys[2] & 0xFFFF) | 2);
            return (byte)((temp * (temp ^ 1)) >> 8);
        }

        /// <summary>
        /// Set the key schedule for encryption/decryption.
        /// </summary>
        /// <param name="keyData">The data use to set the keys from.</param>
        protected void SetKeys(byte[] keyData)
        {
            if (keyData == null)
            {
                throw new ArgumentNullException("keyData");
            }

            if (keyData.Length != 12)
            {
                throw new InvalidOperationException("Key length is not valid");
            }

            keys = new uint[3];
            keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
            keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
            keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
        }

        /// <summary>
        /// Update encryption keys 
        /// </summary>		
        protected void UpdateKeys(byte ch)
        {
            keys[0] = Crc32.ComputeCrc32(keys[0], ch);
            keys[1] = keys[1] + (byte)keys[0];
            keys[1] = keys[1] * 134775813 + 1;
            keys[2] = Crc32.ComputeCrc32(keys[2], (byte)(keys[1] >> 24));
        }

        /// <summary>
        /// Reset the internal state.
        /// </summary>
        protected void Reset()
        {
            keys[0] = 0;
            keys[1] = 0;
            keys[2] = 0;
        }

        #region Instance Fields
        uint[] keys;
        #endregion
    }

    /// <summary>
    /// PkzipClassic CryptoTransform for encryption.
    /// </summary>
    class PkzipClassicEncryptCryptoTransform : PkzipClassicCryptoBase, ICryptoTransform
    {
        /// <summary>
        /// Initialise a new instance of <see cref="PkzipClassicEncryptCryptoTransform"></see>
        /// </summary>
        /// <param name="keyBlock">The key block to use.</param>
        internal PkzipClassicEncryptCryptoTransform(byte[] keyBlock)
        {
            SetKeys(keyBlock);
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Transforms the specified region of the specified byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the byte array to use as data.</param>
        /// <returns>The computed transform.</returns>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {
            byte[] result = new byte[inputCount];
            TransformBlock(inputBuffer, inputOffset, inputCount, result, 0);
            return result;
        }

        /// <summary>
        /// Transforms the specified region of the input byte array and copies 
        /// the resulting transform to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write the transform.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>The number of bytes written.</returns>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            for (int i = inputOffset; i < inputOffset + inputCount; ++i)
            {
                byte oldbyte = inputBuffer[i];
                outputBuffer[outputOffset++] = (byte)(inputBuffer[i] ^ TransformByte());
                UpdateKeys(oldbyte);
            }
            return inputCount;
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            Reset();
        }

        #endregion
    }


    /// <summary>
    /// PkzipClassic CryptoTransform for decryption.
    /// </summary>
    class PkzipClassicDecryptCryptoTransform : PkzipClassicCryptoBase, ICryptoTransform
    {
        /// <summary>
        /// Initialise a new instance of <see cref="PkzipClassicDecryptCryptoTransform"></see>.
        /// </summary>
        /// <param name="keyBlock">The key block to decrypt with.</param>
        internal PkzipClassicDecryptCryptoTransform(byte[] keyBlock)
        {
            SetKeys(keyBlock);
        }

        #region ICryptoTransform Members

        /// <summary>
        /// Transforms the specified region of the specified byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the byte array to use as data.</param>
        /// <returns>The computed transform.</returns>
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
        {
            byte[] result = new byte[inputCount];
            TransformBlock(inputBuffer, inputOffset, inputCount, result, 0);
            return result;
        }

        /// <summary>
        /// Transforms the specified region of the input byte array and copies 
        /// the resulting transform to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input for which to compute the transform.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write the transform.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>The number of bytes written.</returns>
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            for (int i = inputOffset; i < inputOffset + inputCount; ++i)
            {
                byte newByte = (byte)(inputBuffer[i] ^ TransformByte());
                outputBuffer[outputOffset++] = newByte;
                UpdateKeys(newByte);
            }
            return inputCount;
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        public bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets the size of the input data blocks in bytes.
        /// </summary>
        public int InputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets the size of the output data blocks in bytes.
        /// </summary>
        public int OutputBlockSize
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Cleanup internal state.
        /// </summary>
        public void Dispose()
        {
            Reset();
        }

        #endregion
    }

    /// <summary>
    /// Defines a wrapper object to access the Pkzip algorithm. 
    /// This class cannot be inherited.
    /// </summary>
    public sealed class PkzipClassicManaged : PkzipClassic
    {
        /// <summary>
        /// Get / set the applicable block size in bits.
        /// </summary>
        /// <remarks>The only valid block size is 8.</remarks>
        public override int BlockSize
        {
            get
            {
                return 8;
            }

            set
            {
                if (value != 8)
                {
                    throw new CryptographicException("Block size is invalid");
                }
            }
        }

        /// <summary>
        /// Get an array of legal <see cref="KeySizes">key sizes.</see>
        /// </summary>
        public override KeySizes[] LegalKeySizes
        {
            get
            {
                KeySizes[] keySizes = new KeySizes[1];
                keySizes[0] = new KeySizes(12 * 8, 12 * 8, 0);
                return keySizes;
            }
        }

        /// <summary>
        /// Generate an initial vector.
        /// </summary>
        public override void GenerateIV()
        {
            // Do nothing.
        }

        /// <summary>
        /// Get an array of legal <see cref="KeySizes">block sizes</see>.
        /// </summary>
        public override KeySizes[] LegalBlockSizes
        {
            get
            {
                KeySizes[] keySizes = new KeySizes[1];
                keySizes[0] = new KeySizes(1 * 8, 1 * 8, 0);
                return keySizes;
            }
        }

        /// <summary>
        /// Get / set the key value applicable.
        /// </summary>
        public override byte[] Key
        {
            get
            {
                if (key_ == null)
                {
                    GenerateKey();
                }

                return (byte[])key_.Clone();
            }

            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                if (value.Length != 12)
                {
                    throw new CryptographicException("Key size is illegal");
                }

                key_ = (byte[])value.Clone();
            }
        }

        /// <summary>
        /// Generate a new random key.
        /// </summary>
        public override void GenerateKey()
        {
            key_ = new byte[12];
            Random rnd = new Random();
            rnd.NextBytes(key_);
        }

        /// <summary>
        /// Create an encryptor.
        /// </summary>
        /// <param name="rgbKey">The key to use for this encryptor.</param>
        /// <param name="rgbIV">Initialisation vector for the new encryptor.</param>
        /// <returns>Returns a new PkzipClassic encryptor</returns>
        public override ICryptoTransform CreateEncryptor(
            byte[] rgbKey,
            byte[] rgbIV)
        {
            key_ = rgbKey;
            return new PkzipClassicEncryptCryptoTransform(Key);
        }

        /// <summary>
        /// Create a decryptor.
        /// </summary>
        /// <param name="rgbKey">Keys to use for this new decryptor.</param>
        /// <param name="rgbIV">Initialisation vector for the new decryptor.</param>
        /// <returns>Returns a new decryptor.</returns>
        public override ICryptoTransform CreateDecryptor(
            byte[] rgbKey,
            byte[] rgbIV)
        {
            key_ = rgbKey;
            return new PkzipClassicDecryptCryptoTransform(Key);
        }

        #region Instance Fields
        byte[] key_;
        #endregion
    }
}
#endif]]></ProjectItem>
                  <ProjectItem
                    Name="Project"
                    Encoding="UTF16LE"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="4.0" schemaVersion="1.0">
	<msb:PropertyGroup>
		<msb:CodeName>st_7cba1a05836245c19b25f058965b1d94</msb:CodeName>
		<msb:Language>msBuild</msb:Language>
		<msb:DisplayName>st_7cba1a05836245c19b25f058965b1d94</msb:DisplayName>
		<msb:ProjectId>{26888578-91D8-4CCA-9E6E-400A3A870FD0}</msb:ProjectId>
	</msb:PropertyGroup>
	<msb:ItemGroup>
		<msb:Project Include="st_7cba1a05836245c19b25f058965b1d94.csproj"/>
		<msb:File Include="Properties\Settings.settings"/>
		<msb:File Include="Properties\AssemblyInfo.cs"/>
		<msb:File Include="Properties\Resources.resx"/>
		<msb:File Include="Properties\Resources.Designer.cs"/>
		<msb:File Include="Properties\Settings.Designer.cs"/>
		<msb:File Include="ScriptMain.cs"/>
	</msb:ItemGroup>
</c:Project>]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Settings.Designer.cs"
                    Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Settings.get_Default():ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Sett" +
    "ings")]

namespace ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties
{


    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Settings.settings"
                    Encoding="UTF8"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem>
                  <ProjectItem
                    Name="Properties\Resources.Designer.cs"
                    Encoding="UTF8"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_7cba1a05836245c19b25f058965b1d94.csproj.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem>
                  <BinaryItem
                    Name="ST_7cba1a05836245c19b25f058965b1d94.csproj.dll">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
WQAACioAAAATMAQAPwAAAFUAABEEBWpZCgYWai8DFWoqBg4EalkWaijTAAAKCwYHLwMVaioCBiUX
alkKFm+rAAAKJgIoJgIABgMz4gJvXgAACioAEzACAHsAAAA5AAARAnsUAQAEb14AAAoKAiBQSwYG
KCoCAAYCHyxqKCwCAAYCHzMoKAIABgIfLSgoAgAGAhYoKgIABgIWKCoCAAYCAygsAgAGAgMoLAIA
BgIEKCwCAAYCBSgsAgAGAiBQSwYHKCoCAAYCFigqAgAGAgYoLAIABgIXKCoCAAYqABMwBADVAAAA
FgAAEQMg//8AAGovCgUVbi8FBBVuMgkCAwQFKCMCAAYCIFBLBQYoKgIABgIWKCgCAAYCFigoAgAG
AyD//wAAajIYAiD//wAAKCkCAAYCIP//AAAoKQIABisQAgNoKCgCAAYCA2goKAIABgQVbjIJAhUo
KwIABisIAgRpKCoCAAYFFW4yCQIVKCsCAAYrCAIFaSgqAgAGDgQtAxYrBA4EjmkKBiD//wAAMRZy
ZR8AcAaMPwAAASi3AAAKcyYBAAZ6AgYoKAIABgYWMQ0CDgQWDgSOaW9ZAAAKKgAAABMwAwAwAAAA
FgAAEQJ7FAEABG+lAAAKJRYvBnNYAAAKegJ7FAEABG+lAAAKCgYWLwZzWAAACnoGHmJgKkYCKCUC
AAYCKCUCAAYfEGJgKk4CKCYCAAZuAigmAgAGah8gYmAqpgJ7FAEABAMg/wAAAF/Sb6cAAAoCexQB
AAQDHmMg/wAAAF/Sb6cAAAoqjgJ7FAEABAMg/wAAAF/Sb6cAAAoCexQBAAQDHmPSb6cAAAoqSgID
KCgCAAYCAx8QYygoAgAGKmoCAyD//wAAX9EoKQIABgIDHxBk0SgpAgAGKlICA2koKgIABgIDHyBj
aSgqAgAGKl4CAxVuX20oKwIABgIDHyBkbSgrAgAGKgATMAIAfQAAABYAABEDLQtyOAYAcHMsAAAK
ehYKA2/eAAAGHl8sYQIgUEsHCCgqAgAGAgNv+gAABmkoKgIABgYeWAoDb+8AAAYsHwIDb/gAAAYo
LAIABgIDb/YAAAYoLAIABgYfEFgKKx4CA2/4AAAGaSgqAgAGAgNv9gAABmkoKgIABgYeWAoGKgAA
ABMwAgBcAAAAAAAAAAIoJgIABiBQSwcILgtyxR8AcHMmAQAGegQCKCYCAAZqbwkCAAYDLBkEAign
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
VgIoGgAACgIDfSwCAAQCF30uAgAEKjoCKBoAAAoCA30tAgAEKh4Cey4CAAQqPgIoaQMABgJ7LQIA
BI5pKl4CKGkDAAYCey0CAARvNAAACnQBAAAbKmICey4CAAQsCAIUfS0CAAQqAhR9LAIABCpqAnss
AgAELRECAnstAgAEKMwAAAZ9LAIABCpqAnstAgAELRECAnssAgAEKM8AAAZ9LQIABCo2Am9oAwAG
AnssAgAEKlYCFX0wAgAEAigaAAAKAgN9LwIABCo6AnsvAgAEAnswAgAEmioiAhV9MAIABCoTMAMA
HAAAABYAABECAnswAgAEF1gKBn0wAgAEBgJ7LwIABI5p/gQqOgIo0AAACgIDfTECAAQqMgJ7MQIA
BG9aAAAKKjICezECAARvsgAACioOFmoqMgJ7MQIABG9eAAAKKj4CezECAAQDBAVvWQAACir2AijQ
AAAKAgR9NAIABAIFfTUCAAQCA30yAgAEAgJ7MgIABHv1AAAEfTMCAAQCBH02AgAEAgQFWH03AgAE
KhswBABaAAAAcgAAEQJ7NgIABAJ7NwIABDICFSoCezMCAAQKFgsGEgEouAAACgJ7MwIABAICezYC
AAQMCBdqWH02AgAECBZvqwAACiYCezMCAARvpQAACg3eCgcsBgYougAACtwJKgAAARAAAAIAGQA1
TgAKAAAAABswBAB+AAAAcwAAEQJ7MwIABAoWCwYSASi4AAAKBWoCezcCAAQCezYCAARZMRcCezcC
AAQCezYCAARZaRADBS0EFg3eQwJ7MwIABAJ7NgIABBZvqwAACiYCezMCAAQDBAVvKgAACgwIFjEP
AgJ7NgIABAhqWH02AgAECA3eCgcsBgYougAACtwJKgAAARAAAAIACQBpcgAKAAAAABpz6AAACnoA
EzACAHAAAAA5AAARAns2AgAECgRFAwAAAAIAAAANAAAAGAAAACsfAns0AgAEA1gKKxQCezYCAAQD
WAorCQJ7NwIABANYCgYCezQCAAQvC3KHMgBwc34AAAp6BgJ7NwIABDILcsEyAHBz6QAACnoCBn02
AgAEAns2AgAEKjoCezYCAAQCezQCAARZKgATMAIAOQAAADkAABECezQCAAQDWAoGAns0AgAELwty
hzIAcHN+AAAKegYCezcCAAQyC3LBMgBwczAAAAp6AgZ9NgIABCoeAns1AgAEKjICezMCAARv0gAA
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
BI8/AAABJUoXWVQCez0CAAQRBBdYJRMEjz8AAAElShdYVAgXAns+AgAEF1kRBFkfH19iWQwIFjEM
EQQCez4CAAQXWTK0CBYwoAJ7PQIABAJ7PgIABBdZjz8AAAElSghYVAJ7PQIABAJ7PgIABBhZjz8A
AAElSghZVBgHWhMFAns+AgAEEwsrRAJ7PQIABBELF1mUEwwrKhgDEQUlF1gTBZRaEw0DEQ0XWJQV
MxQCezkCAAQDEQ2UEQvSnBEMF1kTDBEMFjDREQsXWRMLEQstuCoAAABCU0pCAQABAAAAAAAMAAAA
djQuMC4zMDMxOQAAAAAFAGwAAACseQAAI34AABh6AABcSgAAI1N0cmluZ3MAAAAAdMQAACwzAAAj
VVMAoPcAABAAAAAjR1VJRAAAALD3AADoFAAAI0Jsb2IAAAAAAAAAAgAAAVefoisJCwAAAPoBMwAW
AAABAAAAbgAAAHMAAABCAgAAmQMAAIoDAAAaAAAA6QAAANAAAAArAAAABwAAAHYAAAA1AAAA2AAA
AC8BAAACAAAAAgAAABAAAAABAAAABAAAAAEAAAAYAAAAAQAAAAAASCoBAAAAAAAGAG8g3DcGAP4g
3DcGAIMfoTcPAME4AAAGALAfty8GACwgty8GAA0gty8GAOUgty8GAI8gty8GAKggty8GANkfty8G
APQf4SQGAA8xYiwGAOoxiy8GAP5Eiy8GAGIxYiwGAP4/YiwGACgt5kYGAJUXYiwGAH0A5kYGANA6
5kYGAIYR5kYGACwr5kYGAA0sOAgGAD4V5kYGAGks5kYGADs75kYGAMw7YiwGALkeYiwGAFhBYiwG
ADkoYiwGANRDAz0GAFoxYiwGAMkzlUQGAOY2Az0GAKAZYiwGAMYxOAgGAMcfYiwGADsuYiwGAMMq
OAgGADM6OAgGAK4tYiwGAGAgYiwGAPsWYiwGABQyOAgGAAcsOAgGAEkgty8GAIkXAz0GAKEXAz0G
APA1Az0GAJsuOAgGALAz5kYKAMMgGikKAEIdGikGAGYfoTcGAIM0/DcGAM8xdi8OANseAioOAJcf
AioOAHUdYS8GAEsf3DcGAG4bYiwGAOMAYiwGAEwlYiwGAFohYiwGAE8V5kYGANc65kYGAHws5kYG
AG8wYiwGAOQwYiwGAOIAYiwGAK493DcGAFRGYiwGAKsXYiwGACQxYiwGAEAw5kYGAJ4sYiwGAOdI
OAgOANNF5DwOABY95DwGAK4yYiwGAHMbYiwGAL4XYiwGALImOAgGANsxOAgGAJ0wYiwGAPowOAgG
AFIYOAgGAMIeYiwGAAEVOAgGAMs9OAgGAHgbOAgGAM8wOAgGALAklUQGADQRhCQGAAAydi8GAJ4m
YiwGAIcwYiwGAHEEYiwGAFcwYiwGADY3hCQGAEQCYiwGACUDYiwGAEMCYiwGABM35kYKAPApGikS
AKI5GxsSAAYXGxsGAAdHty8GACYwOAgAAAAAEgQAAAAAAQABAAEgEAC5MA4QNQABAAEAAAAQAKks
djFFAAEABQAAABAAoyp2MV0ADQAPAIEAEAA3EHYxaQAVABIAAAAQAF4ddjFFABUAFAAAABAAcC12
MRgAFgAZAAAAEABNLXYxGAAWACEAAQEQAHIRdjEUABYAKQABABAAozuKG3EAFwA0AAEAEACxO4ob
cQAZADgAAQAQAMM7ihsoAB0APwABABAAjjuKG3EAHgBBAAEBAACUNYobdQAhAEYAAQEAAPo0iht1
ACEASgABAQAAODWKG3UAIQBOAAEBAADlNIobdQAhAFIAAQEAACA1iht1ACEAVgABAQAADTWKG3UA
IQBaAAEAEACsNYobRQAhAF4AoQAAALksihsAACkAaQChAAAAaDaKGwAAKQBrAAEAEAA4NoobRQAp
AGwAAQAQAF02ihtFACwAdQABABAAVTaKG2AALQB3AAEAEABDNoobYAAxAIMAAQEQAF88ihtFADMA
iQCBABAATjyKG0UAMwCPAAEAEACjPicyRQAzAJEAAQAQAGIyJzJFADoAmQChAAAAuEcnMgAASwC2
AAEAAAD9LCcyRQBLALwAAQEAAOsBJzKpAFAAyQABAQAAlhMnMqkAVADJAAEBAACKLCcyqQBaAMkA
AQEAAFg7JzKpAGkAyQABARAAdD4nMkUAeQDJAAEBAAAPBScyqQCdANMAAQAQAGVJJzJFALMA0wAB
ABAA6EcnMkUAxgARAQEgEAA+MScyCADMACQBoQAAAD0PJzIAAMwAKAEBABAAVg8nMkUAzAArAQEA
EADiDycyRQDOADIBAQAQAEkPJzJFANIAPwGgAAAApUcnMgAA1QBKAQEBEAANDycyRQDVAEsBAQAQ
AHg7JzJxANoAagEBAQAA0EYnMqkA3ABvAQEBAABJLycyqQDfAG8BAQAQAOY+JzJFAOYAbwEBAQAA
WDUnMnUA7AB6AQEBAAAZFScyqQDsAH4BAQAQACEYJzJFAO8AfgGhAAAAhxQnMgAABwHhAaEAAAB0
FCcyAAAHAeIBAQAQAK8UJzJFAAcB4wEBABAAmRQnMkUACAHlAaEAAABjFicyAAAIAecBgQAQAHMW
JzJFAAgB7QEBABAAhhYnMvAACQH0AQEAEACZFicy8AAMAfwBAQAQAKYPJzJFAA4BBAIAABAAjQ8n
MkUAEQELAgAAEAA5KycyYQATARACAQAQAHYrJzJEARUBMAIBAAAA7CwnMkUAHAFCAgEAEADFKycy
PAEfAUwCAQAQAAk2uS5FACsBXwIBABAAgT65LkUAQAFzAgEBAAC0RrkuqQBbAXUCAQAQAEMbuS4Y
AV8BdQIBAAAAIy65LkUAdwGJAgEAEACVJLkuOAGNAZYCAQAQABs2uS5FAI0BlwIAABAAGjO5LkUA
rgGtAgEAAACxFbkuRQDCAbICAQAQAPgzuS5FAMYBtgIBABAA1St5PGEAywHEAgEAEAApNHk8RQDU
AeICAQAQAIUreTxhANwB9AIBABAAO0V5PEUA4gELAwEAEADUNnk8RQDnARUDAQEQANoArzxFAOwB
IAMBARAA1ACvPEUA7gEmA6EAAAC+La88AADxAS8DAQAQAH8ErzxFAPEBNAMBABAAhi4OKNkA8wE7
AwAAEAADOGg5RQDzAT4DAAEQAG87aDnxAPUBQgMAAQAAGwQAAEUA9gFFAwIBAAA3HwAAqQAGAkUD
AgEAAJAeAAB1AAoCRQMDAQAAsTEAAKkACgJJAwIBAAC4JQAAqQARAkkDAgEAAGI7AACpABkCSQMC
AQAAezUAAHUAHQJJAwMBAACyQwAAqQAdAk0DAwEAAE8TAACpACACTQMDABAA+jUAAEUAJAJNAwMA
EABLHgAARQAkAk8DAwAQAB4lAABFACwCYgMDABAAADcAAEUALwJrAwMAEACwKgAAYQAxAm8DAwAQ
AGMrAABhADICfAMDAQAA1TQAAHUAOAKLAwMAEAAMFgAARQA4Ao8DAwEAAGY+AACpAEACmgMTAQAA
sAAAAPkAQwKaAxMBAAAIAwAA+QBDApoDEwEAADcAAAD5AEMCmgMTAQAAWwMAAPkAQwKaAxMBAADq
AgAA+QBDApoDEwEAABkAAAD5AEMCmgMTAQAAdAEAAPkAQwKaA1GALAdCCVGAhwhCCVGAUgdCCQEA
QCNCCQEAhTdFCSEAZhRJCQEAEDRJCQEATT1CCQEAozRJCQEAmQBNCQEADRJRCQEAMxVRCVGAGwdC
CQEAFCxUCQEAoy1YCQEA6zNJCQEAVj1CCQEAIz1CCVGAsgVCCQEAAChCCQEAOT9cCQEAdg5JCQEA
MwvXAgEAuwtRCQEAMwvXAgEAWgpgCQEAzw1gCQEAuwtRCQEANw1RCQEAMwvXAgEAlgxjCQEAuwtR
CQYA0EhnCQYASxhrCQYA7RdvCQYAtxtzCQYAqRt3CQEA5Qx7CQEA/Qx7CQEAlgtRCQEADg3XAgEA
cA1/CQEAfA1/CQEA8QyECQEAnQtgCQEAsgtgCQEASAudAQEAUQudAQEAnQtgCQEAsgtgCQYA0Ehn
CQYASxhrCQYA3j2ICQYA7RdvCQYAtxtzCQYAqRt3CQEA8QuMCQEAuwtRCQEAuwxJCQEALgyRCQEA
BwuWCQEAnQ7XAgEA5QyECQEA/QyECQEAawubCQEAWgugCQEAmQ1RCQEAsw1RCQEAFg1RCQEAkQ2l
CQEAjw6pCQEAVQytCQEAMgqxCQEAwwrXAlGAryZCCQEAOUjXAgEAAjxRCQEAojK2CTEAnD25CQYG
PApCCVaAUiSxCVaA8i2xCVaALxCxCQYGPApCCVaA/xG9CVaAQRK9CVaAxQG9CVaANAG9CVaAvwi9
CQYGPApCCVaAWRvCCVaANxDCCVaA2DfCCVaAGQHCCVaAwwPCCVaAowDCCVaAiAPCCVaAEgHCCVaA
VAPCCVaAShLCCVaAcSbCCVaAaSbCCVaASgLCCVaAtzHCCQYGPApCCVaAjBLHCVaAvRPHCVaAWjfH
CVaAdwLHCVaAlhHHCVaAoDHHCVaAgAPHCVaA2QPHCVaACgTHCVaAEADHCVaAyETHCVaA5z3HCVaA
uxHHCVaAYwHHCVaAhwLHCVaAC0ZCCVaADQpCCVaAmTFCCVaAHghCCVaAkghCCVaA9AFCCVaAwiJC
CVaAQghCCVaAtyNCCVaAvCNCCVaAVwhCCVaA1iJCCVaAUAhCCVaApyJCCVaASQhCCVaAayNCCVaA
0wVCCVaAYRxCCVaAigZCCVaA4htCCVaAmAZCCVaAKxxCCVaAuQZCCVaArRxCCVaAxQZCCVaAsgZC
CVaAdhxCCVaAQRxCCVaAvAFCCVaAjRxCCVaAyBtCCVaADRxCCVaApAZCCVaAxRxCCVaAkQZCCREA
UxZCCQYGPApCCVaAaD3MCVaAvw7MCVaAcTzMCVaAAkbMCVaAazzMCVaA1QnMCVaAMAHMCVaAiCbM
CVaANSzMCVaApSzMCVaAmgnMCVaAaAnMCVaAPh3MCVaAhhDMCVaAUD/MCVaA+D7MCVaA/AjMCVaA
HCzMCVaAAQDMCVaACQrMCVaAvwjMCQEAuTHRCQEAKzpCCQEAGUbWCQEAPhnXAgEAPCTZCQEAmCLZ
CQEA7T/WCQEAghDcCQEAvxrcCQEAxBO9CQEAxQ5JCQEAO0LXAgEAaTtCCQEAo0VgCQEAHUFgCQEA
JgpRCQEAdgvfCQEAszJCCQEAyidCCQEAawytCQEAOQudAQEA3AviCQEARg5RCQEAUg1CCQEAYQ1C
CQEAfyTnCQEACBBJCQEAaDvqCQEAhBqdAQEACxudAQEAxxmdAQEACxudAQEAbhqdAQEAxxmdAQEA
zEVCCQEA7EJCCQEAPidCCQEAAUrvCQEACBBJCQEA0xjXAgEAj0ZJCQYGPApCCVaAxTb0CVaAvT30
CQYGPApCCVaAXSX5CVaAlTP5CVaA/g/5CVaAER/5CVaAwj75CVaAFh/5CQEAEAuWCQEAuA7+CQEA
kQpRCQEAJg5CCQEAhApgCQEAiwz5CQYGPApCCVaAFhYDClaAQ0ADCgYA4BEIClGAmiNCCQEATgpR
CQEAMwvXAgEAEA7XAgEAtgrXAgEAAwxUCQEA4jVRCQEArUlgCQEALg0NCgEAj0ZJCQEAiAtRCQEA
MgqxCQEASQ1/CQEAGQ5gCQEAXQ4TCgEA9woYCgEAzQodCgEAZQpRCQEApgtCCQEArwxJCQEABA4i
CgEAdQpRCQEAew6pCQEAFgvXAgEA6woDCgEAPAxUCQEAFgvXAgEAIAvXAgEAPAzvCQEADwzvCQEA
PCRgCQEAmCJgCQEAghBgCQEA5w1gCQEA1w1gCQEA0gxRCQEATQxUCQEAoTMnCgEAghAsCgEANEr+
CQEAPCRgCQEAxBNCCQEAaTtCCQEALxTXAgEAag7XAjEAnD25CTEA5hK5CQEAYDl/CQEAghAsCgEA
bkn+CQEAGCpCCQEAuhO9CQEAPCRgCQEAHUFgCQEAFkJJCQEAejNRCQEAND1gCQEAQD1gCQEAMgqx
CVaADQhCCVaAwQRCCVaA+QdCCVaA6gdCCVaA8gRCCVGAbAlCCVGA4wZCCVGA1gZCCVGAcwVCCVGA
ZQVCCVGAfgVCCVGAVgVCCVGARgVCCVGAKgVCCVGAOQVCCQEAQipCCQEAkTZRCQEA8B5CCQEA60Ng
CQEApSQxCgEAUhs2ClaAzAZRCVaARQdCCVaAyQhCCVaA1ghCCVaAgwlCCVaAcAdCCVaA+QZCCVaA
7wZCCVaAVAlCCVaAkQVCCVaAYAdCCVaAXglCCVaAqAVCCVaAZgdCCVaAjwlCCVaAigRCCVaAzAlC
CVaAlwVCCRYAxAVCCVaA4wRCCVaApAlCCVaA/AlCCRYAAwc7ChYAHQo7ChYADwc7ChYA4Ac7ChYA
dAQ7CgYGPApCCVaAUEE/ClaA1RE/ClaAGkc/ClGAjDJCCQEAKiZCCQEAJBFECgEAF0VECgEA/EJC
CQEARC5CCQEAcRdRCQEAB0NCCQEAG0NCCQEAHxFCCQEAVUVJCQEA3UY/CgEAkS5CCQEAU0pCCQEA
IydCCQEAGCdCCQEAyS9CCQEAWiRJCQEA6i1gCQEATSRCCQEAKBNCCQEApSQxCgEAMy5ICgEAzzRN
ClGAiQVCCVGAmAdCCVGArwdCCVGApAdCCVGAeANCCVGABwBCCVGAjwNCCVGAggdCCTEAfgg7CjEA
uR1JCREAZDhEChEAyiZJCREAVzhEChEAvCZJCQYApSQxCgEAnhVSCgEACBZSCgEAqhVSCgEAYyRE
CgEAaSRJCQEAOUFCCQEAWz5CCTEA9Qg7CjEA5Ak7CjEAsQk7CjEA3Qk7ClGAXghCCVGAdwlCCVGA
4AhCCVGAhgBCCVGAHQFCCVGA1QRCCVGAbAhCCVGAxgdCCVGAJQlCCVGAuAlCCVGAPAlCCVGAuAdC
CVGAzARCCQEAbRVCCQEAujRCCQEAEj5CCQEATydCCQEAwkNCCQEATS5CCQEAvyhRCQEA60NgCQEA
6i1gCQEANjNRCQEATkRXCgEASEVcCgEALDNhCgEA4xVmCgEACBZmCgEAzzRNClGAkwdCCVGAjQdC
CVGAkgdCCVGA7ghCCVGA9whCCVGAAQlCCTEAfy47CjEAQj47CjEAfgg7CgEA0TxJCQEA2DxJCQEA
qhVmCgEAbRVCCQEAuS1CCQEAsy1CCQEAuC1CCQEAui1CCQEAjypCCQEAZy7fCQEAkDdCCVGA1QdC
CQEAERZEChYA1RVmChYA/BVmCgEAuwxJCQEAHkNCCQEAaBNCCQEAYT7cCQEAnEJCCQEALxTXAgEA
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
iQBeG80AoQJXEpwCoQLKQpgBqQLbPogBqQKWGq0BqQLBEK0BqQLlGq0BqQLVEK0BqQKsEK0BaQEp
NxAAcQEpN8wDwQAnISUBcQEpNwYAwQA7Ie8DOQG7N/QDcQFSRocAIQEpN8YAwQDrKAUEIQFQGakB
IQGQEKkBSQK/MSsEwQCYHQYAQQFkGEEBGQMqJEEEwQAfH4gBIQMpNxAAyQEWHUwEAQKCG1IEgQC9
FkEBAQJVP4UEKQOLNqQEAQJVP6sEKQNCQUEEiQEpNwYAAQEpNwEAiQE9EccEAQEkQ80EAQEjLNQE
iQGcMgYAAQEsLOEE8QI7ByEDwQD2LxoFiQGDRjEFiQEjLDYFwQBZJxoFwQL2HpMFuQIpNxAA0QBl
N1gAoQK3GOEFwQIHIuwFwQJcR/IFQQEpN/kFAQJVPxEGcQEpN2EAwQApNwYAwQD3EIgBwQD0Q4gB
CQNoRS0GAQI+P9EC+QEVJUEBAQI+P1EGAQKsNkEBAQJFJF0GWQIpNwYAoQEpNwYASQP3OmEAsQEK
PisHUQNlQQEAUQOeOTEHWQMjLDcHYQNfIc0AAQJBJF0GcQLSOVUHwQIDETcCsQEpNwYAkQIDR1wH
wQEpN2IH4QEpNwYAEQMpNwYAcQMpNxAACAAEAM4HCAAIANMHCAAMANgHCAA0AN0HCABMANgHCAAs
AeIHCABEAecHCABIAewHCABMAc4HCABUAecHCABYAfEHCABcAfYHCABgAfsHCABkAQAICABsAecH
CABwAewHCAB0AQUICAB4AQoICAB8AQ8ICACAARQICACEARkICACIAR4ICACMASMICACQASgICACU
AS0ICACYATIICACcATcICACgATwICACoAewHCACsAUEICACwAfEHCAC0AdgHCAC4AUYICAC8AUsI
CADAAVAICADEAVUICADIAVoICADMAV8ICADQAWQICADUAWkICADYAW4ICADcAXMICADgAXgICADk
AX0ICADoAX0ICADsAYIICADwAYIICAD0AX0ICAD4AYcICAD8AYwICAAAAowICAAEApEICAAIAtgH
CAAMAtgHCAAQApYICAAUApYICAAYApsICAAcApsICAAgAqAICAAkAqAICAAoAqUICAAsAqUICAAw
AqoICAA0AqoICAA4Aq8ICAA8Aq8ICABAAqoICABEAqoICABIArQICABMArQICABQArkICABUArkI
CABYAr4ICABcAr4ICABgAsMICABkAsMICABoAsgICABsAsgICAB4AucHCAB8AuwHCACAAs4HCACE
As0ICACIAtIICACMAtcICACQAkEICACUAtwICACYAvEHCACcAvYHCACgAt0HCACkAvsHCACoAqAI
CACsAuEICACwAuYICAC0AusICAC4AtgHCAC8AvAICADAAvUICADEAvoICADIAgAICAB0A+cHCAB4
A+wHCACAA+cHCACEA+wHCACIA84HCACMA80ICACQA9IICACUA9cICAC0A+cHCAC4A+wHCADAA2kI
CACsBPYHCACwBOwHCAC0BP8ICAC4BOcHCAC8BPEHCADABOwHCADEBNIICADIBPEHCADMBOcHCADQ
BOwHCADUBNgHCADYBAQJCADcBAkJCADgBIwICADkBA4JAgAABRMJCAAEBecHCAAIBewHCAAMBc4H
CAAQBUYICAAUBfEHCAAYBRUJCAAcBc0ICAAgBesICAAkBXgICAAoBRoJCAAsBesICAAwBXgICAA0
BRoJCAA4BdcICAA8BR8JCABABSQJCABEBSkJCABMBecHCABQBewHCABUBc4HCABwBecHCAB0BewH
CAB4Bc4HCAB8BWkICADcBXMICADgBS4JCADkBYwICADoBfoICADsBdgHCADwBfAICAD0BfUICAD4
BVUICABEBucHCABIBuwHCABMBs4HCABQBs0ICABUBtIICABYBtcICABcBkEICABgBtwICABkBvEH
CABoBvYHCABsBt0HCABwBvsHCAB0BqAICAC4BucHCAC8BuwHCADABs4HCADEBs0ICADIBtIICADM
BtcICAAIB+sICACIB3gICACMBxoJCQCwBzMJCQC4B/8ICAAcCOcHCAAgCOwHCAAkCM4HBQAsCBMJ
BQAwCDgJBQA0CDoJBQA4CDwJBQA8CD4JBQBACEAJCABICOcHCABMCOwHCABQCM4HCABUCM0ICABY
CNIICABcCNcICABgCEEIBQBoCDgJBQBsCDoJBQBwCDwJCAB4COwHCAB8CM4HCACECOcHCACICOwH
CACMCM4HCAAECecHCAAICewHLgALAEERLgATAEoRLgAbAGkRLgAjAHIRLgArAKIRLgAzAKIRLgA7
AKgRLgBDAHIRLgBLALcRLgBTAKIRLgBbANcRQwNjAI4UgwRrAOwHwwZzALIUAwuTAOwHIwubAOwH
YwurAOwHwwtrAOwHAwxrAOwHQwxrAOwHqQ5jAMQUQQ9jADgSgQ9jAFcSARBjAIASYRBjAKUSoRBj
AMkS4RBjAPASIRFjABwTYRFjAD4ToRFjAGQT4RFjAIcTIRJjAK4TQRJjANcToRJjAP8TIRNjADAU
YRNjAF4UCRijAGkRKRijAGkRwBpjACESoT6rAOwHAGqLAOwHIGqLAOwHQGqLAOwHAQAMAAAAbQAB
ABAAAABuAAEAKAAAAG8AAQBMAAAAcAABAHQAAABxAAEAeAAAAHIAAQAABAAAcwArAGcAeQCWAKsA
wQDUANgA3wDkAOsA8gD5ABEBHQE0AXQBjAGTAaIBvQHCAcYB0wH8AQgCEAIYAiACKAI+AlUCagJ5
AoUCkAKxAuAC8wI/A0QDYwNyA5sDogOwA70D1QP4Aw0EGAQeBCMEMwQ7BEYEXARgBGkEiwSyBNkE
5wT1BAEFBgUOBR8FLAU7BUMFTwVYBWAFZgVyBZgFngWlBcgF2gXlBQQGGQYoBjMGQQZHBlgGYgZx
BngGfgaEBp0GpwatBrMGuAbHBswG0wbbBuQG7Ab1BgwHEwcbByAHJgc+B2oHdgd+B4YHjweqBwMA
AQAHAAYACAAKAAkADgAKABIACwAUAAwAGQANABoAGQAdABoAIQAdACMAHgAkAB8AKwAgACwAJQAv
ACcAMAAoAE8AKgBVACsAVgAsAFgALQBdAC8AYQAwAGUAMwBnADYAbQA7AH0APAB+AD4AfwA/AIAA
QACDAEEAhQBCAIwAQwCQAEQAkQBFAJMASACYAEsAmwBOAKIATwCkAFAArABRALIAUwC5AFQAvABV
AL0AVgC+AFcAvwBZAMAAWgDCAGUAwwBmAMoAZwDNAGgAzgBpANMAAACXNJMQAAAdI5gQAAAwI5gQ
AAAzPJwQAAAWLZwQAAAWLZwQAAAdI5gQAAAwI5gQAAAzPJwQAAAWLZwQAAAdI5gQAAAwI5gQAAAz
PJwQAAA2I5gQAAA2O6AQAAAiO6AQAACLRpMQAAAxGaYQAADRJJwQAAAxGaYQAADRJJwQAAABH6oQ
AAAlEq4QAABuQK4QAACwOZwQAAAxGaYQAABiMbIQAADRJJwQAABbI64QAAD8I64QAADyHbcQAAAS
HrcQAABbI64QAAD8I64QAADfKb0QAAAROZwQAAAmFKYQAAAELcMQAADrR8gQAADrAc0QAAB9P5wQ
AAC5P5wQAAAELcMQAAArSKYQAADwO5wQAADTQdMQAABDFtcQAABzEJwQAACCEpwQAADGRJwQAACi
IdsQAABiO5gQAACWRa4QAAAWQa4QAAAUOpgQAAALRpgQAAD/SJwQAABeLJgQAACxLpgQAAD8PZwQ
AAAFApwQAAAiApwQAAC3Gq4QAACgGbcQAAAxGaYQAAAlJK4QAACJIq4QAAB+EK4QAACWE98QAABD
M98QAAAhD5MQAAAfJJgQAAC0J9sQAABcLpgQAAApIpgQAAAzQqYQAADCSJwQAABCGJwQAAAELcMQ
AADIJeUQAACLGbcQAACAOpgQAACkOpgQAADGRJwQAAAJBesQAAAJBesQAAADEJMQAAAJBesQAABz
GrcQAAAQG7cQAAC8GbcQAACCFe8QAAAJBesQAABZGrcQAAC8GbcQAAD8GrcQAACiJ5gQAABDJ5gQ
AABwRZgQAAB0QpgQAADKGKYQAACLRpMQAABNL/UQAABSGPsQAAAuSgERAACEQpgQAADaEq4QAAAd
E5wQAACLRpMQAAAmFKYQAAAoP5wQAADUNZwQAADYIZwQAAD6IZwQAAAHQqYQAAAxGaYQAAAlJJgQ
AACqQq4QAAC0RQcRAAAELcMQAADrR8gQAAChI5gQAACGJZwQAADrAc0QAAAdFQ4RAAAdFQ4RAADd
KhQRAACJIq4QAAAlJK4QAAB+EK4QAADjQK4QAAC8QK4QAADUNZwQAAD7EJwQAADoKJwQAAD4Q5wQ
AACiJ64QAAAdMK4QAAAjH5wQAAAmFKYQAAB7SZwQAAB1F5gQAACiJ64QAADsRaYQAACiEZwQAADr
Ac0QAADJNJgQAADiLa4QAADiQ64QAACiEZwQAAAHRJwQAADJNJgQAADiLa4QAADURhoRAAAHRJwQ
AAB4R5wQAACiEZwQAADJNJgQAADiQ64QAADiLa4QAAAaRJgQAACTQpgQAACxEZwQAADUNZwQAABQ
OZwQAAAmFKYQAAD7EJwQAADoKJwQAAAjH5wQAACiJ64QAAAdMK4QAACLJ5gQAADSD5MQAABnJ5gQ
AADqRJMQAAB1F5gQAACDLSARAADUNZwQAAB1F5gQAAD7EJwQAADoKJwQAAAjH5wQAACiJ64QAAAd
MK4QAAAhPpgQAADBOpgQAAAHRJwQAADIIa4QAADIIa4QAADIIa4QAADIIa4QAACDNCURAAA2HSsR
AABQQTERAAAuSgERAADESQERAABVEzcRAAA6GaYQAADjQK4QAAC8QK4QAABRIq4QAAD/JJwQAACL
J5gQAAAwQpMQAABHQj0RAAD7EJwQAAAjH5wQAADoKJwQAACiJ64QAAAdMK4QAAAdMK4QAACiJ64Q
AAAjH5wQAADoKJwQAAD7EJwQAAD4Q5wQAgAHAAMAAgAKAAUAAgALAAcAAgAMAAkAAgANAAsAAgAc
AA0AAgAdAA8AAgAeABEAAgAfABMAAgAkABUAAgAlABcAAgAmABkAAgAnABsAAgApAB0AAQAqAB0A
AgArAB8AAgAtACEAAgAuACMAAQAvACMAAgA1ACUAAgA2ACcAAQA3ACcAAgA5ACkAAgA6ACsAAQA7
ACsAAgA8AC0AAgA9AC8AAgA+ADEAAgBAADMAAgBCADUAAgBDADcAAgBEADkAAQBFADkAAgB7ADsA
AQB8ADsAAgB9AD0AAQB+AD0AAgB/AD8AAQCAAD8AAgCBAEEAAQCCAEEAAgCFAEMAAQCGAEMAAgCH
AEUAAQCIAEUAAgCWAEcAAQCXAEcAAgCbAEkAAQCcAEkAAgCdAEsAAQCeAEsAAgCfAE0AAQCgAE0A
AgChAE8AAQCiAE8AAgCjAFEAAQCkAFEAAgClAFMAAQCmAFMAAgCnAFUAAQCoAFUAAgC6AFcAAQC7
AFcAAgC+AFkAAQC/AFkAAgDAAFsAAQDBAFsAAgDHAF0AAQDIAF0AAgDJAF8AAQDKAF8AAgDXAGEA
AgDYAGMAAQDZAGMAAgDaAGUAAQDbAGUAAgDcAGcAAQDdAGcAAgDeAGkAAQDfAGkAAgDgAGsAAQDh
AGsAAgDiAG0AAQDjAG0AAgDkAG8AAQDlAG8AAgDmAHEAAgDnAHMAAgDpAHUAAQDqAHUAAgDrAHcA
AgDsAHkAAgDvAHsAAgDwAH0AAgDxAH8AAQDyAH8AAgDzAIEAAQD0AIEAAgD1AIMAAgD2AIUAAQD3
AIUAAgD4AIcAAQD5AIcAAgD6AIkAAQD7AIkAAgD8AIsAAQD9AIsAAgD+AI0AAgD/AI8AAQAAAY8A
AgABAZEAAQACAZEAAgADAZMAAgAEAZUAAgAFAZcAAgAIAZkAAQAJAZkAAgAKAZsAAgALAZ0AAgAU
AZ8AAQAVAZ8AAgAWAaEAAQAXAaEAAgAYAaMAAQAZAaMAAgAaAaUAAQAbAaUAAgAcAacAAQAdAacA
AgAeAakAAQAfAakAAgAoAasAAgAsAa0AAQAtAa0AAgAwAa8AAQAxAa8AAgAyAbEAAgA2AbMAAQA3
AbMAAgA4AbUAAQA5AbUAAgA6AbcAAQA7AbcAAgA8AbkAAQA9AbkAAgA/AbsAAgBDAb0AAQBEAb0A
AgBFAb8AAQBGAb8AAgBHAcEAAQBIAcEAAgBPAcMAAgBTAcUAAgBUAccAAgBVAckAAgBsAcsAAgBt
Ac0AAQBuAc0AAgBwAc8AAgBxAdEAAgByAdMAAgBzAdUAAgB0AdcAAgB1AdkAAgB/AdsAAQCAAdsA
AQCBAd0AAgCCAd8AAgCLAeEAAQCMAeEAAgCNAeMAAgCOAeUAAgCPAecAAgCQAekAAgCRAesAAgCS
Ae0AAgCTAe8AAgCcAfEAAQCdAfEAAgCeAfMAAQCfAfMAAgCgAfUAAQChAfUAAgCiAfcAAgCjAfkA
AQCkAfkAAgDnAfsAAgDzAf0AAgD+Af8AAgAEAgEBAQAFAgEBAgAGAgMBAQAHAgMBAgAIAgUBAQAJ
AgUBAgALAgcBAQAMAgcBAgANAgkBAQAOAgkBAgASAgsBAQATAgsBAgAUAg0BAgAVAg8BAgAWAhEB
AgAXAhMBAgAYAhUBAQAZAhUBAgAaAhcBAgAyAhkBAQAzAhkBAgA0AhsBAgA5Ah0BAgA6Ah8BAgBH
AiEBAQBIAiEBAgBOAiMBAgBSAiUBAQBTAiUBAgBjAicBAgBkAikBAgBlAisBAgBoAi0BAgBpAi8B
AgB8AjEBAgB9AjMBAgB+AjUBAQB/AjUBAgClAjcBAgCmAjkBAgCnAjsBAgCoAj0BAgCpAj8BAgCq
AkEBAgCrAkMBAgC9AkUBAgDBAkcBAgDIAkkBAQDJAkkBAgDKAksBAgDLAk0BAQDMAk0BAgDRAk8B
AgDSAlEBAgDTAlMBAgDUAlUBAgDVAlcBAQDWAlcBAgDkAlkBAgDlAlsBAgDmAl0BAgDnAl8BAgDo
AmEBAQDpAmEBAQDzAmMBAgD3AmUBAQD4AmUBAgD7AmcBAgD9AmkBAgD+AmsBAgD/Am0BAgAAA28B
AgABA3EBAQACA3EBAgAZA3MBAgAaA3UBAgAcA3cBAgAgA3kBAgAnA3sBAQAoA3sBAgAvA30BAgA2
A38BAgA/A4EBAgBAA4MBAQBBA4MBAgBCA4UBAgBXA4cBAgBYA4kBAgBZA4sBAgBaA40BAgBbA48B
AQBcA48BAgBdA5EBAQBeA5EBAgBfA5MBAQBgA5MBAgBkA5UBAgBlA5cBAgBmA5kBAgBsA5sBAgBx
A50BAgBzA58BAgB0A6EBAgB1A6MBAgB2A6UBAQB3A6UBAgCEA6cBAQCFA6cBAgCGA6kBAgCHA6sB
AgCIA60BAgCJA68BAgCKA7EBNgAOAx8ANgCoAyEA0QBxAZwXAgD2AcQXAgD3AewXAgD4ATwYAgD5
ATwcAgD6AUwcAgD7AUwgAgD8AcQgAgD9AewgAgD+AWQhAgD/AXQhAgAAAoQhAgABApQhAgACAgwi
AgADAoQiAgAEAqwiAgAFAgSAAAABAAAAlhpdYAAAAAAAAA4oAAAEAAAAAAAAAAAAAAC8ByYQAAAA
AA4AAAAAAAAAAAAAAMUH+ygAAAAABAAAAAAAAAAAAAAAvAdiLAAAAAAOAAAAAAAAAAAAAADFBwYJ
AAAAAAAAAAABAAAADTgAAFwAHgBdAB4AXgAnAF8AKABgACwAYQA2AGIANgBjADYAZAA2AGUANgBm
ADYAZwA2AGgANgBpADYAagBCAGsASQBsAFgAbQBbAG4AWwBvAFsAcABbAHEAWwByAFsAcwBbAIcA
VAEAAABPUzQwMABSRVBfM18xMABVbnVzZWQxMABfX1N0YXRpY0FycmF5SW5pdFR5cGVTaXplPTEy
MABfX1N0YXRpY0FycmF5SW5pdFR5cGVTaXplPTQwADYxOTUxMDE0RkIxN0M1QkY3NEY0NTQwMUNB
NUM2RDRDNzIwNUNGMTEASE1BQ1NIQTEAREVDT0RFX1NUT1JFRF9MRU4xAF9obWFjc2hhMQBUcmlw
bGVEZXMxMTIAX19TdGF0aWNBcnJheUluaXRUeXBlU2l6ZT0xMgBDb21wdXRlQ3JjMzIAQWRsZXIz
MgBVSW50MzIAMDNCNTY5QzM4RTNDRDZCNzIwMzg4OTE5RDQzNzM1QTkwNDAxMkM1MgBBZXMxOTIA
UkMyAERFQ09ERV9TVE9SRURfTEVOMgBPUzIAQlppcDIAMzczQjQ5NEYyMTBDNjU2MTM0QzU3MjhE
NTUxRDRDOTdCMDEzRUIzMwBSZXNlcnZlZFBrd2FyZTE0AF9fU3RhdGljQXJyYXlJbml0VHlwZVNp
emU9MTAyNABEQjdDNzYzQzk2NzBERDBGNkVEMzRCNzVCMzQxMEEzOUQ4MzVGOTY0AENFTlNJRzY0
AERlZmxhdGU2NABGb3JjZVppcDY0AGdldF9Vc2VaaXA2NABzZXRfVXNlWmlwNjQAVmVyc2lvblpp
cDY0AGdldF9Mb2NhbEhlYWRlclJlcXVpcmVzWmlwNjQAZ2V0X0NlbnRyYWxIZWFkZXJSZXF1aXJl
c1ppcDY0AHppcDY0AFVJbnQ2NABSQzQAMDBDNDBCM0YwMTNFREE2MDM5MEYyRTg0OUM0NTgxODE1
QTk0MTlFNABSZXNlcnZlZFBLd2FyZTQAUmVzZXJ2ZWRQa3dhcmUxNQBBNTg2RjU2QkE1M0ZBQ0Uz
MjAxNDRBREE0MEExNUEzM0IyNzE1MDI1ADZCQzRFQUIwRDYwNEM4RDQ1OTkwMjFBRDYxMUM1REJB
N0ZGN0UzMDYAX19TdGF0aWNBcnJheUluaXRUeXBlU2l6ZT0xMTYAX19TdGF0aWNBcnJheUluaXRU
eXBlU2l6ZT0xNgBJbnQxNgA2M0U5RUJGNkVFQjgxNEZDNkFDMjY3N0FERjZFQTk0NDQwM0M5NjM2
AEFlczI1NgBfX1N0YXRpY0FycmF5SW5pdFR5cGVTaXplPTc2AFJFUF8zXzYAVW51c2VkNwBBZXMx
MjgAUkVQXzExXzEzOAAxRkRDOERCNTY3RjVBQUE3MDY4RDBEMkE2MDFDRDcxNjU3Q0JERjM4AFRy
aXBsZURlczE2OABnZXRfVVRGOABVbnVzZWQ4AEVEMDMyMDI2NDcyRkY3N0E4QTE3QkE0QUZGM0ZD
NTdBRjRCNEJGNzkAVW51c2VkOQA8TW9kdWxlPgA8UHJpdmF0ZUltcGxlbWVudGF0aW9uRGV0YWls
cz4ANjdDMEU3ODRGMzY1NEIwMDhBODFFMjk4ODU4OENGNDk1NkNDRjNEQQBXcml0ZVNob3J0TVNC
AEdDAENPTVBSX0ZVTkMAU3RyYW5nZUNSQwBNSU5fTE9PS0FIRUFEADg5Q0UwRThFQTU5MEZEMzcy
ODNENkJFRkQ5RTY4MDVDOEM0N0FEQkQAQkVTVF9TUEVFRABGSU5JU0hFRABERUNPREVfU1RPUkVE
AERFRkxBVEVfU1RPUkVEAERFRkxBVEVEAGdldF9UYWdJRABzZXRfVGFnSUQASG9zdFN5c3RlbUlE
AGhlYWRlcklEAEJBU0UARklOSVNIRURfU1RBVEUAQ0xPU0VEX1NUQVRFAEZJTklTSElOR19TVEFU
RQBGTFVTSElOR19TVEFURQBTRVRESUNUX1NUQVRFAElOSVRfU1RBVEUAQlVTWV9TVEFURQBCVUZT
SVpFAFdTSVpFAFBFTkRJTkdfQlVGX1NJWkUASEFTSF9TSVpFAENSWVBUT19CTE9DS19TSVpFAE1B
WF9CTE9DS19TSVpFAENSWVBUT19IRUFERVJfU0laRQA3OUQ1MjFFNkUzRTU1MTAzMDA1RTlDQzNG
QTQzQjMxNzRGQUYwOTBGAEI1NjRBN0E0MzNFRTFEQTUwQzVFMTUyQTk5RjI1REJDMDlCQTgzNUYA
RDA2ODgzMkU2QjEzQTYyMzkxNjcwOUMxRTBFMjVBRENCRTdCNDU1RgBEOEU0QUNCQzJEOTU3QzMz
NDRBM0NBRDY5RkNGOUE2MEM4MDM0REJGAExPQ1NJRwBFTkRTSUcAU1BBTk5JTkdTSUcAQ0VORElH
SVRBTFNJRwBDRU5TSUcAU1BBTlRFTVBTSUcARVhUU0lHAERFQlVHR0lORwBJU19GSU5JU0hJTkcA
SVNfRkxVU0hJTkcATUlOX01BVENIAE1BWF9NQVRDSABHT09EX0xFTkdUSABOSUNFX0xFTkdUSABB
VVRIX0NPREVfTEVOR1RIAFBXRF9WRVJfTEVOR1RIAGdldF9BU0NJSQBTVE9SRURfQkxPQ0sARU5D
UllQVF9CTE9DSwBXTUFTSwBIQVNIX01BU0sAREVGQVVMVF9NRU1fTEVWRUwARU9GX1NZTUJPTABE
TlVNAEJMTlVNAExJVEVSQUxfTlVNAEJJVExFTl9OVU0ARElTVF9OVU0AREVDT0RFX0NIS1NVTQBE
RUNPREVfSFVGRk1BTgBNQVhfQklUTEVOAE1BWF9DSEFJTgBOT19DT01QUkVTU0lPTgBERUZBVUxU
X0NPTVBSRVNTSU9OAEJFU1RfQ09NUFJFU1NJT04AVkVSU0lPTl9TVFJPTkdfRU5DUllQVElPTgBT
eXN0ZW0uSU8ATE9DSERSAEVOREhEUgBDRU5IRFIARVhUSERSAERFQ09ERV9IRUFERVIAREVDT0RF
X0RZTl9IRUFERVIAQkxfT1JERVIAS0VZX1JPVU5EUwBWRVJTSU9OX0FFUwBBZGRFeHRyYURhdGFB
RVMAR2V0QXV0aENvZGVJZkFFUwBXaW5aaXBBRVMAU1RBVElDX1RSRUVTAERZTl9UUkVFUwBERUNP
REVfQkxPQ0tTAEJMTEVOUwBDUExFTlMAQmVPUwBSRVBTAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuTWFu
YWdlZERUUwBERUNPREVfSFVGRk1BTl9MRU5CSVRTAERFQ09ERV9IVUZGTUFOX0RJU1RCSVRTAE1B
WF9XQklUUwBIQVNIX0JJVFMATVZTAElTX1NFVERJQ1QAREVDT0RFX0RJQ1QAUFJFU0VUX0RJQ1QA
SEFTSF9TSElGVABXaW5kb3dzTlQAREVGTEFURV9GQVNUAENQRElTVABERUNPREVfSFVGRk1BTl9E
SVNUAE1BWF9ESVNUAEF0YXJpU1QAQ1BERVhUAENQTEVYVAByZ2JJVgBHZW5lcmF0ZUlWAERFRkxB
VEVfU0xPVwBPU1gAVkVSU0lPTl9NQURFX0JZAE1BWF9MQVpZAGZvcmNlWmlwNjRfAHVzZVppcDY0
XwB2YWx1ZV9fAGlzQ2xvc2VkXwBpc0Rpc3Bvc2VkXwBwcm9jZXNzZWRfAGNvbnRlbnRzRWRpdGVk
XwBjb21tZW50RWRpdGVkXwBieXRlc1Rlc3RlZF8AZW50cnlWYWxpZF8Ad2luZG93RW5kXwBjb21t
YW5kXwBlbmRfAHJhd1Bhc3N3b3JkXwBwYXNzd29yZF8AdXBkYXRlRGF0YVNvdXJjZV8AZGF0YVNv
dXJjZV8AdXBkYXRlTW9kZV8AYXJjaGl2ZVN0b3JhZ2VfAHppcEZpbGVfAGZpbGVfAGZpbGVOYW1l
XwB0ZW1wb3JhcnlOYW1lXwBmaWxlbmFtZV8AZml4ZWREYXRlVGltZV8AbWluRGF0ZV8AbWF4RGF0
ZV8AY29uZmlybURlbGVnYXRlXwBvdmVyd3JpdGVfAGNyeXB0b0NoZWNrVmFsdWVfAGlzTmV3QXJj
aGl2ZV8AYWxpdmVfAG1pblNpemVfAGJ1ZmZlclNpemVfAG1heFNpemVfAGNvbnRpbnVlUnVubmlu
Z18AaXNTb3VyY2VTdHJpbmdfAHRpbWVTZXR0aW5nXwBsZW5ndGhfAHByb2dyZXNzSW50ZXJ2YWxf
AGJhc2VTdHJlYW1fAGZpbmFsU3RyZWFtXwBiYXNlT3V0cHV0U3RyZWFtXwBvdXRwdXRTdHJlYW1f
AHRlbXBvcmFyeVN0cmVhbV8Ac3RyZWFtXwBleHRyYWN0TmFtZVRyYW5zZm9ybV8AbmFtZVRyYW5z
Zm9ybV8AY3J5cHRvVHJhbnNmb3JtXwBvcGVyYXRpb25fAGV4Y2VwdGlvbl8AYml0c0luQnVmZmVy
XwBjb3B5QnVmZmVyXwBidWZmZXJfAGlzU3RyZWFtT3duZXJfAGlzT3duZXJfAGRlZmxhdGVyXwBm
aWxlRmlsdGVyXwBuYW1lRmlsdGVyXwBkaXJlY3RvcnlGaWx0ZXJfAGZpbHRlcl8AY3JlYXRlRW1w
dHlEaXJlY3Rvcmllc18AZW50cmllc18AaGFzTWF0Y2hpbmdGaWxlc18AdXBkYXRlc18AZ2V0QXR0
cmlidXRlc18Ac2V0QXR0cmlidXRlc18AaW5jbHVzaW9uc18AZXhjbHVzaW9uc18AcmVhZFBvc18A
ZXZlbnRzXwByZXN0b3JlRGF0ZVRpbWVPbkV4dHJhY3RfAHJlc3RvcmVBdHRyaWJ1dGVzT25FeHRy
YWN0XwB0YXJnZXRfAGNyY1BhdGNoT2Zmc2V0XwBzaXplUGF0Y2hPZmZzZXRfAHJhd0NvbW1lbnRf
AG5ld0NvbW1lbnRfAGNvbW1lbnRfAHVwZGF0ZUNvdW50XwBlcnJvckNvdW50XwB3aW5kb3dTdGFy
dF8Ac3RhcnRfAGlzVW5pY29kZVRleHRfAHdpbmRvd18AdXBkYXRlSW5kZXhfAHRyaW1QcmVmaXhf
AGtleV8AdXBkYXRlRW50cnlGYWN0b3J5XwBlbnRyeUZhY3RvcnlfAHNvdXJjZURpcmVjdG9yeV8A
b3V0RW50cnlfAGVudHJ5XwBBbWlnYQBleHRyYQBnZXRfRGF0YQBzZXRfRGF0YQBQcm9jZXNzQUVT
RXh0cmFEYXRhAGdldF9FeHRyYURhdGEAc2V0X0V4dHJhRGF0YQBaaXBFeHRyYURhdGEAUHJvY2Vz
c0V4dHJhRGF0YQBleHRyYURhdGEAQWRkRGF0YQBJVGFnZ2VkRGF0YQBOVFRhZ2dlZERhdGEAUmF3
VGFnZ2VkRGF0YQB0YWdnZWREYXRhAGZpZWxkRGF0YQBtYXhpbXVtVmFyaWFibGVEYXRhAEVudHJ5
UGF0Y2hEYXRhAHBhdGNoRGF0YQBEZXNjcmlwdG9yRGF0YQBHZXREYXRhAFNldERhdGEAdGVzdERh
dGEAZ2V0X1Jhd0RhdGEAcmF3RGF0YQBFeHRlbmRlZFVuaXhEYXRhAGtleURhdGEAR2V0RW50cnlE
YXRhAF9kYXRhAElDU2hhcnBDb2RlLlNoYXJwWmlwTGliAG1zY29ybGliAER5bmFtaWMAUGt6aXBD
bGFzc2ljAGdldF9DcmMAc2V0X0NyYwBvbGRDcmMAdXBkYXRlQ3JjAGdsb2JhbENyYwBnZXRfSGFz
Q3JjAHRlc3RDcmMAY3JjAEFjb3JuUmlzYwBUb0ZpbGVUaW1lVXRjAENyZWF0ZVRpbWVVdGMAZ2V0
X0xhc3RXcml0ZVRpbWVVdGMAZ2V0X0NyZWF0aW9uVGltZVV0YwBnZXRfTGFzdEFjY2Vzc1RpbWVV
dGMASW5pdGlhbFJlYWQAZ2V0X0NhblJlYWQAT3BlblJlYWQAQmVnaW5SZWFkAEJvZHlSZWFkAGxv
b2thaGVhZABnZXRfQ3VycmVudFRocmVhZAB0b0FkZABJc1ppcDY0Rm9yY2VkAElzSW5jbHVkZWQA
SXNFeGNsdWRlZABDcmNTZWVkAHNlZWQAUGt6aXBDbGFzc2ljTWFuYWdlZABSaWpuZGFlbE1hbmFn
ZWQAUGF0Y2hlZABnZXRfSXNGaW5pc2hlZABnZXRfSXNGbHVzaGVkAEhlYWRlck1hc2tlZAB3aW5k
b3dGaWxsZWQARmlsdGVyZWQAT25LZXlzUmVxdWlyZWQARGVmbGF0ZVN0b3JlZABDb3B5U3RvcmVk
AHN0b3JlZABfZmluYWxpc2VkAGlzQ2xvc2VkAGdldF9Qcm9jZXNzZWQAcHJvY2Vzc2VkAHVwZGF0
ZWQARGVmbGF0ZWQAUkMyQ29ycmVjdGVkAElzUGF0aFJvb3RlZABTcGxpdFF1b3RlZABnZXRfSXND
cnlwdGVkAHNldF9Jc0NyeXB0ZWQARW5jcnlwdGVkAElzQ29tcHJlc3Npb25NZXRob2RTdXBwb3J0
ZWQAUmVhZGluZ05vdFN1cHBvcnRlZABnZXRfQnl0ZXNUZXN0ZWQAU2V0Qnl0ZXNUZXN0ZWQASW52
YWxpZEVudHJ5Q2hhcnNSZWxheGVkAHJlbGF4ZWQARml4ZWQATmFtZUlzVmFsaWQAZ2V0X0VudHJ5
VmFsaWQAaW5wdXRFbmQAd2luZG93RW5kAF9hZXNSbmQAZ2V0X0NvbW1hbmQAVXBkYXRlQ29tbWFu
ZABjb21tYW5kAEFwcGVuZABGaW5kAGdldF9TZWNvbmQAZ2V0X0NvbXByZXNzaW9uTWV0aG9kAHNl
dF9Db21wcmVzc2lvbk1ldGhvZABjb21wcmVzc2lvbk1ldGhvZABjdXJNZXRob2QAbWV0aG9kAElu
aXRpYWxpemVBRVNQYXNzd29yZABnZXRfUGFzc3dvcmQAc2V0X1Bhc3N3b3JkAENoZWNrQ2xhc3Np
Y1Bhc3N3b3JkAEluaXRpYWxpemVQYXNzd29yZAByYXdQYXNzd29yZABwYXNzd29yZABSZXBsYWNl
AEdldEZyZWVTcGFjZQBkaXN0YW5jZQBkZWZhdWx0SW5zdGFuY2UAX2NvdW50ZXJOb25jZQBJRHlu
YW1pY0RhdGFTb3VyY2UASVN0YXRpY0RhdGFTb3VyY2UARHluYW1pY0Rpc2tEYXRhU291cmNlAFN0
YXRpY0Rpc2tEYXRhU291cmNlAGRhdGFTb3VyY2UAR2V0U291cmNlAHNvdXJjZQBBRVNBdXRoQ29k
ZQBHZXRBdXRoQ29kZQBzZXRfTW9kZQBGaWxlTW9kZQBnZXRfVXBkYXRlTW9kZQBGaWxlVXBkYXRl
TW9kZQB1cGRhdGVNb2RlAF93cml0ZU1vZGUAQ3J5cHRvU3RyZWFtTW9kZQBDaXBoZXJNb2RlAERj
b2RlAExjb2RlAERlY29kZQBtb2RlAGdldF9JbmNsdWRlAHNldF9JbmNsdWRlAEJ1aWxkVHJlZQBX
cml0ZVRyZWUAbGl0ZXJhbFRyZWUAYmxUcmVlAEluZmxhdGVySHVmZm1hblRyZWUAQnVpbGRMaXRM
ZW5UcmVlAGRlZkxpdExlblRyZWUAbGl0bGVuVHJlZQBCdWlsZERpc3RUcmVlAGRlZkRpc3RUcmVl
AGRpc3RUcmVlAHRyZWUAU2FmZQBnZXRfT0VNQ29kZVBhZ2UAZ2V0X0RlZmF1bHRDb2RlUGFnZQBz
ZXRfRGVmYXVsdENvZGVQYWdlAGRlZmF1bHRDb2RlUGFnZQBJQXJjaGl2ZVN0b3JhZ2UAQmFzZUFy
Y2hpdmVTdG9yYWdlAERpc2tBcmNoaXZlU3RvcmFnZQBNZW1vcnlBcmNoaXZlU3RvcmFnZQBhcmNo
aXZlU3RvcmFnZQBnZXRfTWVzc2FnZQBtZXNzYWdlAEVuZEludm9rZQBCZWdpbkludm9rZQBjcmMz
MlRhYmxlAENyY1RhYmxlAElDbG9uZWFibGUAVmFyaWFibGUAZ2V0X0F2YWlsYWJsZQBzZXRfQXZh
aWxhYmxlAE1ha2VCeXRlc0F2YWlsYWJsZQBHZXRBdmFpbGFibGUAUmVhZGluZ05vdEF2YWlsYWJs
ZQBNYWtlVGV4dEF2YWlsYWJsZQBwcmV2QXZhaWxhYmxlAGF2YWlsYWJsZQBJRW51bWVyYWJsZQBJ
RGlzcG9zYWJsZQBIYXNodGFibGUAUnVudGltZUZpZWxkSGFuZGxlAFJ1bnRpbWVUeXBlSGFuZGxl
AEdldFR5cGVGcm9tSGFuZGxlAGdldF9GaWxlAE9uQ29tcGxldGVkRmlsZQBPbkNvbXBsZXRlRmls
ZQB3b3JrRmlsZQBUcmFuc2Zvcm1GaWxlAFppcEZpbGUAemlwRmlsZQBtYWtlVGVtcEZpbGUAZ2V0
X0lzRmlsZQBPblByb2Nlc3NGaWxlAGZpbGUAQ29tcGlsZQBnZXRfTmFtZQBNYWtlVmFsaWROYW1l
AElzVmFsaWROYW1lAGdldF9GaWxlTmFtZQBHZXRUcmFuc2Zvcm1lZEZpbGVOYW1lAHppcEZpbGVO
YW1lAEdldFRlbXBGaWxlTmFtZQBHZXRGaWxlTmFtZQBmaWxlTmFtZQBDbGVhbk5hbWUAdGFyZ2V0
TmFtZQBHZXRUcmFuc2Zvcm1lZERpcmVjdG9yeU5hbWUAR2V0RGlyZWN0b3J5TmFtZQBkaXJlY3Rv
cnlOYW1lAGVudHJ5TmFtZQBnZXRfRmlsZW5hbWUARnJvbUZpbGVUaW1lAFRvRmlsZVRpbWUAZ2V0
X0RhdGVUaW1lAHNldF9EYXRlVGltZQBnZXRfRml4ZWREYXRlVGltZQBzZXRfRml4ZWREYXRlVGlt
ZQByZXN0b3JlRGF0ZVRpbWUAZ2V0X0NyZWF0ZVRpbWUAc2V0X0NyZWF0ZVRpbWUAX2NyZWF0ZVRp
bWUAZ2V0X0xhc3RXcml0ZVRpbWUAU2V0TGFzdFdyaXRlVGltZQBUb0xvY2FsVGltZQBUb1VuaXZl
cnNhbFRpbWUAZ2V0X01vZGlmaWNhdGlvblRpbWUAc2V0X01vZGlmaWNhdGlvblRpbWUAZ2V0X0xh
c3RNb2RpZmljYXRpb25UaW1lAHNldF9MYXN0TW9kaWZpY2F0aW9uVGltZQBfbGFzdE1vZGlmaWNh
dGlvblRpbWUAX21vZGlmaWNhdGlvblRpbWUAZ2V0X0NyZWF0aW9uVGltZQBnZXRfRG9zVGltZQBz
ZXRfRG9zVGltZQBkb3NUaW1lAGdldF9BY2Nlc3NUaW1lAHNldF9BY2Nlc3NUaW1lAGdldF9MYXN0
QWNjZXNzVGltZQBzZXRfTGFzdEFjY2Vzc1RpbWUAX2xhc3RBY2Nlc3NUaW1lAE1pY3Jvc29mdC5T
cWxTZXJ2ZXIuRHRzLlJ1bnRpbWUAQ29tYmluZQBEZWZsYXRlckVuZ2luZQBlbmdpbmUATm9uZQBN
ZW1iZXJ3aXNlQ2xvbmUAVmFsdWVUeXBlAEZpbGVTaGFyZQBDb21wYXJlAElDU2hhcnBDb2RlLlNo
YXJwWmlwTGliLkNvcmUAT25GaWxlRmFpbHVyZQBPbkRpcmVjdG9yeUZhaWx1cmUAQXJjaGl2ZUV4
dHJhRGF0YVNpZ25hdHVyZQBTcGFubmluZ1NpZ25hdHVyZQBMb2NhdGVCbG9ja1dpdGhTaWduYXR1
cmUAQ2VudHJhbEhlYWRlckRpZ2l0YWxTaWduYXR1cmUAU3Bhbm5pbmdUZW1wU2lnbmF0dXJlAFpp
cDY0Q2VudHJhbEZpbGVIZWFkZXJTaWduYXR1cmUATG9jYWxIZWFkZXJTaWduYXR1cmUAQ2VudHJh
bEhlYWRlclNpZ25hdHVyZQBaaXA2NENlbnRyYWxEaXJMb2NhdG9yU2lnbmF0dXJlAERhdGFEZXNj
cmlwdG9yU2lnbmF0dXJlAEVuZE9mQ2VudHJhbERpcmVjdG9yeVNpZ25hdHVyZQBzaWduYXR1cmUA
Z2V0X0N1bHR1cmUAc2V0X0N1bHR1cmUAcmVzb3VyY2VDdWx0dXJlAGdldF9JbnZhcmlhbnRDdWx0
dXJlAGdldF9DdXJyZW50Q3VsdHVyZQBWc2UAVlNUQVJUU2NyaXB0T2JqZWN0TW9kZWxCYXNlAFBr
emlwQ2xhc3NpY0NyeXB0b0Jhc2UAQXBwbGljYXRpb25TZXR0aW5nc0Jhc2UAaWdub3JlQ2FzZQBD
bG9zZQBTeXN0ZW0uSURpc3Bvc2FibGUuRGlzcG9zZQBiaXQ0UmV2ZXJzZQB0b1JldmVyc2UAQml0
UmV2ZXJzZQByZWN1cnNlAGdldF9NaW5EYXRlAHNldF9NaW5EYXRlAG1pbkRhdGUAZ2V0X01heERh
dGUAc2V0X01heERhdGUAbWF4RGF0ZQBBZGRVcGRhdGUARmluZEV4aXN0aW5nVXBkYXRlAEJlZ2lu
VXBkYXRlAFppcFVwZGF0ZQBPcGVuRm9yRGlyZWN0VXBkYXRlAENvbW1pdFVwZGF0ZQBBYm9ydFVw
ZGF0ZQB1cGRhdGUAQ3JlYXRlAENvbmZpcm1PdmVyd3JpdGVEZWxlZ2F0ZQBjb25maXJtRGVsZWdh
dGUATXVsdGljYXN0RGVsZWdhdGUARGVmbGF0ZQBJbmZsYXRlAEVkaXRvckJyb3dzYWJsZVN0YXRl
AHN0YXRlAERlbGV0ZQBnZXRfUGVyY2VudENvbXBsZXRlAEVudHJ5Q29tcGxldGUAZ2V0X0Nhbldy
aXRlAEJlZ2luV3JpdGUAT3ZlcndyaXRlAG92ZXJ3cml0ZQBDb21waWxlckdlbmVyYXRlZEF0dHJp
YnV0ZQBEZWJ1Z2dlck5vblVzZXJDb2RlQXR0cmlidXRlAERlYnVnZ2FibGVBdHRyaWJ1dGUARWRp
dG9yQnJvd3NhYmxlQXR0cmlidXRlAEFzc2VtYmx5VGl0bGVBdHRyaWJ1dGUAT2Jzb2xldGVBdHRy
aWJ1dGUAQXNzZW1ibHlUcmFkZW1hcmtBdHRyaWJ1dGUAVGFyZ2V0RnJhbWV3b3JrQXR0cmlidXRl
AEFzc2VtYmx5Q29uZmlndXJhdGlvbkF0dHJpYnV0ZQBBc3NlbWJseURlc2NyaXB0aW9uQXR0cmli
dXRlAERlZmF1bHRNZW1iZXJBdHRyaWJ1dGUARmxhZ3NBdHRyaWJ1dGUAQ29tcGlsYXRpb25SZWxh
eGF0aW9uc0F0dHJpYnV0ZQBBc3NlbWJseVByb2R1Y3RBdHRyaWJ1dGUAQXNzZW1ibHlDb3B5cmln
aHRBdHRyaWJ1dGUAU1NJU1NjcmlwdFRhc2tFbnRyeVBvaW50QXR0cmlidXRlAEFzc2VtYmx5Q29t
cGFueUF0dHJpYnV0ZQBSdW50aW1lQ29tcGF0aWJpbGl0eUF0dHJpYnV0ZQBnZXRfTWludXRlAFJl
YWRCeXRlAFJlYWRMZUJ5dGUAV3JpdGVCeXRlAFRyYW5zZm9ybUJ5dGUAQWxpZ25Ub0J5dGUAZ2V0
X1ZhbHVlAHNldF9WYWx1ZQBjcmNWYWx1ZQBJc1ZhbGlkVmFsdWUAZ2V0X0NyeXB0b0NoZWNrVmFs
dWUAc2V0X0NyeXB0b0NoZWNrVmFsdWUATWluVmFsdWUATWF4VmFsdWUAa2V5VmFsdWUAdmFsdWUA
Z2V0X0lzRW1iZWRkZWRBcmNoaXZlAFRlc3RBcmNoaXZlAGdldF9Jc05ld0FyY2hpdmUATW92ZQBS
ZW1vdmUAZ2V0X1NpemUAc2V0X1NpemUAZ2V0X0FFU092ZXJoZWFkU2l6ZQBnZXRfT2Zmc2V0QmFz
ZWRTaXplAHNldF9PZmZzZXRCYXNlZFNpemUAX29mZnNldEJhc2VkU2l6ZQBnZXRfQ29tcHJlc3Nl
ZFNpemUAc2V0X0NvbXByZXNzZWRTaXplAGNvbXByZXNzZWRTaXplAEVuZE9mQ2VudHJhbFJlY29y
ZEJhc2VTaXplAExvY2FsSGVhZGVyQmFzZVNpemUAQ2VudHJhbEhlYWRlckJhc2VTaXplAGdldF9C
bG9ja1NpemUAc2V0X0Jsb2NrU2l6ZQBtaW5pbXVtQmxvY2tTaXplAGdldF9JbnB1dEJsb2NrU2l6
ZQBnZXRfT3V0cHV0QmxvY2tTaXplAF9ibG9ja1NpemUAZ2V0X01pblNpemUAc2V0X01pblNpemUA
bWluU2l6ZQBDcnlwdG9IZWFkZXJTaXplAGdldF9CdWZmZXJTaXplAHNldF9CdWZmZXJTaXplAERl
ZmF1bHRCdWZmZXJTaXplAGJ1ZmZlclNpemUAWmlwNjREYXRhRGVzY3JpcHRvclNpemUAR2V0RGVz
Y3JpcHRvclNpemUAV2luZG93U2l6ZQBnZXRfTWF4U2l6ZQBzZXRfTWF4U2l6ZQBtYXhTaXplAGdl
dF9BRVNLZXlTaXplAHNldF9BRVNLZXlTaXplAFN1cHByZXNzRmluYWxpemUAY3NpemUATGFzdElu
ZGV4T2YAaW5wdXRPZmYAaW5mAGlucHV0QnVmAGRfYnVmAGxfYnVmAEdldFN0cmVhbUZvclRhZwBf
dGFnAFN5c3RlbS5UaHJlYWRpbmcARGVmbGF0ZXJQZW5kaW5nAHBlbmRpbmcAR2V0RW5jb2RpbmcA
Z2V0X0NvbnRpbnVlUnVubmluZwBzZXRfQ29udGludWVSdW5uaW5nAFN5c3RlbS5SdW50aW1lLlZl
cnNpb25pbmcAZ2V0X0lzU291cmNlU3RyaW5nAENvbnZlcnRUb1N0cmluZwBaaXBTdHJpbmcAemlw
U3RyaW5nAEdldFN0cmluZwBJbnNlcnRTdHJpbmcAcmF3U3RyaW5nAFN1YnN0cmluZwBJbml0aWFs
aXNpbmcAZGlzcG9zaW5nAENoZWNrVXBkYXRpbmcAZ2V0X0lzVXBkYXRpbmcAU3RvcERlY3J5cHRp
bmcAZ2V0X1NldHRpbmcAc2V0X1NldHRpbmcAVGltZVNldHRpbmcAdGltZVNldHRpbmcAUmVhZExF
TG9uZwBXcml0ZUxFTG9uZwBSZWFkTG9uZwBSZWFkTGVMb25nAEFkZExlTG9uZwBXcml0ZUxlTG9u
ZwBSZWFkTEVVbG9uZwBXcml0ZUxFVWxvbmcAaW5zX2gAY3VyTWF0Y2gASXNNYXRjaABGaW5kTG9u
Z2VzdE1hdGNoAGRoAGdldF9IYXNoAFVwZGF0ZUhhc2gAVHdvZmlzaABCbG93ZmlzaABGaW5pc2gA
ZmluaXNoAE1hY2ludG9zaABGbHVzaABmbHVzaABNYXRoAEdldEZ1bGxQYXRoAE1heFBhdGgAcGF0
aABzdGF0aWNETGVuZ3RoAHN0YXRpY0xMZW5ndGgAZ2V0X0xlbmd0aABzZXRfTGVuZ3RoAEdldEVu
Y29kZWRMZW5ndGgAc3RvcmVkTGVuZ3RoAEJ1aWxkTGVuZ3RoAGdvb2RMZW5ndGgAbmljZUxlbmd0
aABnZXRfVmFsdWVMZW5ndGgAX3JlYWRWYWx1ZUxlbmd0aAByZXBMZW5ndGgAU2V0TGVuZ3RoAGdl
dF9DbGVhclRleHRMZW5ndGgAY2xlYXJUZXh0TGVuZ3RoAGdldF9SYXdMZW5ndGgAcmF3TGVuZ3Ro
AG1heExlbmd0aABsZW5ndGgAZ2V0X0FFU0VuY3J5cHRpb25TdHJlbmd0aABfYWVzRW5jcnlwdGlv
blN0cmVuZ3RoAEVuZHNXaXRoAGdldF9Nb250aABEYXlzSW5Nb250aABfYmxvY2tBbmRBdXRoAFNU
XzdjYmExYTA1ODM2MjQ1YzE5YjI1ZjA1ODk2NWIxZDk0LmNzcHJvagBBc3luY0NhbGxiYWNrAGNh
bGxiYWNrAFJlYWRDaGVjawBGbHVzaFN0b3JlZEJsb2NrAFdyaXRlQmxvY2sARmx1c2hCbG9jawBU
cmFuc2Zvcm1GaW5hbEJsb2NrAFRyYW5zZm9ybUJsb2NrAENvbXByZXNzQmxvY2sARW5jcnlwdEJs
b2NrAGlzTGFzdEJsb2NrAGxhc3RCbG9jawBrZXlCbG9jawBibG9jawBnZXRfQ2FuU2VlawBXaW5k
b3dNYXNrAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuU2NyaXB0VGFzawBNaWNyb3NvZnQuU3FsU2VydmVy
LkR0cy5UYXNrcy5TY3JpcHRUYXNrAENvbnZlcnRUZW1wb3JhcnlUb0ZpbmFsAG9yaWdpbmFsAERp
c3Bvc2VJbnRlcm5hbABSZWFkU2hvcnRJbnRlcm5hbABsaXRlcmFsAG9wX0dyZWF0ZXJUaGFuT3JF
cXVhbABvcF9MZXNzVGhhbk9yRXF1YWwAdXBkYXRlSW50ZXJ2YWwAZ2V0X1Byb2dyZXNzSW50ZXJ2
YWwAc2V0X1Byb2dyZXNzSW50ZXJ2YWwAU2NyaXB0T2JqZWN0TW9kZWwAU3lzdGVtLkNvbXBvbmVu
dE1vZGVsAGRlZmF1bHRDb21wcmVzc2lvbkxldmVsAEdldExldmVsAFNldExldmVsAGxldmVsAFNU
XzdjYmExYTA1ODM2MjQ1YzE5YjI1ZjA1ODk2NWIxZDk0LmNzcHJvai5kbGwARmlsbABJc0Z1bGwA
V3JpdGVTeW1ib2wAcmVwU3ltYm9sAEdldFN5bWJvbABaaXBBRVNTdHJlYW0AVW5jb21wcmVzc2Vk
U3RyZWFtAEZpbGVTdHJlYW0AYmFzZVN0cmVhbQBnZXRfRmluYWxTdHJlYW0AQ3JlYXRlQW5kSW5p
dERlY3J5cHRpb25TdHJlYW0AQ3JlYXRlQW5kSW5pdEVuY3J5cHRpb25TdHJlYW0AY2xhc3NpY0Ny
eXB0b1N0cmVhbQBaaXBIZWxwZXJTdHJlYW0Ab3V0U3RyZWFtAGJhc2VJbnB1dFN0cmVhbQBQYXJ0
aWFsSW5wdXRTdHJlYW0AWmlwSW5wdXRTdHJlYW0ASW5mbGF0ZXJJbnB1dFN0cmVhbQBHZXRJbnB1
dFN0cmVhbQBpbnB1dFN0cmVhbQBiYXNlT3V0cHV0U3RyZWFtAFppcE91dHB1dFN0cmVhbQBEZWZs
YXRlck91dHB1dFN0cmVhbQBHZXRPdXRwdXRTdHJlYW0Ab3V0cHV0U3RyZWFtAE1lbW9yeVN0cmVh
bQBfc3RyZWFtAFRhbmRlbQBnZXRfSXRlbQBzZXRfSXRlbQBaU3lzdGVtAHVzZUZpbGVTeXN0ZW0A
Z2V0X0hvc3RTeXN0ZW0Ac2V0X0hvc3RTeXN0ZW0AU3ltbWV0cmljQWxnb3JpdGhtAEhhc2hBbGdv
cml0aG0ARW5jcnlwdGlvbkFsZ29yaXRobQBSYW5kb20AQ3BtAFppcEFFU1RyYW5zZm9ybQBJTmFt
ZVRyYW5zZm9ybQBnZXRfTmFtZVRyYW5zZm9ybQBzZXRfTmFtZVRyYW5zZm9ybQBaaXBOYW1lVHJh
bnNmb3JtAFdpbmRvd3NOYW1lVHJhbnNmb3JtAGdldF9DYW5SZXVzZVRyYW5zZm9ybQBJQ3J5cHRv
VHJhbnNmb3JtAHNldF9DcnlwdG9UcmFuc2Zvcm0AUGt6aXBDbGFzc2ljRGVjcnlwdENyeXB0b1Ry
YW5zZm9ybQBQa3ppcENsYXNzaWNFbmNyeXB0Q3J5cHRvVHJhbnNmb3JtAGNyeXB0b1RyYW5zZm9y
bQBfdHJhbnNmb3JtAEVudW0AZG51bQBibG51bQBJQ2hlY2tzdW0AY2hlY2tzdW0ARGVjb2RlQ2hr
c3VtAGdldF9Ub3RhbEluAHRvdGFsSW4AT24AcmVzb3VyY2VNYW4AU2NhbgBvcF9HcmVhdGVyVGhh
bgBEZWNvZGVIdWZmbWFuAERlZmxhdGVySHVmZm1hbgBodWZmbWFuAFRpbWVTcGFuAG1hdGNoTGVu
AHVuY29tcHJMZW4AZ2V0X0FFU1NhbHRMZW4AbGFzdExlbgBsZW4AT3BlbgBSZW9wZW4AcmVwTWlu
AFNjcmlwdE1haW4AbWF4X2NoYWluAFNlZWtPcmlnaW4Ab3JpZ2luAGdldF9WZXJzaW9uAElDU2hh
cnBDb2RlLlNoYXJwWmlwTGliLlppcC5Db21wcmVzc2lvbgBJc1ZhbGlkRXhwcmVzc2lvbgBJc1Zh
bGlkRmlsdGVyRXhwcmVzc2lvbgBleHByZXNzaW9uAGVuZExvY2F0aW9uAGRlc3RpbmF0aW9uAGdl
dF9PcGVyYXRpb24AU2V0T3BlcmF0aW9uAFRlc3RPcGVyYXRpb24Ab3BlcmF0aW9uAFN5c3RlbS5D
b25maWd1cmF0aW9uAFN5c3RlbS5HbG9iYWxpemF0aW9uAFN5c3RlbS5SdW50aW1lLlNlcmlhbGl6
YXRpb24Ab3BfU3VidHJhY3Rpb24AU3lzdGVtLlJlZmxlY3Rpb24AY29tcHJlc3Npb25GdW5jdGlv
bgBvcF9BZGRpdGlvbgBnZXRfUG9zaXRpb24Ac2V0X1Bvc2l0aW9uAHNvdXJjZVBvc2l0aW9uAGRl
c3RpbmF0aW9uUG9zaXRpb24ASU9FeGNlcHRpb24AZ2V0X0V4Y2VwdGlvbgBDcnlwdG9ncmFwaGlj
RXhjZXB0aW9uAE9iamVjdERpc3Bvc2VkRXhjZXB0aW9uAE5vdEltcGxlbWVudGVkRXhjZXB0aW9u
AE5vdFN1cHBvcnRlZEV4Y2VwdGlvbgBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24AU2hhcnBa
aXBCYXNlRXhjZXB0aW9uAFBhdGhUb29Mb25nRXhjZXB0aW9uAEFyZ3VtZW50TnVsbEV4Y2VwdGlv
bgBFbmRPZlN0cmVhbUV4Y2VwdGlvbgBBcHBsaWNhdGlvbkV4Y2VwdGlvbgBJbnZhbGlkT3BlcmF0
aW9uRXhjZXB0aW9uAFppcEV4Y2VwdGlvbgBpbm5lckV4Y2VwdGlvbgBBcmd1bWVudEV4Y2VwdGlv
bgBleGNlcHRpb24ASUNTaGFycENvZGUuU2hhcnBaaXBMaWIuRW5jcnlwdGlvbgBWZXJzaW9uU3Ry
b25nRW5jcnlwdGlvbgBLbm93bgBVbmtub3duAENvcHlUbwBGaWxlSW5mbwBDdWx0dXJlSW5mbwBG
aWxlU3lzdGVtSW5mbwBTZXJpYWxpemF0aW9uSW5mbwBnZXRfVGV4dEluZm8AbWFkZUJ5SW5mbwBE
aXJlY3RvcnlJbmZvAGluZm8ASUNTaGFycENvZGUuU2hhcnBaaXBMaWIuWmlwAENyZWF0ZVppcABF
eHRyYWN0WmlwAHRhcmdldFppcABGYXN0WmlwAFNraXAAUG9zdFVwZGF0ZUNsZWFudXAAQ2FsY0JM
RnJlcQBUb29GYXIAZ2V0X1llYXIAQ2xlYXIAX3JlcGxhY2VtZW50Q2hhcgBfYWVzVmVyAFdyaXRl
QUVTSGVhZGVyAERlY29kZUhlYWRlcgBXcml0ZUxvY2FsSGVhZGVyAFRlc3RMb2NhbEhlYWRlcgBs
b2NhbEhlYWRlcgBXcml0ZUVuY3J5cHRpb25IZWFkZXIASW5mbGF0ZXJEeW5IZWFkZXIAZHluSGVh
ZGVyAG5vSGVhZGVyAGdldF9Db21wcmVzc2lvbk1ldGhvZEZvckhlYWRlcgBXcml0ZUNlbnRyYWxE
aXJlY3RvcnlIZWFkZXIAcGF0Y2hFbnRyeUhlYWRlcgBXcml0ZUxvY2FsRW50cnlIZWFkZXIAaW50
ZXJuYWxSZWFkZXIAUk5HQ3J5cHRvU2VydmljZVByb3ZpZGVyAFN0cmluZ0J1aWxkZXIAc291cmNl
Rm9sZGVyAHNlbmRlcgBfc2xpZGVCdWZmZXIAUGVuZGluZ0J1ZmZlcgBHZXRCdWZmZXIAX2VuY3J5
cHRCdWZmZXIAb3V0QnVmZmVyAEluZmxhdGVySW5wdXRCdWZmZXIAaW5wdXRCdWZmZXIAb3V0cHV0
QnVmZmVyAFJlYWRDbGVhclRleHRCdWZmZXIAUmVhZFJhd0J1ZmZlcgBidWZmZXIAZ2V0X1Jlc291
cmNlTWFuYWdlcgBnZXRfUHdkVmVyaWZpZXIAX3B3ZFZlcmlmaWVyAGdldF9BZGxlcgByZWFkQWRs
ZXIAUmVzZXRBZGxlcgBhZGxlcgBSZWFkRGF0YUhhbmRsZXIAQ29tcGxldGVkRmlsZUhhbmRsZXIA
UHJvY2Vzc0ZpbGVIYW5kbGVyAEZpbGVGYWlsdXJlSGFuZGxlcgBEaXJlY3RvcnlGYWlsdXJlSGFu
ZGxlcgBQcm9ncmVzc0hhbmRsZXIAcHJvZ3Jlc3NIYW5kbGVyAFppcFRlc3RSZXN1bHRIYW5kbGVy
AHJlc3VsdEhhbmRsZXIAS2V5c1JlcXVpcmVkRXZlbnRIYW5kbGVyAFByb2Nlc3NEaXJlY3RvcnlI
YW5kbGVyAEZpbGVTeXN0ZW1TY2FubmVyAGdldF9Jc1N0cmVhbU93bmVyAHNldF9Jc1N0cmVhbU93
bmVyAGlzU3RyZWFtT3duZXIASUNvbXBhcmVyAFVwZGF0ZUNvbXBhcmVyAERlZmxhdGVyAGRlZmxh
dGVyAEluZmxhdGVyAGluZmxhdGVyAGZpbGVGaWx0ZXIATmFtZUZpbHRlcgBOYW1lQW5kU2l6ZUZp
bHRlcgBFeHRlbmRlZFBhdGhGaWx0ZXIASVNjYW5GaWx0ZXIAZGlyZWN0b3J5RmlsdGVyAGZpbHRl
cgBFbnRlcgBub1psaWJIZWFkZXJPckZvb3RlcgBOZXZlcgBUb0xvd2VyAFNjYW5EaXIAQWRkRXJy
b3IARmluZEZpcnN0RXJyb3IAU3RyZWFtTWFuaXB1bGF0b3IASUVudW1lcmF0b3IAR2V0RW51bWVy
YXRvcgBaaXBFbnRyeUVudW1lcmF0b3IAUmFuZG9tTnVtYmVyR2VuZXJhdG9yAC5jdG9yAC5jY3Rv
cgBNb25pdG9yAFJlYWREYXRhRGVzY3JpcHRvcgBXcml0ZURhdGFEZXNjcmlwdG9yAENyZWF0ZURl
Y3J5cHRvcgBDcmVhdGVFbmNyeXB0b3IAX2VuY3J5cHRvcgBwdHIAc3RyAGdldF9Ib3VyAFN5c3Rl
bS5EaWFnbm9zdGljcwBjaGlsZHMAZ2V0X1RvdGFsU2Vjb25kcwBGcm9tU2Vjb25kcwBEZXMAU3lz
dGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcwBTeXN0ZW0uUmVzb3VyY2VzAFNUXzdjYmExYTA1
ODM2MjQ1YzE5YjI1ZjA1ODk2NWIxZDk0LmNzcHJvai5Qcm9wZXJ0aWVzLlJlc291cmNlcy5yZXNv
dXJjZXMAc3RhdGljRENvZGVzAHN0YXRpY0xDb2RlcwBTZXRTdGF0aWNDb2RlcwBzdGF0aWNDb2Rl
cwBCdWlsZENvZGVzAGJsVHJlZUNvZGVzAG1pbk51bUNvZGVzAG51bUNvZGVzAG1pbkNvZGVzAERl
YnVnZ2luZ01vZGVzAGNvZGVzAFNlbmRBbGxUcmVlcwBHZXREaXJlY3RvcmllcwBnZXRfQ3JlYXRl
RW1wdHlEaXJlY3RvcmllcwBzZXRfQ3JlYXRlRW1wdHlEaXJlY3RvcmllcwBSZWFkRW50cmllcwBz
aXplRW50cmllcwBub09mRW50cmllcwBnZXRfQ2FuUGF0Y2hFbnRyaWVzAGVudHJpZXMAU1RfN2Ni
YTFhMDU4MzYyNDVjMTliMjVmMDU4OTY1YjFkOTQuY3Nwcm9qLlByb3BlcnRpZXMAZ2V0X1Zhcmlh
YmxlcwBnZXRfSGFzTWF0Y2hpbmdGaWxlcwBoYXNNYXRjaGluZ0ZpbGVzAEdldEZpbGVzAFJ1blVw
ZGF0ZXMAZ2V0X0F0dHJpYnV0ZXMAZ2V0X0V4dGVybmFsRmlsZUF0dHJpYnV0ZXMAc2V0X0V4dGVy
bmFsRmlsZUF0dHJpYnV0ZXMAZXh0ZXJuYWxGaWxlQXR0cmlidXRlcwBNYWtlRXh0ZXJuYWxBdHRy
aWJ1dGVzAEhhc0Rvc0F0dHJpYnV0ZXMAZ2V0X0dldEF0dHJpYnV0ZXMAc2V0X0dldEF0dHJpYnV0
ZXMAZ2V0X1NldEF0dHJpYnV0ZXMAc2V0X1NldEF0dHJpYnV0ZXMAYXR0cmlidXRlcwBnZXRfQXZh
aWxhYmxlQnl0ZXMAUmZjMjg5OERlcml2ZUJ5dGVzAENvcHlEZXNjcmlwdG9yQnl0ZXMAR2V0Qnl0
ZXMAc2FsdEJ5dGVzAE5leHRCeXRlcwBDb3B5Qnl0ZXMAZ2V0X0xlZ2FsQmxvY2tTaXplcwBnZXRf
TGVnYWxLZXlTaXplcwBnZXRfRmxhZ3MAc2V0X0ZsYWdzAEdlbmVyYWxCaXRGbGFncwBfZmxhZ3MA
U2V0dGluZ3MAS2V5c1JlcXVpcmVkRXZlbnRBcmdzAFNjYW5GYWlsdXJlRXZlbnRBcmdzAFNjYW5F
dmVudEFyZ3MAUHJvZ3Jlc3NFdmVudEFyZ3MARGlyZWN0b3J5RXZlbnRBcmdzAGdldF9UcmltSW5j
b21pbmdQYXRocwBzZXRfVHJpbUluY29taW5nUGF0aHMAX3RyaW1JbmNvbWluZ1BhdGhzAHN0YXRp
Y0xlbmd0aHMAY29kZUxlbmd0aHMAZ2V0X0NhblRyYW5zZm9ybU11bHRpcGxlQmxvY2tzAFdpbmRv
d3NQYXRoVXRpbHMAU3RyZWFtVXRpbHMAVk1DbXMAT3BlblZtcwBJQ1NoYXJwQ29kZS5TaGFycFpp
cExpYi5aaXAuQ29tcHJlc3Npb24uU3RyZWFtcwBlbGVtcwBJQ1NoYXJwQ29kZS5TaGFycFppcExp
Yi5DaGVja3N1bXMAYmxMZW5zAGxpdGRpc3RMZW5zAFN5c3RlbS5UZXh0LlJlZ3VsYXJFeHByZXNz
aW9ucwBTeXN0ZW0uQ29sbGVjdGlvbnMAUmVnZXhPcHRpb25zAF9zbGlkZUJ1ZkZyZWVQb3MAY3Jj
UGF0Y2hQb3MAc2l6ZVBhdGNoUG9zAF9lbmNyUG9zAF9zbGlkZUJ1ZlN0YXJ0UG9zAE1zZG9zAGZy
ZXFzAGdldF9DaGFycwBzZXRfQ2hhcnMAR2V0SW52YWxpZFBhdGhDaGFycwBJbnZhbGlkRW50cnlD
aGFycwBSdW50aW1lSGVscGVycwBGaW5kQWxsRXJyb3JzAEZpbGVBY2Nlc3MAU3VjY2VzcwBQcm9n
cmVzcwBFbmhhbmNlZENvbXByZXNzAGdldF9DYW5EZWNvbXByZXNzAGdldF9EdHMAbmVlZGVkQml0
cwBnZXRfQXZhaWxhYmxlQml0cwBXcml0ZUJpdHMAUGVla0JpdHMAcmVwQml0cwBEcm9wQml0cwBH
ZXRCaXRzAGV4dHJhX2JpdHMAU2NyaXB0UmVzdWx0cwBaaXBDb25zdGFudHMARGVmbGF0ZXJDb25z
dGFudHMAQWRkRmlsZUNvbnRlbnRzAEZhc3RaaXBFdmVudHMAZXZlbnRzAGJsX2NvdW50cwBNaXNj
ZWxsYW5lb3VzVGVzdHMAdGVzdHMAZ2V0X0V4aXN0cwBUZXN0U3RhdHVzAHN0YXR1cwBBbHRlcm5h
dGVNdnMAQWx3YXlzAFVwZGF0ZUtleXMAR2VuZXJhdGVLZXlzAGdldF9IYXZlS2V5cwBTZXRLZXlz
AGtleXMAQ29uY2F0AFNsb3dSZXBlYXQAVmZhdABGb3JtYXQAZ2V0X1Jlc3RvcmVEYXRlVGltZU9u
RXh0cmFjdABzZXRfUmVzdG9yZURhdGVUaW1lT25FeHRyYWN0AGdldF9SZXN0b3JlQXR0cmlidXRl
c09uRXh0cmFjdABzZXRfUmVzdG9yZUF0dHJpYnV0ZXNPbkV4dHJhY3QAdmVyc2lvblJlcXVpcmVk
VG9FeHRyYWN0AHZlcnNpb25Ub0V4dHJhY3QAT2JqZWN0AG9iamVjdABDb3B5RW50cnlEYXRhRGly
ZWN0AENvcHlEZXNjcmlwdG9yQnl0ZXNEaXJlY3QAQ29weUVudHJ5RGlyZWN0AERlY29kZURpY3QA
Q29weURpY3QAZ2V0X1RhcmdldABmaXhlZFRhcmdldAB0YXJnZXQAUmVzZXQAZ2V0X09mZnNldABz
ZXRfT2Zmc2V0AHN0b3JlZE9mZnNldABnZXRfQ3JjUGF0Y2hPZmZzZXQAc2V0X0NyY1BhdGNoT2Zm
c2V0AGdldF9TaXplUGF0Y2hPZmZzZXQAc2V0X1NpemVQYXRjaE9mZnNldABjZW50cmFsRGlyT2Zm
c2V0AGlucHV0T2Zmc2V0AG91dHB1dE9mZnNldABvZmZzZXQAVGFsbHlMaXQAb3BfSW1wbGljaXQA
bGFzdF9saXQARXhpdABzYWx0AGdldF9EZWZhdWx0AElBc3luY1Jlc3VsdABzZXRfVGFza1Jlc3Vs
dAByZXN1bHQAUmVhZExFSW50AFdyaXRlTEVJbnQAUmVhZEludABSZWFkTGVJbnQAQWRkTGVJbnQA
V3JpdGVMZUludABXcml0ZUludABnZXRfUmVwbGFjZW1lbnQAc2V0X1JlcGxhY2VtZW50AHJlcGxh
Y2VtZW50AGdldF9Db21tZW50AHNldF9Db21tZW50AGdldF9aaXBGaWxlQ29tbWVudAB6aXBDb21t
ZW50AFNldENvbW1lbnQAZ2V0X1Jhd0NvbW1lbnQAY29tbWVudABnZXRfQ3VycmVudABSZWFkTEVV
aW50AFdyaXRlTEVVaW50AGdldF9Db3VudABnZXRfVW5yZWFkQ291bnQAZ2V0X0Vycm9yQ291bnQA
Z2V0X0JpdENvdW50AGJpdENvdW50AGlucHV0Q291bnQAY291bnQAYW1vdW50AERyb3BQYXRoUm9v
dABHZXRQYXRoUm9vdABQcm9tcHQAQ29weUFuZEVuY3J5cHQAX3JlYWRWYWx1ZVN0YXJ0AG1hdGNo
U3RhcnQAYmxvY2tTdGFydAByZXBTdGFydABzdHJzdGFydABTb3J0AFJlYWRMRVNob3J0AFdyaXRl
TEVTaG9ydABSZWFkU2hvcnQAUmVhZExlU2hvcnQAQWRkTGVTaG9ydABXcml0ZUxlU2hvcnQAV3Jp
dGVTaG9ydABTZXRTaG9ydABSZWFkTEVVc2hvcnQAV3JpdGVMRVVzaG9ydABEZWZsYXRlRmFzdAB0
b1Rlc3QASGVhZGVyVGVzdABkZXN0AHJlcERpc3QAVGFsbHlEaXN0AEFycmF5TGlzdABnZXRfVG90
YWxPdXQAdG90YWxPdXQAZ2V0X0NhblRpbWVvdXQAZ2V0X0lzTmVlZGluZ0lucHV0AGdldF9SZW1h
aW5pbmdJbnB1dABTZXRJbmZsYXRlcklucHV0AE5lZWRzSW5wdXQAU2V0SW5wdXQAaW5wdXQAQ29w
eU91dHB1dABHZXRUZW1wb3JhcnlPdXRwdXQAb3V0cHV0AENvbnZlcnRUb1N0cmluZ0V4dABNb3Zl
TmV4dABTeXN0ZW0uVGV4dAB1c2VVbmljb2RlVGV4dABnZXRfSXNVbmljb2RlVGV4dABzZXRfSXNV
bmljb2RlVGV4dABnZXRfQ2xlYXJUZXh0AGludGVybmFsQ2xlYXJUZXh0AGNsZWFyVGV4dABTdHJl
YW1pbmdDb250ZXh0AGNvbnRleHQAcHJldgBnZXRfTm93AFNsaWRlV2luZG93AEZpbGxXaW5kb3cA
T3V0cHV0V2luZG93AG91dHB1dFdpbmRvdwB3aW5kb3cARGVmbGF0ZVNsb3cATWF4AGdldF9DdXJy
ZW50UmVhZEluZGV4AGdldF9aaXBGaWxlSW5kZXgAc2V0X1ppcEZpbGVJbmRleAB6aXBGaWxlSW5k
ZXgAZ2V0X0VudHJ5QnlJbmRleABlbnRyeUluZGV4AF9pbmRleABSZWdleABnZXRfVHJpbVByZWZp
eABzZXRfVHJpbVByZWZpeAB0cmltUHJlZml4AFVuaXgAZ2V0X1ZlcnNpb25NYWRlQnkAdmVyc2lv
bk1hZGVCeQBnZXRfRGF5AFRvQnl0ZUFycmF5AEluaXRpYWxpemVBcnJheQBDb252ZXJ0VG9BcnJh
eQBhcnJheQBnZXRfS2V5AHNldF9LZXkAcmdiS2V5AEdlbmVyYXRlS2V5AENvbnRhaW5zS2V5AGtl
eQBNb2RpZnkAZ2V0X1N0cmF0ZWd5AHNldF9TdHJhdGVneQBEZWZsYXRlU3RyYXRlZ3kAU2V0U3Ry
YXRlZ3kAVGVzdFN0cmF0ZWd5AHN0cmF0ZWd5AFN5c3RlbS5TZWN1cml0eS5DcnlwdG9ncmFwaHkA
Z2V0X0Fzc2VtYmx5AFJlYWRGdWxseQBIdWZmbWFuT25seQBVcGRhdGVDb21tZW50T25seQBJbmRl
eE9mQW55AGJ5dGVzVG9Db3B5AE1ha2VUZW1wb3JhcnlDb3B5AFNraXBUb0J5dGVCb3VuZGFyeQBn
ZXRfSXNOZWVkaW5nRGljdGlvbmFyeQBTZXREaWN0aW9uYXJ5AGRpY3Rpb25hcnkASVRhZ2dlZERh
dGFGYWN0b3J5AElFbnRyeUZhY3RvcnkAZ2V0X0VudHJ5RmFjdG9yeQBzZXRfRW50cnlGYWN0b3J5
AFppcEVudHJ5RmFjdG9yeQBBZGREaXJlY3RvcnkAc291cmNlRGlyZWN0b3J5AGdldF9CYXNlRGly
ZWN0b3J5AHNldF9CYXNlRGlyZWN0b3J5AF9iYXNlRGlyZWN0b3J5AENyZWF0ZURpcmVjdG9yeQBX
cml0ZVppcDY0RW5kT2ZDZW50cmFsRGlyZWN0b3J5AFdyaXRlRW5kT2ZDZW50cmFsRGlyZWN0b3J5
AHN0YXJ0T2ZDZW50cmFsRGlyZWN0b3J5AFRyYW5zZm9ybURpcmVjdG9yeQBnZXRfSXNEaXJlY3Rv
cnkAT25Qcm9jZXNzRGlyZWN0b3J5AHRhcmdldERpcmVjdG9yeQBkaXJlY3RvcnkAZ2V0X0lzRE9T
RW50cnkAZ2V0X0VudHJ5AEFkZEVudHJ5AEZpbmRFbnRyeQBNYWtlRmlsZUVudHJ5AEV4dHJhY3RG
aWxlRW50cnkAQ29tcGxldGVDbG9zZUVudHJ5AExvY2F0ZUVudHJ5AFppcEVudHJ5AGN1ckVudHJ5
AGdldF9DYW5EZWNvbXByZXNzRW50cnkARXh0cmFjdEVudHJ5AEdldEVudHJ5AFNldEVudHJ5AG9m
ZnNldE9mRmlyc3RFbnRyeQBnZXRfT3V0RW50cnkAR2V0TmV4dEVudHJ5AFB1dE5leHRFbnRyeQBB
ZGROZXdFbnRyeQBTdGFydE5ld0VudHJ5AF9uZXdFbnRyeQBNb2RpZnlFbnRyeQBDb3B5RW50cnkA
TWFrZURpcmVjdG9yeUVudHJ5AGVudHJ5AG9wX0luZXF1YWxpdHkAQ2hlY2tFbXB0eQBtYXhfbGF6
eQAAJUkAbgB2AGEAbABpAGQAIABiAGwAbwBjAGsAcwBpAHoAZQAgAAAnLgAgAE0AdQBzAHQAIABi
AGUAIAAxADYAIABvAHIAIAAzADIALgAANUkAbgB2AGEAbABpAGQAIABzAGEAbAB0ACAAbABlAG4A
LgAgAE0AdQBzAHQAIABiAGUAIAAAHyAAZgBvAHIAIABiAGwAbwBjAGsAcwBpAHoAZQAgAABHWgBp
AHAAQQBFAFMAVAByAGEAbgBzAGYAbwByAG0ALgBUAHIAYQBuAHMAZgBvAHIAbQBGAGkAbgBhAGwA
QgBsAG8AYwBrAAA1WgBpAHAAQQBFAFMAUwB0AHIAZQBhAG0AIABvAG4AbAB5ACAAZgBvAHIAIABy
AGUAYQBkAAA/SQBuAHQAZQByAG4AYQBsACAAZQByAHIAbwByACAAbQBpAHMAcwBlAGQAIABhAHUA
dABoACAAYwBvAGQAZQAAgS1BAEUAUwAgAEEAdQB0AGgAZQBuAHQAaQBjAGEAdABpAG8AbgAgAEMA
bwBkAGUAIABkAG8AZQBzACAAbgBvAHQAIABtAGEAdABjAGgALgAgAFQAaABpAHMAIABpAHMAIABh
ACAAcwB1AHAAZQByAC0AQwBSAEMAIABjAGgAZQBjAGsAIABvAG4AIAB0AGgAZQAgAGQAYQB0AGEA
IABpAG4AIAB0AGgAZQAgAGYAaQBsAGUAIABhAGYAdABlAHIAIABjAG8AbQBwAHIAZQBzAHMAaQBv
AG4AIABhAG4AZAAgAGUAbgBjAHIAeQBwAHQAaQBvAG4ALgAgAA0ACgBUAGgAZQAgAGYAaQBsAGUA
IABtAGEAeQAgAGIAZQAgAGQAYQBtAGEAZwBlAGQALgABCXMAZQBlAGQAAB1MAGUAbgBnAHQAaAAg
AGkAcwAgAHoAZQByAG8AAA9rAGUAeQBEAGEAdABhAAAvSwBlAHkAIABsAGUAbgBnAHQAaAAgAGkA
cwAgAG4AbwB0ACAAdgBhAGwAaQBkAAArQgBsAG8AYwBrACAAcwBpAHoAZQAgAGkAcwAgAGkAbgB2
AGEAbABpAGQAAAt2AGEAbAB1AGUAACdLAGUAeQAgAHMAaQB6AGUAIABpAHMAIABpAGwAbABlAGcA
YQBsAAANdABvAFQAZQBzAHQAAElNAGkAcwBzAGkAbgBnACAAdABlAHIAbQBpAG4AYQB0AGkAbgBn
ACAAZQBzAGMAYQBwAGUAIABjAGgAYQByAGEAYwB0AGUAcgAAEW8AcgBpAGcAaQBuAGEAbAAAAQAf
RQB4AGMAZQBlAGQAcwAgAE0AYQB4AEQAYQB0AGUAAB9FAHgAYwBlAGUAZABzACAATQBpAG4ARABh
AHQAZQAADXMAdAByAGUAYQBtAAANYgB1AGYAZgBlAHIAAA1vAGYAZgBzAGUAdAAAC2MAbwB1AG4A
dAAADXMAbwB1AHIAYwBlAAAXZABlAHMAdABpAG4AYQB0AGkAbwBuAAAnQgB1AGYAZgBlAHIAIABp
AHMAIAB0AG8AbwAgAHMAbQBhAGwAbAAAH3AAcgBvAGcAcgBlAHMAcwBIAGEAbgBkAGwAZQByAAAf
YwBvAG4AZgBpAHIAbQBEAGUAbABlAGcAYQB0AGUAABtiAGEAcwBlAEQAaQByAGUAYwB0AG8AcgB5
AAAzRABpAHIAZQBjAHQAbwByAHkAIABuAGEAbQBlACAAaQBzACAAaQBuAHYAYQBsAGkAZAAAA1wA
AEdDAGEAbgBuAG8AdAAgAGgAYQB2AGUAIABhAG4AIABlAG0AcAB0AHkAIABkAGkAcgBlAGMAdABv
AHIAeQAgAG4AYQBtAGUAAAluAGEAbQBlAAADLwAABVwAXAAALWkAbgB2AGEAbABpAGQAIABwAGEA
dABoACAAYwBoAGEAcgBhAGMAdABlAHIAADtpAG4AdgBhAGwAaQBkACAAcgBlAHAAbABhAGMAZQBt
AGUAbgB0ACAAYwBoAGEAcgBhAGMAdABlAHIAACFOAGEAbQBlACAAaQBzACAAdABvAG8AIABsAG8A
bgBnAAAxdgBlAHIAcwBpAG8AbgBSAGUAcQB1AGkAcgBlAGQAVABvAEUAeAB0AHIAYQBjAHQAAAtl
AG4AdAByAHkAAEFDAG8AbQBwAHIAZQBzAHMAaQBvAG4AIABtAGUAdABoAG8AZAAgAG4AbwB0ACAA
cwB1AHAAcABvAHIAdABlAGQAAD1JAG4AdgBhAGwAaQBkACAAQQBFAFMARQBuAGMAcgB5AHAAdABp
AG8AbgBTAHQAcgBlAG4AZwB0AGgAIAAARUEARQBTAEsAZQB5AFMAaQB6AGUAIABtAHUAcwB0ACAA
YgBlACAAMAAsACAAMQAyADgAIABvAHIAIAAyADUANgA6ACAAAG9FAHgAdAByAGEAIABkAGEAdABh
ACAAZQB4AHQAZQBuAGQAZQBkACAAWgBpAHAANgA0ACAAaQBuAGYAbwByAG0AYQB0AGkAbwBuACAA
bABlAG4AZwB0AGgAIABpAHMAIABpAG4AdgBhAGwAaQBkAABnWgBpAHAANgA0ACAARQB4AHQAZQBu
AGQAZQBkACAAaQBuAGYAbwByAG0AYQB0AGkAbwBuACAAcgBlAHEAdQBpAHIAZQBkACAAYgB1AHQA
IABpAHMAIABtAGkAcwBzAGkAbgBnAC4AAC9OAFQARgBTACAARQB4AHQAcgBhACAAZABhAHQAYQAg
AGkAbgB2AGEAbABpAGQAAC1BAEUAUwAgAEUAeAB0AHIAYQAgAEQAYQB0AGEAIABMAGUAbgBnAHQA
aAAgAAATIABpAG4AdgBhAGwAaQBkAC4AAC1BAEUAUwAgAEUAeAB0AHIAYQAgAEQAYQB0AGEAIABt
AGkAcwBzAGkAbgBnAAAnYwBhAG4AbgBvAHQAIABlAHgAYwBlAGUAZAAgADYANQA1ADMANQAAOVYA
YQBsAHUAZQAgAGkAcwAgAHQAbwBvACAAbwBsAGQAIAB0AG8AIABiAGUAIAB2AGEAbABpAGQAAE9V
AG4AaABhAG4AZABsAGUAZAAgAHQAaQBtAGUAIABzAGUAdAB0AGkAbgBnACAAaQBuACAATQBhAGsA
ZQBGAGkAbABlAEUAbgB0AHIAeQAAWVUAbgBoAGEAbgBkAGwAZQBkACAAdABpAG0AZQAgAHMAZQB0
AHQAaQBuAGcAIABpAG4AIABNAGEAawBlAEQAaQByAGUAYwB0AG8AcgB5AEUAbgB0AHIAeQAACWQA
YQB0AGEAADdEAGEAdABhACAAZQB4AGMAZQBlAGQAcwAgAG0AYQB4AGkAbQB1AG0AIABsAGUAbgBn
AHQAaAAAYUYAaQBuAGQAIABtAHUAcwB0ACAAYgBlACAAYwBhAGwAbABlAGQAIABiAGUAZgBvAHIA
ZQAgAGMAYQBsAGwAaQBuAGcAIABhACAAUgBlAGEAZAAgAG0AZQB0AGgAbwBkAAAVdABhAGcAZwBl
AGQARABhAHQAYQAAEWgAZQBhAGQAZQByAEkARAAAE2YAaQBlAGwAZABEAGEAdABhAAAtZQB4AGMA
ZQBlAGQAcwAgAG0AYQB4AGkAbQB1AG0AIABsAGUAbgBnAHQAaAAAI0UAbgBkACAAbwBmACAAZQB4
AHQAcgBhACAAZABhAHQAYQAAP0MAYQBuAG4AbwB0ACAAcgBlAGEAZAAgAGIAZQBmAG8AcgBlACAA
cwB0AGEAcgB0ACAAbwBmACAAdABhAGcAAAlmAGkAbABlAAAtUwB0AHIAZQBhAG0AIABpAHMAIABu
AG8AdAAgAHMAZQBlAGsAYQBiAGwAZQAAEWYAaQBsAGUATgBhAG0AZQAAE28AdQB0AFMAdAByAGUA
YQBtAAAvUwB0AHIAZQBhAG0AIABpAHMAIABuAG8AdAAgAHcAcgBpAHQAZQBhAGIAbABlAAAPWgBp
AHAARgBpAGwAZQAAK0UAbgB0AHIAeQAgAGMAYQBuAG4AbwB0ACAAYgBlACAAZgBvAHUAbgBkAAA5
VQBuAGEAYgBsAGUAIAB0AG8AIABkAGUAYwByAHkAcAB0ACAAdABoAGkAcwAgAGUAbgB0AHIAeQAA
P1UAbgBzAHUAcABwAG8AcgB0AGUAZAAgAGMAbwBtAHAAcgBlAHMAcwBpAG8AbgAgAG0AZQB0AGgA
bwBkACAAADtFAHgAYwBlAHAAdABpAG8AbgAgAGQAdQByAGkAbgBnACAAdABlAHMAdAAgAC0AIAAn
AHsAMAB9ACcAARlDAFIAQwAgAG0AaQBzAG0AYQB0AGMAaAAAR1cAcgBvAG4AZwAgAGwAbwBjAGEA
bAAgAGgAZQBhAGQAZQByACAAcwBpAGcAbgBhAHQAdQByAGUAIABAAHsAMAA6AFgAfQAAN1MAaQB6
AGUAIABpAG4AdgBhAGwAaQBkACAAZgBvAHIAIABkAGUAcwBjAHIAaQBwAHQAbwByAABNQwBvAG0A
cAByAGUAcwBzAGUAZAAgAHMAaQB6AGUAIABpAG4AdgBhAGwAaQBkACAAZgBvAHIAIABkAGUAcwBj
AHIAaQBwAHQAbwByAABXUgBlAHEAdQBpAHIAZQBkACAAWgBpAHAANgA0ACAAZQB4AHQAZQBuAGQA
ZQBkACAAaQBuAGYAbwByAG0AYQB0AGkAbwBuACAAbQBpAHMAcwBpAG4AZwAAdVYAZQByAHMAaQBv
AG4AIAByAGUAcQB1AGkAcgBlAGQAIAB0AG8AIABlAHgAdAByAGEAYwB0ACAAdABoAGkAcwAgAGUA
bgB0AHIAeQAgAG4AbwB0ACAAcwB1AHAAcABvAHIAdABlAGQAIAAoAHsAMAB9ACkAAICXVABoAGUA
IABsAGkAYgByAGEAcgB5ACAAZABvAGUAcwAgAG4AbwB0ACAAcwB1AHAAcABvAHIAdAAgAHQAaABl
ACAAegBpAHAAIAB2AGUAcgBzAGkAbwBuACAAcgBlAHEAdQBpAHIAZQBkACAAdABvACAAZQB4AHQA
cgBhAGMAdAAgAHQAaABpAHMAIABlAG4AdAByAHkAAG9WAGUAcgBzAGkAbwBuACAAcgBlAHEAdQBp
AHIAZQBkACAAdABvACAAZQB4AHQAcgBhAGMAdAAgAHQAaABpAHMAIABlAG4AdAByAHkAIABpAHMA
IABpAG4AdgBhAGwAaQBkACAAKAB7ADAAfQApAABDUgBlAHMAZQByAHYAZQBkACAAYgBpAHQAIABm
AGwAYQBnAHMAIABjAGEAbgBuAG8AdAAgAGIAZQAgAHMAZQB0AC4AAICNVgBlAHIAcwBpAG8AbgAg
AHIAZQBxAHUAaQByAGUAZAAgAHQAbwAgAGUAeAB0AHIAYQBjAHQAIAB0AGgAaQBzACAAZQBuAHQA
cgB5ACAAaQBzACAAdABvAG8AIABsAG8AdwAgAGYAbwByACAAZQBuAGMAcgB5AHAAdABpAG8AbgAg
ACgAewAwAH0AKQAAc1MAdAByAG8AbgBnACAAZQBuAGMAcgB5AHAAdABpAG8AbgAgAGYAbABhAGcA
IABzAGUAdAAgAGIAdQB0ACAAZQBuAGMAcgB5AHAAdABpAG8AbgAgAGYAbABhAGcAIABpAHMAIABu
AG8AdAAgAHMAZQB0AABfUABhAHQAYwBoAGUAZAAgAGQAYQB0AGEAIAByAGUAcQB1AGkAcgBlAHMA
IABoAGkAZwBoAGUAcgAgAHYAZQByAHMAaQBvAG4AIAB0AGgAYQBuACAAKAB7ADAAfQApAABVQwBl
AG4AdAByAGEAbAAgAGgAZQBhAGQAZQByAC8AbABvAGMAYQBsACAAaABlAGEAZABlAHIAIABmAGwA
YQBnAHMAIABtAGkAcwBtAGEAdABjAGgAAG9DAGUAbgB0AHIAYQBsACAAaABlAGEAZABlAHIALwBs
AG8AYwBhAGwAIABoAGUAYQBkAGUAcgAgAGMAbwBtAHAAcgBlAHMAcwBpAG8AbgAgAG0AZQB0AGgA
bwBkACAAbQBpAHMAbQBhAHQAYwBoAAAxRQB4AHQAcgBhAGMAdAAgAHYAZQByAHMAaQBvAG4AIABt
AGkAcwBtAGEAdABjAGgAAG1TAHQAcgBvAG4AZwAgAGUAbgBjAHIAeQBwAHQAaQBvAG4AIABmAGwA
YQBnACAAcwBlAHQAIABiAHUAdAAgAHYAZQByAHMAaQBvAG4AIABuAG8AdAAgAGgAaQBnAGgAIABl
AG4AbwB1AGcAaAAAX0gAZQBhAGQAZQByACAAbQBhAHMAawBlAGQAIABzAGUAdAAgAGIAdQB0ACAA
ZABhAHQAZQAvAHQAaQBtAGUAIAB2AGEAbAB1AGUAcwAgAG4AbwBuAC0AegBlAHIAbwABUUMAZQBu
AHQAcgBhAGwAIABoAGUAYQBkAGUAcgAvAGwAbwBjAGEAbAAgAGgAZQBhAGQAZQByACAAYwByAGMA
IABtAGkAcwBtAGEAdABjAGgAADdJAG4AdgBhAGwAaQBkACAAQwBSAEMAIABmAG8AcgAgAGUAbQBw
AHQAeQAgAGUAbgB0AHIAeQAAM0YAaQBsAGUAIABuAGEAbQBlACAAbABlAG4AZwB0AGgAIABtAGkA
cwBtAGEAdABjAGgAAGVDAGUAbgB0AHIAYQBsACAAaABlAGEAZABlAHIAIABhAG4AZAAgAGwAbwBj
AGEAbAAgAGgAZQBhAGQAZQByACAAZgBpAGwAZQAgAG4AYQBtAGUAIABtAGkAcwBtAGEAdABjAGgA
ADVEAGkAcgBlAGMAdABvAHIAeQAgAGMAYQBuAG4AbwB0ACAAaABhAHYAZQAgAHMAaQB6AGUAAENE
AGkAcgBlAGMAdABvAHIAeQAgAGMAbwBtAHAAcgBlAHMAcwBlAGQAIABzAGkAegBlACAAaQBuAHYA
YQBsAGkAZAAAH04AYQBtAGUAIABpAHMAIABpAG4AdgBhAGwAaQBkAAB/UwBpAHoAZQAgAG0AaQBz
AG0AYQB0AGMAaAAgAGIAZQB0AHcAZQBlAG4AIABjAGUAbgB0AHIAYQBsACAAaABlAGEAZABlAHIA
KAB7ADAAfQApACAAYQBuAGQAIABsAG8AYwBhAGwAIABoAGUAYQBkAGUAcgAoAHsAMQB9ACkAAICV
QwBvAG0AcAByAGUAcwBzAGUAZAAgAHMAaQB6AGUAIABtAGkAcwBtAGEAdABjAGgAIABiAGUAdAB3
AGUAZQBuACAAYwBlAG4AdAByAGEAbAAgAGgAZQBhAGQAZQByACgAewAwAH0AKQAgAGEAbgBkACAA
bABvAGMAYQBsACAAaABlAGEAZABlAHIAKAB7ADEAfQApAAApYwBhAG4AbgBvAHQAIABiAGUAIABi
AGUAbABvAHcAIAAxADAAMgA0AAAdYQByAGMAaABpAHYAZQBTAHQAbwByAGEAZwBlAAAVZABhAHQA
YQBTAG8AdQByAGMAZQAAR0MAYQBuAG4AbwB0ACAAdQBwAGQAYQB0AGUAIABlAG0AYgBlAGQAZABl
AGQALwBTAEYAWAAgAGEAcgBjAGgAaQB2AGUAcwAATUMAbwBtAG0AZQBuAHQAIABsAGUAbgBnAHQA
aAAgAGUAeABjAGUAZQBkAHMAIABtAGEAeABpAG0AdQBtACAALQAgADYANQA1ADMANQABI2MAbwBt
AHAAcgBlAHMAcwBpAG8AbgBNAGUAdABoAG8AZAAAE2UAbgB0AHIAeQBOAGEAbQBlAAA1RQBuAHQA
cgB5ACAAYwBhAG4AbgBvAHQAIABoAGEAdgBlACAAYQBuAHkAIABkAGEAdABhAAAbZABpAHIAZQBj
AHQAbwByAHkATgBhAG0AZQAAN0MAYQBuAG4AbwB0ACAAZgBpAG4AZAAgAGUAbgB0AHIAeQAgAHQA
bwAgAGQAZQBsAGUAdABlAAApRQBuAHQAcgB5ACAAbgBhAG0AZQAgAHQAbwBvACAAbABvAG4AZwAu
AABLSQBuAHQAZQByAG4AYQBsACAAZQByAHIAbwByACAAYwBhAG4AbgBvAHQAIABmAGkAbgBkACAA
ZQB4AHQAcgBhACAAZABhAHQAYQAAd0EAdAB0AGUAbQBwAHQAIAB0AG8AIAB3AHIAaQB0AGUAIABj
AGUAbgB0AHIAYQBsACAAZABpAHIAZQBjAHQAbwByAHkAIABlAG4AdAByAHkAIAB3AGkAdABoACAA
dQBuAGsAbgBvAHcAbgAgAGMAcwBpAHoAZQAAdUEAdAB0AGUAbQBwAHQAIAB0AG8AIAB3AHIAaQB0
AGUAIABjAGUAbgB0AHIAYQBsACAAZABpAHIAZQBjAHQAbwByAHkAIABlAG4AdAByAHkAIAB3AGkA
dABoACAAdQBuAGsAbgBvAHcAbgAgAHMAaQB6AGUAAHNBAHQAdABlAG0AcAB0ACAAdABvACAAdwBy
AGkAdABlACAAYwBlAG4AdAByAGEAbAAgAGQAaQByAGUAYwB0AG8AcgB5ACAAZQBuAHQAcgB5ACAA
dwBpAHQAaAAgAHUAbgBrAG4AbwB3AG4AIABjAHIAYwAAL0UAbgB0AHIAeQAgAG4AYQBtAGUAIABp
AHMAIAB0AG8AbwAgAGwAbwBuAGcALgAAL1UAbgB4AHAAZQBjAHQAZQBkACAAZQBuAGQAIABvAGYA
IABzAHQAcgBlAGEAbQAAR0QAZQBzAHQAaQBuAGEAdABpAG8AbgAgAGEAbgBkACAAcwBvAHUAcgBj
AGUAIABhAHIAZQAgAHQAaABlACAAcwBhAG0AZQAAVUYAYQBpAGwAZQBkACAAdABvACAAYwBvAHAA
eQAgAGIAeQB0AGUAcwAgAGUAeABwAGUAYwB0AGUAZAAgAHsAMAB9ACAAcgBlAGEAZAAgAHsAMQB9
AAA3VQBuAGsAbgBvAHcAbgAgAGMAbwBtAHAAcgBlAHMAcwBpAG8AbgAgAG0AZQB0AGgAbwBkACAA
AD9FAG4AdAByAHkAIABzAGkAegBlAC8AcwB0AHIAZQBhAG0AIABzAGkAegBlACAAbQBpAHMAbQBh
AHQAYwBoAABJRgBhAGkAbABlAGQAIAB0AG8AIAByAGUAbwBwAGUAbgAgAGEAcgBjAGgAaQB2AGUA
IAAtACAAbgBvACAAcwBvAHUAcgBjAGUAAT9OAGEAbQBlACAAaQBzACAAbgBvAHQAIABrAG4AbwB3
AG4AIABjAGEAbgBuAG8AdAAgAFIAZQBvAHAAZQBuAAA7QwBhAG4AbgBvAHQAIABmAGkAbgBkACAA
YwBlAG4AdAByAGEAbAAgAGQAaQByAGUAYwB0AG8AcgB5AAA/QgBlAGcAaQBuAFUAcABkAGEAdABl
ACAAaABhAHMAIABuAG8AdAAgAGIAZQBlAG4AIABjAGEAbABsAGUAZAAAG0UAbgBkACAAbwBmACAA
cwB0AHIAZQBhAG0AAD9aAGkAcABGAGkAbABlACAAcwB0AHIAZQBhAG0AIABtAHUAcwB0ACAAYgBl
ACAAcwBlAGUAawBhAGIAbABlAAAzQwBhAG4AbgBvAHQAIABmAGkAbgBkACAAWgBpAHAANgA0ACAA
bABvAGMAYQB0AG8AcgAAZUkAbgB2AGEAbABpAGQAIABaAGkAcAA2ADQAIABDAGUAbgB0AHIAYQBs
ACAAZABpAHIAZQBjAHQAbwByAHkAIABzAGkAZwBuAGEAdAB1AHIAZQAgAGEAdAAgAHsAMAA6AFgA
fQAAOUkAbgB2AGEAbABpAGQAIABlAG0AYgBlAGQAZABlAGQAIAB6AGkAcAAgAGEAcgBjAGgAaQB2
AGUAAENXAHIAbwBuAGcAIABDAGUAbgB0AHIAYQBsACAARABpAHIAZQBjAHQAbwByAHkAIABzAGkA
ZwBuAGEAdAB1AHIAZQAAVU4AbwAgAHAAYQBzAHMAdwBvAHIAZAAgAGEAdgBhAGkAbABhAGIAbABl
ACAAZgBvAHIAIABlAG4AYwByAHkAcAB0AGUAZAAgAHMAdAByAGUAYQBtAABdTgBvACAAcABhAHMA
cwB3AG8AcgBkACAAYQB2AGEAaQBsAGEAYgBsAGUAIABmAG8AcgAgAEEARQBTACAAZQBuAGMAcgB5
AHAAdABlAGQAIABzAHQAcgBlAGEAbQAAJUEARQBTACAAUwBhAGwAdAAgAGUAeABwAGUAYwB0AGUA
ZAAgAAALIABnAG8AdAAgAAAxSQBuAHYAYQBsAGkAZAAgAHAAYQBzAHMAdwBvAHIAZAAgAGYAbwBy
ACAAQQBFAFMAAD9EAGUAYwByAHkAcAB0AGkAbwBuACAAbQBlAHQAaABvAGQAIABuAG8AdAAgAHMA
dQBwAHAAbwByAHQAZQBkAAAhSQBuAHYAYQBsAGkAZAAgAHAAYQBzAHMAdwBvAHIAZAAAO0MAYQBu
AHQAIABoAGEAbgBkAGwAZQAgAG4AbwBuACAAZgBpAGwAZQAgAGEAcgBjAGgAaQB2AGUAcwAASU4A
bwAgAHQAZQBtAHAAbwByAGEAcgB5ACAAcwB0AHIAZQBhAG0AIABoAGEAcwAgAGIAZQBlAG4AIABj
AHIAZQBhAHQAZQBkAAAdewAwAH0ALgB7ADEAfQB7ADIAfQAuAHQAbQBwAABHSQBuAHQAZQByAG4A
YQBsACAAZQByAHIAbwByACAAYwBhAG4AdAAgAGYAaQBuAGQAIABlAHgAdAByAGEAIABkAGEAdABh
AABfQwBvAG0AbQBlAG4AdAAgAGwAZQBuAGcAdABoACgAewAwAH0AKQAgAGkAcwAgAHQAbwBvACAA
bABvAG4AZwAgAGMAYQBuACAAbwBuAGwAeQAgAGIAZQAgADYANABLAABHRABhAHQAYQAgAGQAZQBz
AGMAcgBpAHAAdABvAHIAIABzAGkAZwBuAGEAdAB1AHIAZQAgAG4AbwB0ACAAZgBvAHUAbgBkAAAP
QwBsAG8AcwBlAGQALgAAQVcAcgBvAG4AZwAgAEwAbwBjAGEAbAAgAGgAZQBhAGQAZQByACAAcwBp
AGcAbgBhAHQAdQByAGUAOgAgADAAeAAAC3sAMAA6AFgAfQAATVMAdABvAHIAZQBkACwAIABiAHUA
dAAgAGMAbwBtAHAAcgBlAHMAcwBlAGQAIAAhAD0AIAB1AG4AYwBvAG0AcAByAGUAcwBzAGUAZAAA
DUMAbABvAHMAZQBkAAAvWgBpAHAAIABhAHIAYwBoAGkAdgBlACAAZQBuAGQAcwAgAGUAYQByAGwA
eQAuAABVTABlAG4AZwB0AGgAIABuAG8AdAAgAGEAdgBhAGkAbABhAGIAbABlACAAZgBvAHIAIAB0
AGgAZQAgAGMAdQByAHIAZQBuAHQAIABlAG4AdAByAHkAACFOAG8AIABjAHUAcgByAGUAbgB0ACAA
ZQBuAHQAcgB5AAA/VQBuAGEAYgBsAGUAIAB0AG8AIAByAGUAYQBkACAAZgByAG8AbQAgAHQAaABp
AHMAIABzAHQAcgBlAGEAbQAAbVQAaABlACAAYwBvAG0AcAByAGUAcwBzAGkAbwBuACAAbQBlAHQA
aABvAGQAIABmAG8AcgAgAHQAaABpAHMAIABlAG4AdAByAHkAIABpAHMAIABuAG8AdAAgAHMAdQBw
AHAAbwByAHQAZQBkAABxTABpAGIAcgBhAHIAeQAgAGMAYQBuAG4AbwB0ACAAZQB4AHQAcgBhAGMA
dAAgAHQAaABpAHMAIABlAG4AdAByAHkALgAgAFYAZQByAHMAaQBvAG4AIAByAGUAcQB1AGkAcgBl
AGQAIABpAHMAIAAoAAADKQAAIU4AbwAgAHAAYQBzAHMAdwBvAHIAZAAgAHMAZQB0AC4AAGVFAG4A
dAByAHkAIABjAG8AbQBwAHIAZQBzAHMAZQBkACAAcwBpAHoAZQAgAHsAMAB9ACAAdABvAG8AIABz
AG0AYQBsAGwAIABmAG8AcgAgAGUAbgBjAHIAeQBwAHQAaQBvAG4AACVDAGEAbgBuAG8AdAAgAGIA
ZQAgAG4AZQBnAGEAdABpAHYAZQAAQUkAbgB2AGEAbABpAGQAIABvAGYAZgBzAGUAdAAvAGMAbwB1
AG4AdAAgAGMAbwBtAGIAaQBuAGEAdABpAG8AbgAARU8AZgBmAHMAZQB0ACAAKwAgAGMAbwB1AG4A
dAAgAGUAeABjAGUAZQBkAHMAIABiAHUAZgBmAGUAcgAgAHMAaQB6AGUAAC1JAG4AZgBsAGEAdABl
AHIAIABuAG8AdAAgAGYAaQBuAGkAcwBoAGUAZAAhAAAfUwBpAHoAZQAgAG0AaQBzAG0AYQB0AGMA
aAA6ACAAAAM7AAALIAA8AC0APgAgAAEnRQBPAEYAIABpAG4AIABzAHQAbwByAGUAZAAgAGIAbABv
AGMAawAABS8ALwAAD2MAbwBtAG0AZQBuAHQAADlaAGkAcABPAHUAdABwAHUAdABTAHQAcgBlAGEA
bQAgAHcAYQBzACAAZgBpAG4AaQBzAGgAZQBkAAA7VABvAG8AIABtAGEAbgB5ACAAZQBuAHQAcgBp
AGUAcwAgAGYAbwByACAAWgBpAHAAIABmAGkAbABlAAAbTgBvACAAbwBwAGUAbgAgAGUAbgB0AHIA
eQAAE3MAaQB6AGUAIAB3AGEAcwAgAAAjLAAgAGIAdQB0ACAASQAgAGUAeABwAGUAYwB0AGUAZAAg
AAApYwBvAG0AcAByAGUAcwBzAGUAZAAgAHMAaQB6AGUAIAB3AGEAcwAgAAARYwByAGMAIAB3AGEA
cwAgAABjRQBuAHQAcgB5ACAAcgBlAHEAdQBpAHIAZQBzACAAegBpAHAANgA0ACAAYgB1AHQAIAB0
AGgAaQBzACAAaABhAHMAIABiAGUAZQBuACAAdAB1AHIAbgBlAGQAIABvAGYAZgAAHU4AbwAgAG8A
cABlAG4AIABlAG4AdAByAHkALgAAHU4AYQBtAGUAIAB0AG8AbwAgAGwAbwBuAGcALgAAI0MAbwBt
AG0AZQBuAHQAIAB0AG8AbwAgAGwAbwBuAGcALgAAC2wAZQB2AGUAbAAAL0YAaQBuAGkAcwBoACgA
KQAgAGEAbAByAGUAYQBkAHkAIABjAGEAbABsAGUAZAAAH0QAZQBmAGwAYQB0AGUAcgAgAGMAbABv
AHMAZQBkAAA3dQBuAGsAbgBvAHcAbgAgAGMAbwBtAHAAcgBlAHMAcwBpAG8AbgBGAHUAbgBjAHQA
aQBvAG4AAE1PAGwAZAAgAGkAbgBwAHUAdAAgAHcAYQBzACAAbgBvAHQAIABjAG8AbQBwAGwAZQB0
AGUAbAB5ACAAcAByAG8AYwBlAHMAcwBlAGQAAC9IAGUAYQBkAGUAcgAgAGMAaABlAGMAawBzAHUA
bQAgAGkAbABsAGUAZwBhAGwAADVDAG8AbQBwAHIAZQBzAHMAaQBvAG4AIABNAGUAdABoAG8AZAAg
AHUAbgBrAG4AbwB3AG4AAC9JAGwAbABlAGcAYQBsACAAcgBlAHAAIABsAGUAbgBnAHQAaAAgAGMA
bwBkAGUAACtJAGwAbABlAGcAYQBsACAAcgBlAHAAIABkAGkAcwB0ACAAYwBvAGQAZQAAK0kAbgBm
AGwAYQB0AGUAcgAgAHUAbgBrAG4AbwB3AG4AIABtAG8AZABlAAA5QQBkAGwAZQByACAAYwBoAGsA
cwB1AG0AIABkAG8AZQBzAG4AJwB0ACAAbQBhAHQAYwBoADoAIAABCyAAdgBzAC4AIAAAJ1UAbgBr
AG4AbwB3AG4AIABiAGwAbwBjAGsAIAB0AHkAcABlACAAADNiAHIAbwBrAGUAbgAgAHUAbgBjAG8A
bQBwAHIAZQBzAHMAZQBkACAAYgBsAG8AYwBrAAA5SQBuAGYAbABhAHQAZQByAC4ARABlAGMAbwBk
AGUAIAB1AG4AawBuAG8AdwBuACAAbQBvAGQAZQAAC2kAbgBkAGUAeAAAMUQAaQBjAHQAaQBvAG4A
YQByAHkAIABpAHMAIABuAG8AdAAgAG4AZQBlAGQAZQBkAAApVwByAG8AbgBnACAAYQBkAGwAZQBy
ACAAYwBoAGUAYwBrAHMAdQBtAAAxYwBvAHUAbgB0ACAAYwBhAG4AbgBvAHQAIABiAGUAIABuAGUA
ZwBhAHQAaQB2AGUAADNvAGYAZgBzAGUAdAAgAGMAYQBuAG4AbwB0ACAAYgBlACAAbgBlAGcAYQB0
AGkAdgBlAAA3YwBvAHUAbgB0ACAAZQB4AGMAZQBlAGQAcwAgAGIAdQBmAGYAZQByACAAYgBvAHUA
bgBkAHMAAF9JAG4AZgBsAGEAdABlAHIASAB1AGYAZgBtAGEAbgBUAHIAZQBlADoAIABzAHQAYQB0
AGkAYwAgAHQAcgBlAGUAIABsAGUAbgBnAHQAaAAgAGkAbABsAGUAZwBhAGwAACFiAGEAcwBlAE8A
dQB0AHAAdQB0AFMAdAByAGUAYQBtAAApTQB1AHMAdAAgAHMAdQBwAHAAbwByAHQAIAB3AHIAaQB0
AGkAbgBnAAARZABlAGYAbABhAHQAZQByAAAVYgB1AGYAZgBlAHIAUwBpAHoAZQAAMUMAYQBuACcA
dAAgAGQAZQBmAGwAYQB0AGUAIABhAGwAbAAgAGkAbgBwAHUAdAA/AAFbRABlAGYAbABhAHQAZQBy
AE8AdQB0AHAAdQB0AFMAdAByAGUAYQBtACAAYwBhAG4AJwB0ACAAZABlAGYAbABhAHQAZQAgAGEA
bABsACAAaQBuAHAAdQB0AD8AAT9QAG8AcwBpAHQAaQBvAG4AIABwAHIAbwBwAGUAcgB0AHkAIABu
AG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABPRABlAGYAbABhAHQAZQByAE8AdQB0AHAAdQB0AFMA
dAByAGUAYQBtACAAUwBlAGUAawAgAG4AbwB0ACAAcwB1AHAAcABvAHIAdABlAGQAAFlEAGUAZgBs
AGEAdABlAHIATwB1AHQAcAB1AHQAUwB0AHIAZQBhAG0AIABTAGUAdABMAGUAbgBnAHQAaAAgAG4A
bwB0ACAAcwB1AHAAcABvAHIAdABlAGQAAFdEAGUAZgBsAGEAdABlAHIATwB1AHQAcAB1AHQAUwB0
AHIAZQBhAG0AIABSAGUAYQBkAEIAeQB0AGUAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABP
RABlAGYAbABhAHQAZQByAE8AdQB0AHAAdQB0AFMAdAByAGUAYQBtACAAUgBlAGEAZAAgAG4AbwB0
ACAAcwB1AHAAcABvAHIAdABlAGQAAG1EAGUAZgBsAGEAdABlAHIATwB1AHQAcAB1AHQAUwB0AHIA
ZQBhAG0AIABCAGUAZwBpAG4AUgBlAGEAZAAgAG4AbwB0ACAAYwB1AHIAcgBlAG4AdABsAHkAIABz
AHUAcABwAG8AcgB0AGUAZAAAN0IAZQBnAGkAbgBXAHIAaQB0AGUAIABpAHMAIABuAG8AdAAgAHMA
dQBwAHAAbwByAHQAZQBkAAANbABlAG4AZwB0AGgAABtFAE8ARgAgAGkAbgAgAGgAZQBhAGQAZQBy
AAAfYgBhAHMAZQBJAG4AcAB1AHQAUwB0AHIAZQBhAG0AABFpAG4AZgBsAGEAdABlAHIAAB1VAG4A
ZQB4AHAAZQBjAHQAZQBkACAARQBPAEYAAFVJAG4AZgBsAGEAdABlAHIASQBuAHAAdQB0AFMAdABy
AGUAYQBtACAAUABvAHMAaQB0AGkAbwBuACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAJVMA
ZQBlAGsAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABXSQBuAGYAbABhAHQAZQByAEkAbgBw
AHUAdABTAHQAcgBlAGEAbQAgAFMAZQB0AEwAZQBuAGcAdABoACAAbgBvAHQAIABzAHUAcABwAG8A
cgB0AGUAZAAAT0kAbgBmAGwAYQB0AGUAcgBJAG4AcAB1AHQAUwB0AHIAZQBhAG0AIABXAHIAaQB0
AGUAIABuAG8AdAAgAHMAdQBwAHAAbwByAHQAZQBkAABXSQBuAGYAbABhAHQAZQByAEkAbgBwAHUA
dABTAHQAcgBlAGEAbQAgAFcAcgBpAHQAZQBCAHkAdABlACAAbgBvAHQAIABzAHUAcABwAG8AcgB0
AGUAZAAAWUkAbgBmAGwAYQB0AGUAcgBJAG4AcAB1AHQAUwB0AHIAZQBhAG0AIABCAGUAZwBpAG4A
VwByAGkAdABlACAAbgBvAHQAIABzAHUAcABwAG8AcgB0AGUAZAAAI04AZQBlAGQAIABhACAAZABp
AGMAdABpAG8AbgBhAHIAeQAAKUQAbwBuAHQAIABrAG4AbwB3ACAAdwBoAGEAdAAgAHQAbwAgAGQA
bwAAF1cAaQBuAGQAbwB3ACAAZgB1AGwAbAAAFWQAaQBjAHQAaQBvAG4AYQByAHkAAD9CAGkAdAAg
AGIAdQBmAGYAZQByACAAaQBzACAAbgBvAHQAIABiAHkAdABlACAAYQBsAGkAZwBuAGUAZAAhAAAl
YwBhAG4AbgBvAHQAIABiAGUAIABuAGUAZwBhAHQAaQB2AGUAADtuAG8AdAAgAGEAIAB2AGEAbABp
AGQAIABpAG4AZABlAHgAIABpAG4AdABvACAAYgB1AGYAZgBlAHIAACdlAHgAYwBlAGUAZABzACAA
YgB1AGYAZgBlAHIAIABzAGkAegBlAAA9QwBvAHUAbgB0ACAAYwBhAG4AbgBvAHQAIABiAGUAIABs
AGUAcwBzACAAdABoAGEAbgAgAHoAZQByAG8AADFjAGEAbgBuAG8AdAAgAGIAZQAgAGwAZQBzAHMA
IAB0AGgAYQBuACAAegBlAHIAbwAAKUQAZQBzAHQAaQBuAGEAdABpAG8AbgBaAGkAcABTAG8AdQBy
AGMAZQAAHUQAZQBzAHQAaQBuAGEAdABpAG8AbgBaAGkAcAAAf1MAVABfADcAYwBiAGEAMQBhADAA
NQA4ADMANgAyADQANQBjADEAOQBiADIANQBmADAANQA4ADkANgA1AGIAMQBkADkANAAuAGMAcwBw
AHIAbwBqAC4AUAByAG8AcABlAHIAdABpAGUAcwAuAFIAZQBzAG8AdQByAGMAZQBzAAA9TQBvAGQA
aQBmAHkAIABuAG8AdAAgAGMAdQByAHIAZQBuAHQAbAB5ACAAcwB1AHAAcABvAHIAdABlAGQAADlO
AGUAZwBhAHQAaQB2AGUAIABwAG8AcwBpAHQAaQBvAG4AIABpAHMAIABpAG4AdgBhAGwAaQBkAAAp
QwBhAG4AbgBvAHQAIABzAGUAZQBrACAAcABhAHMAdAAgAGUAbgBkAAANIQBFAG0AcAB0AHkAAC9I
AGUAYQBwACAAaQBuAHYAYQByAGkAYQBuAHQAIAB2AGkAbwBsAGEAdABlAGQAAAAAAAlcGsybK6FA
jcdoq3d3TY8ABCABAQgDIAABBSABARERBCABAQ4GIAEBEYDpByACARI5ET0GIAIBDhJBCgcEElUS
WR0FHQUGAAMOHBwcBQABDh0cByADAQ4dBQgGIAEBEYEJBSABHQUICCACEkkdBR0FBSABAR0FBgcE
CAgFCAogBQgdBQgIHQUIBAcBHQUIIAMdBR0FCAgEIAAdBQkgAwESYRJJEWUMBwkICAgICAgdBQgI
ByADCB0FCAgFBwIdCQgFIAIBDg4JAAIBEoElEYEpBAcCCAUGIAMBCAgIAyAAHAIdBQMHAQwGBwIS
SBI0BAcBEjQGBwISPBIoBgcCEkQSKAYHAhI4EjARBwodDgIIHQ4IDhJBEkEOEkEFAAEdDg4DBwEC
ByACAQ4RgUEHBwQCHQ4IDgMgAAgEIAEDCAUgAg4ICAwHBQMdAxKAgQgSgIkDIAAOBCABCBwJEAEC
CB0eAB4AAwoBAwYgARKAiQMIAAESgUkRgU0IIAESgSUSgUkCHQ4IBwMCEoCNEk0FIAASgI0EIAEC
DgMgAAIGBwMdDggOBAcCAg4EAAEODgQGEYCRBgcCAhKAlQMgAAoFIAARgJEJAAICEYCREYCRBAcC
AgoDBwEIBAcCAggHIAMBHQUICAwHBwIRgJEKChIsAggFAAARgJELAAIRgJ0RgJERgJEJAAICEYCd
EYCdBgcEDggICAQgAQ4IBwcDAhJIEjQHBwMSTAISNAcHAwISPBIoBwcDAhJEEigHBwMCEjgSMAYA
ARGAnQ0GAAESgKEOCgcDEoEQEoEQElALAAISgWUSgWUSgWUEBwESYQ8ABBKAoQ4RgWkRgW0RgXEO
BwQSgNgSgNgSgI0SgJwFBwESgJwFAAICDg4KBwMSgKESgJwSQQsHBAISgKERgKUSQQQAAQIOBwAC
AQ4RgJEHAAIBDhGApQcHBAIODhJBBgABEoC1DgUgABGApQQAAB0DBSABCB0DBQACDg4OAgYOBQAC
CA4OBQcCHQMIDAAFARKBJQgSgSUICAYHAggSgIkFIAIODg4EIAEIDgUgAgEIAwYgAggdAwgGAAES
gXkIByADDh0FCAgFAAASgXkFIAEdBQ4FAAASgX0FIAASgOUFIAASgYEEBwICCwgHBgkJCQkJCAUA
AgkJCQUAAggICAkgBgEICAgICAgIBwYJCQkJCQkFAAIOHBwMBwYSgLwICggIEYCRBgABEYCRCggg
BQEICAgICAsAAhGAkRGAkRGAnQYHBAgICAgNBwUSgJwIAhKAlRGBfAwHBBKAnAgSgLURgXwOBwYS
gLkSgQQIEYCRCAgIIAQBHQUICAIZBwoSgLkSgQQRgJ0IEYCREYCdCBGAnQgdBQQgAQEFAyAADQwH
BhKAuRKBBAgKCgoHIAIKChGAzQoHAxKAuRKBBB0FBQcBEoCoBAcCCAgHBwQICB0FCAcgAgESgSUI
BwcEAggdBQgFBwESgMAEAAEBHAUHARKAoQUAABKA5QkABAgODgISgOUDBwEKCAcDChGAiBJhGwcM
EoDMEYGIAggSgKQSgVQSYR0FCggSgPwSQQUAAg4OHBgHERJhAgYGBgYGCQoKCAgdBR0FEoC8CAoG
AAIBHBACBgADDg4cHBQHCAgdEoCcCBKAnAgSgI0SgZQSTQUgAgEcHAYgAQESgMkEIAEcCAcHAh0F
EoEEBSACAQgcDQcEEoCcHQUSgLwRgIQLBwQdBRKAvB0FHQUEBwESVAcHBAgdBQgICwcGEoFUHQUK
CggIBCABAQoMBwcKEoFUHQUKCggIBAcCCA4EIAECHAQgARwcBwcCEmERgIgLBwYSYRJhCgoKEmEI
BwQKChJhEmEHBwUCCgoJCQUHAwoJCQsHBAoSgQQSgQQdBSAHDgoKAgoSgNgKHQUSgI0SgZQRgYwS
TRKBlBKBBBKBlAQAAQEOBQcCEmECBgcCEoEECiIHGwoHCwsLCgkCHQULCwgICAgJCQoKCAgICQod
BRKAnB0FEQcJEl0SJAgdBQgdBQgSDB0FBgcCEl0SJAMAAA4GBwMSYQ4CBQACAQ4OBgADAQ4OAgog
AwEOEYFpEYFtDAcGDggIEYCRDhKAoQcABA4OHBwcDgcGEYCIAgIdBRKAvB0FBAcCCgoFAAIKCgoN
BwkIBgkICAIdBQ4dBQUHAh0FCgkHBAgSJB0FHQUGAAMODg4OBAcCDggEIAEIAw4HBhGAiAgCHQUS
gLwdBQYHAh0FHQUFBwERgIgFBwIdBQgYBwoKChKAjRKAnB0FEoC8HQUdBRJNEoEECQcHCAgICAgI
CAUHAwICCAUHAwgICAQHAgYIDgcLCAgdBggICAgICAUFBAcCCAIGBwQIAggCBwcFCAgICAIIBwYI
CAgICAgHBwUICAgICAgHBggICAUICBYHEh0IHQgICAgICAgICAgICAgICAgIBgcCEiQdBQcHBAgd
BQgKBAcCCQkFBwMJCQgEBwIODgUgABKBqQUgABKBrQYgARKBsRwWBwsIDg4dDhKBEB0FHQ4IEoCc
EoChCAYAAh0ODg4FIAASgbUHIAIBDhKBtQsHBRKBlBKBlAgICgcHBBJhAgoIBwcEEmECCAgIBwUd
CAgICAgaBxUIHQgICB0IHQgICAgICAgICAgICAgICAgRBw4ICAgdCAgICAgICAgICAgIt3pcVhk0
4IkIiYRdzYCAzJEEAgAAAAToAwAABBAAAAAECgAAAAQEAQAABAAAAAAEAQAAAAQIAAAABAkAAAAE
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
ARJhCAUAAgIOAgkAAgESgJwSgLwFIAIBCAIGIAEBEYEcBSABCB0FBiABARKBKAUgAgICAgUgABGB
HAUgAgIICAQAAQYIBAABCAgGIAECEoFMBSAAEoE0BiABCBKBTAUgAgEICAggAgESYRKBFAkgAwES
YRKBFAgNIAQBEoCcDhAdBRAdBQsgBRJ5HQUICBJ9HAYgAQESgSwFIAEBEkkIIAIBEmESgSwJIAMB
EmESgSwIBCABCgoHIAIIEoFMCAQgAQgIBQACCQkFBQAAEoDhBgABARKA5QUAABKBaAggAxJ5DhJ9
HAUgAQISeQcgAgEcEoDACyAEEnkcEoDAEn0cBSACCBwcByACAQ4SgJwIIAMBDg4RgIgJIAIBEoDc
EoCcCSACARKAnBKAnAkgAgERgYwSgJwFIAARgYwGAAEOEoGYByABAR0SgJwIIAMBEoDYCgoFIAEI
EnkJIAQBEoEkCAgIByACAR0GHQUGIAEBEoGsBSABAR0IBCgAHQUDKAAIAygAAgUoAB0SbQMoAA4D
KAAMAygACgQoABJBBSgAEYCRBSgAEYCdBCgAElQEKAASfAUoABGAhAMoAAMDCAAIAygABQUoABGA
iAUoABGBfAMoAAYFKAARgYAFKAARgMgFKAASgNgFKAASgJwGKAESgJwIBSgAEYDUBSgAEoC5BSgA
EYEcBCgAEkkFCAASgOEFCAASgOUFCAASgWgFKAARgYwDKAAcCAEACAAAAAAAHgEAAQBUAhZXcmFw
Tm9uRXhjZXB0aW9uVGhyb3dzAQgBAAIAAAAAAC8BACpTVF83Y2JhMWEwNTgzNjI0NWMxOWIyNWYw
NTg5NjViMWQ5NC5jc3Byb2oAAAUBAAAAAA4BAAlNaWNyb3NvZnQAAB8BABpDb3B5cmlnaHQgQCBN
aWNyb3NvZnQgMjAxMQAASQEAGi5ORVRGcmFtZXdvcmssVmVyc2lvbj12NC41AQBUDhRGcmFtZXdv
cmtEaXNwbGF5TmFtZRIuTkVUIEZyYW1ld29yayA0LjUWAQARVXNlIENsb25lIGluc3RlYWQAAB4B
ABlVc2UgVmVyc2lvbk1hZGVCeSBpbnN0ZWFkAAAoAQAjVXNlIFZlcnNpb25TdHJvbmdFbmNyeXB0
aW9uIGluc3RlYWQAACQBAB9Vc2UgTG9jYWxIZWFkZXJCYXNlU2l6ZSBpbnN0ZWFkAAAjAQAeVXNl
IERhdGFEZXNjcmlwdG9yU2l6ZSBpbnN0ZWFkAAAmAQAhVXNlIENlbnRyYWxIZWFkZXJCYXNlU2l6
ZSBpbnN0ZWFkAAArAQAmVXNlIEVuZE9mQ2VudHJhbFJlY29yZEJhc2VTaXplIGluc3RlYWQAACEB
ABxVc2UgQ3J5cHRvSGVhZGVyU2l6ZSBpbnN0ZWFkAAAlAQAgVXNlIExvY2FsSGVhZGVyU2lnbmF0
dXJlIGluc3RlYWQAACIBAB1Vc2UgU3Bhbm5pbmdTaWduYXR1cmUgaW5zdGVhZAAAJgEAIVVzZSBT
cGFubmluZ1RlbXBTaWduYXR1cmUgaW5zdGVhZAAAKAEAI1VzZSBEYXRhRGVzY3JpcHRvclNpZ25h
dHVyZSBpbnN0ZWFkAAAnAQAiVXNlIENlbnRyYWxIZWFkZXJTaWduYXR1cmUgaW5zdGVhZAAAMAEA
K1VzZSBaaXA2NENlbnRyYWxGaWxlSGVhZGVyU2lnbmF0dXJlIGluc3RlYWQAAC0BAChVc2UgQ2Vu
dHJhbEhlYWRlckRpZ2l0YWxTaWduYXVyZSBpbnN0ZWFkAAAvAQAqVXNlIEVuZE9mQ2VudHJhbERp
cmVjdG9yeVNpZ25hdHVyZSBpbnN0ZWFkAAAjAQAeVXNlIEV4dGVuZGVkUGF0aEZpbHRlciBpbnN0
ZWFkAAARAQAMRW50cnlCeUluZGV4AAAjAQAeVXNlIHRoZSBDb3VudCBwcm9wZXJ0eSBpbnN0ZWFk
AAC0AAAAzsrvvgEAAACRAAAAbFN5c3RlbS5SZXNvdXJjZXMuUmVzb3VyY2VSZWFkZXIsIG1zY29y
bGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3
YTVjNTYxOTM0ZTA4OSNTeXN0ZW0uUmVzb3VyY2VzLlJ1bnRpbWVSZXNvdXJjZVNldAIAAAAAAAAA
AAAAAFBBRFBBRFC0AAAAbBcCAAAAAAAAAAAAhhcCAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgX
AgAAAAAAAAAAAAAAX0NvckRsbE1haW4AbXNjb3JlZS5kbGwAAAAAAP8lACAAEAAAAAAEAAAABAAA
AAQAAAAEAAAACAAAAAgAAAAIAAAAIAAAACAAAAAAAAAACAAAABAAAAAgAAAAEAAAACAAAACAAAAA
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
AQAAAAEAAAACAAAAAgAAAAIAAAACAAAAAgAAAAAAAAAEAAAACAAAACAAAAAQAAAAIAAAAIAAAAAA
AQAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAEAAAABgAAIAAAAAAAAAA
AAAAAAAAAAEAAQAAADAAAIAAAAAAAAAAAAAAAAAAAAEAAAAAAEgAAABYQAIAfgQAAAAAAAAAAAAA
fgQ0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAAAL0E7/4AAAEAAAABAF1glhoA
AAEAXWCWGj8AAAAAAAAABAAAAAIAAAAAAAAAAAAAAAAAAABEAAAAAQBWAGEAcgBGAGkAbABlAEkA
bgBmAG8AAAAAACQABAAAAFQAcgBhAG4AcwBsAGEAdABpAG8AbgAAAAAAAACwBN4DAAABAFMAdABy
AGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAALoDAAABADAAMAAwADAAMAA0AGIAMAAAABoAAQABAEMA
bwBtAG0AZQBuAHQAcwAAAAAAAAA0AAoAAQBDAG8AbQBwAGEAbgB5AE4AYQBtAGUAAAAAAE0AaQBj
AHIAbwBzAG8AZgB0AAAAfgArAAEARgBpAGwAZQBEAGUAcwBjAHIAaQBwAHQAaQBvAG4AAAAAAFMA
VABfADcAYwBiAGEAMQBhADAANQA4ADMANgAyADQANQBjADEAOQBiADIANQBmADAANQA4ADkANgA1
AGIAMQBkADkANAAuAGMAcwBwAHIAbwBqAAAAAAA+AA8AAQBGAGkAbABlAFYAZQByAHMAaQBvAG4A
AAAAADEALgAwAC4ANgA4ADAANgAuADIANAA2ADYAOQAAAAAAfgAvAAEASQBuAHQAZQByAG4AYQBs
AE4AYQBtAGUAAABTAFQAXwA3AGMAYgBhADEAYQAwADUAOAAzADYAMgA0ADUAYwAxADkAYgAyADUA
ZgAwADUAOAA5ADYANQBiADEAZAA5ADQALgBjAHMAcAByAG8AagAuAGQAbABsAAAAAABaABsAAQBM
AGUAZwBhAGwAQwBvAHAAeQByAGkAZwBoAHQAAABDAG8AcAB5AHIAaQBnAGgAdAAgAEAAIABNAGkA
YwByAG8AcwBvAGYAdAAgADIAMAAxADEAAAAAACoAAQABAEwAZQBnAGEAbABUAHIAYQBkAGUAbQBh
AHIAawBzAAAAAAAAAAAAhgAvAAEATwByAGkAZwBpAG4AYQBsAEYAaQBsAGUAbgBhAG0AZQAAAFMA
VABfADcAYwBiAGEAMQBhADAANQA4ADMANgAyADQANQBjADEAOQBiADIANQBmADAANQA4ADkANgA1
AGIAMQBkADkANAAuAGMAcwBwAHIAbwBqAC4AZABsAGwAAAAAAHYAKwABAFAAcgBvAGQAdQBjAHQA
TgBhAG0AZQAAAAAAUwBUAF8ANwBjAGIAYQAxAGEAMAA1ADgAMwA2ADIANAA1AGMAMQA5AGIAMgA1
AGYAMAA1ADgAOQA2ADUAYgAxAGQAOQA0AC4AYwBzAHAAcgBvAGoAAAAAAEIADwABAFAAcgBvAGQA
dQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4ANgA4ADAANgAuADIANAA2ADYAOQAAAAAARgAP
AAEAQQBzAHMAZQBtAGIAbAB5ACAAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4ANgA4ADAANgAuADIA
NAA2ADYAOQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAIADAAAAJg3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</BinaryItem>
                </ScriptProject>
              </DTS:ObjectData>
            </DTS:Executable>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\Clean Up\Send Mail Task"
              DTS:CreationName="Microsoft.SendMailTask"
              DTS:DelayValidation="True"
              DTS:Description="Send Mail Task"
              DTS:DTSID="{8E270293-C8CD-4552-BE75-A1EA2BCE2746}"
              DTS:ExecutableType="Microsoft.SendMailTask"
              DTS:LocaleID="-1"
              DTS:ObjectName="Send Mail Task"
              DTS:TaskContact="Send Mail Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; Â© 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
              DTS:ThreadHint="0">
              <DTS:Variables />
              <DTS:PropertyExpression
                DTS:Name="FileAttachments">@[User::DestinationZip]</DTS:PropertyExpression>
              <DTS:PropertyExpression
                DTS:Name="FromLine">@[User::EmailFrom]</DTS:PropertyExpression>
              <DTS:PropertyExpression
                DTS:Name="Subject">@[User::EmailSubject]</DTS:PropertyExpression>
              <DTS:PropertyExpression
                DTS:Name="ToLine">@[User::EmailCC]</DTS:PropertyExpression>
              <DTS:ObjectData>
                <SendMailTask:SendMailTaskData
                  SendMailTask:SMTPServer="{98039C3A-502D-4E16-9BBB-AAB576E11DDB}"
                  SendMailTask:From="aptak@hcfm.com" xmlns:SendMailTask="www.microsoft.com/sqlserver/dts/tasks/sendmailtask" />
              </DTS:ObjectData>
            </DTS:Executable>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\Clean Up\UpdatePurchaseOrderStatus"
              DTS:CreationName="Microsoft.ExecuteSQLTask"
              DTS:Description="Execute SQL Task"
              DTS:DTSID="{7ED5311A-CAF2-4932-8284-09813D503761}"
              DTS:ExecutableType="Microsoft.ExecuteSQLTask"
              DTS:LocaleID="-1"
              DTS:ObjectName="UpdatePurchaseOrderStatus"
              DTS:TaskContact="Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; Â© 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
              DTS:ThreadHint="0">
              <DTS:Variables />
              <DTS:ObjectData>
                <SQLTask:SqlTaskData
                  SQLTask:Connection="{9FEC6523-BFEE-491B-8350-50107CA5666F}"
                  SQLTask:IsStoredProc="True"
                  SQLTask:SqlStatementSource="[dbo].[mtnUpdatePurchaseOrderToSent]" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask">
                  <SQLTask:ParameterBinding
                    SQLTask:ParameterName="@PurchaseOrderGUID"
                    SQLTask:DtsVariableName="User::CurrentHPOGuid"
                    SQLTask:ParameterDirection="Input"
                    SQLTask:DataType="16"
                    SQLTask:ParameterSize="-1" />
                </SQLTask:SqlTaskData>
              </DTS:ObjectData>
            </DTS:Executable>
          </DTS:Executables>
          <DTS:PrecedenceConstraints>
            <DTS:PrecedenceConstraint
              DTS:refId="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 1]"
              DTS:CreationName=""
              DTS:DTSID="{848B1A8D-28B4-438C-B816-1F08AB493FE8}"
              DTS:From="Package\SET PO Number Variables\Clean Up\UpdatePurchaseOrderStatus"
              DTS:LogicalAnd="True"
              DTS:ObjectName="Constraint 1"
              DTS:To="Package\SET PO Number Variables\Clean Up\Clean Up Local Files" />
            <DTS:PrecedenceConstraint
              DTS:refId="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 2]"
              DTS:CreationName=""
              DTS:DTSID="{A4AF847D-F36E-41BA-A5CA-BB1330FE1714}"
              DTS:From="Package\SET PO Number Variables\Clean Up\New Zip Task"
              DTS:LogicalAnd="True"
              DTS:ObjectName="Constraint 2"
              DTS:To="Package\SET PO Number Variables\Clean Up\Send Mail Task" />
            <DTS:PrecedenceConstraint
              DTS:refId="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 4]"
              DTS:CreationName=""
              DTS:DTSID="{982F4A0A-79BD-4B0F-B957-E9BD79B1E291}"
              DTS:From="Package\SET PO Number Variables\Clean Up\Send Mail Task"
              DTS:LogicalAnd="True"
              DTS:ObjectName="Constraint 4"
              DTS:To="Package\SET PO Number Variables\Clean Up\UpdatePurchaseOrderStatus" />
          </DTS:PrecedenceConstraints>
        </DTS:Executable>
        <DTS:Executable
          DTS:refId="Package\SET PO Number Variables\XML Export"
          DTS:CreationName="STOCK:SEQUENCE"
          DTS:Description="XML Export"
          DTS:DTSID="{AEEF5DBD-4D6E-488A-8D10-4A5ECC2172C1}"
          DTS:ExecutableType="STOCK:SEQUENCE"
          DTS:LocaleID="-1"
          DTS:ObjectName="XML Export">
          <DTS:Variables />
          <DTS:Executables>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\XML Export\FTP Task"
              DTS:CreationName="Microsoft.FtpTask"
              DTS:Description="FTP Task"
              DTS:DTSID="{80F3C3A9-26DA-4312-8B9D-969C119696D8}"
              DTS:ExecutableType="Microsoft.FtpTask"
              DTS:LocaleID="-1"
              DTS:ObjectName="FTP Task"
              DTS:TaskContact="FTP Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; (c) Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
              DTS:ThreadHint="0">
              <DTS:Variables />
              <DTS:ObjectData>
                <FtpData
                  ConnectionName="{1B09DEEF-122C-4A14-90A0-C89849E9E161}"
                  TaskIsLocalPathVar="True"
                  TaskLocalPath="User::LocalXMLFilePath"
                  TaskIsRemotePathVar="True"
                  TaskRemotePath="User::RemoteXMLFTPPath"
                  TaskOverwriteDest="True"
                  TaskTransferAscii="True" />
              </DTS:ObjectData>
            </DTS:Executable>
            <DTS:Executable
              DTS:refId="Package\SET PO Number Variables\XML Export\Get Orders"
              DTS:CreationName="Microsoft.Pipeline"
              DTS:Description="Data Flow Task"
              DTS:DTSID="{19B1030E-0D93-4AF1-9DB2-9CB09FAEE891}"
              DTS:ExecutableType="Microsoft.Pipeline"
              DTS:LocaleID="-1"
              DTS:ObjectName="Get Orders"
              DTS:TaskContact="Performs high-performance data extraction, transformation and loading;Microsoft Corporation; Microsoft SQL Server v10; (C) 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1">
              <DTS:Variables />
              <DTS:ObjectData>
                <pipeline
                  BLOBTempStoragePath=""
                  bufferTempStoragePath=""
                  version="1">
                  <components>
                    <component
                      refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data"
                      componentClassID="Microsoft.OLEDBSource"
                      contactInfo="OLE DB Source;Microsoft Corporation; Microsoft SqlServer v10; (C) Microsoft Corporation; All Rights Reserved; http://www.microsoft.com/sql/support;7"
                      description="OLE DB Source"
                      name="CMS Data"
                      usesDispositions="true"
                      version="7">
                      <properties>
                        <property
                          dataType="System.Int32"
                          description="The number of seconds before a command times out.  A value of 0 indicates an infinite time-out."
                          name="CommandTimeout">0</property>
                        <property
                          dataType="System.String"
                          description="Specifies the name of the database object used to open a rowset."
                          name="OpenRowset"></property>
                        <property
                          dataType="System.String"
                          description="Specifies the variable that contains the name of the database object used to open a rowset."
                          name="OpenRowsetVariable"></property>
                        <property
                          dataType="System.String"
                          description="The SQL command to be executed."
                          name="SqlCommand"
                          UITypeEditor="Microsoft.DataTransformationServices.Controls.ModalMultilineStringEditor">EXEC [selFactoryXMLExportForPO] ?</property>
                        <property
                          dataType="System.String"
                          description="The variable that contains the SQL command to be executed."
                          name="SqlCommandVariable"></property>
                        <property
                          dataType="System.Int32"
                          description="Specifies the column code page to use when code page information is unavailable from the data source."
                          name="DefaultCodePage">1252</property>
                        <property
                          dataType="System.Boolean"
                          description="Forces the use of the DefaultCodePage property value when describing character data."
                          name="AlwaysUseDefaultCodePage">false</property>
                        <property
                          dataType="System.Int32"
                          description="Specifies the mode used to access the database."
                          name="AccessMode"
                          typeConverter="AccessMode">2</property>
                        <property
                          dataType="System.String"
                          description="The mappings between the parameters in the SQL command and variables."
                          name="ParameterMapping">"@PurchaseOrderGUID",{D7402577-8E5B-408F-A9A7-AAB167C49529};</property>
                      </properties>
                      <connections>
                        <connection
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Connections[OleDbConnection]"
                          connectionManagerID="Package.ConnectionManagers[HCSQL2.HairClubCMS]"
                          connectionManagerRefId="Package.ConnectionManagers[HCSQL2.HairClubCMS]"
                          description="The OLE DB runtime connection used to access the database."
                          name="OleDbConnection" />
                      </connections>
                      <outputs>
                        <output
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output]"
                          name="OLE DB Source Output">
                          <outputColumns>
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hponumber]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hponumber]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hponumber]"
                              name="hponumber"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[center]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[center]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[center]"
                              name="center"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcenternam]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pcenternam]"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcenternam]"
                              name="pcenternam"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcountry]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pcountry]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcountry]"
                              name="pcountry"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pctype]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pctype]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pctype]"
                              name="pctype"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[cd]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[cd]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[cd]"
                              name="cd"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[Orderstcod]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[Orderstcod]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[Orderstcod]"
                              name="Orderstcod"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statusdate]"
                              dataType="dbTimeStamp"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statusdate]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statusdate]"
                              name="statusdate"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[programcod]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[programcod]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[programcod]"
                              name="programcod"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[progbig]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[progbig]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[progbig]"
                              name="progbig"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[duedate]"
                              dataType="dbTimeStamp"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[duedate]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[duedate]"
                              name="duedate"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[redo]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[redo]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[redo]"
                              name="redo"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypecod]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[systypecod]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypecod]"
                              name="systypecod"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypedes]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[systypedes]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypedes]"
                              name="systypedes"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolorcode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[scolorcode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolorcode]"
                              name="scolorcode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolordesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[scolordesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolordesc]"
                              name="scolordesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templcode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templcode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templcode]"
                              name="templcode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templdesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templdesc]"
                              name="templdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templwidth]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templwidth]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templwidth]"
                              name="templwidth"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjwidth]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[adjwidth]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjwidth]"
                              name="adjwidth"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templength]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templength]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templength]"
                              name="templength"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjlength]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[adjlength]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjlength]"
                              name="adjlength"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recesscode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[recesscode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recesscode]"
                              name="recesscode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recessdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[recessdesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recessdesc]"
                              name="recessdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairlcode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairlcode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairlcode]"
                              name="hairlcode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairldesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairldesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairldesc]"
                              name="hairldesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densecode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[densecode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densecode]"
                              name="densecode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densedesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[densedesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densedesc]"
                              name="densedesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdense]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontdense]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdense]"
                              name="frontdense"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fdensedesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[fdensedesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fdensedesc]"
                              name="fdensedesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontcode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontcode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontcode]"
                              name="frontcode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontdesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdesc]"
                              name="frontdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[undervent]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[undervent]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[undervent]"
                              name="undervent"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairhuman]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairhuman]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairhuman]"
                              name="hairhuman"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircfront]"
                              name="haircfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairctempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctempl]"
                              name="hairctempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairctop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctop]"
                              name="hairctop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircsides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircsides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircsides]"
                              name="haircsides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairccrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccrown]"
                              name="hairccrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircback]"
                              name="haircback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highhuman]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highhuman]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highhuman]"
                              name="highhuman"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highstreak]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highstreak]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highstreak]"
                              name="highstreak"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcfront]"
                              name="highcfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpfront]"
                              name="highpfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highctempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctempl]"
                              name="highctempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highptempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptempl]"
                              name="highptempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highctop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctop]"
                              name="highctop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highptop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptop]"
                              name="highptop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcsides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcsides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcsides]"
                              name="highcsides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpsides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpsides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpsides]"
                              name="highpsides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highccrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highccrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highccrown]"
                              name="highccrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpcrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpcrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpcrown]"
                              name="highpcrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcback]"
                              name="highcback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpback]"
                              name="highpback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2human]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2human]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2human]"
                              name="hig2human"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2streak]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2streak]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2streak]"
                              name="hig2streak"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2cfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cfront]"
                              name="hig2cfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pfront]"
                              name="hig2pfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ctempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctempl]"
                              name="hig2ctempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ptempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptempl]"
                              name="hig2ptempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ctop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctop]"
                              name="hig2ctop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ptop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptop]"
                              name="hig2ptop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2csides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2csides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2csides]"
                              name="hig2csides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2psides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2psides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2psides]"
                              name="hig2psides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ccrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ccrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ccrown]"
                              name="hig2ccrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pcrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pcrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pcrown]"
                              name="hig2pcrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2cback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cback]"
                              name="hig2cback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pback]"
                              name="hig2pback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyhuman]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyhuman]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyhuman]"
                              name="greyhuman"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypfront]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypfront]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypfront]"
                              name="greypfront"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptempl]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyptempl]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptempl]"
                              name="greyptempl"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptop]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyptop]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptop]"
                              name="greyptop"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypsides]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypsides]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypsides]"
                              name="greypsides"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypcrown]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypcrown]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypcrown]"
                              name="greypcrown"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypback]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypback]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypback]"
                              name="greypback"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairccode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccode]"
                              name="hairccode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircdesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircdesc]"
                              name="haircdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairscode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairscode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairscode]"
                              name="hairscode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairsdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairsdesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairsdesc]"
                              name="hairsdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frombridge]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frombridge]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frombridge]"
                              name="frombridge"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permcode]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[permcode]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permcode]"
                              name="permcode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permdesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[permdesc]"
                              length="16"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permdesc]"
                              name="permdesc"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[ownhaircod]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[ownhaircod]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[ownhaircod]"
                              name="ownhaircod"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsinit]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplsinit]"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsinit]"
                              name="samplsinit"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsdate]"
                              dataType="dbTimeStamp"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplsdate]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsdate]"
                              name="samplsdate"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techninit]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[techninit]"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techninit]"
                              name="techninit"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techndate]"
                              dataType="dbTimeStamp"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[techndate]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techndate]"
                              name="techndate"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[notes]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[notes]"
                              length="500"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[notes]"
                              name="notes"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplesent]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplesent]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplesent]"
                              name="samplesent"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[rush]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[rush]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[rush]"
                              name="rush"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factoryid]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factoryid]"
                              length="2"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factoryid]"
                              name="factoryid"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fassigned]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[fassigned]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fassigned]"
                              name="fassigned"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didprintfo]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[didprintfo]"
                              length="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didprintfo]"
                              name="didprintfo"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didfax]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[didfax]"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didfax]"
                              name="didfax"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factactual]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factactual]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factactual]"
                              name="factactual"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statuserid]"
                              dataType="dbTimeStamp"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statuserid]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statuserid]"
                              name="statuserid"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreq]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statreq]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreq]"
                              name="statreq"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statfact]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statfact]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statfact]"
                              name="statfact"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreply]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statreply]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreply]"
                              name="statreply"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[firstname]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[firstname]"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[firstname]"
                              name="firstname"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[lastname]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[lastname]"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[lastname]"
                              name="lastname"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factcost]"
                              dataType="cy"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factcost]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factcost]"
                              name="factcost"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costbase]"
                              dataType="cy"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costbase]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costbase]"
                              name="costbase"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costhuman]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costhuman]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costhuman]"
                              name="costhuman"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costlength]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costlength]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costlength]"
                              name="costlength"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costarea]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costarea]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costarea]"
                              name="costarea"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costadj]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costadj]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costadj]"
                              name="costadj"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[group]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[group]"
                              length="2"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[group]"
                              name="group"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[faccode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[faccode]"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[faccode]"
                              name="faccode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[price]"
                              dataType="cy"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[price]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[price]"
                              name="price"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[OrderCount]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[OrderCount]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[OrderCount]"
                              name="OrderCount"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factnotes]"
                              codePage="1252"
                              dataType="text"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factnotes]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factnotes]"
                              name="factnotes"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[HairSystemOrderNumber]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[HairSystemOrderNumber]"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[HairSystemOrderNumber]"
                              name="HairSystemOrderNumber"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[clientno]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[clientno]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[clientno]"
                              name="clientno"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[StartingPointMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[StartingPointMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[StartingPointMeasurement]"
                              name="StartingPointMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[CircumferenceMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[CircumferenceMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[CircumferenceMeasurement]"
                              name="CircumferenceMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontToBackMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[FrontToBackMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontToBackMeasurement]"
                              name="FrontToBackMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverFrontMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[EarToEarOverFrontMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverFrontMeasurement]"
                              name="EarToEarOverFrontMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverTopMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[EarToEarOverTopMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverTopMeasurement]"
                              name="EarToEarOverTopMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnToSideburnMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[SideburnToSideburnMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnToSideburnMeasurement]"
                              name="SideburnToSideburnMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[TempleToTempleMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[TempleToTempleMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[TempleToTempleMeasurement]"
                              name="TempleToTempleMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[NapeAreaMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[NapeAreaMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[NapeAreaMeasurement]"
                              name="NapeAreaMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontLaceMeasurement]"
                              dataType="numeric"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[FrontLaceMeasurement]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontLaceMeasurement]"
                              name="FrontLaceMeasurement"
                              precision="10"
                              scale="4"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[MeaRecession]"
                              dataType="wstr"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[MeaRecession]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[MeaRecession]"
                              name="MeaRecession"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[AreSideburnsAndTemplesLaceFlag]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[AreSideburnsAndTemplesLaceFlag]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[AreSideburnsAndTemplesLaceFlag]"
                              name="AreSideburnsAndTemplesLaceFlag"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnTemplateDiagram]"
                              dataType="i4"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[SideburnTemplateDiagram]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnTemplateDiagram]"
                              name="SideburnTemplateDiagram"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[DoesMeasurementExist]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[DoesMeasurementExist]"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[DoesMeasurementExist]"
                              name="DoesMeasurementExist"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[laceLengthCode]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[laceLengthCode]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[laceLengthCode]"
                              name="laceLengthCode"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[POType]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[POType]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[POType]"
                              name="POType"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsFashionHairlineHighlightsFlag]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsFashionHairlineHighlightsFlag]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsFashionHairlineHighlightsFlag]"
                              name="IsFashionHairlineHighlightsFlag"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsSignatureHairlineAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsSignatureHairlineAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsSignatureHairlineAddOn]"
                              name="IsSignatureHairlineAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsExtendedLaceAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsExtendedLaceAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsExtendedLaceAddOn]"
                              name="IsExtendedLaceAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsOmbreAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsOmbreAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsOmbreAddOn]"
                              name="IsOmbreAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsLongHairAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsLongHairAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsLongHairAddOn]"
                              name="IsLongHairAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsCuticleIntactHairAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsCuticleIntactHairAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsCuticleIntactHairAddOn]"
                              name="IsCuticleIntactHairAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsRootShadowingAddOn]"
                              dataType="bool"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsRootShadowingAddOn]"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsRootShadowingAddOn]"
                              name="IsRootShadowingAddOn"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLength]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColorLength]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLength]"
                              name="RootShadowingRootColorLength"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColor]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColor]"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColor]"
                              name="RootShadowingRootColor"
                              truncationRowDisposition="FailComponent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLengthDesc]"
                              codePage="1252"
                              dataType="str"
                              errorOrTruncationOperation="Conversion"
                              errorRowDisposition="FailComponent"
                              externalMetadataColumnId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColorLengthDesc]"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLengthDesc]"
                              name="RootShadowingRootColorLengthDesc"
                              truncationRowDisposition="FailComponent" />
                          </outputColumns>
                          <externalMetadataColumns
                            isUsed="True">
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hponumber]"
                              dataType="i4"
                              name="hponumber" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[center]"
                              dataType="i4"
                              name="center" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pcenternam]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              name="pcenternam" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pcountry]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="pcountry" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[pctype]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="pctype" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[cd]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="cd" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[Orderstcod]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="Orderstcod" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statusdate]"
                              dataType="dbTimeStamp"
                              name="statusdate" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[programcod]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="programcod" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[progbig]"
                              dataType="i4"
                              name="progbig" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[duedate]"
                              dataType="dbTimeStamp"
                              name="duedate" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[redo]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="redo" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[systypecod]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="systypecod" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[systypedes]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="systypedes" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[scolorcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="scolorcode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[scolordesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="scolordesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="templcode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="templdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templwidth]"
                              dataType="numeric"
                              name="templwidth"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[adjwidth]"
                              dataType="numeric"
                              name="adjwidth"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[templength]"
                              dataType="numeric"
                              name="templength"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[adjlength]"
                              dataType="numeric"
                              name="adjlength"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[recesscode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="recesscode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[recessdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="recessdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairlcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairlcode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairldesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="hairldesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[densecode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="densecode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[densedesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="densedesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontdense]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="frontdense" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[fdensedesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="fdensedesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="frontcode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frontdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="frontdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[undervent]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="undervent" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairhuman" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="haircfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairctempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairctop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="haircsides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairccrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="haircback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highhuman" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highstreak]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highstreak" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highcfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highpfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highctempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highptempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highctop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highptop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highcsides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highpsides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highccrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highpcrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highcback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highcback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[highpback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="highpback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2human]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2human" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2streak]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2streak" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2cfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2cfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2pfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2ctempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2ptempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2ctop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2ptop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2csides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2csides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2psides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2psides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2ccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2ccrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2pcrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2cback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2cback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hig2pback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hig2pback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greyhuman" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greypfront" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greyptempl" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greyptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greyptop" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greypsides" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greypcrown" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[greypback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="greypback" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairccode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairccode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[haircdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="haircdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairscode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="hairscode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[hairsdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="hairsdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[frombridge]"
                              dataType="numeric"
                              name="frombridge"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[permcode]"
                              dataType="i4"
                              name="permcode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[permdesc]"
                              codePage="1252"
                              dataType="str"
                              length="16"
                              name="permdesc" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[ownhaircod]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="ownhaircod" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplsinit]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              name="samplsinit" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplsdate]"
                              dataType="dbTimeStamp"
                              name="samplsdate" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[techninit]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              name="techninit" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[techndate]"
                              dataType="dbTimeStamp"
                              name="techndate" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[notes]"
                              codePage="1252"
                              dataType="str"
                              length="500"
                              name="notes" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[samplesent]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="samplesent" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[rush]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="rush" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factoryid]"
                              codePage="1252"
                              dataType="str"
                              length="2"
                              name="factoryid" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[fassigned]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="fassigned" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[didprintfo]"
                              codePage="1252"
                              dataType="str"
                              length="4"
                              name="didprintfo" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[didfax]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              name="didfax" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factactual]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="factactual" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statuserid]"
                              dataType="dbTimeStamp"
                              name="statuserid" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statreq]"
                              dataType="i4"
                              name="statreq" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statfact]"
                              dataType="i4"
                              name="statfact" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[statreply]"
                              dataType="i4"
                              name="statreply" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[firstname]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              name="firstname" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[lastname]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              name="lastname" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factcost]"
                              dataType="cy"
                              name="factcost" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costbase]"
                              dataType="cy"
                              name="costbase" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costhuman]"
                              dataType="i4"
                              name="costhuman" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costlength]"
                              dataType="i4"
                              name="costlength" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costarea]"
                              dataType="i4"
                              name="costarea" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[costadj]"
                              dataType="i4"
                              name="costadj" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[group]"
                              codePage="1252"
                              dataType="str"
                              length="2"
                              name="group" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[faccode]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              name="faccode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[price]"
                              dataType="cy"
                              name="price" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[OrderCount]"
                              dataType="i4"
                              name="OrderCount" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[factnotes]"
                              codePage="1252"
                              dataType="text"
                              name="factnotes" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[HairSystemOrderNumber]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              name="HairSystemOrderNumber" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[clientno]"
                              dataType="i4"
                              name="clientno" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[DoesMeasurementExist]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              name="DoesMeasurementExist" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[StartingPointMeasurement]"
                              dataType="numeric"
                              name="StartingPointMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[CircumferenceMeasurement]"
                              dataType="numeric"
                              name="CircumferenceMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[FrontToBackMeasurement]"
                              dataType="numeric"
                              name="FrontToBackMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[EarToEarOverFrontMeasurement]"
                              dataType="numeric"
                              name="EarToEarOverFrontMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[EarToEarOverTopMeasurement]"
                              dataType="numeric"
                              name="EarToEarOverTopMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[SideburnToSideburnMeasurement]"
                              dataType="numeric"
                              name="SideburnToSideburnMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[TempleToTempleMeasurement]"
                              dataType="numeric"
                              name="TempleToTempleMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[NapeAreaMeasurement]"
                              dataType="numeric"
                              name="NapeAreaMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[FrontLaceMeasurement]"
                              dataType="numeric"
                              name="FrontLaceMeasurement"
                              precision="10"
                              scale="4" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[MeaRecession]"
                              dataType="wstr"
                              length="10"
                              name="MeaRecession" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[AreSideburnsAndTemplesLaceFlag]"
                              dataType="bool"
                              name="AreSideburnsAndTemplesLaceFlag" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[SideburnTemplateDiagram]"
                              dataType="i4"
                              name="SideburnTemplateDiagram" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[laceLengthCode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="laceLengthCode" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[POType]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="POType" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsFashionHairlineHighlightsFlag]"
                              dataType="bool"
                              name="IsFashionHairlineHighlightsFlag" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsSignatureHairlineAddOn]"
                              dataType="bool"
                              name="IsSignatureHairlineAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsExtendedLaceAddOn]"
                              dataType="bool"
                              name="IsExtendedLaceAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsOmbreAddOn]"
                              dataType="bool"
                              name="IsOmbreAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsLongHairAddOn]"
                              dataType="bool"
                              name="IsLongHairAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsCuticleIntactHairAddOn]"
                              dataType="bool"
                              name="IsCuticleIntactHairAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[IsRootShadowingAddOn]"
                              dataType="bool"
                              name="IsRootShadowingAddOn" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColorLength]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="RootShadowingRootColorLength" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColor]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              name="RootShadowingRootColor" />
                            <externalMetadataColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].ExternalColumns[RootShadowingRootColorLengthDesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              name="RootShadowingRootColorLengthDesc" />
                          </externalMetadataColumns>
                        </output>
                        <output
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output]"
                          isErrorOut="true"
                          name="OLE DB Source Error Output">
                          <outputColumns>
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[HairSystemOrderNumber]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[HairSystemOrderNumber]"
                              name="HairSystemOrderNumber" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hponumber]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hponumber]"
                              name="hponumber" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[center]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[center]"
                              name="center" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pcenternam]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pcenternam]"
                              name="pcenternam" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pcountry]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pcountry]"
                              name="pcountry" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pctype]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[pctype]"
                              name="pctype" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[clientno]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[clientno]"
                              name="clientno" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[cd]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[cd]"
                              name="cd" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[Orderstcod]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[Orderstcod]"
                              name="Orderstcod" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statusdate]"
                              dataType="dbTimeStamp"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statusdate]"
                              name="statusdate" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[programcod]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[programcod]"
                              name="programcod" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[progbig]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[progbig]"
                              name="progbig" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[duedate]"
                              dataType="dbTimeStamp"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[duedate]"
                              name="duedate" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[redo]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[redo]"
                              name="redo" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[systypecod]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[systypecod]"
                              name="systypecod" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[systypedes]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[systypedes]"
                              name="systypedes" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[scolorcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[scolorcode]"
                              name="scolorcode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[scolordesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[scolordesc]"
                              name="scolordesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templcode]"
                              name="templcode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templdesc]"
                              name="templdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templwidth]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templwidth]"
                              name="templwidth"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[adjwidth]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[adjwidth]"
                              name="adjwidth"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templength]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[templength]"
                              name="templength"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[adjlength]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[adjlength]"
                              name="adjlength"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[recesscode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[recesscode]"
                              name="recesscode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[recessdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[recessdesc]"
                              name="recessdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairlcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairlcode]"
                              name="hairlcode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairldesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairldesc]"
                              name="hairldesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[densecode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[densecode]"
                              name="densecode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[densedesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[densedesc]"
                              name="densedesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontdense]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontdense]"
                              name="frontdense" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[fdensedesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[fdensedesc]"
                              name="fdensedesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontcode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontcode]"
                              name="frontcode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frontdesc]"
                              name="frontdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[undervent]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[undervent]"
                              name="undervent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairhuman]"
                              name="hairhuman" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircfront]"
                              name="haircfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairctempl]"
                              name="hairctempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairctop]"
                              name="hairctop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircsides]"
                              name="haircsides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairccrown]"
                              name="hairccrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircback]"
                              name="haircback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highhuman]"
                              name="highhuman" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highstreak]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highstreak]"
                              name="highstreak" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcfront]"
                              name="highcfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpfront]"
                              name="highpfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highctempl]"
                              name="highctempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highptempl]"
                              name="highptempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highctop]"
                              name="highctop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highptop]"
                              name="highptop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcsides]"
                              name="highcsides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpsides]"
                              name="highpsides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highccrown]"
                              name="highccrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpcrown]"
                              name="highpcrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highcback]"
                              name="highcback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[highpback]"
                              name="highpback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2human]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2human]"
                              name="hig2human" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2streak]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2streak]"
                              name="hig2streak" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2cfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2cfront]"
                              name="hig2cfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pfront]"
                              name="hig2pfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ctempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ctempl]"
                              name="hig2ctempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ptempl]"
                              name="hig2ptempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ctop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ctop]"
                              name="hig2ctop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ptop]"
                              name="hig2ptop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2csides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2csides]"
                              name="hig2csides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2psides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2psides]"
                              name="hig2psides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ccrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2ccrown]"
                              name="hig2ccrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pcrown]"
                              name="hig2pcrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2cback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2cback]"
                              name="hig2cback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hig2pback]"
                              name="hig2pback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyhuman]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyhuman]"
                              name="greyhuman" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypfront]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypfront]"
                              name="greypfront" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyptempl]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyptempl]"
                              name="greyptempl" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyptop]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greyptop]"
                              name="greyptop" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypsides]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypsides]"
                              name="greypsides" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypcrown]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypcrown]"
                              name="greypcrown" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypback]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[greypback]"
                              name="greypback" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairccode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairccode]"
                              name="hairccode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[haircdesc]"
                              name="haircdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairscode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairscode]"
                              name="hairscode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairsdesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[hairsdesc]"
                              name="hairsdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frombridge]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[frombridge]"
                              name="frombridge"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[permcode]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[permcode]"
                              name="permcode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[permdesc]"
                              codePage="1252"
                              dataType="str"
                              length="16"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[permdesc]"
                              name="permdesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ownhaircod]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ownhaircod]"
                              name="ownhaircod" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplsinit]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplsinit]"
                              name="samplsinit" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplsdate]"
                              dataType="dbTimeStamp"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplsdate]"
                              name="samplsdate" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[techninit]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[techninit]"
                              name="techninit" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[techndate]"
                              dataType="dbTimeStamp"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[techndate]"
                              name="techndate" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[notes]"
                              codePage="1252"
                              dataType="str"
                              length="500"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[notes]"
                              name="notes" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplesent]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[samplesent]"
                              name="samplesent" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[rush]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[rush]"
                              name="rush" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factoryid]"
                              codePage="1252"
                              dataType="str"
                              length="2"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factoryid]"
                              name="factoryid" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[fassigned]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[fassigned]"
                              name="fassigned" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[didprintfo]"
                              codePage="1252"
                              dataType="str"
                              length="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[didprintfo]"
                              name="didprintfo" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[didfax]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[didfax]"
                              name="didfax" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factactual]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factactual]"
                              name="factactual" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statuserid]"
                              dataType="dbTimeStamp"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statuserid]"
                              name="statuserid" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statreq]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statreq]"
                              name="statreq" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statfact]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statfact]"
                              name="statfact" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statreply]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[statreply]"
                              name="statreply" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[firstname]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[firstname]"
                              name="firstname" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[lastname]"
                              codePage="1252"
                              dataType="str"
                              length="50"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[lastname]"
                              name="lastname" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factcost]"
                              dataType="cy"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factcost]"
                              name="factcost" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costbase]"
                              dataType="cy"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costbase]"
                              name="costbase" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costhuman]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costhuman]"
                              name="costhuman" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costlength]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costlength]"
                              name="costlength" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costarea]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costarea]"
                              name="costarea" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costadj]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[costadj]"
                              name="costadj" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[group]"
                              codePage="1252"
                              dataType="str"
                              length="2"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[group]"
                              name="group" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[faccode]"
                              codePage="1252"
                              dataType="str"
                              length="1"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[faccode]"
                              name="faccode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[price]"
                              dataType="cy"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[price]"
                              name="price" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[OrderCount]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[OrderCount]"
                              name="OrderCount" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factnotes]"
                              codePage="1252"
                              dataType="text"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[factnotes]"
                              name="factnotes" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[laceLengthCode]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[laceLengthCode]"
                              name="laceLengthCode" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[StartingPointMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[StartingPointMeasurement]"
                              name="StartingPointMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[CircumferenceMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[CircumferenceMeasurement]"
                              name="CircumferenceMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[FrontToBackMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[FrontToBackMeasurement]"
                              name="FrontToBackMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[EarToEarOverFrontMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[EarToEarOverFrontMeasurement]"
                              name="EarToEarOverFrontMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[EarToEarOverTopMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[EarToEarOverTopMeasurement]"
                              name="EarToEarOverTopMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[SideburnToSideburnMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[SideburnToSideburnMeasurement]"
                              name="SideburnToSideburnMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[TempleToTempleMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[TempleToTempleMeasurement]"
                              name="TempleToTempleMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[NapeAreaMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[NapeAreaMeasurement]"
                              name="NapeAreaMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[FrontLaceMeasurement]"
                              dataType="numeric"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[FrontLaceMeasurement]"
                              name="FrontLaceMeasurement"
                              precision="10"
                              scale="4" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[MeaRecession]"
                              dataType="wstr"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[MeaRecession]"
                              name="MeaRecession" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[AreSideburnsAndTemplesLaceFlag]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[AreSideburnsAndTemplesLaceFlag]"
                              name="AreSideburnsAndTemplesLaceFlag" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[SideburnTemplateDiagram]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[SideburnTemplateDiagram]"
                              name="SideburnTemplateDiagram" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ErrorCode]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ErrorCode]"
                              name="ErrorCode"
                              specialFlags="1" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ErrorColumn]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[ErrorColumn]"
                              name="ErrorColumn"
                              specialFlags="2" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsFashionHairlineHighlightsFlag]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsFashionHairlineHighlightsFlag]"
                              name="IsFashionHairlineHighlightsFlag" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsSignatureHairlineAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsSignatureHairlineAddOn]"
                              name="IsSignatureHairlineAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsExtendedLaceAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsExtendedLaceAddOn]"
                              name="IsExtendedLaceAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsOmbreAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsOmbreAddOn]"
                              name="IsOmbreAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsLongHairAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsLongHairAddOn]"
                              name="IsLongHairAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsCuticleIntactHairAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsCuticleIntactHairAddOn]"
                              name="IsCuticleIntactHairAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsRootShadowingAddOn]"
                              dataType="bool"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[IsRootShadowingAddOn]"
                              name="IsRootShadowingAddOn" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColorLength]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColorLength]"
                              name="RootShadowingRootColorLength" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColorLengthDesc]"
                              codePage="1252"
                              dataType="str"
                              length="100"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColorLengthDesc]"
                              name="RootShadowingRootColorLengthDesc" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColor]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[RootShadowingRootColor]"
                              name="RootShadowingRootColor" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[DoesMeasurementExist]"
                              codePage="1252"
                              dataType="str"
                              length="5"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[DoesMeasurementExist]"
                              name="DoesMeasurementExist" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[POType]"
                              codePage="1252"
                              dataType="str"
                              length="10"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Error Output].Columns[POType]"
                              name="POType" />
                          </outputColumns>
                          <externalMetadataColumns />
                        </output>
                      </outputs>
                    </component>
                    <component
                      refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files"
                      componentClassID="Microsoft.ConditionalSplit"
                      contactInfo="Conditional Split;Microsoft Corporation; Microsoft SqlServer v10; (C) Microsoft Corporation; All Rights Reserved; http://www.microsoft.com/sql/support;0"
                      description="Evaluates and directs rows in a dataset."
                      name="Create PO XML Files"
                      usesDispositions="true">
                      <inputs>
                        <input
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input]"
                          description="Input to the Conditional Split Transformation"
                          name="Conditional Split Input">
                          <inputColumns>
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input].Columns[factoryid]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="2"
                              cachedName="factoryid"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factoryid]" />
                          </inputColumns>
                          <externalMetadataColumns />
                        </input>
                      </inputs>
                      <outputs>
                        <output
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Matching Records]"
                          description="Output 1 of the Conditional Split Transformation"
                          errorOrTruncationOperation="Computation"
                          errorRowDisposition="FailComponent"
                          exclusionGroup="1"
                          name="Matching Records"
                          synchronousInputId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input]"
                          truncationRowDisposition="FailComponent">
                          <properties>
                            <property
                              containsID="true"
                              dataType="System.String"
                              description="Specifies the expression. This expression version uses lineage identifiers instead of column names."
                              name="Expression">#{Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factoryid]} == @[User::Factory]</property>
                            <property
                              containsID="true"
                              dataType="System.String"
                              description="Specifies the friendly version of the expression. This expression version uses column names."
                              expressionType="Notify"
                              name="FriendlyExpression">factoryid == @[User::Factory]</property>
                            <property
                              dataType="System.Int32"
                              description="Specifies the position of the condition in the list of conditions that the transformation evaluates. The evaluation order is from the lowest to the highest value."
                              name="EvaluationOrder">0</property>
                          </properties>
                          <externalMetadataColumns />
                        </output>
                        <output
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Default Output]"
                          description="Default Output of the Conditional Split Transformation"
                          exclusionGroup="1"
                          name="Conditional Split Default Output"
                          synchronousInputId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input]">
                          <properties>
                            <property
                              dataType="System.Boolean"
                              name="IsDefaultOut">true</property>
                          </properties>
                          <externalMetadataColumns />
                        </output>
                        <output
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Error Output]"
                          description="Error Output of the Conditional Split Transformation"
                          exclusionGroup="1"
                          isErrorOut="true"
                          name="Conditional Split Error Output"
                          synchronousInputId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input]">
                          <outputColumns>
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Error Output].Columns[ErrorCode]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Error Output].Columns[ErrorCode]"
                              name="ErrorCode"
                              specialFlags="1" />
                            <outputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Error Output].Columns[ErrorColumn]"
                              dataType="i4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Error Output].Columns[ErrorColumn]"
                              name="ErrorColumn"
                              specialFlags="2" />
                          </outputColumns>
                          <externalMetadataColumns />
                        </output>
                      </outputs>
                    </component>
                    <component
                      refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component"
                      componentClassID="Microsoft.ManagedComponentHost"
                      contactInfo="Executes a custom script.;Microsoft Corporation; Microsoft SqlServer v10; Â© 2007 Microsoft Corporation; All Rights Reserved; http://www.microsoft.com/sql/support;4"
                      description="Executes a custom script."
                      name="XML Script Component"
                      version="11">
                      <properties>
                        <property
                          dataType="System.String"
                          description="Stores the source code of the component"
                          isArray="true"
                          name="SourceCode"
                          state="cdata">
                          <arrayElements
                            arrayElementCount="30">
                            <arrayElement
                              dataType="System.String"><![CDATA[ComponentWrapper.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[/* THIS IS AUTO-GENERATED CODE THAT WILL BE OVERWRITTEN! DO NOT EDIT!
*  Microsoft SQL Server Integration Services component wrapper
*  This module defines the base class for your component
*  THIS IS AUTO-GENERATED CODE THAT WILL BE OVERWRITTEN! DO NOT EDIT! */

using System;
using System.Data;
using Microsoft.SqlServer.Dts.Pipeline;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using Microsoft.SqlServer.Dts.Runtime.Wrapper;

public class UserComponent: ScriptComponent
{
    public Connections Connections;
    public Variables Variables;
    public UserComponent()
    {
        Connections = new Connections(this);
        Variables = new Variables(this);
    }

    public override void ProcessInput(int InputID, string InputName, PipelineBuffer Buffer, OutputNameMap OutputMap)
    {

        if (InputName.Equals(@"Input 0", StringComparison.Ordinal))
        {
            Input0_ProcessInput(new Input0Buffer(Buffer, GetColumnIndexes(InputID), OutputMap));
        }

    }

    public virtual void Input0_ProcessInput(Input0Buffer Buffer)
    {
        while (Buffer.NextRow())
        {
            Input0_ProcessInputRow(Buffer);
        }
    }

    public virtual void Input0_ProcessInputRow(Input0Buffer Row)
    {
    }

}

public class Connections
{
    ScriptComponent ParentComponent;

    public Connections(ScriptComponent Component)
    {
        ParentComponent = Component;
    }

    public IDTSConnectionManager100 xmldocument
    {
        get
        {
            return ParentComponent.ComponentMetaData.RuntimeConnectionCollection.GetRuntimeConnectionByName(@"xmldocument").ConnectionManager;
        }
    }

}

public class Variables
{
    ScriptComponent ParentComponent;

    public Variables(ScriptComponent Component)
    {
        ParentComponent = Component;
    }

    public String CurrentHPONumber
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["CurrentHPONumber"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String Factory
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["Factory"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String LocalXMLFileDirectory
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["LocalXMLFileDirectory"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String PurchaseOrderType
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["PurchaseOrderType"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String RemoteXMLFTPDirectory
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["RemoteXMLFTPDirectory"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String XMLNameSpace
    {
        get
        {
            return (String)(ParentComponent.ReadOnlyVariables["XMLNameSpace"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
    }

    public String DestinationZip
    {
        get
        {
            return (String)(ParentComponent.ReadWriteVariables["DestinationZip"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
        set
        {
            ParentComponent.ReadWriteVariables["DestinationZip"].Value = value;
        }
    }

    public String DestinationZipSource
    {
        get
        {
            return (String)(ParentComponent.ReadWriteVariables["DestinationZipSource"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
        set
        {
            ParentComponent.ReadWriteVariables["DestinationZipSource"].Value = value;
        }
    }

    public String EmailSubject
    {
        get
        {
            return (String)(ParentComponent.ReadWriteVariables["EmailSubject"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
        set
        {
            ParentComponent.ReadWriteVariables["EmailSubject"].Value = value;
        }
    }

    public String LocalXMLFilePath
    {
        get
        {
            return (String)(ParentComponent.ReadWriteVariables["LocalXMLFilePath"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
        set
        {
            ParentComponent.ReadWriteVariables["LocalXMLFilePath"].Value = value;
        }
    }

    public String RemoteXMLFTPPath
    {
        get
        {
            return (String)(ParentComponent.ReadWriteVariables["RemoteXMLFTPPath"].GetValueWithContext(ScriptComponent.EvaluatorContext));
        }
        set
        {
            ParentComponent.ReadWriteVariables["RemoteXMLFTPPath"].Value = value;
        }
    }

}
]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Properties\Resources.resx]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[main.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[#region Help:  Introduction to the Script Component
/* The Script Component allows you to perform virtually any operation that can be accomplished in
 * a .Net application within the context of an Integration Services data flow.
 *
 * Expand the other regions which have "Help" prefixes for examples of specific ways to use
 * Integration Services features within this script component. */
#endregion

#region Namespaces
using System;
using System.Data;
using System.Reflection;
using System.Xml;
using System.Text;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using Microsoft.SqlServer.Dts.Runtime.Wrapper;
using System.IO;
#endregion

/// <summary>
/// This is the class to which to add your code.  Do not change the name, attributes, or parent
/// of this class.
/// </summary>
[Microsoft.SqlServer.Dts.Pipeline.SSISScriptComponentEntryPointAttribute]
public class ScriptMain : UserComponent
{
    #region Help:  Using Integration Services variables and parameters
    /* To use a variable in this script, first ensure that the variable has been added to
     * either the list contained in the ReadOnlyVariables property or the list contained in
     * the ReadWriteVariables property of this script component, according to whether or not your
     * code needs to write into the variable.  To do so, save this script, close this instance of
     * Visual Studio, and update the ReadOnlyVariables and ReadWriteVariables properties in the
     * Script Transformation Editor window.
     * To use a parameter in this script, follow the same steps. Parameters are always read-only.
     *
     * Example of reading from a variable or parameter:
     *  DateTime startTime = Variables.MyStartTime;
     *
     * Example of writing to a variable:
     *  Variables.myStringVariable = "new value";
     */
    #endregion

    #region Help:  Using Integration Services Connnection Managers
    /* Some types of connection managers can be used in this script component.  See the help topic
     * "Working with Connection Managers Programatically" for details.
     *
     * To use a connection manager in this script, first ensure that the connection manager has
     * been added to either the list of connection managers on the Connection Managers page of the
     * script component editor.  To add the connection manager, save this script, close this instance of
     * Visual Studio, and add the Connection Manager to the list.
     *
     * If the component needs to hold a connection open while processing rows, override the
     * AcquireConnections and ReleaseConnections methods.
     * 
     * Example of using an ADO.Net connection manager to acquire a SqlConnection:
     *  object rawConnection = Connections.SalesDB.AcquireConnection(transaction);
     *  SqlConnection salesDBConn = (SqlConnection)rawConnection;
     *
     * Example of using a File connection manager to acquire a file path:
     *  object rawConnection = Connections.Prices_zip.AcquireConnection(transaction);
     *  string filePath = (string)rawConnection;
     *
     * Example of releasing a connection manager:
     *  Connections.SalesDB.ReleaseConnection(rawConnection);
     */
    #endregion

    #region Help:  Firing Integration Services Events
    /* This script component can fire events.
     *
     * Example of firing an error event:
     *  ComponentMetaData.FireError(10, "Process Values", "Bad value", "", 0, out cancel);
     *
     * Example of firing an information event:
     *  ComponentMetaData.FireInformation(10, "Process Values", "Processing has started", "", 0, fireAgain);
     *
     * Example of firing a warning event:
     *  ComponentMetaData.FireWarning(10, "Process Values", "No rows were received", "", 0);
     */
    #endregion

    // Variable that contains the XML document 
    XmlTextWriter textWriter;
    String _fileName = String.Empty;

    public override void PreExecute()
    {
        base.PreExecute();

        string dir = Variables.LocalXMLFileDirectory + Variables.Factory;
        string dirZip = dir + "\\Zip";

        if (!Directory.Exists(dir) || !Directory.Exists(dirZip))
        {
            Directory.CreateDirectory(dirZip);
        }


        _fileName = Variables.LocalXMLFileDirectory + Variables.Factory + "\\P" + Variables.CurrentHPONumber + ".xml";

        // Create a new XML document and use the filepath in the connection as XML-file 
        textWriter = new XmlTextWriter(_fileName, null);

        //Set Formatting
        textWriter.Formatting = Formatting.Indented;
        textWriter.Indentation = 4;

        // Start writing the XML document:
        textWriter.WriteStartDocument();

        // Create root element <FactoryImportData>
        textWriter.WriteStartElement("FactoryImportData");

        textWriter.WriteAttributeString("xmlns", Variables.XMLNameSpace); //"http://www.hcfm.com/CMSFactoryService/");

        // Create row element: <ImportPO>
        textWriter.WriteStartElement("ImportPO");

        textWriter.WriteAttributeString("PONo", Variables.CurrentHPONumber);

    }

    public override void PostExecute()
    {
        base.PostExecute();

        //IDTSComponentMetaData100 myMetaData;
        //myMetaData = this.ComponentMetaData;


        // Close root element: </ImportPO>         
        textWriter.WriteEndElement();

        // Close root element: </FactoryImportData>         
        textWriter.WriteEndElement();

        // Stop writing the XML document         
        textWriter.WriteEndDocument();

        // Close document         
        textWriter.Close();

        Variables.LocalXMLFilePath = _fileName;
        Variables.RemoteXMLFTPPath = "/" + Variables.RemoteXMLFTPDirectory + Variables.Factory;

        Variables.DestinationZipSource = _fileName;
        Variables.DestinationZip = Variables.LocalXMLFileDirectory + Variables.Factory + "\\Zip\\P" + Variables.CurrentHPONumber + ".zip";

        Variables.EmailSubject = Variables.PurchaseOrderType + " Orders with PO#" + Variables.CurrentHPONumber;

        // myMetaData.FireWarning(0, null, "Path" + Variables.RemoteXMLFTPPath, null, 0);
    }

    public override void Input0_ProcessInputRow(Input0Buffer Row)
    {
        // Row type to get the value of a column         
        Type rowType = Row.GetType();
        String columnValue = "";


        IDTSComponentMetaData100 myMetaData;

        myMetaData = this.ComponentMetaData;
        //myMetaData.FireWarning(0, null, "Entered Row Processing", null, 0);


        // Create row element: <ImportOrders>         
        textWriter.WriteStartElement("ImportOrders");

        // Loop through all columns and create a column element: <COL1>value</COL1><COL2>value</COL2>         
        foreach (IDTSInputColumn100 column in this.ComponentMetaData.InputCollection[0].InputColumnCollection)
        {
            // Use the SSIS column name as element name: <COL1>            
            textWriter.WriteStartElement(column.Name);


            // Get column value, will fail if null             
            try
            {
                PropertyInfo prop = rowType.GetProperty(column.Name);

                if (column.DataType == DataType.DT_TEXT || column.DataType == DataType.DT_NTEXT)
                {
                    //myMetaData.FireWarning(0, null, "Entered Ntext", null, 0);
                    var blobCol = (Microsoft.SqlServer.Dts.Pipeline.BlobColumn)prop.GetValue(Row, null);
                    if (blobCol == null)
                    {
                        // myMetaData.FireWarning(0, null, "Ntext is null", null, 0);
                        columnValue = "";
                    }
                    else
                    {
                        //myMetaData.FireWarning(0, null, "Ntext has data", null, 0);
                        var data = blobCol.GetBlobData(0, (int)blobCol.Length);
                        columnValue = ConvertBytesToString(data);
                        //myMetaData.FireWarning(0, columnValue, "Ntext value", null, 0);
                    }

                }
                else
                {
                    columnValue = prop.GetValue(Row, null).ToString();
                }

            }
            catch
            {
                // Default value for null values: "null", "" or null                 
                columnValue = "";
            }
            finally
            {
                textWriter.WriteString(removeForbiddenXmlChars(columnValue));
            }

            // Close column element: </COL1>             
            textWriter.WriteEndElement();
        }         // Close row element: </ROW>         
        textWriter.WriteEndElement();

        // Output the number of processed rows. 103 = RowsWritten         
        this.ComponentMetaData.IncrementPipelinePerfCounter(103, 1);
    }

    // Remove forbidden chars that could damage your XML document     
    private string removeForbiddenXmlChars(string columnValue)
    {
        return columnValue.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }

    private string ConvertBytesToString(byte[] bytes)
    {
        string output = String.Empty;

        MemoryStream stream = new MemoryStream(bytes);
        stream.Position = 0;

        using (StreamReader reader = new StreamReader(stream))
        {
            output = reader.ReadToEnd();
        }

        return output;
    }

}
]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.csproj]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectTypeGuids>{30D016F9-3734-4E33-A861-5E7D899E18F3};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{69C4B943-A023-4319-BF62-2F2C313C4150}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>SC_6068c9b47b3d4e6a8d939cc5eff2a6a3</RootNamespace>
    <AssemblyName>SC_6068c9b47b3d4e6a8d939cc5eff2a6a3</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>true</ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>
    <TargetFrameworkProfile></TargetFrameworkProfile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.TxScript, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.DTSRuntimeWrap, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.DTSPipelineWrap, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.PipelineHost, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Compile Include="main.cs" />
    <Compile Include="BufferWrapper.cs" />
    <Compile Include="ComponentWrapper.cs" />
  </ItemGroup>
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- This section defines VSTA properties that describe the host-changable project properties. -->
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{30D016F9-3734-4E33-A861-5E7D899E18F3}">
        <ProjectProperties HostName="VSTAHostName" HostPackage="{B3A685AA-7EAF-4BC6-9940-57959FA5AC07}" ApplicationType="usd" Language="cs" TemplatesPath="" />
        <Host Name="ScriptComponent" IconIndex="0" />
        <ProjectClient>
          <HostIdentifier>SSIS_SC130</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Properties\Settings.Designer.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Settings.get_Default():SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Sett" +
    "ings")]

namespace SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties {
    
    
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[BufferWrapper.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[/* THIS IS AUTO-GENERATED CODE THAT WILL BE OVERWRITTEN! DO NOT EDIT!
*  Microsoft SQL Server Integration Services buffer wrappers
*  This module defines classes for accessing data flow buffers
*  THIS IS AUTO-GENERATED CODE THAT WILL BE OVERWRITTEN! DO NOT EDIT! */



using System;
using System.Data;
using Microsoft.SqlServer.Dts.Pipeline;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;

public class Input0Buffer: ScriptBuffer

{
    public Input0Buffer(PipelineBuffer Buffer, int[] BufferColumnIndexes, OutputNameMap OutputMap)
        : base(Buffer, BufferColumnIndexes, OutputMap)
    {
    }

    public Int32 hponumber
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[0]);
        }
    }
    public bool hponumber_IsNull
    {
        get
        {
            return IsNull(0);
        }
    }

    public Int32 center
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[1]);
        }
    }
    public bool center_IsNull
    {
        get
        {
            return IsNull(1);
        }
    }

    public String pcenternam
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[2]);
        }
    }
    public bool pcenternam_IsNull
    {
        get
        {
            return IsNull(2);
        }
    }

    public String pcountry
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[3]);
        }
    }
    public bool pcountry_IsNull
    {
        get
        {
            return IsNull(3);
        }
    }

    public String pctype
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[4]);
        }
    }
    public bool pctype_IsNull
    {
        get
        {
            return IsNull(4);
        }
    }

    public String cd
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[5]);
        }
    }
    public bool cd_IsNull
    {
        get
        {
            return IsNull(5);
        }
    }

    public String Orderstcod
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[6]);
        }
    }
    public bool Orderstcod_IsNull
    {
        get
        {
            return IsNull(6);
        }
    }

    public DateTime statusdate
    {
        get
        {
            return Buffer.GetDateTime(BufferColumnIndexes[7]);
        }
    }
    public bool statusdate_IsNull
    {
        get
        {
            return IsNull(7);
        }
    }

    public String programcod
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[8]);
        }
    }
    public bool programcod_IsNull
    {
        get
        {
            return IsNull(8);
        }
    }

    public Int32 progbig
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[9]);
        }
    }
    public bool progbig_IsNull
    {
        get
        {
            return IsNull(9);
        }
    }

    public DateTime duedate
    {
        get
        {
            return Buffer.GetDateTime(BufferColumnIndexes[10]);
        }
    }
    public bool duedate_IsNull
    {
        get
        {
            return IsNull(10);
        }
    }

    public String redo
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[11]);
        }
    }
    public bool redo_IsNull
    {
        get
        {
            return IsNull(11);
        }
    }

    public String systypecod
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[12]);
        }
    }
    public bool systypecod_IsNull
    {
        get
        {
            return IsNull(12);
        }
    }

    public String systypedes
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[13]);
        }
    }
    public bool systypedes_IsNull
    {
        get
        {
            return IsNull(13);
        }
    }

    public String scolorcode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[14]);
        }
    }
    public bool scolorcode_IsNull
    {
        get
        {
            return IsNull(14);
        }
    }

    public String scolordesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[15]);
        }
    }
    public bool scolordesc_IsNull
    {
        get
        {
            return IsNull(15);
        }
    }

    public String templcode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[16]);
        }
    }
    public bool templcode_IsNull
    {
        get
        {
            return IsNull(16);
        }
    }

    public String templdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[17]);
        }
    }
    public bool templdesc_IsNull
    {
        get
        {
            return IsNull(17);
        }
    }

    public Decimal templwidth
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[18]);
        }
    }
    public bool templwidth_IsNull
    {
        get
        {
            return IsNull(18);
        }
    }

    public Decimal adjwidth
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[19]);
        }
    }
    public bool adjwidth_IsNull
    {
        get
        {
            return IsNull(19);
        }
    }

    public Decimal templength
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[20]);
        }
    }
    public bool templength_IsNull
    {
        get
        {
            return IsNull(20);
        }
    }

    public Decimal adjlength
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[21]);
        }
    }
    public bool adjlength_IsNull
    {
        get
        {
            return IsNull(21);
        }
    }

    public String recesscode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[22]);
        }
    }
    public bool recesscode_IsNull
    {
        get
        {
            return IsNull(22);
        }
    }

    public String recessdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[23]);
        }
    }
    public bool recessdesc_IsNull
    {
        get
        {
            return IsNull(23);
        }
    }

    public String hairlcode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[24]);
        }
    }
    public bool hairlcode_IsNull
    {
        get
        {
            return IsNull(24);
        }
    }

    public String hairldesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[25]);
        }
    }
    public bool hairldesc_IsNull
    {
        get
        {
            return IsNull(25);
        }
    }

    public String densecode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[26]);
        }
    }
    public bool densecode_IsNull
    {
        get
        {
            return IsNull(26);
        }
    }

    public String densedesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[27]);
        }
    }
    public bool densedesc_IsNull
    {
        get
        {
            return IsNull(27);
        }
    }

    public String frontdense
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[28]);
        }
    }
    public bool frontdense_IsNull
    {
        get
        {
            return IsNull(28);
        }
    }

    public String fdensedesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[29]);
        }
    }
    public bool fdensedesc_IsNull
    {
        get
        {
            return IsNull(29);
        }
    }

    public String frontcode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[30]);
        }
    }
    public bool frontcode_IsNull
    {
        get
        {
            return IsNull(30);
        }
    }

    public String frontdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[31]);
        }
    }
    public bool frontdesc_IsNull
    {
        get
        {
            return IsNull(31);
        }
    }

    public String undervent
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[32]);
        }
    }
    public bool undervent_IsNull
    {
        get
        {
            return IsNull(32);
        }
    }

    public String hairhuman
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[33]);
        }
    }
    public bool hairhuman_IsNull
    {
        get
        {
            return IsNull(33);
        }
    }

    public String haircfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[34]);
        }
    }
    public bool haircfront_IsNull
    {
        get
        {
            return IsNull(34);
        }
    }

    public String hairctempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[35]);
        }
    }
    public bool hairctempl_IsNull
    {
        get
        {
            return IsNull(35);
        }
    }

    public String hairctop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[36]);
        }
    }
    public bool hairctop_IsNull
    {
        get
        {
            return IsNull(36);
        }
    }

    public String haircsides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[37]);
        }
    }
    public bool haircsides_IsNull
    {
        get
        {
            return IsNull(37);
        }
    }

    public String hairccrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[38]);
        }
    }
    public bool hairccrown_IsNull
    {
        get
        {
            return IsNull(38);
        }
    }

    public String haircback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[39]);
        }
    }
    public bool haircback_IsNull
    {
        get
        {
            return IsNull(39);
        }
    }

    public String highhuman
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[40]);
        }
    }
    public bool highhuman_IsNull
    {
        get
        {
            return IsNull(40);
        }
    }

    public String highstreak
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[41]);
        }
    }
    public bool highstreak_IsNull
    {
        get
        {
            return IsNull(41);
        }
    }

    public String highcfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[42]);
        }
    }
    public bool highcfront_IsNull
    {
        get
        {
            return IsNull(42);
        }
    }

    public String highpfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[43]);
        }
    }
    public bool highpfront_IsNull
    {
        get
        {
            return IsNull(43);
        }
    }

    public String highctempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[44]);
        }
    }
    public bool highctempl_IsNull
    {
        get
        {
            return IsNull(44);
        }
    }

    public String highptempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[45]);
        }
    }
    public bool highptempl_IsNull
    {
        get
        {
            return IsNull(45);
        }
    }

    public String highctop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[46]);
        }
    }
    public bool highctop_IsNull
    {
        get
        {
            return IsNull(46);
        }
    }

    public String highptop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[47]);
        }
    }
    public bool highptop_IsNull
    {
        get
        {
            return IsNull(47);
        }
    }

    public String highcsides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[48]);
        }
    }
    public bool highcsides_IsNull
    {
        get
        {
            return IsNull(48);
        }
    }

    public String highpsides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[49]);
        }
    }
    public bool highpsides_IsNull
    {
        get
        {
            return IsNull(49);
        }
    }

    public String highccrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[50]);
        }
    }
    public bool highccrown_IsNull
    {
        get
        {
            return IsNull(50);
        }
    }

    public String highpcrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[51]);
        }
    }
    public bool highpcrown_IsNull
    {
        get
        {
            return IsNull(51);
        }
    }

    public String highcback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[52]);
        }
    }
    public bool highcback_IsNull
    {
        get
        {
            return IsNull(52);
        }
    }

    public String highpback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[53]);
        }
    }
    public bool highpback_IsNull
    {
        get
        {
            return IsNull(53);
        }
    }

    public String hig2human
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[54]);
        }
    }
    public bool hig2human_IsNull
    {
        get
        {
            return IsNull(54);
        }
    }

    public String hig2streak
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[55]);
        }
    }
    public bool hig2streak_IsNull
    {
        get
        {
            return IsNull(55);
        }
    }

    public String hig2cfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[56]);
        }
    }
    public bool hig2cfront_IsNull
    {
        get
        {
            return IsNull(56);
        }
    }

    public String hig2pfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[57]);
        }
    }
    public bool hig2pfront_IsNull
    {
        get
        {
            return IsNull(57);
        }
    }

    public String hig2ctempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[58]);
        }
    }
    public bool hig2ctempl_IsNull
    {
        get
        {
            return IsNull(58);
        }
    }

    public String hig2ptempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[59]);
        }
    }
    public bool hig2ptempl_IsNull
    {
        get
        {
            return IsNull(59);
        }
    }

    public String hig2ctop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[60]);
        }
    }
    public bool hig2ctop_IsNull
    {
        get
        {
            return IsNull(60);
        }
    }

    public String hig2ptop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[61]);
        }
    }
    public bool hig2ptop_IsNull
    {
        get
        {
            return IsNull(61);
        }
    }

    public String hig2csides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[62]);
        }
    }
    public bool hig2csides_IsNull
    {
        get
        {
            return IsNull(62);
        }
    }

    public String hig2psides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[63]);
        }
    }
    public bool hig2psides_IsNull
    {
        get
        {
            return IsNull(63);
        }
    }

    public String hig2ccrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[64]);
        }
    }
    public bool hig2ccrown_IsNull
    {
        get
        {
            return IsNull(64);
        }
    }

    public String hig2pcrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[65]);
        }
    }
    public bool hig2pcrown_IsNull
    {
        get
        {
            return IsNull(65);
        }
    }

    public String hig2cback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[66]);
        }
    }
    public bool hig2cback_IsNull
    {
        get
        {
            return IsNull(66);
        }
    }

    public String hig2pback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[67]);
        }
    }
    public bool hig2pback_IsNull
    {
        get
        {
            return IsNull(67);
        }
    }

    public String greyhuman
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[68]);
        }
    }
    public bool greyhuman_IsNull
    {
        get
        {
            return IsNull(68);
        }
    }

    public String greypfront
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[69]);
        }
    }
    public bool greypfront_IsNull
    {
        get
        {
            return IsNull(69);
        }
    }

    public String greyptempl
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[70]);
        }
    }
    public bool greyptempl_IsNull
    {
        get
        {
            return IsNull(70);
        }
    }

    public String greyptop
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[71]);
        }
    }
    public bool greyptop_IsNull
    {
        get
        {
            return IsNull(71);
        }
    }

    public String greypsides
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[72]);
        }
    }
    public bool greypsides_IsNull
    {
        get
        {
            return IsNull(72);
        }
    }

    public String greypcrown
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[73]);
        }
    }
    public bool greypcrown_IsNull
    {
        get
        {
            return IsNull(73);
        }
    }

    public String greypback
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[74]);
        }
    }
    public bool greypback_IsNull
    {
        get
        {
            return IsNull(74);
        }
    }

    public String hairccode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[75]);
        }
    }
    public bool hairccode_IsNull
    {
        get
        {
            return IsNull(75);
        }
    }

    public String haircdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[76]);
        }
    }
    public bool haircdesc_IsNull
    {
        get
        {
            return IsNull(76);
        }
    }

    public String hairscode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[77]);
        }
    }
    public bool hairscode_IsNull
    {
        get
        {
            return IsNull(77);
        }
    }

    public String hairsdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[78]);
        }
    }
    public bool hairsdesc_IsNull
    {
        get
        {
            return IsNull(78);
        }
    }

    public Decimal frombridge
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[79]);
        }
    }
    public bool frombridge_IsNull
    {
        get
        {
            return IsNull(79);
        }
    }

    public Int32 permcode
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[80]);
        }
    }
    public bool permcode_IsNull
    {
        get
        {
            return IsNull(80);
        }
    }

    public String permdesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[81]);
        }
    }
    public bool permdesc_IsNull
    {
        get
        {
            return IsNull(81);
        }
    }

    public String ownhaircod
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[82]);
        }
    }
    public bool ownhaircod_IsNull
    {
        get
        {
            return IsNull(82);
        }
    }

    public String samplsinit
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[83]);
        }
    }
    public bool samplsinit_IsNull
    {
        get
        {
            return IsNull(83);
        }
    }

    public DateTime samplsdate
    {
        get
        {
            return Buffer.GetDateTime(BufferColumnIndexes[84]);
        }
    }
    public bool samplsdate_IsNull
    {
        get
        {
            return IsNull(84);
        }
    }

    public String techninit
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[85]);
        }
    }
    public bool techninit_IsNull
    {
        get
        {
            return IsNull(85);
        }
    }

    public DateTime techndate
    {
        get
        {
            return Buffer.GetDateTime(BufferColumnIndexes[86]);
        }
    }
    public bool techndate_IsNull
    {
        get
        {
            return IsNull(86);
        }
    }

    public String notes
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[87]);
        }
    }
    public bool notes_IsNull
    {
        get
        {
            return IsNull(87);
        }
    }

    public String samplesent
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[88]);
        }
    }
    public bool samplesent_IsNull
    {
        get
        {
            return IsNull(88);
        }
    }

    public String rush
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[89]);
        }
    }
    public bool rush_IsNull
    {
        get
        {
            return IsNull(89);
        }
    }

    public String factoryid
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[90]);
        }
    }
    public bool factoryid_IsNull
    {
        get
        {
            return IsNull(90);
        }
    }

    public String fassigned
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[91]);
        }
    }
    public bool fassigned_IsNull
    {
        get
        {
            return IsNull(91);
        }
    }

    public String didprintfo
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[92]);
        }
    }
    public bool didprintfo_IsNull
    {
        get
        {
            return IsNull(92);
        }
    }

    public String didfax
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[93]);
        }
    }
    public bool didfax_IsNull
    {
        get
        {
            return IsNull(93);
        }
    }

    public String factactual
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[94]);
        }
    }
    public bool factactual_IsNull
    {
        get
        {
            return IsNull(94);
        }
    }

    public DateTime statuserid
    {
        get
        {
            return Buffer.GetDateTime(BufferColumnIndexes[95]);
        }
    }
    public bool statuserid_IsNull
    {
        get
        {
            return IsNull(95);
        }
    }

    public Int32 statreq
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[96]);
        }
    }
    public bool statreq_IsNull
    {
        get
        {
            return IsNull(96);
        }
    }

    public Int32 statfact
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[97]);
        }
    }
    public bool statfact_IsNull
    {
        get
        {
            return IsNull(97);
        }
    }

    public Int32 statreply
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[98]);
        }
    }
    public bool statreply_IsNull
    {
        get
        {
            return IsNull(98);
        }
    }

    public String firstname
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[99]);
        }
    }
    public bool firstname_IsNull
    {
        get
        {
            return IsNull(99);
        }
    }

    public String lastname
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[100]);
        }
    }
    public bool lastname_IsNull
    {
        get
        {
            return IsNull(100);
        }
    }

    public Decimal factcost
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[101]);
        }
    }
    public bool factcost_IsNull
    {
        get
        {
            return IsNull(101);
        }
    }

    public Decimal costbase
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[102]);
        }
    }
    public bool costbase_IsNull
    {
        get
        {
            return IsNull(102);
        }
    }

    public Int32 costhuman
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[103]);
        }
    }
    public bool costhuman_IsNull
    {
        get
        {
            return IsNull(103);
        }
    }

    public Int32 costlength
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[104]);
        }
    }
    public bool costlength_IsNull
    {
        get
        {
            return IsNull(104);
        }
    }

    public Int32 costarea
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[105]);
        }
    }
    public bool costarea_IsNull
    {
        get
        {
            return IsNull(105);
        }
    }

    public Int32 costadj
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[106]);
        }
    }
    public bool costadj_IsNull
    {
        get
        {
            return IsNull(106);
        }
    }

    public String group
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[107]);
        }
    }
    public bool group_IsNull
    {
        get
        {
            return IsNull(107);
        }
    }

    public String faccode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[108]);
        }
    }
    public bool faccode_IsNull
    {
        get
        {
            return IsNull(108);
        }
    }

    public Decimal price
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[109]);
        }
    }
    public bool price_IsNull
    {
        get
        {
            return IsNull(109);
        }
    }

    public Int32 OrderCount
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[110]);
        }
    }
    public bool OrderCount_IsNull
    {
        get
        {
            return IsNull(110);
        }
    }

    public BlobColumn factnotes
    {
        get
        {
            return (BlobColumn)Buffer[BufferColumnIndexes[111]];
        }
    }
    public bool factnotes_IsNull
    {
        get
        {
            return IsNull(111);
        }
    }

    public String HairSystemOrderNumber
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[112]);
        }
    }
    public bool HairSystemOrderNumber_IsNull
    {
        get
        {
            return IsNull(112);
        }
    }

    public Int32 clientno
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[113]);
        }
    }
    public bool clientno_IsNull
    {
        get
        {
            return IsNull(113);
        }
    }

    public Decimal StartingPointMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[114]);
        }
    }
    public bool StartingPointMeasurement_IsNull
    {
        get
        {
            return IsNull(114);
        }
    }

    public Decimal CircumferenceMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[115]);
        }
    }
    public bool CircumferenceMeasurement_IsNull
    {
        get
        {
            return IsNull(115);
        }
    }

    public Decimal FrontToBackMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[116]);
        }
    }
    public bool FrontToBackMeasurement_IsNull
    {
        get
        {
            return IsNull(116);
        }
    }

    public Decimal EarToEarOverFrontMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[117]);
        }
    }
    public bool EarToEarOverFrontMeasurement_IsNull
    {
        get
        {
            return IsNull(117);
        }
    }

    public Decimal EarToEarOverTopMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[118]);
        }
    }
    public bool EarToEarOverTopMeasurement_IsNull
    {
        get
        {
            return IsNull(118);
        }
    }

    public Decimal SideburnToSideburnMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[119]);
        }
    }
    public bool SideburnToSideburnMeasurement_IsNull
    {
        get
        {
            return IsNull(119);
        }
    }

    public Decimal TempleToTempleMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[120]);
        }
    }
    public bool TempleToTempleMeasurement_IsNull
    {
        get
        {
            return IsNull(120);
        }
    }

    public Decimal NapeAreaMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[121]);
        }
    }
    public bool NapeAreaMeasurement_IsNull
    {
        get
        {
            return IsNull(121);
        }
    }

    public Decimal FrontLaceMeasurement
    {
        get
        {
            return Buffer.GetDecimal(BufferColumnIndexes[122]);
        }
    }
    public bool FrontLaceMeasurement_IsNull
    {
        get
        {
            return IsNull(122);
        }
    }

    public String MeaRecession
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[123]);
        }
    }
    public bool MeaRecession_IsNull
    {
        get
        {
            return IsNull(123);
        }
    }

    public Boolean AreSideburnsAndTemplesLaceFlag
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[124]);
        }
    }
    public bool AreSideburnsAndTemplesLaceFlag_IsNull
    {
        get
        {
            return IsNull(124);
        }
    }

    public Int32 SideburnTemplateDiagram
    {
        get
        {
            return Buffer.GetInt32(BufferColumnIndexes[125]);
        }
    }
    public bool SideburnTemplateDiagram_IsNull
    {
        get
        {
            return IsNull(125);
        }
    }

    public String DoesMeasurementExist
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[126]);
        }
    }
    public bool DoesMeasurementExist_IsNull
    {
        get
        {
            return IsNull(126);
        }
    }

    public String laceLengthCode
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[127]);
        }
    }
    public bool laceLengthCode_IsNull
    {
        get
        {
            return IsNull(127);
        }
    }

    public String POType
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[128]);
        }
    }
    public bool POType_IsNull
    {
        get
        {
            return IsNull(128);
        }
    }

    public Boolean IsFashionHairlineHighlightsFlag
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[129]);
        }
    }
    public bool IsFashionHairlineHighlightsFlag_IsNull
    {
        get
        {
            return IsNull(129);
        }
    }

    public Boolean IsSignatureHairlineAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[130]);
        }
    }
    public bool IsSignatureHairlineAddOn_IsNull
    {
        get
        {
            return IsNull(130);
        }
    }

    public Boolean IsExtendedLaceAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[131]);
        }
    }
    public bool IsExtendedLaceAddOn_IsNull
    {
        get
        {
            return IsNull(131);
        }
    }

    public Boolean IsOmbreAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[132]);
        }
    }
    public bool IsOmbreAddOn_IsNull
    {
        get
        {
            return IsNull(132);
        }
    }

    public Boolean IsLongHairAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[133]);
        }
    }
    public bool IsLongHairAddOn_IsNull
    {
        get
        {
            return IsNull(133);
        }
    }

    public Boolean IsRootShadowingAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[134]);
        }
    }
    public bool IsRootShadowingAddOn_IsNull
    {
        get
        {
            return IsNull(134);
        }
    }

    public String RootShadowingRootColorLength
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[135]);
        }
    }
    public bool RootShadowingRootColorLength_IsNull
    {
        get
        {
            return IsNull(135);
        }
    }

    public String RootShadowingRootColor
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[136]);
        }
    }
    public bool RootShadowingRootColor_IsNull
    {
        get
        {
            return IsNull(136);
        }
    }

    public Boolean IsCuticleIntactHairAddOn
    {
        get
        {
            return Buffer.GetBoolean(BufferColumnIndexes[137]);
        }
    }
    public bool IsCuticleIntactHairAddOn_IsNull
    {
        get
        {
            return IsNull(137);
        }
    }

    public String RootShadowingRootColorLengthDesc
    {
        get
        {
            return Buffer.GetString(BufferColumnIndexes[138]);
        }
    }
    public bool RootShadowingRootColorLengthDesc_IsNull
    {
        get
        {
            return IsNull(138);
        }
    }

    new public bool NextRow()
    {
        return base.NextRow();
    }

    new public bool EndOfRowset()
    {
        return base.EndOfRowset();
    }

}
]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Project]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF16LE]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[<?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<c:Project xmlns:c="http://schemas.microsoft.com/codeprojectml/2010/08/main" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" runtimeVersion="4.0" schemaVersion="1.0">
  <msb:PropertyGroup>
    <msb:CodeName>SC_6068c9b47b3d4e6a8d939cc5eff2a6a3</msb:CodeName>
    <msb:Language>msBuild</msb:Language>
    <msb:DisplayName>SC_6068c9b47b3d4e6a8d939cc5eff2a6a3</msb:DisplayName>
    <msb:ProjectId>{B1425F82-224D-485F-82A2-F1166284CB05}</msb:ProjectId>
  </msb:PropertyGroup>
  <msb:ItemGroup>
    <msb:Project Include="SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.csproj" />
    <msb:File Include="Properties\Resources.Designer.cs" />
    <msb:File Include="Properties\Settings.Designer.cs" />
    <msb:File Include="main.cs" />
    <msb:File Include="BufferWrapper.cs" />
    <msb:File Include="ComponentWrapper.cs" />
    <msb:File Include="Properties\Settings.settings" />
    <msb:File Include="Properties\AssemblyInfo.cs" />
    <msb:File Include="Properties\Resources.resx" />
  </msb:ItemGroup>
</c:Project>]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Properties\AssemblyInfo.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("SC_6068c9b47b3d4e6a8d939cc5eff2a6a3")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("SC_6068c9b47b3d4e6a8d939cc5eff2a6a3")]
[assembly: AssemblyCopyright("Copyright @  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")]
]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Properties\Settings.settings]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[Properties\Resources.Designer.cs]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[UTF8]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope="member", Target="SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties {
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if ((resourceMan == null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
]]></arrayElement>
                          </arrayElements>
                        </property>
                        <property
                          dataType="System.String"
                          description="Stores the binary representation of the component"
                          isArray="true"
                          name="BinaryCode"
                          state="cdata">
                          <arrayElements
                            arrayElementCount="2">
                            <arrayElement
                              dataType="System.String"><![CDATA[SC_6068c9b47b3d4e6a8d939cc5eff2a6a3.dll]]></arrayElement>
                            <arrayElement
                              dataType="System.String"><![CDATA[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
OQAACgJ7OgAACh93lG8/AAAKKiYCH3coPAAACipWAns5AAAKAns6AAAKH3iUbz8AAAoqJgIfeCg8
AAAKKlYCezkAAAoCezoAAAofeZRvPwAACiomAh95KDwAAAoqVgJ7OQAACgJ7OgAACh96lG8/AAAK
KiYCH3ooPAAACipWAns5AAAKAns6AAAKH3uUbz0AAAoqJgIfeyg8AAAKKlYCezkAAAoCezoAAAof
fJRvQQAACiomAh98KDwAAAoqVgJ7OQAACgJ7OgAACh99lG87AAAKKiYCH30oPAAACipWAns5AAAK
Ans6AAAKH36Ubz0AAAoqJgIffig8AAAKKlYCezkAAAoCezoAAAoff5RvPQAACiomAh9/KDwAAAoq
YgJ7OQAACgJ7OgAACiCAAAAAlG89AAAKKjICIIAAAAAoPAAACipiAns5AAAKAns6AAAKIIEAAACU
b0EAAAoqMgIggQAAACg8AAAKKmICezkAAAoCezoAAAogggAAAJRvQQAACioyAiCCAAAAKDwAAAoq
YgJ7OQAACgJ7OgAACiCDAAAAlG9BAAAKKjICIIMAAAAoPAAACipiAns5AAAKAns6AAAKIIQAAACU
b0EAAAoqMgIghAAAACg8AAAKKmICezkAAAoCezoAAAoghQAAAJRvQQAACioyAiCFAAAAKDwAAAoq
YgJ7OQAACgJ7OgAACiCGAAAAlG9BAAAKKjICIIYAAAAoPAAACipiAns5AAAKAns6AAAKIIcAAACU
bz0AAAoqMgIghwAAACg8AAAKKmICezkAAAoCezoAAAogiAAAAJRvPQAACioyAiCIAAAAKDwAAAoq
YgJ7OQAACgJ7OgAACiCJAAAAlG9BAAAKKjICIIkAAAAoPAAACipiAns5AAAKAns6AAAKIIoAAACU
bz0AAAoqMgIgigAAACg8AAAKKh4CKEIAAAoqHgIoQwAACip+AihEAAAKAgJzJAEABn0DAAAEAgJz
JgEABn0EAAAEKpIEcu0AAHAab0UAAAosFQIFAgMoRgAACg4EcwcAAAZvIgEABipKKwcCA28jAQAG
A28eAQAGLfEqBio6AihHAAAKAgN9BQAABCqCAnsFAAAEbyEAAApvSAAACnL9AABwb0kAAApvSgAA
Cio6AihHAAAKAgN9BgAABCqWAnsGAAAEb0sAAApyFQEAcG9MAAAKKE0AAApvTgAACnQlAAABKpYC
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
WBqNAA8A7jYAAAAAhghuIY0ADwAUNwAAAACGCJQhjQAPADo3AAAAAIYIgQSNAA8AYDcAAAAAhgh6
IY0ADwCGNwAAAACGCK8CjQAPAKw3AAAAAIYIzhmNAA8A0jcAAAAAhgjhGRAADwDvNwAAAACGCNoC
jQAQABU4AAAAAIYI8wIQABAAMjgAAAAAhgjlHY0AEQBYOAAAAACGCPYdEAARAHU4AAAAAIYIMwiN
ABIAmzgAAAAAhghICBAAEgC4OAAAAACGCAkIjQATAN44AAAAAIYIHggQABMA+zgAAAAAgxjRGwYA
FAADOQAAAACTCNYaxAEUAC85AAAAAJMIqgTJARQANjkAAAAAkwi2BM8BFAA+OQAAAACWCDAe1gEV
AEU5AAAAAIYY0RsGABUATTkAAAAAkRjXG9sBFQAAAAEARCEAAAEAIAcAAAEAUR0AAAEAzxoAAAIA
Vx0AAAMAfRkAAAEAMgEAAAIA/AMAAAMAzxoAAAQAfRkAAAEAzxoAAAEARCEAAAEAvB8AAAEAvB8A
AAEANQcAAAEANQcAAAEANQcAAAEANQcAAAEANQcAAAEANQcJANEbAQARANEbBgAZANEbCgApANEb
EAAxANEbEAA5ANEbEABBANEbEABJANEbEABRANEbEABZANEbEABhANEbEABpANEbBgDxANEbBgAR
AdEbFQAhAdEbBgDhAP8GBgApAcodIAAxAcMdJgAxAa4hKwApAcodMgBxANEbOABxAPEHQABxACYY
AQBRAXUfBgBRAUweEABRAb0HRwDhAAoHBgBRATweBgBRAWQfBgBRAQYFBgApAcodTQCpAJcEZgDh
AFEBawBZAZcYcQBhAe0WdwBxAV0YfgB5AcMbhACBAMYfiQCJAOkDjQB5ANEhkQCJAHQElwCRACwH
nQCZAHkIpACZAGcBqACpAN4HjQBRAbEHEACBANAgrwChAAwFBgBZAX8bswApAacCuQApAcshxQCJ
AdEbyACRAasYzgCxANEb0wCZAWECjQC5ANEb2gC5AM8a5AC5AFcd6ADBAPwA7AC5AEkW8QDBAOcH
9gDBADwE+wDBAE8JAQHBAO0WBwHBAJkX8QC5AEAhrwC5AAcerwDhANEbBgApAYUdDAHhAGsdFAGp
ANEbBgBZAXcYGgGpAQYEIAGxAeoaJwHhACMdLAG5Ae0WMgHhABQhOQHBAeUgPwHhAAwdLAHBARYH
RgF5ANcDSwF5AFMhUwH5ANEbWQEZAdEbBgAuAAsADwIuABMAGAIuABsANwIuACMAQAIuACsAaQIu
ADMAaQIuADsAaQIuAEMAQAIuAEsAbwIuAFMAaQIuAFsAhgJDAGMA0ALjAGsA0AIhAXsA0AJpJHMA
NwKJJHMANwIcAFQAvwADAAEABQAXAQYAGAEHACMBCAAlAQAAixrfAQAAkxLjAQAAeBvfAQAAqBLj
AQAAxhbnAQAApA/jAQAAwiHnAQAAQBbjAQAAowTnAQAAsgzjAQAAMwLnAQAAvwrjAQAAnALnAQAA
TwvjAQAAQQXrAQAALA3jAQAAfgLnAQAAIwvjAQAAhgffAQAAlw3jAQAAGAXrAQAA7gzjAQAAJxnn
AQAAnBHjAQAAbwLnAQAADQvjAQAAaRznAQAA3BLjAQAAdAPnAQAACwzjAQAA+QHnAQAAaQrjAQAA
SwPnAQAAzQvjAQAA0AHnAQAAKwrjAQAAbgjwAQAAzg3jAQAAYQjwAQAAug3jAQAAtwjwAQAAIQ7j
AQAAqQjwAQAADA7jAQAAkQPnAQAANgzjAQAAFgLnAQAAlArjAQAAWQPnAQAA4gvjAQAA3gHnAQAA
QArjAQAAPQPnAQAAuAvjAQAAwgHnAQAAFgrjAQAA+wTnAQAA2AzjAQAAwQHnAQAAFQrjAQAAoAPn
AQAATAzjAQAAJQLnAQAAqgrjAQAA5R/nAQAANhXjAQAAxBfnAQAAwRDjAQAAESDnAQAAdxXjAQAA
fRbnAQAATA/jAQAAEhrnAQAA/hHjAQAAlhznAQAAHhPjAQAA6xjnAQAARBHjAQAAGwnnAQAAtg7j
AQAAthfnAQAArBDjAQAA8AjnAQAAdg7jAQAAAiDnAQAAYRXjAQAALyDnAQAAoxXjAQAAbhbnAQAA
Ng/jAQAAmxbnAQAAeA/jAQAABRrnAQAA6hHjAQAALBrnAQAAJhLjAQAAhxznAQAACBPjAQAAtBzn
AQAAShPjAQAA3BjnAQAALhHjAQAACRnnAQAAcBHjAQAADQnnAQAAoQ7jAQAANwnnAQAA4A7jAQAA
qBfnAQAAlxDjAQAA4QjnAQAAYA7jAQAA8x/nAQAASxXjAQAAICDnAQAAjRXjAQAAXxbnAQAAIA/j
AQAAjBbnAQAAYg/jAQAA+BnnAQAA1hHjAQAAHxrnAQAAEhLjAQAAeBznAQAA8hLjAQAApRznAQAA
NBPjAQAAzRjnAQAAGBHjAQAA+hjnAQAAWhHjAQAA/wjnAQAAjA7jAQAAKQnnAQAAyw7jAQAA4Bfn
AQAA6xDjAQAAPiDnAQAAuRXjAQAAqhbnAQAAjg/jAQAAORrnAQAAOhLjAQAAwxznAQAAYBPjAQAA
GBnnAQAAhhHjAQAARQnnAQAA9Q7jAQAALwPnAQAAowvjAQAApQHnAQAA6wnjAQAAgwPnAQAAIQzj
AQAACALnAQAAfwrjAQAArgPwAQAAYQzjAQAAZwPfAQAA9wvjAQAA7AHnAQAAVQrjAQAAjQLnAQAA
OQvjAQAAJR7nAQAAxRPjAQAAMgXrAQAAFg3jAQAAFx7nAQAAsBPjAQAAJAXrAQAAAQ3jAQAASx3n
AQAAixPjAQAA1h/nAQAAIBXjAQAABAjnAQAAqg3jAQAAVwLnAQAA+ArjAQAAOgLnAQAAzQrjAQAA
VxnnAQAArBHjAQAATCHnAQAAGRbjAQAAXgnnAQAACg/jAQAASALrAQAA4grjAQAAUBrfAQAAXxLj
AQAA1R3fAQAAnBPjAQAAZCHfAQAAKxbjAQAAMgTnAQAAiwzjAQAAJQTnAQAAdwzjAQAAsyDwAQAA
BRbjAQAA7gTwAQAAxAzjAQAA0hffAQAA1hDjAQAAxgjfAQAANw7jAQAASAHfAQAAqwnjAQAA1Qjf
AQAATQ7jAQAARhrnAQAAThLjAQAAIwPnAQAAkAvjAQAAxALwAQAAZQvjAQAATSDfAQAAzxXjAQAA
Rx31AQAAhxPjAQAAcRrnAQAAchLjAQAAZhnfAQAAwhHjAQAAKh/wAQAA1BTjAQAAkx7wAQAAGhTj
AQAAzh7wAQAAYxTjAQAARx/wAQAA+BTjAQAACx/wAQAArhTjAQAA6R7wAQAAhRTjAQAAsB7wAQAA
PhTjAQAAYh7wAQAA2xPjAQAAeh7wAQAA+hPjAQAABBjnAQAAABHjAQAAPwfjAQAAQg3jAQAA1Rbf
AQAAug/jAQAAeSDnAQAA5RXjAQAAEAPnAQAAdgvjAQAAbQTnAQAAoAzjAQAAYgfjAQAAbA3jAQAA
GRfjAQAA/A/jAQAAARfjAQAA3Q/jAQAANhfjAQAAIBDjAQAAYBfjAQAAWBDjAQAARxfjAQAAOBDj
AQAAiAjnAQAA5A3jAQAAoBvnAQAAuhLjAQAAdBfjAQAAcxDjAQAAgAHnAQAAvwnjAQAAjB/6AQAA
XBrnAQAAciHnAQAAmCHnAQAAhQTnAQAAfiHnAQAAswLnAQAA5RnnAQAA9wLnAQAA+h3nAQAATAjn
AQAAIgjnAQAA2hr/AQAAygQEAgAANB4KAgIACAADAAIACQAFAAIACgAHAAIACwAJAAIADAALAAIA
DQANAAIADgAPAAIADwARAAIAEAATAAIAEQAVAAIAEgAXAAIAEwAZAAIAFAAbAAIAFQAdAAIAFgAf
AAIAFwAhAAIAGAAjAAIAGQAlAAIAGgAnAAIAGwApAAIAHAArAAIAHQAtAAIAHgAvAAIAHwAxAAIA
IAAzAAIAIQA1AAIAIgA3AAIAIwA5AAIAJAA7AAIAJQA9AAIAJgA/AAIAJwBBAAIAKABDAAIAKQBF
AAIAKgBHAAIAKwBJAAIALABLAAIALQBNAAIALgBPAAIALwBRAAIAMABTAAIAMQBVAAIAMgBXAAIA
MwBZAAIANABbAAIANQBdAAIANgBfAAIANwBhAAIAOABjAAIAOQBlAAIAOgBnAAIAOwBpAAIAPABr
AAIAPQBtAAIAPgBvAAIAPwBxAAIAQABzAAIAQQB1AAIAQgB3AAIAQwB5AAIARAB7AAIARQB9AAIA
RgB/AAIARwCBAAIASACDAAIASQCFAAIASgCHAAIASwCJAAIATACLAAIATQCNAAIATgCPAAIATwCR
AAIAUACTAAIAUQCVAAIAUgCXAAIAUwCZAAIAVACbAAIAVQCdAAIAVgCfAAIAVwChAAIAWACjAAIA
WQClAAIAWgCnAAIAWwCpAAIAXACrAAIAXQCtAAIAXgCvAAIAXwCxAAIAYACzAAIAYQC1AAIAYgC3
AAIAYwC5AAIAZAC7AAIAZQC9AAIAZgC/AAIAZwDBAAIAaADDAAIAaQDFAAIAagDHAAIAawDJAAIA
bADLAAIAbQDNAAIAbgDPAAIAbwDRAAIAcADTAAIAcQDVAAIAcgDXAAIAcwDZAAIAdADbAAIAdQDd
AAIAdgDfAAIAdwDhAAIAeADjAAIAeQDlAAIAegDnAAIAewDpAAIAfADrAAIAfQDtAAIAfgDvAAIA
fwDxAAIAgADzAAIAgQD1AAIAggD3AAIAgwD5AAIAhAD7AAIAhQD9AAIAhgD/AAIAhwABAQIAiAAD
AQIAiQAFAQIAigAHAQIAiwAJAQIAjAALAQIAjQANAQIAjgAPAQIAjwARAQIAkAATAQIAkQAVAQIA
kgAXAQIAkwAZAQIAlAAbAQIAlQAdAQIAlgAfAQIAlwAhAQIAmAAjAQIAmQAlAQIAmgAnAQIAmwAp
AQIAnAArAQIAnQAtAQIAngAvAQIAnwAxAQIAoAAzAQIAoQA1AQIAogA3AQIAowA5AQIApAA7AQIA
pQA9AQIApgA/AQIApwBBAQIAqABDAQIAqQBFAQIAqgBHAQIAqwBJAQIArABLAQIArQBNAQIArgBP
AQIArwBRAQIAsABTAQIAsQBVAQIAsgBXAQIAswBZAQIAtABbAQIAtQBdAQIAtgBfAQIAtwBhAQIA
uABjAQIAuQBlAQIAugBnAQIAuwBpAQIAvABrAQIAvQBtAQIAvgBvAQIAvwBxAQIAwABzAQIAwQB1
AQIAwgB3AQIAwwB5AQIAxAB7AQIAxQB9AQIAxgB/AQIAxwCBAQIAyACDAQIAyQCFAQIAygCHAQIA
ywCJAQIAzACLAQIAzQCNAQIAzgCPAQIAzwCRAQIA0ACTAQIA0QCVAQIA0gCXAQIA0wCZAQIA1ACb
AQIA1QCdAQIA1gCfAQIA1wChAQIA2ACjAQIA2QClAQIA2gCnAQIA2wCpAQIA3ACrAQIA3QCtAQIA
3gCvAQIA3wCxAQIA4ACzAQIA4QC1AQIA4gC3AQIA4wC5AQIA5AC7AQIA5QC9AQIA5gC/AQIA5wDB
AQIA6ADDAQIA6QDFAQIA6gDHAQIA6wDJAQIA7ADLAQIA7QDNAQIA7gDPAQIA7wDRAQIA8ADTAQIA
8QDVAQIA8gDXAQIA8wDZAQIA9ADbAQIA9QDdAQIA9gDfAQIA9wDhAQIA+ADjAQIA+QDlAQIA+gDn
AQIA+wDpAQIA/ADrAQIA/QDtAQIA/gDvAQIA/wDxAQIAAAHzAQIAAQH1AQIAAgH3AQIAAwH5AQIA
BAH7AQIABQH9AQIABgH/AQIABwEBAgIACAEDAgIACQEFAgIACgEHAgIACwEJAgIADAELAgIADQEN
AgIADgEPAgIADwERAgIAEAETAgIAEQEVAgIAEgEXAgIAEwEZAgIAFAEbAgIAFQEdAgIAFgEfAgIA
FwEhAgIAGAEjAgIAGQElAgIAGgEnAgIAGwEpAgIAHAErAgIAHQEtAgIAJQEvAgIAJwExAgIAKAEz
AgIAKQE1AgIAKgE3AgIAKwE5AgIALAE7AgIALQE9AgEALgE9AgIALwE/AgEAMAE/AgIAMQFBAgEA
MgFBAgIAMwFDAgEANAFDAgIANQFFAgEANgFFAgIAOAFHAgIAOQFJAgEAOgFJAgIAOwFLAgSAAAAB
AAAAAAAAAAAAAAAAAAUBAAAEAAAAAAAAAAAAAABhAXMBAAAAAA4AAAAAAAAAAAAAAGoBWCAAAAAA
BAAAAAAAAAAAAAAAYQFQFgAAAAAOAAAAAAAAAAAAAABqAaoZAAAAAA4AAAAAAAAAAAAAAGoBjiAA
AAAADgAAAAAAAAAAAAAAagGHGQAAAAAEAAAAAAAAAAAAAABhAfYWAAAAAAAAAAABAAAAIhwAAAAA
AElEVFNDb21wb25lbnRNZXRhRGF0YTEwMABJRFRTVmFyaWFibGUxMDAASURUU0lucHV0Q29sdW1u
MTAwAElEVFNJbnB1dENvbHVtbkNvbGxlY3Rpb24xMDAASURUU1J1bnRpbWVDb25uZWN0aW9uQ29s
bGVjdGlvbjEwMABJRFRTSW5wdXRDb2xsZWN0aW9uMTAwAElEVFNSdW50aW1lQ29ubmVjdGlvbjEw
MABJRFRTQ29ubmVjdGlvbk1hbmFnZXIxMDAASURUU1ZhcmlhYmxlczEwMABJRFRTSW5wdXQxMDAA
SURUU0V2YWx1YXRvckNvbnRleHQxMDAAR2V0SW50MzIAU0NfNjA2OGM5YjQ3YjNkNGU2YThkOTM5
Y2M1ZWZmMmE2YTMAPE1vZHVsZT4ASW5wdXRJRABTeXN0ZW0uSU8AZ2V0X2Nvc3RhcmVhAGdldF9D
b21wb25lbnRNZXRhRGF0YQBHZXRCbG9iRGF0YQBtc2NvcmxpYgBnZXRfUm9vdFNoYWRvd2luZ1Jv
b3RDb2xvckxlbmd0aERlc2MAZ2V0X2hhaXJjZGVzYwBnZXRfZGVuc2VkZXNjAGdldF9mZGVuc2Vk
ZXNjAGdldF90ZW1wbGRlc2MAZ2V0X2hhaXJsZGVzYwBnZXRfcGVybWRlc2MAZ2V0X3Njb2xvcmRl
c2MAZ2V0X2hhaXJzZGVzYwBnZXRfcmVjZXNzZGVzYwBnZXRfZnJvbnRkZXNjAGdldF9jZABnZXRf
ZmFzc2lnbmVkAGdldF9zdGF0dXNlcmlkAGdldF9mYWN0b3J5aWQAUmVhZFRvRW5kAGdldF9zeXN0
eXBlY29kAGdldF9wcm9ncmFtY29kAGdldF9vd25oYWlyY29kAGdldF9PcmRlcnN0Y29kAFJlcGxh
Y2UAZ2V0X1hNTE5hbWVTcGFjZQBnZXRfcHJpY2UAZGVmYXVsdEluc3RhbmNlAGdldF9EZXN0aW5h
dGlvblppcFNvdXJjZQBzZXRfRGVzdGluYXRpb25aaXBTb3VyY2UAZ2V0X2xhY2VMZW5ndGhDb2Rl
AGdldF9mYWNjb2RlAGdldF9oYWlyY2NvZGUAZ2V0X2RlbnNlY29kZQBnZXRfdGVtcGxjb2RlAGdl
dF9oYWlybGNvZGUAZ2V0X3Blcm1jb2RlAGdldF9zY29sb3Jjb2RlAGdldF9oYWlyc2NvZGUAZ2V0
X3JlY2Vzc2NvZGUAZ2V0X2Zyb250Y29kZQBnZXRfZnJvbWJyaWRnZQBJRGlzcG9zYWJsZQBSdW50
aW1lVHlwZUhhbmRsZQBHZXRUeXBlRnJvbUhhbmRsZQBnZXRfTmFtZQBfZmlsZU5hbWUASW5wdXRO
YW1lAEdldFJ1bnRpbWVDb25uZWN0aW9uQnlOYW1lAGdldF9sYXN0bmFtZQBnZXRfZmlyc3RuYW1l
AEdldERhdGVUaW1lAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuRHRzLlBpcGVsaW5lAGdldF9QT1R5cGUA
Z2V0X0RhdGFUeXBlAGdldF9QdXJjaGFzZU9yZGVyVHlwZQBHZXRUeXBlAGdldF9wY3R5cGUAZ2V0
X0N1bHR1cmUAc2V0X0N1bHR1cmUAcmVzb3VyY2VDdWx0dXJlAEFwcGxpY2F0aW9uU2V0dGluZ3NC
YXNlAGdldF9jb3N0YmFzZQBnZXRfZnJvbnRkZW5zZQBDbG9zZQBEaXNwb3NlAGdldF9kdWVkYXRl
AGdldF90ZWNobmRhdGUAZ2V0X3NhbXBsc2RhdGUAZ2V0X3N0YXR1c2RhdGUARWRpdG9yQnJvd3Nh
YmxlU3RhdGUAQ29tcGlsZXJHZW5lcmF0ZWRBdHRyaWJ1dGUARGVidWdnZXJOb25Vc2VyQ29kZUF0
dHJpYnV0ZQBEZWJ1Z2dhYmxlQXR0cmlidXRlAEVkaXRvckJyb3dzYWJsZUF0dHJpYnV0ZQBBc3Nl
bWJseVRpdGxlQXR0cmlidXRlAEFzc2VtYmx5VHJhZGVtYXJrQXR0cmlidXRlAFRhcmdldEZyYW1l
d29ya0F0dHJpYnV0ZQBBc3NlbWJseUNvbmZpZ3VyYXRpb25BdHRyaWJ1dGUAQXNzZW1ibHlEZXNj
cmlwdGlvbkF0dHJpYnV0ZQBDb21waWxhdGlvblJlbGF4YXRpb25zQXR0cmlidXRlAEFzc2VtYmx5
UHJvZHVjdEF0dHJpYnV0ZQBBc3NlbWJseUNvcHlyaWdodEF0dHJpYnV0ZQBTU0lTU2NyaXB0Q29t
cG9uZW50RW50cnlQb2ludEF0dHJpYnV0ZQBBc3NlbWJseUNvbXBhbnlBdHRyaWJ1dGUAUnVudGlt
ZUNvbXBhdGliaWxpdHlBdHRyaWJ1dGUAUHJlRXhlY3V0ZQBQb3N0RXhlY3V0ZQBzZXRfVmFsdWUA
Y29sdW1uVmFsdWUAR2V0VmFsdWUAdmFsdWUAZ2V0X0FyZVNpZGVidXJuc0FuZFRlbXBsZXNMYWNl
RmxhZwBnZXRfSXNGYXNoaW9uSGFpcmxpbmVIaWdobGlnaHRzRmxhZwBnZXRfcHJvZ2JpZwBFbmNv
ZGluZwBTeXN0ZW0uUnVudGltZS5WZXJzaW9uaW5nAFdyaXRlU3RyaW5nAFdyaXRlQXR0cmlidXRl
U3RyaW5nAENvbnZlcnRCeXRlc1RvU3RyaW5nAEdldFN0cmluZwBzZXRfRm9ybWF0dGluZwBnZXRf
cnVzaABnZXRfUmVtb3RlWE1MRlRQUGF0aABzZXRfUmVtb3RlWE1MRlRQUGF0aABnZXRfTG9jYWxY
TUxGaWxlUGF0aABzZXRfTG9jYWxYTUxGaWxlUGF0aABnZXRfYWRqd2lkdGgAZ2V0X3RlbXBsd2lk
dGgAZ2V0X0xlbmd0aABnZXRfUm9vdFNoYWRvd2luZ1Jvb3RDb2xvckxlbmd0aABnZXRfYWRqbGVu
Z3RoAGdldF90ZW1wbGVuZ3RoAGdldF9jb3N0bGVuZ3RoAGdldF9jb3N0YWRqAGdldF9oaWcyc3Ry
ZWFrAGdldF9oaWdoc3RyZWFrAGdldF9oaWcyY2JhY2sAZ2V0X2hpZ2hjYmFjawBnZXRfaGFpcmNi
YWNrAGdldF9oaWcycGJhY2sAZ2V0X2hpZ2hwYmFjawBnZXRfZ3JleXBiYWNrAEdldERlY2ltYWwA
Z2V0X2ZhY3RhY3R1YWwAU3lzdGVtLkNvbXBvbmVudE1vZGVsAFNDXzYwNjhjOWI0N2IzZDRlNmE4
ZDkzOWNjNWVmZjJhNmEzLmRsbABnZXRfY29zdGFyZWFfSXNOdWxsAGdldF9Sb290U2hhZG93aW5n
Um9vdENvbG9yTGVuZ3RoRGVzY19Jc051bGwAZ2V0X2hhaXJjZGVzY19Jc051bGwAZ2V0X2RlbnNl
ZGVzY19Jc051bGwAZ2V0X2ZkZW5zZWRlc2NfSXNOdWxsAGdldF90ZW1wbGRlc2NfSXNOdWxsAGdl
dF9oYWlybGRlc2NfSXNOdWxsAGdldF9wZXJtZGVzY19Jc051bGwAZ2V0X3Njb2xvcmRlc2NfSXNO
dWxsAGdldF9oYWlyc2Rlc2NfSXNOdWxsAGdldF9yZWNlc3NkZXNjX0lzTnVsbABnZXRfZnJvbnRk
ZXNjX0lzTnVsbABnZXRfY2RfSXNOdWxsAGdldF9mYXNzaWduZWRfSXNOdWxsAGdldF9zdGF0dXNl
cmlkX0lzTnVsbABnZXRfZmFjdG9yeWlkX0lzTnVsbABnZXRfc3lzdHlwZWNvZF9Jc051bGwAZ2V0
X3Byb2dyYW1jb2RfSXNOdWxsAGdldF9vd25oYWlyY29kX0lzTnVsbABnZXRfT3JkZXJzdGNvZF9J
c051bGwAZ2V0X3ByaWNlX0lzTnVsbABnZXRfbGFjZUxlbmd0aENvZGVfSXNOdWxsAGdldF9mYWNj
b2RlX0lzTnVsbABnZXRfaGFpcmNjb2RlX0lzTnVsbABnZXRfZGVuc2Vjb2RlX0lzTnVsbABnZXRf
dGVtcGxjb2RlX0lzTnVsbABnZXRfaGFpcmxjb2RlX0lzTnVsbABnZXRfcGVybWNvZGVfSXNOdWxs
AGdldF9zY29sb3Jjb2RlX0lzTnVsbABnZXRfaGFpcnNjb2RlX0lzTnVsbABnZXRfcmVjZXNzY29k
ZV9Jc051bGwAZ2V0X2Zyb250Y29kZV9Jc051bGwAZ2V0X2Zyb21icmlkZ2VfSXNOdWxsAGdldF9s
YXN0bmFtZV9Jc051bGwAZ2V0X2ZpcnN0bmFtZV9Jc051bGwAZ2V0X1BPVHlwZV9Jc051bGwAZ2V0
X3BjdHlwZV9Jc051bGwAZ2V0X2Nvc3RiYXNlX0lzTnVsbABnZXRfZnJvbnRkZW5zZV9Jc051bGwA
Z2V0X2R1ZWRhdGVfSXNOdWxsAGdldF90ZWNobmRhdGVfSXNOdWxsAGdldF9zYW1wbHNkYXRlX0lz
TnVsbABnZXRfc3RhdHVzZGF0ZV9Jc051bGwAZ2V0X0FyZVNpZGVidXJuc0FuZFRlbXBsZXNMYWNl
RmxhZ19Jc051bGwAZ2V0X0lzRmFzaGlvbkhhaXJsaW5lSGlnaGxpZ2h0c0ZsYWdfSXNOdWxsAGdl
dF9wcm9nYmlnX0lzTnVsbABnZXRfcnVzaF9Jc051bGwAZ2V0X2FkandpZHRoX0lzTnVsbABnZXRf
dGVtcGx3aWR0aF9Jc051bGwAZ2V0X1Jvb3RTaGFkb3dpbmdSb290Q29sb3JMZW5ndGhfSXNOdWxs
AGdldF9hZGpsZW5ndGhfSXNOdWxsAGdldF90ZW1wbGVuZ3RoX0lzTnVsbABnZXRfY29zdGxlbmd0
aF9Jc051bGwAZ2V0X2Nvc3RhZGpfSXNOdWxsAGdldF9oaWcyc3RyZWFrX0lzTnVsbABnZXRfaGln
aHN0cmVha19Jc051bGwAZ2V0X2hpZzJjYmFja19Jc051bGwAZ2V0X2hpZ2hjYmFja19Jc051bGwA
Z2V0X2hhaXJjYmFja19Jc051bGwAZ2V0X2hpZzJwYmFja19Jc051bGwAZ2V0X2hpZ2hwYmFja19J
c051bGwAZ2V0X2dyZXlwYmFja19Jc051bGwAZ2V0X2ZhY3RhY3R1YWxfSXNOdWxsAGdldF9oaWcy
Y3RlbXBsX0lzTnVsbABnZXRfaGlnaGN0ZW1wbF9Jc051bGwAZ2V0X2hhaXJjdGVtcGxfSXNOdWxs
AGdldF9oaWcycHRlbXBsX0lzTnVsbABnZXRfaGlnaHB0ZW1wbF9Jc051bGwAZ2V0X2dyZXlwdGVt
cGxfSXNOdWxsAGdldF9wY2VudGVybmFtX0lzTnVsbABnZXRfU2lkZWJ1cm5UZW1wbGF0ZURpYWdy
YW1fSXNOdWxsAGdldF9Jc0V4dGVuZGVkTGFjZUFkZE9uX0lzTnVsbABnZXRfSXNTaWduYXR1cmVI
YWlybGluZUFkZE9uX0lzTnVsbABnZXRfSXNPbWJyZUFkZE9uX0lzTnVsbABnZXRfSXNSb290U2hh
ZG93aW5nQWRkT25fSXNOdWxsAGdldF9Jc0xvbmdIYWlyQWRkT25fSXNOdWxsAGdldF9Jc0N1dGlj
bGVJbnRhY3RIYWlyQWRkT25fSXNOdWxsAGdldF9oaWcyaHVtYW5fSXNOdWxsAGdldF9oaWdoaHVt
YW5fSXNOdWxsAGdldF9oYWlyaHVtYW5fSXNOdWxsAGdldF9jb3N0aHVtYW5fSXNOdWxsAGdldF9n
cmV5aHVtYW5fSXNOdWxsAGdldF9NZWFSZWNlc3Npb25fSXNOdWxsAGdldF9oaWcyY2Nyb3duX0lz
TnVsbABnZXRfaGlnaGNjcm93bl9Jc051bGwAZ2V0X2hhaXJjY3Jvd25fSXNOdWxsAGdldF9oaWcy
cGNyb3duX0lzTnVsbABnZXRfaGlnaHBjcm93bl9Jc051bGwAZ2V0X2dyZXlwY3Jvd25fSXNOdWxs
AGdldF9yZWRvX0lzTnVsbABnZXRfZGlkcHJpbnRmb19Jc051bGwAZ2V0X2NsaWVudG5vX0lzTnVs
bABnZXRfaGlnMmN0b3BfSXNOdWxsAGdldF9oaWdoY3RvcF9Jc051bGwAZ2V0X2hhaXJjdG9wX0lz
TnVsbABnZXRfaGlnMnB0b3BfSXNOdWxsAGdldF9oaWdocHRvcF9Jc051bGwAZ2V0X2dyZXlwdG9w
X0lzTnVsbABnZXRfZ3JvdXBfSXNOdWxsAGdldF9zdGF0cmVxX0lzTnVsbABnZXRfSGFpclN5c3Rl
bU9yZGVyTnVtYmVyX0lzTnVsbABnZXRfaHBvbnVtYmVyX0lzTnVsbABnZXRfY2VudGVyX0lzTnVs
bABnZXRfUm9vdFNoYWRvd2luZ1Jvb3RDb2xvcl9Jc051bGwAZ2V0X3N5c3R5cGVkZXNfSXNOdWxs
AGdldF9oaWcyY3NpZGVzX0lzTnVsbABnZXRfaGlnaGNzaWRlc19Jc051bGwAZ2V0X2hhaXJjc2lk
ZXNfSXNOdWxsAGdldF9oaWcycHNpZGVzX0lzTnVsbABnZXRfaGlnaHBzaWRlc19Jc051bGwAZ2V0
X2dyZXlwc2lkZXNfSXNOdWxsAGdldF9ub3Rlc19Jc051bGwAZ2V0X2ZhY3Rub3Rlc19Jc051bGwA
Z2V0X3N0YXRmYWN0X0lzTnVsbABnZXRfdGVjaG5pbml0X0lzTnVsbABnZXRfc2FtcGxzaW5pdF9J
c051bGwAZ2V0X05hcGVBcmVhTWVhc3VyZW1lbnRfSXNOdWxsAGdldF9Gcm9udExhY2VNZWFzdXJl
bWVudF9Jc051bGwAZ2V0X0NpcmN1bWZlcmVuY2VNZWFzdXJlbWVudF9Jc051bGwAZ2V0X1RlbXBs
ZVRvVGVtcGxlTWVhc3VyZW1lbnRfSXNOdWxsAGdldF9Gcm9udFRvQmFja01lYXN1cmVtZW50X0lz
TnVsbABnZXRfU2lkZWJ1cm5Ub1NpZGVidXJuTWVhc3VyZW1lbnRfSXNOdWxsAGdldF9FYXJUb0Vh
ck92ZXJUb3BNZWFzdXJlbWVudF9Jc051bGwAZ2V0X1N0YXJ0aW5nUG9pbnRNZWFzdXJlbWVudF9J
c051bGwAZ2V0X0VhclRvRWFyT3ZlckZyb250TWVhc3VyZW1lbnRfSXNOdWxsAGdldF9zYW1wbGVz
ZW50X0lzTnVsbABnZXRfdW5kZXJ2ZW50X0lzTnVsbABnZXRfaGlnMmNmcm9udF9Jc051bGwAZ2V0
X2hpZ2hjZnJvbnRfSXNOdWxsAGdldF9oYWlyY2Zyb250X0lzTnVsbABnZXRfaGlnMnBmcm9udF9J
c051bGwAZ2V0X2hpZ2hwZnJvbnRfSXNOdWxsAGdldF9ncmV5cGZyb250X0lzTnVsbABnZXRfT3Jk
ZXJDb3VudF9Jc051bGwAZ2V0X0RvZXNNZWFzdXJlbWVudEV4aXN0X0lzTnVsbABnZXRfZmFjdGNv
c3RfSXNOdWxsAGdldF9kaWRmYXhfSXNOdWxsAGdldF9zdGF0cmVwbHlfSXNOdWxsAGdldF9wY291
bnRyeV9Jc051bGwAU3lzdGVtLlhtbABnZXRfaGlnMmN0ZW1wbABnZXRfaGlnaGN0ZW1wbABnZXRf
aGFpcmN0ZW1wbABnZXRfaGlnMnB0ZW1wbABnZXRfaGlnaHB0ZW1wbABnZXRfZ3JleXB0ZW1wbABN
ZW1vcnlTdHJlYW0AZ2V0X3BjZW50ZXJuYW0AZ2V0X1NpZGVidXJuVGVtcGxhdGVEaWFncmFtAGdl
dF9JdGVtAFN5c3RlbQBnZXRfSXNFeHRlbmRlZExhY2VBZGRPbgBnZXRfSXNTaWduYXR1cmVIYWly
bGluZUFkZE9uAGdldF9Jc09tYnJlQWRkT24AZ2V0X0lzUm9vdFNoYWRvd2luZ0FkZE9uAGdldF9J
c0xvbmdIYWlyQWRkT24AZ2V0X0lzQ3V0aWNsZUludGFjdEhhaXJBZGRPbgByZXNvdXJjZU1hbgBH
ZXRCb29sZWFuAGdldF9oaWcyaHVtYW4AZ2V0X2hpZ2hodW1hbgBnZXRfaGFpcmh1bWFuAGdldF9j
b3N0aHVtYW4AZ2V0X2dyZXlodW1hbgBTY3JpcHRNYWluAEJsb2JDb2x1bW4AZ2V0X01lYVJlY2Vz
c2lvbgBTeXN0ZW0uQ29uZmlndXJhdGlvbgBzZXRfSW5kZW50YXRpb24AU3lzdGVtLkdsb2JhbGl6
YXRpb24AU3lzdGVtLlJlZmxlY3Rpb24AZ2V0X0lucHV0Q29sdW1uQ29sbGVjdGlvbgBnZXRfUnVu
dGltZUNvbm5lY3Rpb25Db2xsZWN0aW9uAGdldF9JbnB1dENvbGxlY3Rpb24Ac2V0X1Bvc2l0aW9u
AFN0cmluZ0NvbXBhcmlzb24AZ2V0X2hpZzJjY3Jvd24AZ2V0X2hpZ2hjY3Jvd24AZ2V0X2hhaXJj
Y3Jvd24AZ2V0X2hpZzJwY3Jvd24AZ2V0X2hpZ2hwY3Jvd24AZ2V0X2dyZXlwY3Jvd24AZ2V0X3Jl
ZG8AQ3VsdHVyZUluZm8ARGlyZWN0b3J5SW5mbwBQcm9wZXJ0eUluZm8AZ2V0X2RpZHByaW50Zm8A
Z2V0X2NsaWVudG5vAE91dHB1dE5hbWVNYXAAT3V0cHV0TWFwAE1pY3Jvc29mdC5TcWxTZXJ2ZXIu
RFRTUnVudGltZVdyYXAATWljcm9zb2Z0LlNxbFNlcnZlci5EVFNQaXBlbGluZVdyYXAAZ2V0X0Rl
c3RpbmF0aW9uWmlwAHNldF9EZXN0aW5hdGlvblppcABnZXRfaGlnMmN0b3AAZ2V0X2hpZ2hjdG9w
AGdldF9oYWlyY3RvcABnZXRfaGlnMnB0b3AAZ2V0X2hpZ2hwdG9wAGdldF9ncmV5cHRvcABnZXRf
Z3JvdXAAZ2V0X3N0YXRyZXEAZ2V0X0N1cnJlbnRIUE9OdW1iZXIAZ2V0X0hhaXJTeXN0ZW1PcmRl
ck51bWJlcgBnZXRfaHBvbnVtYmVyAFN0cmVhbVJlYWRlcgBUZXh0UmVhZGVyAElucHV0MEJ1ZmZl
cgBQaXBlbGluZUJ1ZmZlcgBTY3JpcHRCdWZmZXIAZ2V0X1Jlc291cmNlTWFuYWdlcgBnZXRfQ29u
bmVjdGlvbk1hbmFnZXIATWljcm9zb2Z0LlNxbFNlcnZlci5EdHMuUnVudGltZS5XcmFwcGVyAE1p
Y3Jvc29mdC5TcWxTZXJ2ZXIuRHRzLlBpcGVsaW5lLldyYXBwZXIAWG1sV3JpdGVyAFhtbFRleHRX
cml0ZXIAdGV4dFdyaXRlcgBnZXRfY2VudGVyAEluY3JlbWVudFBpcGVsaW5lUGVyZkNvdW50ZXIA
Z2V0X1Jvb3RTaGFkb3dpbmdSb290Q29sb3IASUVudW1lcmF0b3IAR2V0RW51bWVyYXRvcgAuY3Rv
cgAuY2N0b3IAU3lzdGVtLkRpYWdub3N0aWNzAFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2Vydmlj
ZXMAU3lzdGVtLlJlc291cmNlcwBTQ182MDY4YzliNDdiM2Q0ZTZhOGQ5MzljYzVlZmYyYTZhMy5Q
cm9wZXJ0aWVzLlJlc291cmNlcy5yZXNvdXJjZXMAZ2V0X3N5c3R5cGVkZXMAZ2V0X2hpZzJjc2lk
ZXMAZ2V0X2hpZ2hjc2lkZXMAZ2V0X2hhaXJjc2lkZXMAZ2V0X2hpZzJwc2lkZXMAZ2V0X2hpZ2hw
c2lkZXMAZ2V0X2dyZXlwc2lkZXMARGVidWdnaW5nTW9kZXMAU0NfNjA2OGM5YjQ3YjNkNGU2YThk
OTM5Y2M1ZWZmMmE2YTMuUHJvcGVydGllcwBnZXRfUmVhZFdyaXRlVmFyaWFibGVzAGdldF9SZWFk
T25seVZhcmlhYmxlcwBnZXRfbm90ZXMAZ2V0X2ZhY3Rub3RlcwBieXRlcwBCdWZmZXJDb2x1bW5J
bmRleGVzAEdldENvbHVtbkluZGV4ZXMAU2V0dGluZ3MARXF1YWxzAFN5c3RlbS5Db2xsZWN0aW9u
cwBDb25uZWN0aW9ucwByZW1vdmVGb3JiaWRkZW5YbWxDaGFycwBFeGlzdHMAQ29uY2F0AGdldF9z
dGF0ZmFjdABPYmplY3QAZ2V0X0VtYWlsU3ViamVjdABzZXRfRW1haWxTdWJqZWN0AEVuZE9mUm93
c2V0AGdldF90ZWNobmluaXQAZ2V0X3NhbXBsc2luaXQAZ2V0X0RlZmF1bHQAV3JpdGVFbmRFbGVt
ZW50AFdyaXRlU3RhcnRFbGVtZW50AGdldF9OYXBlQXJlYU1lYXN1cmVtZW50AGdldF9Gcm9udExh
Y2VNZWFzdXJlbWVudABnZXRfQ2lyY3VtZmVyZW5jZU1lYXN1cmVtZW50AGdldF9UZW1wbGVUb1Rl
bXBsZU1lYXN1cmVtZW50AGdldF9Gcm9udFRvQmFja01lYXN1cmVtZW50AGdldF9TaWRlYnVyblRv
U2lkZWJ1cm5NZWFzdXJlbWVudABnZXRfRWFyVG9FYXJPdmVyVG9wTWVhc3VyZW1lbnQAZ2V0X1N0
YXJ0aW5nUG9pbnRNZWFzdXJlbWVudABnZXRfRWFyVG9FYXJPdmVyRnJvbnRNZWFzdXJlbWVudABX
cml0ZUVuZERvY3VtZW50AFdyaXRlU3RhcnREb2N1bWVudABnZXRfeG1sZG9jdW1lbnQAVXNlckNv
bXBvbmVudABQYXJlbnRDb21wb25lbnQAU2NyaXB0Q29tcG9uZW50AGdldF9DdXJyZW50AGdldF9z
YW1wbGVzZW50AGdldF91bmRlcnZlbnQAZ2V0X2hpZzJjZnJvbnQAZ2V0X2hpZ2hjZnJvbnQAZ2V0
X2hhaXJjZnJvbnQAZ2V0X2hpZzJwZnJvbnQAZ2V0X2hpZ2hwZnJvbnQAZ2V0X2dyZXlwZnJvbnQA
Z2V0X09yZGVyQ291bnQATWljcm9zb2Z0LlNxbFNlcnZlci5UeFNjcmlwdABnZXRfRG9lc01lYXN1
cmVtZW50RXhpc3QATWljcm9zb2Z0LlNxbFNlcnZlci5QaXBlbGluZUhvc3QAZ2V0X2ZhY3Rjb3N0
AElucHV0MF9Qcm9jZXNzSW5wdXQATW92ZU5leHQAU3lzdGVtLlRleHQAR2V0VmFsdWVXaXRoQ29u
dGV4dABTY3JpcHRDb21wb25lbnRFdmFsQ29udGV4dABnZXRfRXZhbHVhdG9yQ29udGV4dABJbnB1
dDBfUHJvY2Vzc0lucHV0Um93AE5leHRSb3cAZ2V0X2RpZGZheABnZXRfQXNzZW1ibHkAZ2V0X3N0
YXRyZXBseQBnZXRfRmFjdG9yeQBnZXRfUmVtb3RlWE1MRlRQRGlyZWN0b3J5AGdldF9Mb2NhbFhN
TEZpbGVEaXJlY3RvcnkAQ3JlYXRlRGlyZWN0b3J5AGdldF9wY291bnRyeQBFbXB0eQBHZXRQcm9w
ZXJ0eQAAAAAACVwAWgBpAHAAAAVcAFAAAAkuAHgAbQBsAAAjRgBhAGMAdABvAHIAeQBJAG0AcABv
AHIAdABEAGEAdABhAAALeABtAGwAbgBzAAARSQBtAHAAbwByAHQAUABPAAAJUABPAE4AbwAAAy8A
AA1cAFoAaQBwAFwAUAAACS4AegBpAHAAACEgAE8AcgBkAGUAcgBzACAAdwBpAHQAaAAgAFAATwAj
AAABABlJAG0AcABvAHIAdABPAHIAZABlAHIAcwAAAyYAAAsmAGEAbQBwADsAAAM8AAAJJgBsAHQA
OwAAAz4AAAkmAGcAdAA7AAAPSQBuAHAAdQB0ACAAMAAAF3gAbQBsAGQAbwBjAHUAbQBlAG4AdAAA
IUMAdQByAHIAZQBuAHQASABQAE8ATgB1AG0AYgBlAHIAAA9GAGEAYwB0AG8AcgB5AAArTABvAGMA
YQBsAFgATQBMAEYAaQBsAGUARABpAHIAZQBjAHQAbwByAHkAACNQAHUAcgBjAGgAYQBzAGUATwBy
AGQAZQByAFQAeQBwAGUAACtSAGUAbQBvAHQAZQBYAE0ATABGAFQAUABEAGkAcgBlAGMAdABvAHIA
eQAAGVgATQBMAE4AYQBtAGUAUwBwAGEAYwBlAAAdRABlAHMAdABpAG4AYQB0AGkAbwBuAFoAaQBw
AAApRABlAHMAdABpAG4AYQB0AGkAbwBuAFoAaQBwAFMAbwB1AHIAYwBlAAAZRQBtAGEAaQBsAFMA
dQBiAGoAZQBjAHQAACFMAG8AYwBhAGwAWABNAEwARgBpAGwAZQBQAGEAdABoAAAhUgBlAG0AbwB0
AGUAWABNAEwARgBUAFAAUABhAHQAaAAAcVMAQwBfADYAMAA2ADgAYwA5AGIANAA3AGIAMwBkADQA
ZQA2AGEAOABkADkAMwA5AGMAYwA1AGUAZgBmADIAYQA2AGEAMwAuAFAAcgBvAHAAZQByAHQAaQBl
AHMALgBSAGUAcwBvAHUAcgBjAGUAcwAAAAAAsCSJ8XPTV0Sg6jMjknQZrQAEIAEBCAMgAAEFIAEB
EREEIAEBDgYgAQERgIUDBwEOBQACDg4OBAABAg4GAAESgJ0OBQABDh0OByACAQ4SgKEGIAEBEYCl
BSACAQ4OBgADDg4ODhEHCBI9DhJBEkUSSRJNHQUSUQQgABI9BSAAEoCtBSAAEoCxBiABEoC5HAUg
ABKAvQQgABJBAyAAHAMgAA4FIAESSQ4FIAARgMEGIAIcHB0cAyAACQYgAh0FCAgDIAACBSACAQkJ
BSACDg4OBQcCDhJZAgYOBSABAR0FBCABAQoGIAEBEoDJCSADARJhHQgSZQMGEmEDBh0IBCABCAgE
IAECCAQgAQ4IBSABEWkIBSABEW0IBCABHAgHIAICDhGA0QUgAR0ICAUgABKA1QYgARKA2Q4EIAAS
dQUgABKA3QYgARKA4RwFAAASgOUGIAEcEoDpBCABARwHAAESPRGA7QUgABKA8QcgAgEOEoDxCLd6
XFYZNOCJCImEXc2AgMyRAwYSOQMGEhQDBhIYAwYScQMGEn0EBhKAgQMGEiAFIAEBEgwEIAEODgUg
AQ4dBQMgAAgEIAARaQQgABFtBCAAEk0JIAQBCA4SYRJlBSABARJxBAAAEn0FAAASgIEGAAEBEoCB
BAAAEiADAAABAygACAMoAAIDKAAOBCgAEWkEKAARbQQoABJNBCgAEnUECAASfQUIABKAgQQIABIg
CAEACAAAAAAAHgEAAQBUAhZXcmFwTm9uRXhjZXB0aW9uVGhyb3dzAQgBAAIAAAAAACgBACNTQ182
MDY4YzliNDdiM2Q0ZTZhOGQ5MzljYzVlZmYyYTZhMwAABQEAAAAAFgEAEUNvcHlyaWdodCBAICAy
MDE4AABJAQAaLk5FVEZyYW1ld29yayxWZXJzaW9uPXY0LjUBAFQOFEZyYW1ld29ya0Rpc3BsYXlO
YW1lEi5ORVQgRnJhbWV3b3JrIDQuNQQBAAAAAAAAtAAAAM7K774BAAAAkQAAAGxTeXN0ZW0uUmVz
b3VyY2VzLlJlc291cmNlUmVhZGVyLCBtc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJl
PW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkjU3lzdGVtLlJlc291cmNl
cy5SdW50aW1lUmVzb3VyY2VTZXQCAAAAAAAAAAAAAABQQURQQURQtAAAAKSHAAAAAAAAAAAAAL6H
AAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwhwAAAAAAAAAAAAAAAF9Db3JEbGxNYWluAG1zY29y
ZWUuZGxsAAAAAAD/JQAgABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAQAQAAAAGAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAMAAAgAAAAAAA
AAAAAAAAAAAAAQAAAAAASAAAAFigAADsAwAAAAAAAAAAAADsAzQAAABWAFMAXwBWAEUAUgBTAEkA
TwBOAF8ASQBOAEYATwAAAAAAvQTv/gAAAQAAAAEAAAAAAAAAAQAAAAAAPwAAAAAAAAAEAAAAAgAA
AAAAAAAAAAAAAAAAAEQAAAABAFYAYQByAEYAaQBsAGUASQBuAGYAbwAAAAAAJAAEAAAAVAByAGEA
bgBzAGwAYQB0AGkAbwBuAAAAAAAAALAETAMAAAEAUwB0AHIAaQBuAGcARgBpAGwAZQBJAG4AZgBv
AAAAKAMAAAEAMAAwADAAMAAwADQAYgAwAAAAGgABAAEAQwBvAG0AbQBlAG4AdABzAAAAAAAAACIA
AQABAEMAbwBtAHAAYQBuAHkATgBhAG0AZQAAAAAAAAAAAHAAJAABAEYAaQBsAGUARABlAHMAYwBy
AGkAcAB0AGkAbwBuAAAAAABTAEMAXwA2ADAANgA4AGMAOQBiADQANwBiADMAZAA0AGUANgBhADgA
ZAA5ADMAOQBjAGMANQBlAGYAZgAyAGEANgBhADMAAAAwAAgAAQBGAGkAbABlAFYAZQByAHMAaQBv
AG4AAAAAADEALgAwAC4AMAAuADAAAABwACgAAQBJAG4AdABlAHIAbgBhAGwATgBhAG0AZQAAAFMA
QwBfADYAMAA2ADgAYwA5AGIANAA3AGIAMwBkADQAZQA2AGEAOABkADkAMwA5AGMAYwA1AGUAZgBm
ADIAYQA2AGEAMwAuAGQAbABsAAAASAASAAEATABlAGcAYQBsAEMAbwBwAHkAcgBpAGcAaAB0AAAA
QwBvAHAAeQByAGkAZwBoAHQAIABAACAAIAAyADAAMQA4AAAAKgABAAEATABlAGcAYQBsAFQAcgBh
AGQAZQBtAGEAcgBrAHMAAAAAAAAAAAB4ACgAAQBPAHIAaQBnAGkAbgBhAGwARgBpAGwAZQBuAGEA
bQBlAAAAUwBDAF8ANgAwADYAOABjADkAYgA0ADcAYgAzAGQANABlADYAYQA4AGQAOQAzADkAYwBj
ADUAZQBmAGYAMgBhADYAYQAzAC4AZABsAGwAAABoACQAAQBQAHIAbwBkAHUAYwB0AE4AYQBtAGUA
AAAAAFMAQwBfADYAMAA2ADgAYwA5AGIANAA3AGIAMwBkADQAZQA2AGEAOABkADkAMwA5AGMAYwA1
AGUAZgBmADIAYQA2AGEAMwAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEA
LgAwAC4AMAAuADAAAAA4AAgAAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAu
ADAALgAwAC4AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AACAAAAMAAAA0DcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]]></arrayElement>
                          </arrayElements>
                        </property>
                        <property
                          dataType="System.String"
                          description="Specifies the name of the Microsoft Visual Studio Tools for Applications project. Project names must be unique within a package."
                          name="VSTAProjectName"
                          typeConverter="NOTBROWSABLE">SC_6068c9b47b3d4e6a8d939cc5eff2a6a3</property>
                        <property
                          dataType="System.String"
                          description="Specifies the programming language used by the script."
                          name="ScriptLanguage"
                          typeConverter="Microsoft.SqlServer.VSTAHosting.ScriptingLanguages">CSharp</property>
                        <property
                          dataType="System.String"
                          description="Specifies a comma-separated list of read-only variables."
                          name="ReadOnlyVariables"
                          UITypeEditor="Microsoft.DataTransformationServices.Controls.ScriptUIVariablePickerDlg">User::CurrentHPONumber,User::Factory,User::PurchaseOrderType,$Package::LocalXMLFileDirectory,$Package::RemoteXMLFTPDirectory,$Package::XMLNameSpace</property>
                        <property
                          dataType="System.String"
                          description="Specifies a comma-separated list of read/write variables."
                          name="ReadWriteVariables"
                          UITypeEditor="Microsoft.DataTransformationServices.Controls.ScriptUIWriteableVariablePickerDlg">User::DestinationZip,User::DestinationZipSource,User::EmailSubject,User::LocalXMLFilePath,User::RemoteXMLFTPPath</property>
                        <property
                          dataType="System.String"
                          description="List of breakpoints present on the script."
                          isArray="true"
                          name="BreakpointCollection"
                          typeConverter="NOTBROWSABLE">
                          <arrayElements
                            arrayElementCount="0" />
                        </property>
                        <property
                          dataType="System.String"
                          name="UserComponentTypeName">Microsoft.ScriptComponentHost</property>
                        <property
                          dataType="System.String"
                          description="Checksum to match component metedata against compiled codes."
                          name="MetadataChecksum140"
                          typeConverter="NOTBROWSABLE">90</property>
                      </properties>
                      <connections>
                        <connection
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Connections[xmldocument]"
                          connectionManagerID="Package.ConnectionManagers[XML File Generator]"
                          connectionManagerRefId="Package.ConnectionManagers[XML File Generator]"
                          name="xmldocument" />
                      </connections>
                      <inputs>
                        <input
                          refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0]"
                          hasSideEffects="true"
                          name="Input 0">
                          <inputColumns>
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hponumber]"
                              cachedDataType="i4"
                              cachedName="hponumber"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hponumber]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[center]"
                              cachedDataType="i4"
                              cachedName="center"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[center]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[pcenternam]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="50"
                              cachedName="pcenternam"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcenternam]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[pcountry]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="pcountry"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pcountry]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[pctype]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="pctype"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[pctype]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[cd]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="cd"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[cd]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[Orderstcod]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="Orderstcod"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[Orderstcod]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[statusdate]"
                              cachedDataType="dbTimeStamp"
                              cachedName="statusdate"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statusdate]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[programcod]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="programcod"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[programcod]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[progbig]"
                              cachedDataType="i4"
                              cachedName="progbig"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[progbig]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[duedate]"
                              cachedDataType="dbTimeStamp"
                              cachedName="duedate"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[duedate]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[redo]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="redo"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[redo]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[systypecod]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="systypecod"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypecod]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[systypedes]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="systypedes"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[systypedes]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[scolorcode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="scolorcode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolorcode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[scolordesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="scolordesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[scolordesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[templcode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="templcode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templcode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[templdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="templdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[templwidth]"
                              cachedDataType="numeric"
                              cachedName="templwidth"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templwidth]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[adjwidth]"
                              cachedDataType="numeric"
                              cachedName="adjwidth"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjwidth]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[templength]"
                              cachedDataType="numeric"
                              cachedName="templength"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[templength]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[adjlength]"
                              cachedDataType="numeric"
                              cachedName="adjlength"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[adjlength]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[recesscode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="recesscode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recesscode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[recessdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="recessdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[recessdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairlcode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairlcode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairlcode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairldesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="hairldesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairldesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[densecode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="densecode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densecode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[densedesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="densedesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[densedesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[frontdense]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="frontdense"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdense]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[fdensedesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="fdensedesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fdensedesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[frontcode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="frontcode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontcode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[frontdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="frontdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frontdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[undervent]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="undervent"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[undervent]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairhuman]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairhuman"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairhuman]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[haircfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="haircfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairctempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairctempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairctop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairctop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairctop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[haircsides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="haircsides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircsides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairccrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairccrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[haircback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="haircback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highhuman]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highhuman"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highhuman]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highstreak]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highstreak"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highstreak]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highcfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highcfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highpfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highpfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highctempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highctempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highptempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highptempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highctop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highctop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highctop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highptop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highptop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highptop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highcsides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highcsides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcsides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highpsides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highpsides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpsides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highccrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highccrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highccrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highpcrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highpcrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpcrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highcback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highcback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highcback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[highpback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="highpback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[highpback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2human]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2human"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2human]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2streak]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2streak"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2streak]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2cfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2cfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2pfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2pfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2ctempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2ctempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2ptempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2ptempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2ctop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2ctop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ctop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2ptop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2ptop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ptop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2csides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2csides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2csides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2psides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2psides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2psides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2ccrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2ccrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2ccrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2pcrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2pcrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pcrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2cback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2cback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2cback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hig2pback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hig2pback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hig2pback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greyhuman]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greyhuman"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyhuman]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greypfront]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greypfront"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypfront]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greyptempl]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greyptempl"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptempl]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greyptop]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greyptop"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greyptop]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greypsides]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greypsides"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypsides]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greypcrown]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greypcrown"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypcrown]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[greypback]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="greypback"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[greypback]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairccode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairccode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairccode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[haircdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="haircdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[haircdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairscode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="hairscode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairscode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[hairsdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="hairsdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[hairsdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[frombridge]"
                              cachedDataType="numeric"
                              cachedName="frombridge"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[frombridge]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[permcode]"
                              cachedDataType="i4"
                              cachedName="permcode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permcode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[permdesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="16"
                              cachedName="permdesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[permdesc]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[ownhaircod]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="ownhaircod"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[ownhaircod]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[samplsinit]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="5"
                              cachedName="samplsinit"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsinit]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[samplsdate]"
                              cachedDataType="dbTimeStamp"
                              cachedName="samplsdate"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplsdate]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[techninit]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="5"
                              cachedName="techninit"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techninit]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[techndate]"
                              cachedDataType="dbTimeStamp"
                              cachedName="techndate"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[techndate]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[notes]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="500"
                              cachedName="notes"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[notes]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[samplesent]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="samplesent"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[samplesent]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[rush]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="rush"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[rush]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[factoryid]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="2"
                              cachedName="factoryid"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factoryid]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[fassigned]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="fassigned"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[fassigned]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[didprintfo]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="4"
                              cachedName="didprintfo"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didprintfo]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[didfax]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="5"
                              cachedName="didfax"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[didfax]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[factactual]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="factactual"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factactual]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[statuserid]"
                              cachedDataType="dbTimeStamp"
                              cachedName="statuserid"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statuserid]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[statreq]"
                              cachedDataType="i4"
                              cachedName="statreq"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreq]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[statfact]"
                              cachedDataType="i4"
                              cachedName="statfact"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statfact]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[statreply]"
                              cachedDataType="i4"
                              cachedName="statreply"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[statreply]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[firstname]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="50"
                              cachedName="firstname"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[firstname]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[lastname]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="50"
                              cachedName="lastname"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[lastname]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[factcost]"
                              cachedDataType="cy"
                              cachedName="factcost"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factcost]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[costbase]"
                              cachedDataType="cy"
                              cachedName="costbase"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costbase]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[costhuman]"
                              cachedDataType="i4"
                              cachedName="costhuman"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costhuman]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[costlength]"
                              cachedDataType="i4"
                              cachedName="costlength"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costlength]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[costarea]"
                              cachedDataType="i4"
                              cachedName="costarea"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costarea]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[costadj]"
                              cachedDataType="i4"
                              cachedName="costadj"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[costadj]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[group]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="2"
                              cachedName="group"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[group]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[faccode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="1"
                              cachedName="faccode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[faccode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[price]"
                              cachedDataType="cy"
                              cachedName="price"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[price]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[OrderCount]"
                              cachedDataType="i4"
                              cachedName="OrderCount"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[OrderCount]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[factnotes]"
                              cachedCodepage="1252"
                              cachedDataType="text"
                              cachedName="factnotes"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[factnotes]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[HairSystemOrderNumber]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="50"
                              cachedName="HairSystemOrderNumber"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[HairSystemOrderNumber]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[clientno]"
                              cachedDataType="i4"
                              cachedName="clientno"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[clientno]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[StartingPointMeasurement]"
                              cachedDataType="numeric"
                              cachedName="StartingPointMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[StartingPointMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[CircumferenceMeasurement]"
                              cachedDataType="numeric"
                              cachedName="CircumferenceMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[CircumferenceMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[FrontToBackMeasurement]"
                              cachedDataType="numeric"
                              cachedName="FrontToBackMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontToBackMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[EarToEarOverFrontMeasurement]"
                              cachedDataType="numeric"
                              cachedName="EarToEarOverFrontMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverFrontMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[EarToEarOverTopMeasurement]"
                              cachedDataType="numeric"
                              cachedName="EarToEarOverTopMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[EarToEarOverTopMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[SideburnToSideburnMeasurement]"
                              cachedDataType="numeric"
                              cachedName="SideburnToSideburnMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnToSideburnMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[TempleToTempleMeasurement]"
                              cachedDataType="numeric"
                              cachedName="TempleToTempleMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[TempleToTempleMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[NapeAreaMeasurement]"
                              cachedDataType="numeric"
                              cachedName="NapeAreaMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[NapeAreaMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[FrontLaceMeasurement]"
                              cachedDataType="numeric"
                              cachedName="FrontLaceMeasurement"
                              cachedPrecision="10"
                              cachedScale="4"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[FrontLaceMeasurement]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[MeaRecession]"
                              cachedDataType="wstr"
                              cachedLength="10"
                              cachedName="MeaRecession"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[MeaRecession]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[AreSideburnsAndTemplesLaceFlag]"
                              cachedDataType="bool"
                              cachedName="AreSideburnsAndTemplesLaceFlag"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[AreSideburnsAndTemplesLaceFlag]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[SideburnTemplateDiagram]"
                              cachedDataType="i4"
                              cachedName="SideburnTemplateDiagram"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[SideburnTemplateDiagram]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[DoesMeasurementExist]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="5"
                              cachedName="DoesMeasurementExist"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[DoesMeasurementExist]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[laceLengthCode]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="laceLengthCode"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[laceLengthCode]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[POType]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="POType"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[POType]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsFashionHairlineHighlightsFlag]"
                              cachedDataType="bool"
                              cachedName="IsFashionHairlineHighlightsFlag"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsFashionHairlineHighlightsFlag]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsSignatureHairlineAddOn]"
                              cachedDataType="bool"
                              cachedName="IsSignatureHairlineAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsSignatureHairlineAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsExtendedLaceAddOn]"
                              cachedDataType="bool"
                              cachedName="IsExtendedLaceAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsExtendedLaceAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsOmbreAddOn]"
                              cachedDataType="bool"
                              cachedName="IsOmbreAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsOmbreAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsLongHairAddOn]"
                              cachedDataType="bool"
                              cachedName="IsLongHairAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsLongHairAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsRootShadowingAddOn]"
                              cachedDataType="bool"
                              cachedName="IsRootShadowingAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsRootShadowingAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[RootShadowingRootColorLength]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="RootShadowingRootColorLength"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLength]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[RootShadowingRootColor]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="10"
                              cachedName="RootShadowingRootColor"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColor]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[IsCuticleIntactHairAddOn]"
                              cachedDataType="bool"
                              cachedName="IsCuticleIntactHairAddOn"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[IsCuticleIntactHairAddOn]" />
                            <inputColumn
                              refId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0].Columns[RootShadowingRootColorLengthDesc]"
                              cachedCodepage="1252"
                              cachedDataType="str"
                              cachedLength="100"
                              cachedName="RootShadowingRootColorLengthDesc"
                              lineageId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output].Columns[RootShadowingRootColorLengthDesc]" />
                          </inputColumns>
                          <externalMetadataColumns />
                        </input>
                      </inputs>
                    </component>
                  </components>
                  <paths>
                    <path
                      refId="Package\SET PO Number Variables\XML Export\Get Orders.Paths[Conditional Split Default Output]"
                      endId="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component.Inputs[Input 0]"
                      name="Conditional Split Default Output"
                      startId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Outputs[Conditional Split Default Output]" />
                    <path
                      refId="Package\SET PO Number Variables\XML Export\Get Orders.Paths[OLE DB Source Output]"
                      endId="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files.Inputs[Conditional Split Input]"
                      name="OLE DB Source Output"
                      startId="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data.Outputs[OLE DB Source Output]" />
                  </paths>
                </pipeline>
              </DTS:ObjectData>
            </DTS:Executable>
          </DTS:Executables>
          <DTS:PrecedenceConstraints>
            <DTS:PrecedenceConstraint
              DTS:refId="Package\SET PO Number Variables\XML Export.PrecedenceConstraints[Constraint]"
              DTS:CreationName=""
              DTS:DTSID="{E6656C29-4D2A-4163-98A3-C3ACD9CA4F53}"
              DTS:From="Package\SET PO Number Variables\XML Export\Get Orders"
              DTS:LogicalAnd="True"
              DTS:ObjectName="Constraint"
              DTS:To="Package\SET PO Number Variables\XML Export\FTP Task" />
          </DTS:PrecedenceConstraints>
        </DTS:Executable>
      </DTS:Executables>
      <DTS:PrecedenceConstraints>
        <DTS:PrecedenceConstraint
          DTS:refId="Package\SET PO Number Variables.PrecedenceConstraints[Constraint 3]"
          DTS:CreationName=""
          DTS:DTSID="{EFB7D036-2BD6-4D10-B1DB-DE70BF506176}"
          DTS:From="Package\SET PO Number Variables\XML Export"
          DTS:LogicalAnd="True"
          DTS:ObjectName="Constraint 3"
          DTS:To="Package\SET PO Number Variables\Clean Up" />
      </DTS:PrecedenceConstraints>
      <DTS:ForEachVariableMappings>
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{2417712C-4489-4BA2-BBC7-E38714A2755D}"
          DTS:ObjectName="{2417712C-4489-4BA2-BBC7-E38714A2755D}"
          DTS:ValueIndex="0"
          DTS:VariableName="User::CurrentHPOGuid" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{F04D670E-943B-4FF7-A42F-712158293770}"
          DTS:ObjectName="{F04D670E-943B-4FF7-A42F-712158293770}"
          DTS:ValueIndex="1"
          DTS:VariableName="User::CurrentHPONumber" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{F9D28937-98A9-4F2C-9277-92A31764F29F}"
          DTS:ObjectName="{F9D28937-98A9-4F2C-9277-92A31764F29F}"
          DTS:ValueIndex="3"
          DTS:VariableName="User::EmailTo" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{63166839-F212-4BAD-8F90-8115616B8666}"
          DTS:ObjectName="{63166839-F212-4BAD-8F90-8115616B8666}"
          DTS:ValueIndex="4"
          DTS:VariableName="User::EmailFrom" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{1CC39BFA-6BE2-4C00-A612-EA773D1E7439}"
          DTS:ObjectName="{1CC39BFA-6BE2-4C00-A612-EA773D1E7439}"
          DTS:ValueIndex="5"
          DTS:VariableName="User::EmailCC" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{48A07EC6-BBD1-4CD1-B9BE-A9A8CEBC917A}"
          DTS:ObjectName="{48A07EC6-BBD1-4CD1-B9BE-A9A8CEBC917A}"
          DTS:ValueIndex="2"
          DTS:VariableName="User::Factory" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{71D7934F-D4FB-4C3A-A1FB-0FDB389300EC}"
          DTS:ObjectName="{71D7934F-D4FB-4C3A-A1FB-0FDB389300EC}"
          DTS:ValueIndex="6"
          DTS:VariableName="User::PurchaseOrderType" />
        <DTS:ForEachVariableMapping
          DTS:CreationName=""
          DTS:DTSID="{F02F3C7B-0EA4-4919-8D61-1AEBF1C32D8B}"
          DTS:ObjectName="{F02F3C7B-0EA4-4919-8D61-1AEBF1C32D8B}"
          DTS:ValueIndex="7"
          DTS:VariableName="User::ExportFileType" />
      </DTS:ForEachVariableMappings>
    </DTS:Executable>
  </DTS:Executables>
  <DTS:PrecedenceConstraints>
    <DTS:PrecedenceConstraint
      DTS:refId="Package.PrecedenceConstraints[Constraint]"
      DTS:CreationName=""
      DTS:DTSID="{E07C41CB-3417-46EB-9A82-286B506A4FEC}"
      DTS:From="Package\Get PO Numbers"
      DTS:LogicalAnd="True"
      DTS:ObjectName="Constraint"
      DTS:To="Package\SET PO Number Variables" />
  </DTS:PrecedenceConstraints>
  <DTS:DesignTimeProperties><![CDATA[<?xml version="1.0"?>
<!--This CDATA section contains the layout information of the package. The section includes information such as (x,y) coordinates, width, and height.-->
<!--If you manually edit this section and make a mistake, you can delete it. -->
<!--The package will still be able to load normally but the previous layout information will be lost and the designer will automatically re-arrange the elements on the design surface.-->
<Objects
  Version="8">
  <!--Each node below will contain properties that do not affect runtime behavior.-->
  <Package
    design-time-name="Package">
    <LayoutInfo>
      <GraphLayout
        Capacity="16" xmlns="clr-namespace:Microsoft.SqlServer.IntegrationServices.Designer.Model.Serialization;assembly=Microsoft.SqlServer.IntegrationServices.Graph" xmlns:mssgle="clr-namespace:Microsoft.SqlServer.Graph.LayoutEngine;assembly=Microsoft.SqlServer.Graph" xmlns:assembly="http://schemas.microsoft.com/winfx/2006/xaml">
        <NodeLayout
          Size="191,44"
          Id="Package\Get PO Numbers"
          TopLeft="413.367924528302,62.5" />
        <NodeLayout
          Size="173,42"
          Id="Package\SET PO Number Variables\Clean Up\Clean Up Local Files"
          TopLeft="645.377358490566,24.7122641509434" />
        <NodeLayout
          Size="143,42"
          Id="Package\SET PO Number Variables\Clean Up\New Zip Task"
          TopLeft="24.207547169811,24.7122641509434" />
        <NodeLayout
          Size="150,42"
          Id="Package\SET PO Number Variables\Clean Up\Send Mail Task"
          TopLeft="206.264150943396,24.7122641509434" />
        <NodeLayout
          Size="211,42"
          Id="Package\SET PO Number Variables\Clean Up\UpdatePurchaseOrderStatus"
          TopLeft="395.320754716981,24.7122641509434" />
        <EdgeLayout
          Id="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 1]"
          TopLeft="606.320754716981,45.7122641509434">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="39.056603773585,0"
              Start="0,0"
              End="31.556603773585,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="31.556603773585,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 2]"
          TopLeft="167.207547169811,45.7122641509434">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="39.056603773585,0"
              Start="0,0"
              End="31.556603773585,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="31.556603773585,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package\SET PO Number Variables\Clean Up.PrecedenceConstraints[Constraint 4]"
          TopLeft="356.264150943396,45.7122641509434">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="39.056603773585,0"
              Start="0,0"
              End="31.556603773585,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="31.556603773585,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <ContainerLayout
          HeaderHeight="43.924528301886795"
          IsExpanded="True"
          PanelSize="846,103"
          Size="846,147"
          Id="Package\SET PO Number Variables\Clean Up"
          TopLeft="5.50000000000006,212.5" />
        <NodeLayout
          Size="136,44"
          Id="Package\SET PO Number Variables\XML Export\FTP Task"
          TopLeft="263.962264150943,21.6415094339623" />
        <NodeLayout
          Size="136,44"
          Id="Package\SET PO Number Variables\XML Export\Get Orders"
          TopLeft="38.867924528302,21.6415094339623" />
        <EdgeLayout
          Id="Package\SET PO Number Variables\XML Export.PrecedenceConstraints[Constraint]"
          TopLeft="174.867924528302,43.6415094339623">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="89.094339622641,0"
              Start="0,0"
              End="81.594339622641,0">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="81.594339622641,0" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <ContainerLayout
          HeaderHeight="43.924528301886795"
          IsExpanded="True"
          PanelSize="434,121"
          Size="434,165"
          Id="Package\SET PO Number Variables\XML Export"
          TopLeft="210,3.49999999999989" />
        <EdgeLayout
          Id="Package\SET PO Number Variables.PrecedenceConstraints[Constraint 3]"
          TopLeft="427.75,168.5">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="0,44"
              Start="0,0"
              End="0,36.5">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="0,36.5" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <ContainerLayout
          HeaderHeight="43.924528301886795"
          IsExpanded="True"
          PanelSize="934,454"
          Size="934,498"
          Id="Package\SET PO Number Variables"
          TopLeft="36.5,151.632075471698" />
        <EdgeLayout
          Id="Package.PrecedenceConstraints[Constraint]"
          TopLeft="506.183962264151,106.5">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="0,45.132075471698"
              Start="0,0"
              End="0,37.632075471698">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="0,37.632075471698" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
      </GraphLayout>
    </LayoutInfo>
  </Package>
  <TaskHost
    design-time-name="Package\SET PO Number Variables\XML Export\Get Orders">
    <LayoutInfo>
      <GraphLayout
        Capacity="8" xmlns="clr-namespace:Microsoft.SqlServer.IntegrationServices.Designer.Model.Serialization;assembly=Microsoft.SqlServer.IntegrationServices.Graph" xmlns:mssgle="clr-namespace:Microsoft.SqlServer.Graph.LayoutEngine;assembly=Microsoft.SqlServer.Graph" xmlns:assembly="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:mssgm="clr-namespace:Microsoft.SqlServer.Graph.Model;assembly=Microsoft.SqlServer.Graph">
        <NodeLayout
          Size="136,44"
          Id="Package\SET PO Number Variables\XML Export\Get Orders\XML Script Component"
          TopLeft="5.5,347.952830188679" />
        <NodeLayout
          Size="136,45"
          Id="Package\SET PO Number Variables\XML Export\Get Orders\Create PO XML Files"
          TopLeft="5.5,178.292452830189" />
        <NodeLayout
          Size="136,44"
          Id="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data"
          TopLeft="5.53773584905662,5.5" />
        <EdgeLayout
          Id="Package\SET PO Number Variables\XML Export\Get Orders.Paths[OLE DB Source Output]"
          TopLeft="73.5188679245283,49.5">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="0,128.792452830189"
              Start="0,0"
              End="0,121.292452830189">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="0,121.292452830189" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <EdgeLabelCollection />
          </EdgeLayout.Labels>
        </EdgeLayout>
        <EdgeLayout
          Id="Package\SET PO Number Variables\XML Export\Get Orders.Paths[Conditional Split Default Output]"
          TopLeft="73.3867924528302,223.198113207547">
          <EdgeLayout.Curve>
            <mssgle:Curve
              StartConnector="{assembly:Null}"
              EndConnector="0,124.754716981132"
              Start="0,0"
              End="0,117.254716981132">
              <mssgle:Curve.Segments>
                <mssgle:SegmentCollection
                  Capacity="5">
                  <mssgle:LineSegment
                    End="0,117.254716981132" />
                </mssgle:SegmentCollection>
              </mssgle:Curve.Segments>
            </mssgle:Curve>
          </EdgeLayout.Curve>
          <EdgeLayout.Labels>
            <mssgm:EdgeLabel
              BoundingBox="-70.61390625,52.798256928066,141.2278125,11.658203125"
              RelativePosition="Any" />
          </EdgeLayout.Labels>
        </EdgeLayout>
      </GraphLayout>
    </LayoutInfo>
  </TaskHost>
  <PipelineComponentMetadata
    design-time-name="Package\SET PO Number Variables\XML Export\Get Orders\CMS Data">
    <Properties>
      <Property>
        <Name>DataSourceViewID</Name>
      </Property>
    </Properties>
  </PipelineComponentMetadata>
</Objects>]]></DTS:DesignTimeProperties>
</DTS:Executable>